"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[9468],{73186:(ht,tt,i)=>{function a(_){return"point"===_.type}i.d(tt,{v:()=>a})},90673:(ht,tt,i)=>{i.d(tt,{$2:()=>H,$C:()=>vt,Hj:()=>U,Mh:()=>$,W$:()=>_t,pW:()=>l,t8:()=>ct,vY:()=>Y});var a=i(82663),_=i(92771),w=i(62789),C=i(25866),z=i(53781),nt=i(89141),L=i(13970),K=i(2296),d=i(51995),X=i(39239),et=i(15268),j=i(78559),k=i(8675),x=i(97669);function _t(r,m){if("point"===r.type)return lt(r,m,!1);if((0,x.gr)(r))switch(r.type){case"extent":return lt(r.center,m,!1);case"polygon":return lt(r.centroid,m,!1);case"polyline":return lt(pt(r),m,!0);case"mesh":return lt((0,j.MW)(r.vertexSpace,r.spatialReference)??r.extent.center,m,!1);case"multipoint":return}else switch(r.type){case"extent":return lt(function yt(r){return(0,k.T)(.5*(r.xmax+r.xmin),.5*(r.ymax+r.ymin),null!=r.zmin&&null!=r.zmax&&isFinite(r.zmin)&&isFinite(r.zmax)?.5*(r.zmax+r.zmin):void 0,r.spatialReference)}(r),m,!0);case"polygon":return lt(function Ot(r){const m=r.rings[0];if(!m||0===m.length)return null;const O=(0,X.S8)(r.rings,!!r.hasZ);return(0,k.T)(O[0],O[1],O[2],r.spatialReference)}(r),m,!0);case"polyline":return lt(pt(r),m,!0);case"multipoint":return}}function pt(r){const m=r.paths[0];if(!m||0===m.length)return null;const O=(0,et.$H)(m,(0,et.Yl)(m)/2);return(0,k.T)(O[0],O[1],O[2],r.spatialReference)}function lt(r,m,O){const M=O?r:(0,x.EL)(r);return m&&r?(0,L.projectPoint)(r,M,m)?M:null:M}function ct(r,m,O,M=0){if(r){m||(m=(0,d.vt)());let q=.5*r.width*(O-1),J=.5*r.height*(O-1);return r.width<1e-7*r.height?q+=J/20:r.height<1e-7*r.width&&(J+=q/20),(0,z.s)(m,r.xmin-q-M,r.ymin-J-M,r.xmax+q+M,r.ymax+J+M),m}return null}function vt(r,m,O=null){const M=(0,nt.o8)(nt.Un);return null!=r&&(M[0]=r[0],M[1]=r[1],M[2]=r[2]),null!=m?M[3]=m:null!=r&&r.length>3&&(M[3]=r[3]),O&&(M[0]*=O,M[1]*=O,M[2]*=O,M[3]*=O),M}function l(r=C.Un,m,O,M=1){const N=new Array(3);if(null==m||null==O)N[0]=1,N[1]=1,N[2]=1;else{let q,J=0;for(let at=2;at>=0;at--){const it=r[at],gt=null!=it,Mt=O[at];let Et;"symbol-value"===it||0===at&&!q&&!gt?Et=0!==Mt?m[at]/Mt:1:gt&&"proportional"!==it&&isFinite(it)&&(Et=0!==Mt?it/Mt:1),null!=Et&&(N[at]=Et,q=Et,J=Math.max(J,Math.abs(Et)))}for(let at=2;at>=0;at--)null==N[at]?N[at]=q:0===N[at]&&(N[at]=.001*J)}for(let q=2;q>=0;q--)N[q]/=M;return(0,C.ci)(N)}function U(r){return $(function E(r){return null!=r.isPrimitive}(r)?[r.width,r.depth,r.height]:r)?null:"Symbol sizes may not be negative values"}function $(r){const m=O=>null==O||O>=0;return Array.isArray(r)?r.every(m):m(r)}function H(r,m,O,M=(0,w.vt)()){return r&&(0,_.Qr)(M,M,-r/180*Math.PI),m&&(0,_.eL)(M,M,m/180*Math.PI),O&&(0,_.Z8)(M,M,O/180*Math.PI),M}function Y(r,m,O){if(null!=O.minDemResolution)return O.minDemResolution;const M=(0,a.GA)(m),N=(0,K.VL)(r)*M,q=(0,K.yr)(r)*M,J=(0,K.uJ)(r)*(m.isGeographic?1:M);return 0===N&&0===q&&0===J?O.minDemResolutionForPoints:.01*Math.max(N,q,J)}},94302:(ht,tt,i)=>{i.d(tt,{CN:()=>L,PY:()=>K,Q_:()=>nt,ny:()=>d,sZ:()=>X}),i(3248);var _=i(86468),w=i(89141),C=i(20706),z=i(50915);const nt=128,L=.5,K=(0,w.CN)(L/2,L/2,1-L/2,1-L/2);function d(l){return"cross"===l||"x"===l}function X(l,E=nt,U=E*L,$=0){const H=function et(l,E=nt,U=E*L,$=0){switch(l){case"circle":default:return function j(l,E){const U=l/2-.5;return ot(l,ct(U,U,E/2))}(E,U);case"square":return function k(l,E){return lt(l,E,!1)}(E,U);case"cross":return function _t(l,E,U=0){return mt(l,E,!1,U)}(E,U,$);case"x":return function pt(l,E,U=0){return mt(l,E,!0,U)}(E,U,$);case"kite":return function x(l,E){return lt(l,E,!0)}(E,U);case"triangle":return function yt(l,E){return ot(l,vt(l/2,E,E/2))}(E,U);case"arrow":return function Ot(l,E){const U=E,$=E/2,H=l/2,Y=.8*U,r=ct(H,(l-E)/2-Y,Math.sqrt(Y*Y+$*$)),m=vt(H,U,$);return ot(l,(O,M)=>Math.max(m(O,M),-r(O,M)))}(E,U)}}(l,E,U,$);return new C.g(H,{mipmap:!1,wrap:{s:z.pF.CLAMP_TO_EDGE,t:z.pF.CLAMP_TO_EDGE},width:E,height:E,components:4,noUnpackFlip:!0,reloadable:!0})}function lt(l,E,U){return U&&(E/=Math.SQRT2),ot(l,($,H)=>{let Y=$-.5*l+.25,r=.5*l-H-.75;if(U){const m=(Y+r)/Math.SQRT2;r=(r-Y)/Math.SQRT2,Y=m}return Math.max(Math.abs(Y),Math.abs(r))-.5*E})}function mt(l,E,U,$=0){E-=$,U&&(E*=Math.SQRT2);const H=.5*E;return ot(l,(Y,r)=>{let m,O=Y-.5*l,M=.5*l-r-1;if(U){const N=(O+M)/Math.SQRT2;M=(M-O)/Math.SQRT2,O=N}return O=Math.abs(O),M=Math.abs(M),m=O>M?O>H?Math.sqrt((O-H)*(O-H)+M*M):M:M>H?Math.sqrt(O*O+(M-H)*(M-H)):O,m-=$/2,m})}function ct(l,E,U){return($,H)=>{const Y=$-l,r=H-E;return Math.sqrt(Y*Y+r*r)-U}}function vt(l,E,U){const $=Math.sqrt(E*E+U*U);return(H,Y)=>{const r=Math.abs(H-l)-U,m=Y-l+E/2+.75;return Math.max((E*r+U*m)/$,-m)}}function ot(l,E){const U=new Uint8Array(4*l*l);for(let $=0;$<l;$++)for(let H=0;H<l;H++){const Y=H+l*$;let r=E(H,$);r=r/l+.5,(0,_.U)(r,U,4*Y)}return U}},66978:(ht,tt,i)=>{i.d(tt,{K:()=>w});var a=i(81680),_=i(24493);function w(C){C.uniforms.add(new a.o("alignPixelEnabled",z=>z.alignPixelEnabled)),C.code.add(_.H`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`),C.code.add(_.H`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`)}},49132:(ht,tt,i)=>{i.d(tt,{Q:()=>X,R:()=>d});var a=i(66360),_=i(30475),w=i(7741),C=i(21130),z=i(82374),nt=i(65840),L=i(24493),K=i(40972);const d=.5;function X(et,j){et.include(_.Y6),et.attributes.add(K.r.POSITION,"vec3"),et.attributes.add(K.r.NORMAL,"vec3"),et.attributes.add(K.r.CENTEROFFSETANDDISTANCE,"vec4");const k=et.vertex;(0,w.NB)(k,j),(0,w.yu)(k,j),k.uniforms.add(new C.I("viewport",x=>x.camera.fullViewport),new nt.m("polygonOffset",x=>x.shaderPolygonOffset),new z.U("cameraGroundRelative",x=>x.camera.aboveGround?1:-1)),j.hasVerticalOffset&&(0,a.V)(k),k.constants.add("smallOffsetAngle","float",.984807753012208),k.code.add(L.H`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),k.code.add(L.H`
    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
      float pointGroundSign = ${j.terrainDepthTest?L.H.float(0):L.H`sign(pointGroundDistance)`};
      if (pointGroundSign == 0.0) {
        pointGroundSign = cameraGroundRelative;
      }

      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground
      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise
      float groundRelative = cameraGroundRelative * pointGroundSign;

      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is
      // dropped is instead introduced using the ground-relative position of the symbol and the camera
      if (polygonOffset > .0) {
        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
        float factor = (1.0 - tanAlpha / viewport[2]);

        // same side of the terrain
        if (groundRelative > 0.0) {
          posView *= factor;
        }
        // opposite sides of the terrain
        else {
          posView /= factor;
        }
      }

      return groundRelative;
    }
  `),j.draped&&!j.hasVerticalOffset||(0,w.S7)(k),j.draped||(k.uniforms.add(new z.U("perDistancePixelRatio",x=>Math.tan(x.camera.fovY/2)/(x.camera.fullViewport[2]/2))),k.code.add(L.H`
    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
      float distanceToCamera = length(posView);

      // Compute offset in world units for a half pixel shift
      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${L.H.float(d)};

      // Apply offset along normal in the direction away from the ground surface
      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;

      // Apply the same offset also on the view space position
      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;

      posModel += modelOffset;
      posView += viewOffset;
    }
  `)),j.screenCenterOffsetUnitsEnabled&&(0,w.Nz)(k),j.hasScreenSizePerspective&&(0,_.OH)(k),k.code.add(L.H`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      vec3 centerOffset = centerOffsetAndDistance.xyz;
      float pointGroundDistance = centerOffsetAndDistance.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${j.draped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${j.hasScreenSizePerspective&&(j.hasVerticalOffset||j.screenCenterOffsetUnitsEnabled)?"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${j.hasVerticalOffset?j.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${j.hasVerticalOffset?L.H`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${j.screenCenterOffsetUnitsEnabled?"":L.H`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${j.screenCenterOffsetUnitsEnabled?j.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${j.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `)}},37683:(ht,tt,i)=>{var a,_;i.d(tt,{D:()=>a}),(_=a||(a={}))[_.Occluded=0]="Occluded",_[_.NotOccluded=1]="NotOccluded",_[_.Both=2]="Both",_[_.COUNT=3]="COUNT"},10064:(ht,tt,i)=>{i.d(tt,{y:()=>L});var a=i(66978),_=i(37683),w=i(21130),C=i(82374),z=i(24493),nt=i(18679);function L(K){K.vertex.uniforms.add(new C.U("renderTransparentlyOccludedHUD",d=>d.hudRenderStyle===_.D.Occluded?1:d.hudRenderStyle===_.D.NotOccluded?0:.75),new w.I("viewport",d=>d.camera.fullViewport),new nt.x("hudVisibilityTexture",d=>d.hudVisibility?.getTexture())),K.vertex.include(a.K),K.vertex.code.add(z.H`bool testHUDVisibility(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}},35955:(ht,tt,i)=>{i.d(tt,{W:()=>_});var a=i(24493);function _(w){w.code.add(a.H`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}`),w.code.add(a.H`const vec4 RGBA_TO_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgbaTofloat(vec4 rgba) {
return dot(rgba, RGBA_TO_FLOAT_FACTORS);
}`),w.code.add(a.H`const vec4 uninterpolatedRGBAToFloatFactors = vec4(
1.0 / 256.0,
1.0 / 256.0 / 256.0,
1.0 / 256.0 / 256.0 / 256.0,
1.0 / 256.0 / 256.0 / 256.0 / 256.0
);
float uninterpolatedRGBAToFloat(vec4 rgba) {
return (dot(round(rgba * 255.0), uninterpolatedRGBAToFloatFactors) - 0.5) * 2.0;
}`)}},80585:(ht,tt,i)=>{i.d(tt,{V:()=>w});var a=i(2006),_=i(64157);class w extends _.n{constructor(z,nt){super(z,"vec4",a.c.Draw,(L,K,d)=>L.setUniform4fv(z,nt(K,d)))}}},36947:(ht,tt,i)=>{i.d(tt,{zC:()=>Qt,C1:()=>vt,EE:()=>zt,YG:()=>Ut,nW:()=>Ht,td:()=>$,_B:()=>Xt,Nq:()=>jt,DJ:()=>Nt,uX:()=>bt,Z8:()=>Gt,CM:()=>Et,Gj:()=>Kt,Ho:()=>Mt,Nb:()=>Ft,Xl:()=>wt,xh:()=>$t});var X,A,a=i(28714),_=i(12225),w=i(25866),C=i(23653),z=i(81596),nt=i(83034),L=i(93617),K=i(55703),d=i(83346);(A=X||(X={})).length=function f(h,p){const y=h[p],o=h[p+1],v=h[p+2];return Math.sqrt(y*y+o*o+v*v)},A.normalize=function c(h,p){const y=h[p],o=h[p+1],v=h[p+2],T=1/Math.sqrt(y*y+o*o+v*v);h[p]*=T,h[p+1]*=T,h[p+2]*=T},A.scale=function s(h,p,y){h[p]*=y,h[p+1]*=y,h[p+2]*=y},A.add=function u(h,p,y,o,v,T=p){(v=v||h)[T]=h[p]+y[o],v[T+1]=h[p+1]+y[o+1],v[T+2]=h[p+2]+y[o+2]},A.subtract=function I(h,p,y,o,v,T=p){(v=v||h)[T]=h[p]-y[o],v[T+1]=h[p+1]-y[o+1],v[T+2]=h[p+2]-y[o+2]};var et=i(98176),j=i(36884),k=i(65388),x=i(40972);const _t=X,pt=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],yt=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],Ot=[0,0,1,0,1,1,0,1],lt=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],mt=new Array(36);for(let A=0;A<6;A++)for(let f=0;f<6;f++)mt[6*A+f]=A;const ct=new Array(36);for(let A=0;A<6;A++)ct[6*A]=0,ct[6*A+1]=1,ct[6*A+2]=2,ct[6*A+3]=2,ct[6*A+4]=3,ct[6*A+5]=0;function vt(A,f){Array.isArray(f)||(f=[f,f,f]);const c=new Array(24);for(let s=0;s<8;s++)c[3*s]=pt[s][0]*f[0],c[3*s+1]=pt[s][1]*f[1],c[3*s+2]=pt[s][2]*f[2];return new j.V(A,[[x.r.POSITION,new d.n(c,lt,3,!0)],[x.r.NORMAL,new d.n(yt,mt,3)],[x.r.UV0,new d.n(Ot,ct,2)]])}const ot=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],l=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],E=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],U=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function $(A,f){Array.isArray(f)||(f=[f,f,f]);const c=new Array(18);for(let s=0;s<6;s++)c[3*s]=ot[s][0]*f[0],c[3*s+1]=ot[s][1]*f[1],c[3*s+2]=ot[s][2]*f[2];return new j.V(A,[[x.r.POSITION,new d.n(c,E,3,!0)],[x.r.NORMAL,new d.n(l,U,3)]])}const H=(0,_.fA)(-.5,0,-.5),Y=(0,_.fA)(.5,0,-.5),r=(0,_.fA)(0,0,.5),m=(0,_.fA)(0,.5,0),O=(0,_.vt)(),M=(0,_.vt)(),N=(0,_.vt)(),q=(0,_.vt)(),J=(0,_.vt)();(0,a.d)(O,H,m),(0,a.d)(M,H,Y),(0,a.e)(N,O,M),(0,a.n)(N,N),(0,a.d)(O,Y,m),(0,a.d)(M,Y,r),(0,a.e)(q,O,M),(0,a.n)(q,q),(0,a.d)(O,r,m),(0,a.d)(M,r,H),(0,a.e)(J,O,M),(0,a.n)(J,J);const at=[H,Y,r,m],it=[0,-1,0,N[0],N[1],N[2],q[0],q[1],q[2],J[0],J[1],J[2]],gt=[0,1,2,3,1,0,3,2,1,3,0,2],dt=[0,0,0,1,1,1,2,2,2,3,3,3];function Mt(A,f){Array.isArray(f)||(f=[f,f,f]);const c=new Array(12);for(let s=0;s<4;s++)c[3*s]=at[s][0]*f[0],c[3*s+1]=at[s][1]*f[1],c[3*s+2]=at[s][2]*f[2];return new j.V(A,[[x.r.POSITION,new d.n(c,gt,3,!0)],[x.r.NORMAL,new d.n(it,dt,3)]])}function Et(A,f,c,s,u={uv:!0}){const I=-Math.PI,h=2*Math.PI,p=-Math.PI/2,y=Math.PI,o=Math.max(3,Math.floor(c)),v=Math.max(2,Math.floor(s)),T=(o+1)*(v+1),W=(0,z.oe)(3*T),G=(0,z.oe)(3*T),F=(0,z.oe)(2*T),S=[];let P=0;for(let D=0;D<=v;D++){const rt=[],g=D/v,Q=p+g*y,Z=Math.cos(Q);for(let ut=0;ut<=o;ut++){const At=ut/o,b=I+At*h,ft=Math.cos(b)*Z,st=Math.sin(Q),Tt=-Math.sin(b)*Z;W[3*P]=ft*f,W[3*P+1]=st*f,W[3*P+2]=Tt*f,G[3*P]=ft,G[3*P+1]=st,G[3*P+2]=Tt,F[2*P]=At,F[2*P+1]=g,rt.push(P),++P}S.push(rt)}const R=new Array;for(let D=0;D<v;D++)for(let rt=0;rt<o;rt++){const g=S[D][rt],Q=S[D][rt+1],Z=S[D+1][rt+1],ut=S[D+1][rt];0===D?(R.push(g),R.push(Z),R.push(ut)):D===v-1?(R.push(g),R.push(Q),R.push(Z)):(R.push(g),R.push(Q),R.push(Z),R.push(Z),R.push(ut),R.push(g))}const B=[[x.r.POSITION,new d.n(W,R,3,!0)],[x.r.NORMAL,new d.n(G,R,3,!0)]];return u.uv&&B.push([x.r.UV0,new d.n(F,R,2,!0)]),u.offset&&(B[0][0]=x.r.OFFSET,B.push([x.r.POSITION,new d.n(Float64Array.from(u.offset),(0,nt.EH)(R.length),3,!0)])),new j.V(A,B)}function bt(A,f,c,s){const u=function Vt(A,f,c){const s=A;let u,I;if(c)u=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],I=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const o=s*(1+Math.sqrt(5))/2;u=[-s,o,0,s,o,0,-s,-o,0,s,-o,0,0,-s,o,0,s,o,0,-s,-o,0,s,-o,o,0,-s,o,0,s,-o,0,-s,-o,0,s],I=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let o=0;o<u.length;o+=3)_t.scale(u,o,A/_t.length(u,o));let h={};function p(o,v){o>v&&([o,v]=[v,o]);const T=o.toString()+"."+v.toString();if(h[T])return h[T];let W=u.length;return u.length+=3,_t.add(u,3*o,u,3*v,u,W),_t.scale(u,W,A/_t.length(u,W)),W/=3,h[T]=W,W}for(let o=0;o<f;o++){const v=I.length,T=new Array(4*v);for(let W=0;W<v;W+=3){const G=I[W],F=I[W+1],S=I[W+2],P=p(G,F),R=p(F,S),B=p(S,G),D=4*W;T[D]=G,T[D+1]=P,T[D+2]=B,T[D+3]=F,T[D+4]=R,T[D+5]=P,T[D+6]=S,T[D+7]=B,T[D+8]=R,T[D+9]=P,T[D+10]=R,T[D+11]=B}I=T,h={}}const y=(0,z.Wz)(u);for(let o=0;o<y.length;o+=3)_t.normalize(y,o);return[[x.r.POSITION,new d.n((0,z.Wz)(u),I,3,!0)],[x.r.NORMAL,new d.n(y,I,3,!0)]]}(f,c,s);return new j.V(A,u)}function Nt(A,f={}){const{normal:c,position:s,color:u,rotation:I,size:h,centerOffsetAndDistance:p,uvs:y,featureAttribute:o,objectAndLayerIdColor:v=null}=f,T=s?(0,w.o8)(s):(0,w.vt)(),W=c?(0,w.o8)(c):(0,w.fA)(0,0,1),G=u?[255*u[0],255*u[1],255*u[2],u.length>3?255*u[3]:255]:[255,255,255,255],F=null!=h&&2===h.length?h:[1,1],S=null!=I?[I]:[0],P=(0,nt.EH)(1),R=[[x.r.POSITION,new d.n(T,P,3,!0)],[x.r.NORMAL,new d.n(W,P,3,!0)],[x.r.COLOR,new d.n(G,P,4,!0)],[x.r.SIZE,new d.n(F,P,2)],[x.r.ROTATION,new d.n(S,P,1,!0)]];return y&&R.push([x.r.UV0,new d.n(y,P,y.length)]),null!=p&&R.push([x.r.CENTEROFFSETANDDISTANCE,new d.n([p[0],p[1],p[2],p[3]],P,4)]),o&&R.push([x.r.FEATUREATTRIBUTE,new d.n([o[0],o[1],o[2],o[3]],P,4)]),new j.V(A,R,null,et.X.Point,v)}const Wt=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function Kt(A,f=Wt){const c=new Array(12);for(let o=0;o<4;o++)for(let v=0;v<3;v++)c[3*o+v]=f[o][v];const s=[0,1,2,2,3,0],I=[0,0,0,0,0,0],y=[[x.r.POSITION,new d.n(c,s,3,!0)],[x.r.NORMAL,new d.n([0,0,1],I,3,!0)],[x.r.UV0,new d.n([0,0,1,0,1,1,0,1],s,2,!0)],[x.r.COLOR,new d.n([255,255,255,255],I,4,!0)]];return new j.V(A,y)}function Ut(A,f,c,s,u=!0,I=!0){let h=0;const p=f,y=A;let o=(0,_.fA)(0,h,0),v=(0,_.fA)(0,h+y,0),T=(0,_.fA)(0,-1,0),W=(0,_.fA)(0,1,0);s&&(h=y,v=(0,_.fA)(0,0,0),o=(0,_.fA)(0,h,0),T=(0,_.fA)(0,1,0),W=(0,_.fA)(0,-1,0));const G=[v,o],F=[T,W],S=c+2,P=Math.sqrt(y*y+p*p);if(s)for(let g=c-1;g>=0;g--){const Q=g*(2*Math.PI/c),Z=(0,_.fA)(Math.cos(Q)*p,h,Math.sin(Q)*p);G.push(Z);const ut=(0,_.fA)(y*Math.cos(Q)/P,-p/P,y*Math.sin(Q)/P);F.push(ut)}else for(let g=0;g<c;g++){const Q=g*(2*Math.PI/c),Z=(0,_.fA)(Math.cos(Q)*p,h,Math.sin(Q)*p);G.push(Z);const ut=(0,_.fA)(y*Math.cos(Q)/P,p/P,y*Math.sin(Q)/P);F.push(ut)}const R=new Array,B=new Array;if(u){for(let g=3;g<G.length;g++)R.push(1),R.push(g-1),R.push(g),B.push(0),B.push(0),B.push(0);R.push(G.length-1),R.push(2),R.push(1),B.push(0),B.push(0),B.push(0)}if(I){for(let g=3;g<G.length;g++)R.push(g),R.push(g-1),R.push(0),B.push(g),B.push(g-1),B.push(1);R.push(0),R.push(2),R.push(G.length-1),B.push(1),B.push(2),B.push(F.length-1)}const D=(0,z.oe)(3*S);for(let g=0;g<S;g++)D[3*g]=G[g][0],D[3*g+1]=G[g][1],D[3*g+2]=G[g][2];const rt=(0,z.oe)(3*S);for(let g=0;g<S;g++)rt[3*g]=F[g][0],rt[3*g+1]=F[g][1],rt[3*g+2]=F[g][2];return[[x.r.POSITION,new d.n(D,R,3,!0)],[x.r.NORMAL,new d.n(rt,B,3,!0)]]}function zt(A,f,c,s,u,I=!0,h=!0){return new j.V(A,Ut(f,c,s,u,I,h))}function Ht(A,f,c,s,u,I,h){const p=u?(0,_.o8)(u):(0,_.fA)(1,0,0),y=I?(0,_.o8)(I):(0,_.fA)(0,0,0);h??=!0;const o=(0,_.vt)();(0,a.n)(o,p);const v=(0,_.vt)();(0,a.h)(v,o,Math.abs(f));const T=(0,_.vt)();(0,a.h)(T,v,-.5),(0,a.g)(T,T,y);const W=(0,_.fA)(0,1,0);Math.abs(1-(0,a.f)(o,W))<.2&&(0,a.i)(W,0,0,1);const G=(0,_.vt)();(0,a.e)(G,o,W),(0,a.n)(G,G),(0,a.e)(W,G,o);const F=2*s+(h?2:0),S=s+(h?2:0),P=(0,z.oe)(3*F),R=(0,z.oe)(3*S),B=(0,z.oe)(2*F),D=new Array(3*s*(h?4:2)),rt=new Array(3*s*(h?4:2));h&&(P[3*(F-2)]=T[0],P[3*(F-2)+1]=T[1],P[3*(F-2)+2]=T[2],B[2*(F-2)]=0,B[2*(F-2)+1]=0,P[3*(F-1)]=P[3*(F-2)]+v[0],P[3*(F-1)+1]=P[3*(F-2)+1]+v[1],P[3*(F-1)+2]=P[3*(F-2)+2]+v[2],B[2*(F-1)]=1,B[2*(F-1)+1]=1,R[3*(S-2)]=-o[0],R[3*(S-2)+1]=-o[1],R[3*(S-2)+2]=-o[2],R[3*(S-1)]=o[0],R[3*(S-1)+1]=o[1],R[3*(S-1)+2]=o[2]);const g=(b,ft,st)=>{D[b]=ft,rt[b]=st};let Q=0;const Z=(0,_.vt)(),ut=(0,_.vt)();for(let b=0;b<s;b++){const ft=b*(2*Math.PI/s);(0,a.h)(Z,W,Math.sin(ft)),(0,a.h)(ut,G,Math.cos(ft)),(0,a.g)(Z,Z,ut),R[3*b]=Z[0],R[3*b+1]=Z[1],R[3*b+2]=Z[2],(0,a.h)(Z,Z,c),(0,a.g)(Z,Z,T),P[3*b]=Z[0],P[3*b+1]=Z[1],P[3*b+2]=Z[2],B[2*b]=b/s,B[2*b+1]=0,P[3*(b+s)]=P[3*b]+v[0],P[3*(b+s)+1]=P[3*b+1]+v[1],P[3*(b+s)+2]=P[3*b+2]+v[2],B[2*(b+s)]=b/s,B[2*b+1]=1;const st=(b+1)%s;g(Q++,b,b),g(Q++,b+s,b),g(Q++,st,st),g(Q++,st,st),g(Q++,b+s,b),g(Q++,st+s,st)}if(h){for(let b=0;b<s;b++){const ft=(b+1)%s;g(Q++,F-2,S-2),g(Q++,b,S-2),g(Q++,ft,S-2)}for(let b=0;b<s;b++){const ft=(b+1)%s;g(Q++,b+s,S-1),g(Q++,F-1,S-1),g(Q++,ft+s,S-1)}}const At=[[x.r.POSITION,new d.n(P,D,3,!0)],[x.r.NORMAL,new d.n(R,rt,3,!0)],[x.r.UV0,new d.n(B,D,2,!0)]];return new j.V(A,At)}function Ft(A,f,c,s,u,I){s=s||10,u=null==u||u,(0,k.vA)(f.length>1);const p=[],y=[];for(let o=0;o<s;o++){p.push([0,-o-1,-(o+1)%s-1]);const v=o/s*2*Math.PI;y.push([Math.cos(v)*c,Math.sin(v)*c])}return jt(A,y,f,[[0,0,0]],p,u,I)}function jt(A,f,c,s,u,I,h=(0,_.fA)(0,0,0)){const p=f.length,y=(0,z.oe)(c.length*p*3+(6*s.length||0)),o=(0,z.oe)(c.length*p*3+(s?6:0)),v=new Array,T=new Array;let W=0,G=0;const F=(0,w.vt)(),S=(0,w.vt)(),P=(0,w.vt)(),R=(0,w.vt)(),B=(0,w.vt)(),D=(0,w.vt)(),rt=(0,w.vt)(),g=(0,w.vt)(),Q=(0,w.vt)(),Z=(0,w.vt)(),ut=(0,w.vt)(),At=(0,w.vt)(),b=(0,w.vt)(),ft=(0,L.vt)();(0,a.i)(Q,0,1,0),(0,a.d)(S,c[1],c[0]),(0,a.n)(S,S),I?((0,a.g)(g,c[0],h),(0,a.n)(P,g)):(0,a.i)(P,0,0,1),wt(S,P,Q,Q,B,P,Bt),(0,a.c)(R,P),(0,a.c)(At,B);for(let V=0;V<s.length;V++)(0,a.h)(D,B,s[V][0]),(0,a.h)(g,P,s[V][2]),(0,a.g)(D,D,g),(0,a.g)(D,D,c[0]),y[W++]=D[0],y[W++]=D[1],y[W++]=D[2];o[G++]=-S[0],o[G++]=-S[1],o[G++]=-S[2];for(let V=0;V<u.length;V++)v.push(u[V][0]>0?u[V][0]:-u[V][0]-1+s.length),v.push(u[V][1]>0?u[V][1]:-u[V][1]-1+s.length),v.push(u[V][2]>0?u[V][2]:-u[V][2]-1+s.length),T.push(0),T.push(0),T.push(0);let st=s.length;const Tt=s.length-1;for(let V=0;V<c.length;V++){let St=!1;V>0&&((0,a.c)(F,S),V<c.length-1?((0,a.d)(S,c[V+1],c[V]),(0,a.n)(S,S)):St=!0,(0,a.g)(Z,F,S),(0,a.n)(Z,Z),(0,a.g)(ut,c[V-1],R),(0,L.O_)(c[V],Z,ft),(0,L.Ui)(ft,(0,K.LV)(ut,F),g)?((0,a.d)(g,g,c[V]),(0,a.n)(P,g),(0,a.e)(B,Z,P),(0,a.n)(B,B)):wt(Z,R,At,Q,B,P,Bt),(0,a.c)(R,P),(0,a.c)(At,B)),I&&((0,a.g)(g,c[V],h),(0,a.n)(b,g));for(let Pt=0;Pt<p;Pt++)if((0,a.h)(D,B,f[Pt][0]),(0,a.h)(g,P,f[Pt][1]),(0,a.g)(D,D,g),(0,a.n)(rt,D),o[G++]=rt[0],o[G++]=rt[1],o[G++]=rt[2],(0,a.g)(D,D,c[V]),y[W++]=D[0],y[W++]=D[1],y[W++]=D[2],!St){const Ct=(Pt+1)%p;v.push(st+Pt),v.push(st+p+Pt),v.push(st+Ct),v.push(st+Ct),v.push(st+p+Pt),v.push(st+p+Ct);for(let Lt=0;Lt<6;Lt++)T.push(v[v.length-6+Lt]-Tt)}st+=p}const Yt=c[c.length-1];for(let V=0;V<s.length;V++)(0,a.h)(D,B,s[V][0]),(0,a.h)(g,P,s[V][1]),(0,a.g)(D,D,g),(0,a.g)(D,D,Yt),y[W++]=D[0],y[W++]=D[1],y[W++]=D[2];const It=G/3;o[G++]=S[0],o[G++]=S[1],o[G++]=S[2];const Rt=st-p;for(let V=0;V<u.length;V++)v.push(u[V][0]>=0?st+u[V][0]:-u[V][0]-1+Rt),v.push(u[V][2]>=0?st+u[V][2]:-u[V][2]-1+Rt),v.push(u[V][1]>=0?st+u[V][1]:-u[V][1]-1+Rt),T.push(It),T.push(It),T.push(It);const Jt=[[x.r.POSITION,new d.n(y,v,3,!0)],[x.r.NORMAL,new d.n(o,T,3,!0)]];return new j.V(A,Jt)}function Gt(A,f,c,s){(0,k.vA)(f.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),(0,k.vA)(3===f[0].length,"createPolylineGeometry(): malformed vertex"),(0,k.vA)(null==c||c.length===f.length,"createPolylineGeometry: need same number of points and normals"),(0,k.vA)(null==c||3===c[0].length,"createPolylineGeometry(): malformed normal");const u=(0,C.jh)(3*f.length),I=new Array(2*(f.length-1));let h=0,p=0;for(let o=0;o<f.length;o++){for(let v=0;v<3;v++)u[h++]=f[o][v];o>0&&(I[p++]=o-1,I[p++]=o)}const y=[[x.r.POSITION,new d.n(u,I,3,!0)]];if(c){const o=(0,z.oe)(3*c.length);let v=0;for(let T=0;T<f.length;T++)for(let W=0;W<3;W++)o[v++]=c[T][W];y.push([x.r.NORMAL,new d.n(o,I,3,!0)])}return s&&y.push([x.r.COLOR,new d.n(s,(0,nt.tM)(s.length/4),4)]),new j.V(A,y,null,et.X.Line)}function Xt(A,f,c,s,u,I=0){const h=new Array(18),p=[[-c,I,u/2],[s,I,u/2],[0,f+I,u/2],[-c,I,-u/2],[s,I,-u/2],[0,f+I,-u/2]];for(let o=0;o<6;o++)h[3*o]=p[o][0],h[3*o+1]=p[o][1],h[3*o+2]=p[o][2];return new j.V(A,[[x.r.POSITION,new d.n(h,[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5],3,!0)]])}function $t(A,f){const c=A.getMutableAttribute(x.r.POSITION).data;for(let s=0;s<c.length;s+=3)(0,a.i)(Dt,c[s],c[s+1],c[s+2]),(0,a.t)(Dt,Dt,f),c[s]=Dt[0],c[s+1]=Dt[1],c[s+2]=Dt[2]}function Qt(A,f=A){const c=A.attributes,s=c.get(x.r.POSITION).data,u=c.get(x.r.NORMAL).data;if(u){const I=f.getMutableAttribute(x.r.NORMAL).data;for(let h=0;h<u.length;h+=3){const p=u[h+1];I[h+1]=-u[h+2],I[h+2]=p}}if(s){const I=f.getMutableAttribute(x.r.POSITION).data;for(let h=0;h<s.length;h+=3){const p=s[h+1];I[h+1]=-s[h+2],I[h+2]=p}}}function xt(A,f,c,s,u){return!(Math.abs((0,a.f)(f,A))>u||((0,a.e)(c,A,f),(0,a.n)(c,c),(0,a.e)(s,c,A),(0,a.n)(s,s),0))}function wt(A,f,c,s,u,I,h){return xt(A,f,u,I,h)||xt(A,c,u,I,h)||xt(A,s,u,I,h)}const Bt=.99619469809,Dt=(0,w.vt)()},16126:(ht,tt,i)=>{i.d(tt,{G7:()=>mt,hz:()=>pt});var a=i(92771),_=i(62789),w=i(28714),C=i(25866),z=i(53781),nt=i(89141),L=i(55703),K=i(23191),d=i(8978),X=i(95263),et=i(32705),j=i(29452);const k=1e-5;class x{constructor(l){this.options=new d.H6,this._results=new yt,this.transform=new j.dg,this.tolerance=k,this.verticalOffset=null,this._ray=(0,L.vt)(),this._rayEnd=(0,C.vt)(),this._rayBeginTransformed=(0,C.vt)(),this._rayEndTransformed=(0,C.vt)(),this.viewingMode=l??K.RT.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(l,E,U){this.resetWithRay((0,L.Cr)(l,E,this._ray),U)}resetWithRay(l,E){this.camera=E,l!==this._ray&&(0,L.C)(l,this._ray),0!==this.options.verticalOffset?this.viewingMode===K.RT.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,(0,w.g)(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(l=null,E,U,$,H){this.point=E,this.filterPredicate=$,this.tolerance=U??k;const Y=(0,j.ou)(this.verticalOffset);if(l&&l.length>0){const r=H?m=>{H(m)&&this.intersectObject(m)}:m=>{this.intersectObject(m)};for(const m of l){const O=m.getSpatialQueryAccelerator?.();null!=O?(null!=Y?O.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,r,Y):O.forEachAlongRay(this._ray.origin,this._ray.direction,r),this.options.selectionMode&&this.options.hud&&O.forEachDegenerateObject(r)):m.objects.forAll(M=>r(M))}}this.sortResults()}intersectObject(l){const E=l.geometries;if(!E)return;const U=l.effectiveTransformation,$=(0,j.ou)(this.verticalOffset);for(const H of E){if(!H.visible)continue;const{material:Y,id:r}=H;if(!Y.visible)continue;this.transform.setAndInvalidateLazyTransforms(U,H.transformation),(0,w.t)(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),(0,w.t)(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const m=this.transform.transform;null!=$&&($.objectTransform=this.transform),Y.intersect(H,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(O,M,N,q,J,at)=>{if(O>=0){if(null!=this.filterPredicate&&!this.filterPredicate(this._ray.origin,this._rayEnd,O))return;const it=q?this._results.hud:this._results,gt=q?dt=>{const Mt=new X.B$(l,r,N,at);dt.set(d.dz.HUD,Mt,O,M,_.zK,J)}:dt=>dt.set(d.dz.OBJECT,{object:l,geometryId:r,triangleNr:N},O,M,m,J);if((null==it.min.drapedLayerOrder||J>=it.min.drapedLayerOrder)&&(null==it.min.dist||O<it.min.dist)&&gt(it.min),this.options.store!==d.oH.MIN&&(null==it.max.drapedLayerOrder||J<it.max.drapedLayerOrder)&&(null==it.max.dist||O>it.max.dist)&&gt(it.max),this.options.store===d.oH.ALL)if(q){const dt=new lt(this._ray);gt(dt),this._results.hud.all.push(dt)}else{const dt=new Ot(this._ray);gt(dt),this._results.all.push(dt)}}})}}sortResults(l=this._results.all){l.sort((E,U)=>E.dist!==U.dist?(E.dist??0)-(U.dist??0):E.drapedLayerOrder!==U.drapedLayerOrder?_t(E.drapedLayerOrder,U.drapedLayerOrder):_t(E.drapedLayerGraphicOrder,U.drapedLayerGraphicOrder))}}function _t(ot,l){return(l??-Number.MAX_VALUE)-(ot??-Number.MAX_VALUE)}function pt(ot){return new x(ot)}class yt{constructor(){this.min=new Ot((0,L.vt)()),this.max=new Ot((0,L.vt)()),this.hud={min:new lt((0,L.vt)()),max:new lt((0,L.vt)()),all:new Array},this.ground=new Ot((0,L.vt)()),this.all=[]}init(l){this.min.init(l),this.max.init(l),this.ground.init(l),this.all.length=0,this.hud.min.init(l),this.hud.max.init(l),this.hud.all.length=0}}class Ot{get ray(){return this._ray}get distanceInRenderSpace(){return null!=this.dist?((0,w.h)(ct,this.ray.direction,this.dist),(0,w.l)(ct)):null}withinDistance(l){return!!(0,et.i3)(this)&&this.distanceInRenderSpace<=l}getIntersectionPoint(l){return!!(0,et.i3)(this)&&((0,w.h)(ct,this.ray.direction,this.dist),(0,w.g)(l,this.ray.origin,ct),!0)}getTransformedNormal(l){return(0,w.c)(vt,this.normal),vt[3]=0,(0,z.t)(vt,vt,this.transformation),(0,w.c)(l,vt),(0,w.n)(l,l)}constructor(l){this.intersector=d.dz.OBJECT,this.normal=(0,C.vt)(),this.transformation=(0,_.vt)(),this._ray=(0,L.vt)(),this.init(l)}init(l){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=d.dz.OBJECT,(0,L.C)(l,this._ray)}set(l,E,U,$,H,Y,r){this.intersector=l,this.dist=U,(0,w.c)(this.normal,$??C.Cb),(0,a.C)(this.transformation,H??_.zK),this.target=E,this.drapedLayerOrder=Y,this.drapedLayerGraphicOrder=r}copy(l){(0,L.C)(l.ray,this._ray),this.intersector=l.intersector,this.dist=l.dist,this.target=l.target,this.drapedLayerOrder=l.drapedLayerOrder,this.drapedLayerGraphicOrder=l.drapedLayerGraphicOrder,(0,w.c)(this.normal,l.normal),(0,a.C)(this.transformation,l.transformation)}}class lt extends Ot{constructor(){super(...arguments),this.intersector=d.dz.HUD}}function mt(ot){return new Ot(ot)}const ct=(0,C.vt)(),vt=(0,nt.vt)()},8978:(ht,tt,i)=>{var a,_,C;i.d(tt,{H6:()=>w,dz:()=>a,oH:()=>_}),(C=a||(a={}))[C.OBJECT=0]="OBJECT",C[C.HUD=1]="HUD",C[C.TERRAIN=2]="TERRAIN",C[C.OVERLAY=3]="OVERLAY",C[C.I3S=4]="I3S",C[C.PCL=5]="PCL",C[C.LOD=6]="LOD",C[C.VOXEL=7]="VOXEL",C[C.TILES3D=8]="TILES3D";class w{constructor(){this.verticalOffset=0,this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.isFiltered=!1,this.filteredLayerUids=[],this.store=_.ALL,this.normalRequired=!0,this.excludeLabels=!1}}!function(C){C[C.MIN=0]="MIN",C[C.MINMAX=1]="MINMAX",C[C.ALL=2]="ALL"}(_||(_={}))},95263:(ht,tt,i)=>{i.d(tt,{B$:()=>w,HE:()=>z,R6:()=>nt});var a=i(25866);class _{constructor(K,d,X){this.object=K,this.geometryId=d,this.triangleNr=X}}class w extends _{constructor(K,d,X,et){super(K,d,X),this.center=null!=et?(0,a.o8)(et):null}}class z{constructor(K){this.layerUid=K}}class nt extends z{constructor(K,d){super(K),this.graphicUid=d}}},32705:(ht,tt,i)=>{i.d(tt,{i3:()=>z}),i(28714);var _=i(25866);function z(X){return null!=X?.dist}i(33096),i(8978),(0,_.vt)()},58309:(ht,tt,i)=>{i.d(tt,{Ci:()=>w,PC:()=>C,Vk:()=>z});var a=i(25866),_=i(45825);function w(K,d){return null==K&&(K=[]),K.push(d),K}function C(K,d){if(null==K)return null;const X=K.filter(et=>et!==d);return 0===X.length?null:X}function z(K,d,X,et,j){nt[0]=K.get(d,0),nt[1]=K.get(d,1),nt[2]=K.get(d,2),(0,_.jS)(nt,L,3),X.set(j,0,L[0]),et.set(j,0,L[1]),X.set(j,1,L[2]),et.set(j,1,L[3]),X.set(j,2,L[4]),et.set(j,2,L[5])}const nt=(0,a.vt)(),L=new Float32Array(6)}}]);