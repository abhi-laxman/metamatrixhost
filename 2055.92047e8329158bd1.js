"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[2055,9361,669,1469,1742],{1469:(g,c,s)=>{s.d(c,{G:()=>P,S:()=>l});class P{*[Symbol.iterator](){let i=this.next();for(;i;)yield i,i=this.next()}}class l extends P{constructor(i){super(),this.m_iGeom=-1,this.m_aGeoms=i?i.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const i=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,i}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}},62107:(g,c,s)=>{s.r(c),s.d(c,{execute:()=>h.e,executeMany:()=>h.a,supportsCurves:()=>h.s}),s(89952),s(69287),s(82663),s(94583),s(90669);var h=s(11583)},90669:(g,c,s)=>{s.r(c),s.d(c,{fromExtent:()=>R,fromGeometry:()=>z,fromMultipoint:()=>x,fromPoint:()=>A,fromPolygon:()=>G,fromPolyline:()=>d,fromSpatialReference:()=>X,getSpatialReference:()=>Z,toExtent:()=>I,toGeometry:()=>S,toMultipoint:()=>T,toPoint:()=>U,toPolygon:()=>V,toPolyline:()=>j});var P=s(33165),l=(s(87571),s(62257)),_=s(7085),i=s(95944),h=s(3037),B=s(28067),K=s(21870),O=s(1749),L=s(55861),W=s(93615),y=(s(51509),s(27312));const a="_gxVersion",v=2,p=1;function Z(t){return Array.isArray(t)?t[0].spatialReference:t.spatialReference}function z(t){switch(t.type){case"point":return A(t);case"multipoint":return x(t);case"polyline":return d(t);case"polygon":return G(t);case"extent":return R(t);default:throw new Error(`Unsupported geometry type: ${t.type}`)}}function R(t){if(!t.getCacheValue(a)){const n=new _.E;n.setCoords(t.xmin,t.ymin,t.xmax,t.ymax),t.hasM&&n.setInterval(v,0,t.mmin,t.mmax),t.hasZ&&n.setInterval(p,0,t.zmin,t.zmax),t.setCacheValue(a,n)}return t.getCacheValue(a)}function x(t){if(!t.getCacheValue(a)){const n=new i.M,e=new _.P,o=t.points,r=t.hasM,u=t.hasZ,m=u?3:2;for(let E=0,f=o.length;E<f;E++){const M=o[E];e.setXYCoords(M[0],M[1]),u&&e.setZ(M[2]??0),r&&e.setM(M[m]??NaN),n.add(e)}t.setCacheValue(a,n)}return t.getCacheValue(a)}function A(t){if(!t.getCacheValue(a)){const n=new _.P;n.setXYCoords(t.x,t.y),t.hasM&&n.setM(t.m),t.hasZ&&n.setZ(t.z),t.setCacheValue(a,n)}return t.getCacheValue(a)}function G(t){if(!t.getCacheValue(a)){const{curveRings:n,hasM:e,hasZ:o,rings:r}=t,u=(0,y.fromGeometryToGXGeometry)({curveRings:n,hasM:e,hasZ:o,rings:r});t.setCacheValue(a,u)}return t.getCacheValue(a)}function d(t){if(!t.getCacheValue(a)){const{curvePaths:n,hasM:e,hasZ:o,paths:r}=t,u=(0,y.fromGeometryToGXGeometry)({curvePaths:n,hasM:e,hasZ:o,paths:r});t.setCacheValue(a,u)}return t.getCacheValue(a)}function X(t){if(t.wkid)return(0,h.c)(t.wkid);const n=t.wkt2||t.wkt;return n?(0,h.b)(n):null}function S(t,n){if(t)switch(t.getGeometryType()){case l.G.enumPoint:return U(t,n);case l.G.enumEnvelope:return I(t,n);case l.G.enumMultiPoint:return T(t,n);case l.G.enumPolyline:return j(t,n);case l.G.enumPolygon:return V(t,n)}return null}function I(t,n){if(t.isEmpty())return null;const e=new B.A({xmin:t.getXMin(),ymin:t.getYMin(),xmax:t.getXMax(),ymax:t.getYMax(),spatialReference:n}),o=t.getDescription();if(o.hasM()){const r=t.queryInterval(v,0);e.mmin=r.vmin,e.mmax=r.vmax}if(o.hasZ()){const r=t.queryInterval(p,0);e.zmin=r.vmin,e.zmax=r.vmax}return e.setCacheValue(a,t),e}function T(t,n){if(t.isEmpty())return null;const e=t.getDescription(),o=e.hasM(),r=e.hasZ(),u=[],m=new _.P;for(let f=0,M=t.getPointCount();f<M;f++){t.getPointByVal(f,m);const C=[m.getX(),m.getY()];r&&C.push(m.getZ()),o&&C.push(m.getM()),u.push(C)}const E=new K.A({hasM:o,hasZ:r,points:u,spatialReference:n});return E.setCacheValue(a,t),E}function U(t,n){if(t instanceof P.P)return new O.A({x:t.x,y:t.y,spatialReference:n});if(t.isEmpty())return null;const e=new O.A({x:t.getX(),y:t.getY(),spatialReference:n}),o=t.getDescription();return o.hasM()&&(e.m=t.getM()),o.hasZ()&&(e.z=t.getZ()),e.setCacheValue(a,t),e}function V(t,n){if(t.isEmpty())return null;const e=L.A.fromJSON({spatialReference:n,...(0,y.toGeometry)(t,null)});return e.setCacheValue(a,t),e}function j(t,n){if(t.isEmpty())return null;const e=W.A.fromJSON({spatialReference:n,...(0,y.toGeometry)(t,null)});return e.setCacheValue(a,t),e}}}]);