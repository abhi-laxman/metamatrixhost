"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[5065,1635],{71635:(ve,se,c)=>{c.r(se),c.d(se,{QueueProcessor:()=>he});var b=c(11432),I=c(56492),X=c(82767),H=c(12619),$=c(3804),j=c(54029);class le{constructor(h,_){this.item=h,this.controller=_,this.promise=null}}class he{constructor(h){this._schedule=null,this._deferreds=new H.A,this._controllers=new H.A,this._processingItems=new H.A,this._pausedSignal=(0,j.v)(!1),this.concurrency=1,h.concurrency&&(this.concurrency=h.concurrency),this._queue=new X.A(h.peeker),this.process=h.process}destroy(){this.clear(),this._schedule=(0,b.xt)(this._schedule)}get updating(){return this.running}get length(){return this._processingItems.size+this._queue.length}get running(){return!this._pausedSignal.value&&this._queue.length>0&&this._processingItems.size<this.concurrency}abort(h){const _=this._controllers.get(h);_&&_.abort()}clear(){this._queue.clear();const h=[];this._controllers.forEach(_=>h.push(_)),this._controllers.clear(),h.forEach(_=>_.abort()),this._processingItems.clear(),this._cancelNext()}forEach(h){this._deferreds.forEach((_,B)=>h(B))}get(h){const _=this._deferreds.get(h);return _?_.promise:void 0}isOngoing(h){return this._processingItems.has(h)}has(h){return this._deferreds.has(h)}pause(){this._pausedSignal.value||(this._pausedSignal.value=!0,this._cancelNext())}push(h,_){const B=this.get(h);if(B)return B;const S=new AbortController;let W=null;_&&(W=(0,I.u7)(_,()=>S.abort()));const D=()=>{E.remove(),W?.remove(),this._removeItem(h),this._queue.remove(h),this._scheduleNext()},E=(0,I.NY)(S.signal,()=>{const g=this._processingItems.get(h);g&&g.controller.abort(),D(),f.reject((0,I.NK)())}),f=(0,I.Tw)();return this._deferreds.set(h,f),this._controllers.set(h,S),f.promise.then(D,D),this._queue.push(h),this._scheduleNext(),f.promise}last(){return this._queue.last()}lastPromise(){const h=this.last();return h?this.get(h):null}peek(){return this._queue.peek()}popLast(){const h=this._queue.popLast();return h&&(this._deferreds.get(h)?.reject((0,I.NK)()),this._removeItem(h)),h}reset(){const h=Array.from(this._processingItems.values());this._processingItems.clear();for(const _ of h)this._queue.push(_.item),_.controller.abort();this._scheduleNext()}resume(){this._pausedSignal.value&&(this._pausedSignal.value=!1,this._scheduleNext())}takeAll(){const h=[];for(;this._queue.length;)h.push(this._queue.pop());return this.clear(),h}_removeItem(h){this._deferreds.delete(h),this._controllers.delete(h),this._processingItems.delete(h)}_scheduleNext(){this._pausedSignal.value||this._schedule||(this._schedule=(0,$._)(()=>{this._schedule=null,this._next()}))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(h,_){this._canProcessFulfillment(h)&&(this._scheduleNext(),this._deferreds.get(h.item).resolve(_))}_processError(h,_){this._canProcessFulfillment(h)&&(this._scheduleNext(),this._deferreds.get(h.item).reject(_))}_canProcessFulfillment(h){return!!this._deferreds.get(h.item)&&this._processingItems.get(h.item)===h}_process(h){if(null==h)return;let _;const B=new AbortController,S=new le(h,B);this._processingItems.set(h,S);try{_=this.process(h,B.signal)}catch(W){this._processError(S,W)}(0,I.$X)(_)?(S.promise=_,_.then(W=>this._processResult(S,W),W=>this._processError(S,W))):this._processResult(S,_)}}},4695:(ve,se,c)=>{c.d(se,{o:()=>t});var b=c(10467),I=c(8189),X=c(89563),H=c(5922),$=c(35150),j=c(85211),le=c(55739),h=(c(3248),c(40707),c(15463)),_=c(17221),B=c(76576),S=c(1749),W=c(32034),J=c(58701),D=c(68438),E=c(22329),f=c(52593),g=c(92870),x=c(9932),m=c(49343),P=c(85889),v=c(11333),U=c(48457),k=c(20053),w=c(18703),G=c(90126),F=c(40018),q=c(48104),V=c(50444),K=c(22151),Z=c(54636),L=c(28919),de=c(98464),Q=c(91551);const t=n=>{let r=class extends n{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===e[0]?.raster?.datasetFormat}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){"none"===e?.functionName?.toLowerCase()&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",(0,D.Jf)(e,$.A.getLogger(this)))}get renderer(){if("imagery-tile"!==this.type)return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:s}=this;return e?s?.find(({name:i})=>i===e)?.renderer.clone():this.internalRenderer}set renderer(e){"imagery-tile"===this.type&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){null==e&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,s,l){const i=s?.layerDefinition?.drawingInfo?.renderer;return(0,L.LF)(i,l)||void 0}convertVectorFieldData(e,s){var l=this;return(0,b.A)(function*(){const{serviceRasterInfo:i}=l;if(null==e||!i)return null;const a=l._rasterJobHandler.instance,u=i.dataType;return a?a.convertVectorFieldData({pixelBlock:e,dataType:u},s):(0,V.FI)(e,u)})()}computeStatisticsHistograms(e,s){var l=this;return(0,b.A)(function*(){yield l.load(s),e=(0,le.PZ)(de.A,e).clone();const{serviceRasterInfo:i}=l;if(null==i)throw new H.A("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:a}=e;if(null==a)throw new H.A("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let u=a;const{spatialReference:d}=i;a.spatialReference.equals(d)||(yield(0,F.Hh)(),u="extent"===a.type?(0,F._l)(a,d):(0,F.uk)(a,d));const y=e.pixelSize??new S.A({x:i.pixelSize.x,y:i.pixelSize.y,spatialReference:d}),{extent:R,width:p,height:M}=(0,w.b7)(i,u,y),C=yield l.fetchPixels(R,p,M,{...s,interpolation:"nearest"});if(null==C.pixelBlock)throw new H.A("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const A=yield(0,w.$Q)(C.pixelBlock,R,u),O=l._rasterJobHandler.instance;return O?O.computeStatisticsHistograms({pixelBlock:A},s):(0,q.eH)(A)})()}createFlowMesh(e,s){var l=this;return(0,b.A)(function*(){const i=l._rasterJobHandler.instance;return i?i.createFlowMesh(e,s):(0,Q.CW)(e.meshType,e.simulationSettings,e.flowData,null!=s.signal?s.signal:(new AbortController).signal)})()}normalizeRasterFetchOptions(e){const{multidimensionalInfo:s}=this.serviceRasterInfo??{};if(null==s)return e;const l=(0,k.XU)({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:l}}updateRasterFunction(){var e=this;return(0,b.A)(function*(){return e.loaded&&"imagery-tile"===e.type&&(e.rasterFunction||e._cachedRasterFunctionJson)&&JSON.stringify(e.rasterFunction)!==JSON.stringify(e._cachedRasterFunctionJson)&&(e._cachedRasterFunctionJson=e.rasterFunction?.toJSON(),e._rasterFunctionUpdatePromise=e._updateRasterFunction()),e._rasterFunctionUpdatePromise})()}updateRenderer(){var e=this;return(0,b.A)(function*(){const{loaded:s,symbolizer:l}=e;if(!s||!l||!e.renderer)return;const{rasterInfo:i}=e.raster,a=(0,k.ct)(i,{multidimensionalDefinition:e.multidimensionalDefinition,multidimensionalSubset:e.multidimensionalSubset}),u=a?.name,d=(0,K.$P)({...e.renderer.toJSON(),variableName:u});if(JSON.stringify(e._cachedRendererJson)===JSON.stringify(d))return;const y=e._rasterJobHandler.instance;y&&(l.rasterInfo=(0,K.m7)(i,u),l.rendererJSON=d,l.bind(),yield y.updateSymbolizer(l),e._cachedRendererJson=d)})()}applyRenderer(e,s){var l=this;return(0,b.A)(function*(){const i=e?.pixelBlock;if(!(null!=i&&i.pixels&&i.pixels.length>0))return null;let a;yield l.updateRenderer();const u=l._rasterJobHandler.instance,d=l.bandIds??[];return a=u?yield u.symbolize({...e,simpleStretchParams:s,bandIds:d}):l.symbolizer.symbolize({...e,simpleStretchParams:s,bandIds:d}),a})()}getTileUrl(e,s,l){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${s}/${l}`:""}getCompatibleTileInfo(e,s,l=!1){if(!this.loaded||null==s)return null;if(l&&e.equals(this.spatialReference))return this.tileInfo;const i=(0,J.Vp)(e);return v.A.create({size:256,spatialReference:e,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:s.xmin,y:s.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}fetchTile(e,s,l,i={}){var a=this;return(0,b.A)(function*(){if(o(a),i.requestAsImageElement){const d=a.getTileUrl(e,s,l);return(0,X.A)(d,{responseType:"image",query:{...a.refreshParameters,...a.raster.ioConfig.customFetchParameters},signal:i.signal}).then(y=>y.data)}const{serviceRasterInfo:u}=a;return null!=u.multidimensionalInfo&&null==(i=a.normalizeRasterFetchOptions(i)).multidimensionalDefinition?{extent:a.raster.getTileExtentFromTileInfo(e,s,l,i.tileInfo||u.storageInfo.tileInfo),pixelBlock:null}:(yield a._initJobHandler(),yield a.updateRasterFunction(),"raster-shaded-relief"===a.renderer?.type&&(i={...i,buffer:{cols:1,rows:1}}),a.raster.fetchTile(e,s,l,i))})()}fetchPixels(e,s,l,i={}){var a=this;return(0,b.A)(function*(){return null!=a.serviceRasterInfo.multidimensionalInfo&&null==(i=a.normalizeRasterFetchOptions(i)).multidimensionalDefinition?{extent:e,pixelBlock:null}:(yield a._initJobHandler(),yield a.updateRasterFunction(),s=Math.round(s),l=Math.round(l),a.raster.fetchPixels(e,s,l,i))})()}identify(e,s={}){var l=this;return(0,b.A)(function*(){yield l.load();const{raster:i,serviceRasterInfo:a}=l;if(!(null==a?.multidimensionalInfo||a.hasMultidimensionalTranspose&&((0,k.DY)(s.multidimensionalDefinition)||s.transposedVariableName||s.timeExtent)||null!=(s=l.normalizeRasterFetchOptions(s)).multidimensionalDefinition))return{location:e,value:null};const u=l.multidimensionalSubset?.areaOfInterest;if(u&&!u.contains(e))throw new H.A("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return i.identify(e,s)})()}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(null==e||"standard-time"!==this.serviceRasterInfo?.dataType)return!1;const s=this.multidimensionalDefinition,l=s?.[0]?.variableName;return e.variables.some(i=>i.name===l&&(!s?.[0].dimensionName||i.dimensions.some(a=>"StdTime"===a.name)))}getStandardTimeValue(e){return new Date((0,k.$E)(e)).toISOString()}getMultidimensionalSubsetVariables(e){return(0,k.z2)(this.multidimensionalSubset,e??this.serviceRasterInfo?.multidimensionalInfo)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=(0,k.fy)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){var e=this;if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const s=new P.A;return this._rasterJobHandler.connectionPromise=s.initialize().then((0,b.A)(function*(){o(e),e._rasterJobHandler.instance=s,e.raster.rasterJobHandler=s,"Function"===e.raster.datasetFormat&&e.raster.syncJobHandler(),e.rasterFunction&&(yield e.updateRasterFunction().catch(()=>{})),e.renderer&&e.updateRenderer()})).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){o(this);const{raster:e}=this,s=(0,K.w6)(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",s)}}_configDefaultRenderer(e="no"){o(this);const{rasterInfo:s}=this.raster,l=(0,k.ct)(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),i=l?.name,a=(0,K.I8)({variableName:i,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&s.bandCount>1&&(this.bandIds=a?.bandIds??(0,K.ci)(s)),!this.renderer||"override"===e){const R=(0,K.Mm)(this.raster),p=a?.renderer??(0,K.PD)(s,{bandIds:this.bandIds,variableName:i,rasterFunctionColorRamp:R}),M=s.statistics,C=M&&M.length>0?M[0]:null;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===p.type&&((C?.max??0)>1e24||(C?.min??0)<-1e24)&&(p.dynamicRangeAdjustment=!0,p.customStatistics=null,"none"===p.stretchType&&(p.stretchType="min-max")),this.renderer=p}const u=(0,K.$P)({...this.renderer.toJSON(),variableName:i}),d=(0,K.m7)(s,i);this.symbolizer?(this.symbolizer.rendererJSON=u,this.symbolizer.rasterInfo=d):this.symbolizer=new Z.A({rendererJSON:u,rasterInfo:d});const y=this.symbolizer.bind();if(y.success){if("auto"===e){const{colormap:R}=this.raster.rasterInfo,p=this.renderer;if(null!=R&&"raster-colormap"===p.type){const M=(0,K.PD)(this.raster.rasterInfo);JSON.stringify(M)!==JSON.stringify(p)&&this._configDefaultRenderer("override")}else if("raster-stretch"===p.type){const M=this.bandIds?.length,C=p.customStatistics?.length;!p.dynamicRangeAdjustment&&C&&M&&C!==M&&this._configDefaultRenderer("override")}}}else $.A.getLogger(this).warn("imagery-tile-mixin",y.error||"The given renderer is not supported by the layer."),"auto"===e&&this._configDefaultRenderer("override")}_updateRasterFunction(){var e=this;return(0,b.A)(function*(){if(e._isConstructedFromFunctionRaster&&"Function"===e.raster.datasetFormat){const R=e.raster.rasterFunction.toJSON();return void(!e.rasterFunction&&R&&e._set("rasterFunction",m.A.fromJSON(R)))}let s,l=e.raster,i=!1;"Function"===l.datasetFormat?(s=l.primaryRasters.rasters,l=s[0],i=!0):s=[l];const{rasterFunction:a}=e;if(a){const R={raster:l};s.length>1&&s.forEach(C=>R[C.url]=C);const p=(0,G.vt)(a.functionDefinition?.toJSON()??a.toJSON(),R),M=new U.A({rasterFunction:p});M.rasterJobHandler=e._rasterJobHandler.instance,yield M.open(),e.raster=M}else e.raster=l,yield l.open();if(e._cachedRendererJson=null,!i&&!a)return;const{bandIds:u}=e,{bandCount:d}=e.raster.rasterInfo,y=u?.length?u.some(R=>R>=d):d>=3;u&&(y||e.renderer&&"raster-stretch"!==e.renderer.type)&&e._set("bandIds",null),e._configDefaultRenderer("auto")})()}};function o(e){if(!e.raster||!e.serviceRasterInfo)throw new H.A("imagery-tile","no raster")}return(0,I._)([(0,j.MZ)({clonable:!1})],r.prototype,"_cachedRendererJson",void 0),(0,I._)([(0,j.MZ)({clonable:!1})],r.prototype,"_cachedRasterFunctionJson",void 0),(0,I._)([(0,j.MZ)({clonable:!1})],r.prototype,"_compatibleFullExtent",void 0),(0,I._)([(0,j.MZ)({clonable:!1})],r.prototype,"_isConstructedFromFunctionRaster",void 0),(0,I._)([(0,j.MZ)({clonable:!1})],r.prototype,"_rasterJobHandler",void 0),(0,I._)([(0,j.MZ)({clonable:!1})],r.prototype,"_rasterFunctionUpdatePromise",void 0),(0,I._)([(0,j.MZ)({type:[le.jz],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],r.prototype,"bandIds",void 0),(0,I._)([(0,j.MZ)({json:{origins:{service:{read:{source:"copyrightText"}}}}})],r.prototype,"copyright",void 0),(0,I._)([(0,j.MZ)({json:{read:!1}})],r.prototype,"fullExtent",null),(0,I._)([(0,j.MZ)({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),(0,h.e)(x.SZ)],r.prototype,"interpolation",void 0),(0,I._)([(0,j.MZ)()],r.prototype,"ioConfig",void 0),(0,I._)([(0,j.MZ)({type:[f.A],json:{write:!0}})],r.prototype,"multidimensionalDefinition",null),(0,I._)([(0,j.MZ)({type:g.A,json:{write:!0}})],r.prototype,"multidimensionalSubset",void 0),(0,I._)([(0,j.MZ)()],r.prototype,"raster",void 0),(0,I._)([(0,j.MZ)({type:m.A})],r.prototype,"rasterFunction",null),(0,I._)([(0,j.MZ)()],r.prototype,"serviceRasterInfo",void 0),(0,I._)([(0,j.MZ)()],r.prototype,"sourceJSON",void 0),(0,I._)([(0,j.MZ)({readOnly:!0,type:W.A,json:{read:!1}})],r.prototype,"spatialReference",void 0),(0,I._)([(0,j.MZ)({type:v.A})],r.prototype,"tileInfo",void 0),(0,I._)([(0,j.MZ)(E.OZ)],r.prototype,"url",null),(0,I._)([(0,j.MZ)()],r.prototype,"renderer",null),(0,I._)([(0,j.MZ)({types:L.uy,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||!("raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma)}}},origins:{"web-scene":{types:L.Gj,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],r.prototype,"internalRenderer",null),(0,I._)([(0,_.w)("internalRenderer")],r.prototype,"readRenderer",null),(0,I._)([(0,j.MZ)({clonable:!1})],r.prototype,"symbolizer",void 0),r=(0,I._)([(0,B.$)("esri.layers.mixins.ImageryTileMixin")],r),r}},78240:(ve,se,c)=>{c.d(se,{A:()=>Q});var b=c(10467),I=c(8189),X=c(89563),H=c(5922),$=c(71065),j=c(35150),le=c(56492),he=c(71635),N=c(85211),h=c(55739),S=(c(3248),c(40707),c(76576)),W=c(28067),J=c(1749),D=c(32034),E=c(68438),f=c(22329),g=c(52593),x=c(29598),m=c(61599),P=c(11333),v=c(20053),U=c(62619),k=c(96115),w=c(99263),G=c(40275),F=c(40018),q=c(50444);let Z=0,L=class extends $.A{constructor(){super(...arguments),this._tileFetchQueue=new he.QueueProcessor({concurrency:32,process:(t,n)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:n})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t?.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:P.A.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,n=(0,F.FT)(t.spatialReference);return null!=n&&t.extent.width>=n/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return null==t||"gcs-shift"===t.type}set rasterJobHandler(t){this._set("rasterJobHandler",t),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach(n=>n.rasterJobHandler=t)}get rasterId(){return this.url||"rasterId-"+Z++}set url(t){this._set("url",(0,E.Jf)(t,j.A.getLogger(this)))}open(t){var n=this;return(0,b.A)(function*(){return n._openPromise??=(0,F.Hh)().then(()=>n._open(t)),n._openPromise})()}fetchTile(t,n,r,o={}){var e=this;return(0,b.A)(function*(){const s=o.tileInfo||e.rasterInfo.storageInfo.tileInfo,l=e.getTileExtentFromTileInfo(t,n,r,s);return o={noClip:!0,...o},e.fetchPixels(l,s.size[0],s.size[1],o)})()}identify(t,n={}){var r=this;return(0,b.A)(function*(){t=(0,h.PZ)(J.A,t).clone().normalize();const{multidimensionalDefinition:o,timeExtent:e}=n,{rasterInfo:s}=r,{hasMultidimensionalTranspose:l,multidimensionalInfo:i}=s;let{transposedVariableName:a}=n;const u=null!=i&&l&&(null!=e||(0,v.DY)(o));u&&!a&&(a=null!=o&&o.length>0?o[0].variableName??void 0:i.variables[0].name,n={...n,transposedVariableName:a}),n=r._getRequestOptionsWithSliceId(n);const{spatialReference:d,extent:y}=s,{datumTransformation:R}=n;let p=(0,F._I)(t,d,R);if(!y.intersects(p))return{location:p,value:null};if(null!=s.transform){const ae=s.transform.inverseTransform(p);if(!s.nativeExtent.intersects(ae))return{location:ae,value:null};p=ae}let M=0;const C=null!=a&&null!=i&&s.hasMultidimensionalTranspose;if("Function"===r.datasetFormat){const ae=r.primaryRasters.rasters[0];if(C)return ae.identify(p,n);const{pixelSize:Pe}=s,ee=3,oe=Pe.x*ee/2,te=Pe.y*ee/2,ce=new W.A({xmin:p.x-oe,xmax:p.x+oe,ymin:p.y-te,ymax:p.y+te,spatialReference:d}),_e={interpolation:"nearest",multidimensionalDefinition:o,sliceId:n.sliceId},{pixelBlock:me}=yield ae.fetchPixels(ce,ee,ee,_e),{pixelBlock:ne}=yield r.fetchPixels(ce,ee,ee,_e);if(null==me)return{location:p,value:null};const re=Math.floor(ee*ee*.5),Re=!me.mask||me.mask[re]?me.pixels.map(ue=>ue[re]):null;let Me;return null!=ne&&(Me=!ne.mask||ne.mask[re]?ne.pixels.map(ue=>ue[re]):void 0),{location:p,value:Re,processedValue:Me,pyramidLevel:0}}if(!C)if(n.srcResolution)M=(0,F.t$)(n.srcResolution,s,r.ioConfig.sampling).pyramidLevel;else if(M=yield r.computeBestPyramidLevelForLocation(t,n),null==M)return{location:p,value:null};const A=r.identifyPixelLocation(p,M,null,C);if(null===A)return{location:p,value:null};const{row:O,col:T,rowOffset:z,colOffset:Y,blockWidth:ie}=A,fe=(0,U.ph)(r.rasterId,a??n.sliceId),pe=`${M}/${O}/${T}`;let ye=(0,U.gd)(fe,null,pe);null==ye&&(ye=r.fetchRawTile(M,O,T,n),(0,U.no)(fe,null,pe,ye));const ge=yield ye;return ge?.pixels?.length?r._processIdentifyResult(ge,{srcLocation:p,position:z*ie+Y,pyramidLevel:M,useTransposedTile:!!C,requestSomeSlices:u,identifyOptions:n}):{location:p,value:null}})()}fetchPixels(t,n,r,o={}){var e=this;return(0,b.A)(function*(){t=(0,F.Ps)(t),o=e._getRequestOptionsWithSliceId(o);const{_hasNoneOrGCSShiftTransform:s}=e;if(o.requestRawData&&s)return e._fetchPixels(t,n,r,o);const l=(0,F.FT)(t.spatialReference),i=(0,F.OM)(t);if(null==l||0===i||1===i&&e._isGlobalWrappableSource&&s)return e._fetchPixels(t,n,r,o);if(i>=3)return{extent:t,pixelBlock:null};const a=[],{xmin:u,xmax:d}=t,y=Math.round(l/(d-u)*n),R=y-Math.round((l/2-u)/(d-u)*n);let p=0;const M=[];for(let T=0;T<=i;T++){const z=new W.A({xmin:0===T?u:-l/2,xmax:T===i?d-l*T:l/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),Y=0===T?y-R:T===i?n-p:y;p+=Y,M.push(Y);const ie=o.disableWrapAround&&T>0?null:e._fetchPixels(z,Y,r,o);a.push(ie)}const C=(yield Promise.all(a)).map(T=>T?.pixelBlock);let A=null;const O={width:n,height:r};return A=e.rasterJobHandler?(yield e.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:C,srcMosaicSize:O,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:M},o)).pixelBlock:(0,G.z7)(C,O,{blockWidths:M}),{extent:t,srcExtent:(0,F._l)(t,e.rasterInfo.spatialReference,o.datumTransformation),pixelBlock:A}})()}fetchRawPixels(t,n,r,o={}){var e=this;return(0,b.A)(function*(){n={x:Math.floor(n.x),y:Math.floor(n.y)};const s=yield e._fetchRawTiles(t,n,r,o),{nativeExtent:l,nativePixelSize:i,storageInfo:a}=e.rasterInfo,u=2**t,d=i.x*u,y=i.y*u,R=new W.A({xmin:l.xmin+d*n.x,xmax:l.xmin+d*(n.x+r.width-1),ymin:l.ymax-y*(n.y+r.height-1),ymax:l.ymax-y*n.y,spatialReference:l.spatialReference});if(!s)return{extent:R,srcExtent:R,pixelBlock:null};const{pixelBlocks:p,mosaicSize:M}=s;if(1===p.length&&null!=p[0]&&p[0].width===r.width&&p[0].height===r.height)return{extent:R,srcExtent:R,pixelBlock:s.pixelBlocks[0]};const O={x:n.x%(t>0?a.pyramidBlockWidth:a.blockWidth),y:n.y%(t>0?a.pyramidBlockHeight:a.blockHeight)};let T;return T=e.rasterJobHandler?(yield e.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:M,destDimension:r,clipOffset:O,clipSize:r,coefs:null,sampleSpacing:null,interpolation:o.interpolation,alignmentInfo:null,blockWidths:null},o)).pixelBlock:(0,G.z7)(p,M,{clipOffset:O,clipSize:r}),{extent:R,srcExtent:R,pixelBlock:T}})()}fetchRawTile(t,n,r,o){throw new H.A("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return(0,F._l)(this.rasterInfo.extent,t)}decodePixelBlock(t,n){return!this.rasterJobHandler||n.useCanvas?(0,w.D)(t,n):this.rasterJobHandler.decode({data:t,options:n})}request(t,n,r=0){var o=this;return(0,b.A)(function*(){const{customFetchParameters:e}=o.ioConfig,{range:s,query:l,headers:i}=n;r=r??n.retryCount??o.ioConfig.retryCount;const a=s?{Range:`bytes=${s.from}-${s.to}`}:null;try{return yield(0,X.A)(t,{...n,query:{...l,...e},headers:{...i,...a}})}catch(u){if(r>0)return r--,o.request(t,n,r);throw u}})()}getSliceIndex(t){const{multidimensionalInfo:n}=this.rasterInfo;return null==n||null==t||0===t.length?null:(0,v.NG)(t,n)}getTileExtentFromTileInfo(t,n,r,o){const e=o.lodAt(t);return this.getTileExtent({x:e.resolution,y:e.resolution},n,r,o.origin,o.spatialReference,o.size)}updateTileInfo(){const{storageInfo:t,spatialReference:n,extent:r,pixelSize:o}=this.rasterInfo,{pyramidResolutions:e}=t;if(!t.tileInfo){const s=[],l=t.maximumPyramidLevel||0;let i=(o.x+o.y)/2,a=1/.0254*96*i;for(let d=0;d<=l&&(s.unshift(new x.A({level:l-d,resolution:i,scale:a})),d!==l);d++)if(e){const y=(e[d].x+e[d].y)/2;a*=y/i,i=y}else i*=2,a*=2;const u=new J.A({x:r.xmin,y:r.ymax,spatialReference:n});t.tileInfo=new P.A({origin:u,size:[t.blockWidth,t.blockHeight],spatialReference:n,lods:s}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,n=512,r=512,o){const{width:e,height:s,nativeExtent:l,pixelSize:i,spatialReference:a}=t,u=new J.A({x:l.xmin,y:l.ymax,spatialReference:a});null==o&&(o=Math.max(0,Math.round(Math.log(Math.max(e,s))/Math.LN2-8)));const d=this.computeBlockBoundary(l,512,512,{x:l.xmin,y:l.ymax},[i],o);t.storageInfo=new m.A({blockWidth:n,blockHeight:r,pyramidBlockWidth:n,pyramidBlockHeight:r,origin:u,firstPyramidLevel:1,maximumPyramidLevel:o,blockBoundary:d})}computeBestPyramidLevelForLocation(t,n={}){return(0,b.A)(function*(){return 0})()}computeBlockBoundary(t,n,r,o,e,s=0,l=2){if(1===e.length&&s>0){e=[...e];let{x:d,y}=e[0];for(let R=0;R<s;R++)d*=l,y*=l,e.push({x:d,y})}const i=[],{x:a,y:u}=o;for(let d=0;d<e.length;d++){const{x:y,y:R}=e[d];i.push({minCol:Math.floor((t.xmin-a+.1*y)/n/y),maxCol:Math.floor((t.xmax-a-.1*y)/n/y),minRow:Math.floor((u-t.ymax+.1*R)/r/R),maxRow:Math.floor((u-t.ymin-.1*R)/r/R)})}return i}getPyramidPixelSize(t){const{nativePixelSize:n}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:o}=this.rasterInfo.storageInfo;if(0===t)return n;if(null!=r&&r.length)return r[t-1];const e=o**t;return{x:n.x*e,y:n.y*e}}identifyPixelLocation(t,n,r,o){const{spatialReference:e,nativeExtent:s,storageInfo:l}=this.rasterInfo,{maximumPyramidLevel:i,origin:a,transposeInfo:u}=l,d=o&&null!=u?u.tileSize[0]:l.blockWidth,y=o&&null!=u?u.tileSize[1]:l.blockHeight,R=(0,F._I)(t,e,r);if(!s.intersects(R)||n<0||n>i)return null;const p=this.getPyramidPixelSize(n),{x:M,y:C}=p,A=(a.y-R.y)/C/y,O=(R.x-a.x)/M/d,T=Math.min(y-1,Math.floor((A-Math.floor(A))*y)),z=Math.min(d-1,Math.floor((O-Math.floor(O))*d));return{pyramidLevel:n,row:Math.floor(A),col:Math.floor(O),rowOffset:T,colOffset:z,blockWidth:d,srcLocation:R}}getTileExtent(t,n,r,o,e,s){const[l,i]=s,a=o.x+r*l*t.x,d=o.y-n*i*t.y;return new W.A({xmin:a,xmax:a+l*t.x,ymin:d-i*t.y,ymax:d,spatialReference:e})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,n,r){const o=this.rasterInfo.storageInfo.blockBoundary[t];return!o||o.maxRow<n||o.maxCol<r||o.minRow>n||o.minCol>r}updateImageSpaceRasterInfo(t){const{pixelSize:n}=t,{width:r,height:o}=t,e=D.A.WebMercator;t.spatialReference=e,t.extent=t.nativeExtent=new W.A({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-o,spatialReference:e}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new J.A({x:1,y:1,spatialReference:e});const{extent:s,storageInfo:l}=t;if(l){l.origin=new J.A({x:s.xmin,y:s.ymax,spatialReference:e});const{pyramidResolutions:i,tileInfo:a}=l;if(i&&i.forEach(u=>{u.x/=n.x,u.y/=n.y}),a){a.origin=l.origin;const u=(t.nativePixelSize.x+t.nativePixelSize.y)/2;a.lods.forEach((d,y)=>{d.resolution=u*2**y,d.scale=96*d.resolution/.0254})}}}_fetchPixels(t,n,r,o={}){var e=this;return(0,b.A)(function*(){let s=(0,F.OM)(t);if(s>=2)return{extent:t,pixelBlock:null};const l=e._getSourceDataInfo(t,n,r,o),{pyramidLevel:i,srcResolution:a,srcExtent:u,srcWidth:d,srcHeight:y,ul:R}=l;if(0===d||0===y)return{extent:t,srcExtent:u,pixelBlock:null};const{rasterInfo:p}=e,M=p.transform,C="gcs-shift"===M?.type,A=null!=(0,F.FT)(t.spatialReference);!C&&A||(s=(0,F.OM)(l.srcExtent,C));const O=yield e._fetchRawTiles(i,R,{width:d,height:y,wrapCount:s},o);if(!O)return{extent:t,srcExtent:u,pixelBlock:null};const T=p.storageInfo,z=i>0?T.pyramidBlockWidth:T.blockWidth,Y=i>0?T.pyramidBlockHeight:T.blockHeight;let{x:ie,y:Ie}=p.pixelSize;if(i>0){const{pyramidResolutions:Ee,pyramidScalingFactor:Oe}=T;if(null!=Ee&&Ee[i-1])({x:ie,y:Ie}=Ee[i-1]);else{const De=Oe**i;ie*=De,Ie*=De}}const fe=p.spatialReference,pe=new J.A({x:ie,y:Ie,spatialReference:fe}),ye=z===d&&Y===y&&R.x%z==0&&R.y%Y==0,ge=new J.A({x:(t.xmax-t.xmin)/n,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference}),xe=!t.spatialReference.equals(fe),ae=fe.isGeographic?1e-9:1e-4,{datumTransformation:Pe}=o;if(!xe&&ye&&1===O.pixelBlocks.length&&z===n&&Y===r&&function de(t,n,r){return Math.abs(t.x-n.x)<r&&Math.abs(t.y-n.y)<r}(a,ge,ae))return{extent:t,srcExtent:u,srcTilePixelSize:pe,pixelBlock:O.pixelBlocks[0]};const ee=A&&null!=(0,F.FT)(u.spatialReference)&&e._hasNoneOrGCSShiftTransform,oe=o.requestProjectedLocalDirections&&e.rasterInfo.dataType.startsWith("vector");oe&&!e.rasterJobHandler&&(yield(0,F.Hh)());const te=e.rasterJobHandler?yield e.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:O.extent,pixelSize:ge.toJSON(),datumTransformation:Pe,rasterTransform:M,hasWrapAround:s>0||ee,isAdaptive:!1!==e.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:oe},o):(0,F.l0)({projectedExtent:t,srcBufferExtent:O.extent,pixelSize:ge,datumTransformation:Pe,rasterTransform:M,hasWrapAround:s>0||ee,isAdaptive:!1,includeGCSGrid:oe});let ce;const _e=!o.requestRawData,me={rows:te.spacing[0],cols:te.spacing[1]},ne=e._hasNoneOrGCSShiftTransform?e._getRasterTileAlignmentInfo(i,O.extent.xmin):void 0,{pixelBlocks:re,mosaicSize:Re,isPartiallyFilled:Me}=O;let ue=null;if(e.rasterJobHandler)({pixelBlock:ce,localNorthDirections:ue}=yield e.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:re,srcMosaicSize:Re,destDimension:_e?{width:n,height:r}:null,coefs:_e?te.coefficients:null,sampleSpacing:_e?me:null,projectDirections:oe,gcsGrid:oe?te.gcsGrid:null,isUV:"vector-uv"===e.rasterInfo.dataType,interpolation:o.interpolation,alignmentInfo:ne,blockWidths:null},o));else{const Ee=(0,G.z7)(re,Re,{alignmentInfo:ne});ce=_e?(0,G.$i)(Ee,{width:n,height:r},te.coefficients,me,o.interpolation):Ee,oe&&te.gcsGrid&&(ue=(0,G.QF)({width:n,height:r},te.gcsGrid),ce=(0,q.Y2)(ce,e.rasterInfo.dataType,ue))}return o.requestRawData||oe?{extent:t,srcExtent:u,srcTilePixelSize:pe,pixelBlock:ce,transformGrid:te,localNorthDirections:ue,isPartiallyFilled:Me}:{extent:t,srcExtent:u,srcTilePixelSize:pe,pixelBlock:ce}})()}_fetchRawTiles(t,n,r,o){var e=this;return(0,b.A)(function*(){const{origin:s,blockBoundary:l}=e.rasterInfo.storageInfo,{blockWidth:i,blockHeight:a}=e.getBlockWidthHeight(t);let{x:u,y:d}=n,{width:y,height:R,wrapCount:p}=r;const M=e._getRasterTileAlignmentInfo(t,0);o.buffer&&(u-=o.buffer.cols,d-=o.buffer.rows,y+=2*o.buffer.cols,R+=2*o.buffer.rows);let C=0,A=0,O=0;p&&null!=M&&(({worldColumnCountFromOrigin:A,originColumnOffset:O,rightPadding:C}=M),A*M.blockWidth-C>=u+y&&(C=0));const T=Math.floor(u/i),z=Math.floor(d/a),Y=Math.floor((u+y+C-1)/i),ie=Math.floor((d+R+C-1)/a),Ie=l[t];if(!Ie)return null;const{minRow:fe,minCol:pe,maxCol:ye,maxRow:ge}=Ie;if(0===p&&(ie<fe||Y<pe||z>ge||T>ye))return null;const xe=new Array;let ae=!1;const Pe=null==e.ioConfig.allowPartialFill?o.allowPartialFill:e.ioConfig.allowPartialFill;for(let ne=z;ne<=ie;ne++)for(let re=T;re<=Y;re++){let Re=re;if(!o.disableWrapAround&&p&&null!=M&&A<=re&&(Re=re-A-O),ne>=fe&&Re>=pe&&ge>=ne&&ye>=Re){const Me=e._tileFetchQueue.push({pyramidLevel:t,row:ne,col:Re,options:o},{signal:o.signal});xe.push(Pe?new Promise(ue=>{Me.then(Ee=>ue(Ee)).catch(()=>{ae=!0,ue(null)})}):Me)}else xe.push(Promise.resolve(null))}if(0===xe.length)return null;const ee=yield Promise.all(xe),oe={height:(ie-z+1)*a,width:(Y-T+1)*i},{spatialReference:te}=e.rasterInfo,ce=e.getPyramidPixelSize(t),{x:_e,y:me}=ce;return{extent:new W.A({xmin:s.x+T*i*_e,xmax:s.x+(Y+1)*i*_e,ymin:s.y-(ie+1)*a*me,ymax:s.y-z*a*me,spatialReference:te}),pixelBlocks:ee,mosaicSize:oe,isPartiallyFilled:ae}})()}_fetchRawTile(t,n,r,o){const e=this.rasterInfo.storageInfo.blockBoundary[t];if(!e)return Promise.resolve(null);const{minRow:s,minCol:l,maxCol:i,maxRow:a}=e;if(n<s||r<l||n>a||r>i)return Promise.resolve(null);const u=(0,U.ph)(this.rasterId,o.sliceId),d=`${t}/${n}/${r}`;let y=(0,U.gd)(u,o.registryId,d);if(null==y){const R=new AbortController;y=this.fetchRawTile(t,n,r,{...o,signal:R.signal}),(0,U.no)(u,o.registryId,d,y,R),y.catch(()=>(0,U.zo)(u,o.registryId,d))}return o.signal&&(0,le.u7)(o,()=>{(0,U.jX)(u,o.registryId,d)}),y}_computeMagDirValues(t){const{bandCount:n,dataType:r}=this.rasterInfo;if((2!==n||"vector-magdir"!==r)&&"vector-uv"!==r||2!==t?.length||!t[0]?.length)return null;const o=t[0].length;if("vector-magdir"===r){const a=t[1].map(u=>(u+360)%360);return[t[0],a]}const[e,s]=t,l=[],i=[];for(let a=0;a<o;a++){const[u,d]=(0,q.Lu)([e[a],s[a]]);l.push(u),i.push(d)}return[l,i]}_getRasterTileAlignmentInfo(t,n){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=(0,F.DO)(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:n,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,n,r,o={}){const e={datumTransformation:o.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};o.srcResolution&&(e.srcResolution=o.srcResolution,this._updateSourceDataInfo(t,e));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:l,srcHeight:i,pyramidLevel:a}=e,u=l/n,d=i/r,y=a<s&&u*d>=16,R=a===s&&this._requireTooManySrcTiles(l,i,n,r);if(y||R||0===l||0===i){const p=new J.A({x:(t.xmax-t.xmin)/n,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference});let M=(0,F.Wo)(p,this.rasterInfo.spatialReference,t,e.datumTransformation);if(y&&o.srcResolution&&(!M||o.srcResolution&&M.x+M.y<o.srcResolution.x+o.srcResolution.y)){const A=Math.round(Math.log(Math.max(u,d))/Math.LN2)-1;if(s-a+3>=A){const O=2**A;M={x:o.srcResolution.x*O,y:o.srcResolution.y*O}}}M&&(e.srcResolution=M,this._updateSourceDataInfo(t,e))}return this._requireTooManySrcTiles(e.srcWidth,e.srcHeight,n,r)&&(e.srcWidth=0,e.srcHeight=0),e}_requireTooManySrcTiles(t,n,r,o){const{tileInfo:e}=this.rasterInfo.storageInfo,l=t/r,i=n/o;return Math.ceil(t/e.size[0])*Math.ceil(n/e.size[1])>=256*Math.max(1,(r+o)/1024)||l>8||i>8}_updateSourceDataInfo(t,n){n.srcWidth=0,n.srcHeight=0;const{rasterInfo:r}=this,o=r.spatialReference,{srcResolution:e,datumTransformation:s}=n,{pyramidLevel:l,pyramidResolution:i,excessiveReading:a}=(0,F.t$)(e,r,this.ioConfig.sampling);if(a)return;let u=n.srcExtent||(0,F._l)(t,o,s);if(null==u)return;const d=r.transform;d&&(u=d.inverseTransform(u)),n.srcExtent=u;const{x:y,y:R}=r.storageInfo.origin,p=Math.floor((u.xmin-y)/i.x+.1),M=Math.floor((R-u.ymax)/i.y+.1),C=Math.floor((u.xmax-y)/i.x-.1),A=Math.floor((R-u.ymin)/i.y-.1),O=u.width<.1*i.x?0:C-p+1,T=u.height<.1*i.y?0:A-M+1;n.pyramidLevel=l,n.pyramidResolution=i,n.srcWidth=O,n.srcHeight=T,n.ul={x:p,y:M}}_getRequestOptionsWithSliceId(t){return null!=this.rasterInfo.multidimensionalInfo&&null==t.sliceId&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,n){const{srcLocation:r,position:o,pyramidLevel:e,useTransposedTile:s}=n,l=t.pixels[0].length/t.width/t.height;if(t.mask&&!t.mask[o])return{location:r,value:null};const{multidimensionalInfo:i}=this.rasterInfo;if(null==i||!s){const A=t.pixels.map(z=>z[o]),O={location:r,value:A,pyramidLevel:e},T=this._computeMagDirValues(A.map(z=>[z]));return T?.length&&(O.magdirValue=T.map(z=>z[0])),O}let a=t.pixels.map(A=>A.slice(o*l,o*l+l)),u=this._computeMagDirValues(a);const{requestSomeSlices:d,identifyOptions:y}=n;let R=(0,v.QW)(i,y.transposedVariableName);if(d){const A=(0,v.xx)(R,y.multidimensionalDefinition,y.timeExtent);a=a.map(O=>A.map(T=>O[T])),u=u?.map(O=>A.map(T=>O[T])),R=A.map(O=>R[O])}const p=t.noDataValues||this.rasterInfo.noDataValue,M={pixels:a,pixelType:t.pixelType};let C;return null!=p&&((0,k.Sp)(M,p),C=M.mask),{location:r,value:null,dataSeries:R.map((A,O)=>{const T={value:0===C?.[O]?null:a.map(z=>z[O]),multidimensionalDefinition:A.multidimensionalDefinition.map(z=>new g.A({...z,isSlice:!0}))};return u?.length&&(T.magdirValue=[u[0][O],u[1][O]]),T}),pyramidLevel:e}}};(0,I._)([(0,N.MZ)()],L.prototype,"_rasterTileAlignmentInfo",void 0),(0,I._)([(0,N.MZ)()],L.prototype,"_tileFetchQueue",void 0),(0,I._)([(0,N.MZ)({readOnly:!0})],L.prototype,"_isGlobalWrappableSource",null),(0,I._)([(0,N.MZ)({readOnly:!0})],L.prototype,"_hasNoneOrGCSShiftTransform",null),(0,I._)([(0,N.MZ)()],L.prototype,"_openPromise",void 0),(0,I._)([(0,N.MZ)()],L.prototype,"rasterJobHandler",null),(0,I._)([(0,N.MZ)({readOnly:!0})],L.prototype,"rasterId",null),(0,I._)([(0,N.MZ)(f.OZ)],L.prototype,"url",null),(0,I._)([(0,N.MZ)({type:String,json:{write:!0}})],L.prototype,"datasetName",void 0),(0,I._)([(0,N.MZ)({type:String,json:{write:!0}})],L.prototype,"datasetFormat",void 0),(0,I._)([(0,N.MZ)()],L.prototype,"hasUniqueSourceStorageInfo",void 0),(0,I._)([(0,N.MZ)()],L.prototype,"rasterInfo",void 0),(0,I._)([(0,N.MZ)()],L.prototype,"ioConfig",void 0),(0,I._)([(0,N.MZ)()],L.prototype,"sourceJSON",void 0),L=(0,I._)([(0,S.$)("esri.layers.support.rasterDatasets.BaseRaster")],L);const Q=L},48457:(ve,se,c)=>{c.d(se,{A:()=>E});var b=c(10467),I=c(8189),X=c(5922),H=c(85211),he=(c(3248),c(35150),c(40707),c(76576)),N=c(55861),h=c(78240),_=c(18703),B=c(40275),S=c(40018),W=c(93327);let D=class extends h.A{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}fetchPixels(x,m,P,v={}){var U=this;return(0,b.A)(function*(){const{rasters:k,rasterIds:w}=U.primaryRasters;let G=!1;const{interpolation:F}=v,q=U.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!v.requestRawData&&q&&(G=1===k.length&&!v.skipRasterFunction,v={...v,interpolation:"bilinear",requestRawData:G});const V=k.map(e=>e.fetchPixels(x,m,P,v)),K=yield Promise.all(V),Z=K.map(e=>e.pixelBlock),L=G||v.requestRawData?K.map(e=>e.srcTilePixelSize):null;if(v.skipRasterFunction||Z.every(e=>null==e))return K[0];const de=K.find(e=>null!=e.pixelBlock)?.extent??x;let Q=U.rasterJobHandler?yield U.rasterJobHandler.process({extent:de,primaryPixelBlocks:Z,primaryPixelSizes:L,primaryRasterIds:w}):U.rasterFunction.process({extent:de,primaryPixelBlocks:Z,primaryPixelSizes:L,primaryRasterIds:w});const{transformGrid:t}=K[0];if(!G||null==Q||null==t){const e=v.noClip?null:U.getClippingGeometry(de.spatialReference);return v.noClip||v.requestRawData||null==Q||!e||(Q=yield(0,_.$Q)(Q,de,e)),{...K[0],pixelBlock:Q}}const n={rows:t.spacing[0],cols:t.spacing[1]};let r;r=U.rasterJobHandler?(yield U.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[Q],srcMosaicSize:{width:Q.width,height:Q.height},destDimension:{width:m,height:P},coefs:t.coefficients,sampleSpacing:n,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:F,alignmentInfo:void 0,blockWidths:null},v)).pixelBlock:(0,B.$i)(Q,{width:m,height:P},t.coefficients,n,F);const o=v.noClip?null:U.getClippingGeometry(x.spatialReference);return v.noClip||v.requestRawData||null==r||null==o||(r=yield(0,_.$Q)(r,x,o)),{extent:x,srcExtent:K[0].srcExtent,pixelBlock:r}})()}getClippingGeometry(x){const m=this._clippingGeometry.get("0");if(!x||!m)return m;const P=function g(x){return String(x.wkid??x.wkt??x.wkt2)}(x);let v=this._clippingGeometry.get(P);return null!=v||(v=x.equals(m.spatialReference)?m:(0,S.uk)(m,x),this._clippingGeometry.set(P,v)),v}_open(x){var m=this;return(0,b.A)(function*(){const{rasterFunction:P}=m;m.primaryRasters?.rasters?.length?P.sourceRasters=m.primaryRasters.rasters:(m.primaryRasters=P.getPrimaryRasters(),m.rasterJobHandler&&m.primaryRasters.rasters?.forEach(V=>V.rasterJobHandler=m.rasterJobHandler));const{rasters:v,rasterIds:U}=m.primaryRasters,k=v.map(V=>V.rasterInfo?void 0:V.open(x));yield Promise.all(k);const w=v.map(({rasterInfo:V})=>V),G=P.bind({rasterInfos:w,rasterIds:U});if(P.rawSourceRasterInfos=w,!G.success||0===w.length)throw new X.A("raster-function:open",`cannot bind the function: ${G.error??""}`);const F="Table"===P.functionName?P:P.functionArguments?.raster;"Table"===F?.functionName&&(P.rasterInfo.attributeTable=W.A.fromJSON(F.functionArguments.attributeTableAsRecordSet)),yield m.syncJobHandler();const q=w[0];m.hasUniqueSourceStorageInfo=1===w.length||w.slice(1).every(V=>function f(x,m){const{storageInfo:P,pixelSize:v,spatialReference:U,extent:k}=x,{storageInfo:w,pixelSize:G,spatialReference:F,extent:q}=m;return v.x===G.x&&v.y===G.y&&U.equals(F)&&k.equals(q)&&P.blockHeight===w.blockHeight&&P.blockWidth===w.blockWidth&&P.maximumPyramidLevel===w.maximumPyramidLevel}(V,q)),m.set("sourceJSON",v[0].sourceJSON),m.set("rasterInfo",P.rasterInfo),yield m._updateClipGeometry()})()}syncJobHandler(){var x=this;return(0,b.A)(function*(){return x.rasterJobHandler?.updateRasterFunction(x.rasterFunction)})()}_updateClipGeometry(){var x=this;return(0,b.A)(function*(){const m=x.rasterFunction.getClippingGeometries()[0];let P=m?.clippingGeometry;if(P&&"inside"===m.clippingType){const{extent:v}=x.rasterInfo,{difference:U,densify:k}=yield Promise.all([c.e(3930),c.e(6041)]).then(c.bind(c,46041));let w=k(N.A.fromExtent(v),2*(v.width+v.height)/40);w=(0,S.uk)(w,P.spatialReference),P=U(w,P)}x._clippingGeometry.clear(),P&&x._clippingGeometry.set("0",P)})()}};(0,I._)([(0,H.MZ)({type:String,json:{write:!0}})],D.prototype,"datasetFormat",void 0),(0,I._)([(0,H.MZ)()],D.prototype,"tileType",void 0),(0,I._)([(0,H.MZ)()],D.prototype,"rasterFunction",void 0),(0,I._)([(0,H.MZ)()],D.prototype,"primaryRasters",void 0),D=(0,I._)([(0,he.$)("esri.layers.support.rasterDatasets.FunctionRaster")],D);const E=D},62619:(ve,se,c)=>{c.d(se,{jX:()=>h,zo:()=>S,gd:()=>_,ph:()=>j,no:()=>B,kz:()=>le,ht:()=>he,yo:()=>J});var b=c(1749),X=c(40018);const H=new Map,$=new class I{constructor(E=15e3,f=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=E,this._interval=Math.min(E,f)}decreaseRefCount(E,f){const g=E+"/"+f,x=this._cachedBlocks;if(x.has(g)){const m=x.get(g);return m.refCount--,m.refCount<=0&&(x.delete(g),m.controller&&m.controller.abort()),m.refCount}return 0}getBlock(E,f){const g=E+"/"+f,x=this._cachedBlocks;if(x.has(g)){const m=x.get(g);return m.ts=Date.now(),m.refCount++,x.delete(g),x.set(g,m),m.block}return null}putBlock(E,f,g,x){const m=this._cachedBlocks,P=E+"/"+f;if(m.has(P)){const v=m.get(P);v.ts=Date.now(),v.refCount++}else m.set(P,{block:g,ts:Date.now(),refCount:1,controller:x});this._trim(),this._updateTimer()}deleteBlock(E,f){const g=this._cachedBlocks,x=E+"/"+f;g.has(x)&&g.delete(x)}updateMaxSize(E){this._size=E,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const E=this._cachedBlocks;this._timer=setInterval(()=>{const f=Array.from(E),g=Date.now();for(let x=0;x<f.length&&f[x][1].ts<=g-this._duration;x++)E.delete(f[x][0]);0===E.size&&this._clearTimer()},this._interval)}_trim(){const E=this._cachedBlocks;if(-1===this._size||this._size>=E.size)return;const f=Array.from(E);for(let g=0;g<f.length-this._size;g++)E.delete(f[g][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function j(D,E){return null==E?D:`${D}?sliceId=${E}`}function le(D,E){const f={extent:null,rasterInfo:E,cache:new Map},g=H.get(D);return g?(g.push(f),g.length-1):(H.set(D,[f]),0)}function he(D,E){const f=H.get(D);f&&(f[E]=null,f.some(g=>null!=g)||H.delete(D))}function h(D,E,f){const g=H.get(D);if(!g)return null==E?$.decreaseRefCount(D,f):0;if(null==E||null==g[E])return $.decreaseRefCount(D,f);const x=g[E]?.cache,m=x?.get(f);if(x&&m){if(m.refCount--,0===m.refCount){x.delete(f);for(let P=0;P<g.length;P++)g[P]?.cache.delete(f);m.controller&&m.controller.abort()}return m.refCount}return 0}function _(D,E,f){const g=H.get(D);if(!g)return null==E?$.getBlock(D,f):null;if(null==E||null==g[E]){for(let m=0;m<g.length;m++){const P=g[m]?.cache.get(f);if(P)return P.refCount++,P.block}return $.getBlock(D,f)}const x=g[E]?.cache.get(f);if(x)return x.refCount++,x.block;for(let m=0;m<g.length;m++){if(m===E||!g[m])continue;const P=g[m]?.cache,v=P?.get(f);if(P&&v)return v.refCount++,P.set(f,v),v.block}return null}function B(D,E,f,g,x=null){const m=H.get(D);if(!m)return void(null==E&&$.putBlock(D,f,g,x));if(null==E||null==m[E])return void $.putBlock(D,f,g,x);const P={refCount:1,block:g,isResolved:!1,isRejected:!1,controller:x};g.then(()=>P.isResolved=!0).catch(()=>P.isRejected=!0),m[E]?.cache.set(f,P)}function S(D,E,f){const g=H.get(D);g?null!=E&&null!=g[E]?g[E]?.cache.delete(f):$.deleteBlock(D,f):null==E&&$.deleteBlock(D,f)}function J(D,E,f,g,x,m,P=null){const v=function W(D,E){const f=H.get(D);return f?f[E]??null:null}(D,E);if(!v)return;const U=v.extent,{cache:k,rasterInfo:w}=v;if(U&&U.xmin===f.xmin&&U.xmax===f.xmax&&U.ymin===f.ymin&&U.ymax===f.ymax)return;g=g??0;const G=f.clone().normalize(),{spatialReference:F,transform:q}=w,V=new Set;for(let K=0;K<G.length;K++){const Z=G[K];if(Z.xmax-Z.xmin<=g||Z.ymax-Z.ymin<=g)continue;let L=(0,X._l)(Z,F,P);null!=q&&(L=q.inverseTransform(L));const de=new b.A({x:g,y:g,spatialReference:Z.spatialReference});if(null==x&&!(x=(0,X.Wo)(de,F,Z,P)))return;const{pyramidLevel:Q,pyramidResolution:t,excessiveReading:n}=(0,X.t$)(x,w,m||"closest");if(n)return;const{storageInfo:r}=w,{origin:o}=r,{x:e,y:s}=t,l=Math.max(0,Math.floor((L.xmin-o.x)/e)),i=Math.max(0,Math.floor((o.y-L.ymax)/s)),a=Math.ceil(L.width/e-.1),u=Math.ceil(L.height/s-.1),d=Q>0?r.pyramidBlockWidth:r.blockWidth,y=Q>0?r.pyramidBlockHeight:r.blockHeight,R=r.blockBoundary[Q];if(!R)continue;const p=1,M=Math.max(R.minCol,Math.floor(l/d)-p),C=Math.max(R.minRow,Math.floor(i/y)-p),A=Math.min(R.maxCol,Math.floor((l+a-1)/d)+p),O=Math.min(R.maxRow,Math.floor((i+u-1)/y)+p);for(let T=C;T<=O;T++)for(let z=M;z<=A;z++)V.add(`${Q}/${T}/${z}`)}k.forEach((K,Z)=>{if(!V.has(Z)){const L=k.get(Z);(null==L||L.isResolved||L.isRejected)&&k.delete(Z)}}),v.extent={xmin:f.xmin,ymin:f.ymin,xmax:f.xmax,ymax:f.ymax}}},19639:(ve,se,c)=>{function b(h,_){if(!h||!_)return[];let B=_;_.includes("/")?(B=_.slice(0,_.indexOf("/")),_=_.slice(_.indexOf("/")+1)):_="";const S=[];if(_){const J=b(h,B);for(let D=0;D<J.length;D++)b(J[D],_).forEach(E=>S.push(E));return S}const W=h.getElementsByTagNameNS("*",B);if(!W||0===W.length)return[];for(let J=0;J<W.length;J++)S.push(W[J]||W.item(J));return S}function I(h,_){if(!h||!_)return null;let B=_;_.includes("/")?(B=_.slice(0,_.indexOf("/")),_=_.slice(_.indexOf("/")+1)):_="";const S=b(h,B);return S.length>0?_?I(S[0],_):S[0]:null}function X(h,_=null){const B=_?I(h,_):h;let S;return B?(S=B.textContent||B.nodeValue,S?S.trim():null):null}function H(h,_){const B=b(h,_),S=[];let W;for(let J=0;J<B.length;J++)W=B[J].textContent||B[J].nodeValue,W&&(W=W.trim(),""!==W&&S.push(W));return S}function $(h,_=null){return X(h,_)?.split(" ").map(S=>Number(S))??[]}function j(h,_){return H(h,_).map(B=>Number(B))}function le(h,_){const B=X(h,_);return Number(B)}function he(h,_){const B=h?.nodeName?.toLowerCase(),S=_.toLowerCase();return B.slice(B.lastIndexOf(":")+1)===S}function N(h){return h.nodeName.slice(h.nodeName.lastIndexOf(":")+1)}c.d(se,{Dy:()=>H,IC:()=>b,Ui:()=>j,V6:()=>I,g7:()=>he,mX:()=>X,pN:()=>$,v7:()=>le,vv:()=>N})}}]);