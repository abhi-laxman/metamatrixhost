"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[669],{90669:(X,M,a)=>{a.r(M),a.d(M,{fromExtent:()=>p,fromGeometry:()=>L,fromMultipoint:()=>D,fromPoint:()=>v,fromPolygon:()=>O,fromPolyline:()=>R,fromSpatialReference:()=>W,getSpatialReference:()=>K,toExtent:()=>x,toGeometry:()=>z,toMultipoint:()=>A,toPoint:()=>V,toPolygon:()=>G,toPolyline:()=>I});var T=a(33165),h=(a(87571),a(62257)),_=a(7085),j=a(95944),P=a(3037),Z=a(28067),B=a(21870),y=a(1749),d=a(55861),U=a(93615),f=(a(51509),a(27312));const s="_gxVersion",g=2,C=1;function K(t){return Array.isArray(t)?t[0].spatialReference:t.spatialReference}function L(t){switch(t.type){case"point":return v(t);case"multipoint":return D(t);case"polyline":return R(t);case"polygon":return O(t);case"extent":return p(t);default:throw new Error(`Unsupported geometry type: ${t.type}`)}}function p(t){if(!t.getCacheValue(s)){const n=new _.E;n.setCoords(t.xmin,t.ymin,t.xmax,t.ymax),t.hasM&&n.setInterval(g,0,t.mmin,t.mmax),t.hasZ&&n.setInterval(C,0,t.zmin,t.zmax),t.setCacheValue(s,n)}return t.getCacheValue(s)}function D(t){if(!t.getCacheValue(s)){const n=new j.M,e=new _.P,r=t.points,o=t.hasM,u=t.hasZ,i=u?3:2;for(let l=0,m=r.length;l<m;l++){const c=r[l];e.setXYCoords(c[0],c[1]),u&&e.setZ(c[2]??0),o&&e.setM(c[i]??NaN),n.add(e)}t.setCacheValue(s,n)}return t.getCacheValue(s)}function v(t){if(!t.getCacheValue(s)){const n=new _.P;n.setXYCoords(t.x,t.y),t.hasM&&n.setM(t.m),t.hasZ&&n.setZ(t.z),t.setCacheValue(s,n)}return t.getCacheValue(s)}function O(t){if(!t.getCacheValue(s)){const{curveRings:n,hasM:e,hasZ:r,rings:o}=t,u=(0,f.fromGeometryToGXGeometry)({curveRings:n,hasM:e,hasZ:r,rings:o});t.setCacheValue(s,u)}return t.getCacheValue(s)}function R(t){if(!t.getCacheValue(s)){const{curvePaths:n,hasM:e,hasZ:r,paths:o}=t,u=(0,f.fromGeometryToGXGeometry)({curvePaths:n,hasM:e,hasZ:r,paths:o});t.setCacheValue(s,u)}return t.getCacheValue(s)}function W(t){if(t.wkid)return(0,P.c)(t.wkid);const n=t.wkt2||t.wkt;return n?(0,P.b)(n):null}function z(t,n){if(t)switch(t.getGeometryType()){case h.G.enumPoint:return V(t,n);case h.G.enumEnvelope:return x(t,n);case h.G.enumMultiPoint:return A(t,n);case h.G.enumPolyline:return I(t,n);case h.G.enumPolygon:return G(t,n)}return null}function x(t,n){if(t.isEmpty())return null;const e=new Z.A({xmin:t.getXMin(),ymin:t.getYMin(),xmax:t.getXMax(),ymax:t.getYMax(),spatialReference:n}),r=t.getDescription();if(r.hasM()){const o=t.queryInterval(g,0);e.mmin=o.vmin,e.mmax=o.vmax}if(r.hasZ()){const o=t.queryInterval(C,0);e.zmin=o.vmin,e.zmax=o.vmax}return e.setCacheValue(s,t),e}function A(t,n){if(t.isEmpty())return null;const e=t.getDescription(),r=e.hasM(),o=e.hasZ(),u=[],i=new _.P;for(let m=0,c=t.getPointCount();m<c;m++){t.getPointByVal(m,i);const E=[i.getX(),i.getY()];o&&E.push(i.getZ()),r&&E.push(i.getM()),u.push(E)}const l=new B.A({hasM:r,hasZ:o,points:u,spatialReference:n});return l.setCacheValue(s,t),l}function V(t,n){if(t instanceof T.P)return new y.A({x:t.x,y:t.y,spatialReference:n});if(t.isEmpty())return null;const e=new y.A({x:t.getX(),y:t.getY(),spatialReference:n}),r=t.getDescription();return r.hasM()&&(e.m=t.getM()),r.hasZ()&&(e.z=t.getZ()),e.setCacheValue(s,t),e}function G(t,n){if(t.isEmpty())return null;const e=d.A.fromJSON({spatialReference:n,...(0,f.toGeometry)(t,null)});return e.setCacheValue(s,t),e}function I(t,n){if(t.isEmpty())return null;const e=U.A.fromJSON({spatialReference:n,...(0,f.toGeometry)(t,null)});return e.setCacheValue(s,t),e}}}]);