"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[9361,669,1469,1742],{1469:(j,E,a)=>{a.d(E,{G:()=>M,S:()=>l});class M{*[Symbol.iterator](){let i=this.next();for(;i;)yield i,i=this.next()}}class l extends M{constructor(i){super(),this.m_iGeom=-1,this.m_aGeoms=i?i.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const i=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,i}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}},90669:(j,E,a)=>{a.r(E),a.d(E,{fromExtent:()=>v,fromGeometry:()=>w,fromMultipoint:()=>x,fromPoint:()=>G,fromPolygon:()=>O,fromPolyline:()=>R,fromSpatialReference:()=>z,getSpatialReference:()=>W,toExtent:()=>A,toGeometry:()=>X,toMultipoint:()=>V,toPoint:()=>d,toPolygon:()=>I,toPolyline:()=>T});var M=a(33165),l=(a(87571),a(62257)),c=a(7085),i=a(95944),g=a(3037),B=a(28067),U=a(21870),C=a(1749),K=a(55861),L=a(93615),P=(a(51509),a(27312));const s="_gxVersion",p=2,D=1;function W(t){return Array.isArray(t)?t[0].spatialReference:t.spatialReference}function w(t){switch(t.type){case"point":return G(t);case"multipoint":return x(t);case"polyline":return R(t);case"polygon":return O(t);case"extent":return v(t);default:throw new Error(`Unsupported geometry type: ${t.type}`)}}function v(t){if(!t.getCacheValue(s)){const n=new c.E;n.setCoords(t.xmin,t.ymin,t.xmax,t.ymax),t.hasM&&n.setInterval(p,0,t.mmin,t.mmax),t.hasZ&&n.setInterval(D,0,t.zmin,t.zmax),t.setCacheValue(s,n)}return t.getCacheValue(s)}function x(t){if(!t.getCacheValue(s)){const n=new i.M,e=new c.P,r=t.points,o=t.hasM,u=t.hasZ,m=u?3:2;for(let _=0,f=r.length;_<f;_++){const h=r[_];e.setXYCoords(h[0],h[1]),u&&e.setZ(h[2]??0),o&&e.setM(h[m]??NaN),n.add(e)}t.setCacheValue(s,n)}return t.getCacheValue(s)}function G(t){if(!t.getCacheValue(s)){const n=new c.P;n.setXYCoords(t.x,t.y),t.hasM&&n.setM(t.m),t.hasZ&&n.setZ(t.z),t.setCacheValue(s,n)}return t.getCacheValue(s)}function O(t){if(!t.getCacheValue(s)){const{curveRings:n,hasM:e,hasZ:r,rings:o}=t,u=(0,P.fromGeometryToGXGeometry)({curveRings:n,hasM:e,hasZ:r,rings:o});t.setCacheValue(s,u)}return t.getCacheValue(s)}function R(t){if(!t.getCacheValue(s)){const{curvePaths:n,hasM:e,hasZ:r,paths:o}=t,u=(0,P.fromGeometryToGXGeometry)({curvePaths:n,hasM:e,hasZ:r,paths:o});t.setCacheValue(s,u)}return t.getCacheValue(s)}function z(t){if(t.wkid)return(0,g.c)(t.wkid);const n=t.wkt2||t.wkt;return n?(0,g.b)(n):null}function X(t,n){if(t)switch(t.getGeometryType()){case l.G.enumPoint:return d(t,n);case l.G.enumEnvelope:return A(t,n);case l.G.enumMultiPoint:return V(t,n);case l.G.enumPolyline:return T(t,n);case l.G.enumPolygon:return I(t,n)}return null}function A(t,n){if(t.isEmpty())return null;const e=new B.A({xmin:t.getXMin(),ymin:t.getYMin(),xmax:t.getXMax(),ymax:t.getYMax(),spatialReference:n}),r=t.getDescription();if(r.hasM()){const o=t.queryInterval(p,0);e.mmin=o.vmin,e.mmax=o.vmax}if(r.hasZ()){const o=t.queryInterval(D,0);e.zmin=o.vmin,e.zmax=o.vmax}return e.setCacheValue(s,t),e}function V(t,n){if(t.isEmpty())return null;const e=t.getDescription(),r=e.hasM(),o=e.hasZ(),u=[],m=new c.P;for(let f=0,h=t.getPointCount();f<h;f++){t.getPointByVal(f,m);const y=[m.getX(),m.getY()];o&&y.push(m.getZ()),r&&y.push(m.getM()),u.push(y)}const _=new U.A({hasM:r,hasZ:o,points:u,spatialReference:n});return _.setCacheValue(s,t),_}function d(t,n){if(t instanceof M.P)return new C.A({x:t.x,y:t.y,spatialReference:n});if(t.isEmpty())return null;const e=new C.A({x:t.getX(),y:t.getY(),spatialReference:n}),r=t.getDescription();return r.hasM()&&(e.m=t.getM()),r.hasZ()&&(e.z=t.getZ()),e.setCacheValue(s,t),e}function I(t,n){if(t.isEmpty())return null;const e=K.A.fromJSON({spatialReference:n,...(0,P.toGeometry)(t,null)});return e.setCacheValue(s,t),e}function T(t,n){if(t.isEmpty())return null;const e=L.A.fromJSON({spatialReference:n,...(0,P.toGeometry)(t,null)});return e.setCacheValue(s,t),e}}}]);