"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[4314],{28872:(S,j,c)=>{c.d(j,{u:()=>A});var h=c(82663),D=c(58701);function T(f,R,E){if(null==f.hasM||f.hasZ)for(const M of R)for(const v of M)v.length>2&&(v[2]*=E)}function A(f,R,E){if(!f&&!R||!E)return;const M=(0,h.G9)(E);O(f,E,M),O(R,E,M)}function O(f,R,E){if(f)for(const M of f)d(M.geometry,R,E)}function d(f,R,E){if(!f?.spatialReference||(0,D.aI)(f.spatialReference,R))return;const M=(0,h.G9)(f.spatialReference)/E;if(1!==M)if("x"in f)null!=f.z&&(f.z*=M);else if("rings"in f)T(f,f.rings,M);else if("paths"in f)T(f,f.paths,M);else if("points"in f&&(null==f.hasM||f.hasZ))for(const v of f.points)v.length>2&&(v[2]*=M)}},98789:(S,j,c)=>{c.d(j,{q:()=>D});var h=c(23743);function D(T,A,O){if(!O?.features||!O.hasZ)return;const d=(0,h.N)(O.geometryType,A,T.outSpatialReference);if(null!=d)for(const f of O.features)d(f.geometry)}},93327:(S,j,c)=>{c.d(j,{A:()=>W});var C,h=c(8189),D=c(81098),T=c(49976),A=c(71065),O=c(77806),d=c(85211),E=(c(3248),c(35150),c(17221)),M=c(76576),v=c(50305),B=c(32034),x=c(61320),U=c(6434),K=c(29141);const L=new T.J({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});let g=C=class extends A.A{constructor(r){super(r),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(r,i){return this.readFeaturesWithClass(r,i,D.A)}writeGeometryType(r,i,n,e){if(r)return void L.write(r,i,n,e);const{features:s}=this;if(s)for(const o of s)if(null!=o?.geometry)return void L.write(o.geometry.type,i,n,e)}readQueryGeometry(r,i){if(!r)return null;const n=!!r.spatialReference,e=(0,x.rS)(r);return e&&!n&&i.spatialReference&&(e.spatialReference=B.A.fromJSON(i.spatialReference)),e}writeSpatialReference(r,i){if(r)return void(i.spatialReference=r.toJSON());const{features:n}=this;if(n)for(const e of n)if(e&&null!=e.geometry&&e.geometry.spatialReference)return void(i.spatialReference=e.geometry.spatialReference.toJSON())}clone(){return new C(this.cloneProperties())}cloneProperties(){return(0,O.o8)({displayFieldName:this.displayFieldName,exceededTransferLimit:this.exceededTransferLimit,features:this.features,fields:this.fields,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,queryGeometry:this.queryGeometry,spatialReference:this.spatialReference,transform:this.transform})}toJSON(r){const i=this.write();if(i.features&&Array.isArray(r)&&r.length>0)for(let n=0;n<i.features.length;n++){const e=i.features[n];if(e.geometry){const s=r?.[n];e.geometry=s?.toJSON()||e.geometry}}return i}quantize(r){const{scale:[i,n],translate:[e,s]}=r,y=this.features,m=this._getQuantizationFunction(this.geometryType,t=>Math.round((t-e)/i),t=>Math.round((s-t)/n));for(let t=0,p=y.length;t<p;t++)m?.(y[t].geometry)||(y.splice(t,1),t--,p--);return this.transform=r,this}unquantize(){const{geometryType:r,features:i,transform:n}=this;if(!n)return this;const{translate:[e,s],scale:[o,a]}=n;let t=null,p=null;if(this.hasZ&&null!=n?.scale?.[2]){const{translate:[,,_],scale:[,,P]}=n;t=u=>u*P+_}if(this.hasM&&null!=n?.scale?.[3]){const{translate:[,,,_],scale:[,,,P]}=n;p=u=>null==u?u:u*P+_}const l=this._getHydrationFunction(r,_=>_*o+e,_=>s-_*a,t,p);for(const{geometry:_}of i)null!=_&&l&&l(_);return this.transform=null,this}readFeaturesWithClass(r,i,n){const e=B.A.fromJSON(i.spatialReference),s=[];for(let o=0;o<r.length;o++){const a=r[o],y=n.fromJSON(a),m=a.geometry?.spatialReference;null==y.geometry||m||(y.geometry.spatialReference=e);const t=a.aggregateGeometries,p=y.aggregateGeometries;if(t&&null!=p)for(const l in p){const _=p[l],P=t[l],u=P?.spatialReference;null==_||u||(_.spatialReference=e)}s.push(y)}return s}_quantizePoints(r,i,n){let e,s;const o=[];for(let a=0,y=r.length;a<y;a++){const m=r[a];if(a>0){const t=i(m[0]),p=n(m[1]);t===e&&p===s||(o.push([t-e,p-s]),e=t,s=p)}else e=i(m[0]),s=n(m[1]),o.push([e,s])}return o.length>0?o:null}_getQuantizationFunction(r,i,n){return"point"===r?e=>(e.x=i(e.x),e.y=n(e.y),e):"polyline"===r||"polygon"===r?e=>{const s=(0,x.Bi)(e)?e.rings:e.paths,o=[];for(let a=0,y=s.length;a<y;a++){const t=this._quantizePoints(s[a],i,n);t&&o.push(t)}return o.length>0?((0,x.Bi)(e)?e.rings=o:e.paths=o,e):null}:"multipoint"===r?e=>{const s=this._quantizePoints(e.points,i,n);return s&&s.length>0?(e.points=s,e):null}:"extent"===r?e=>e:null}_getHydrationFunction(r,i,n,e,s){return"point"===r?o=>{o.x=i(o.x),o.y=n(o.y),e&&(o.z=e(o.z))}:"polyline"===r||"polygon"===r?o=>{const a=(0,x.Bi)(o)?o.rings:o.paths;let y,m;for(let t=0,p=a.length;t<p;t++){const l=a[t];for(let _=0,P=l.length;_<P;_++){const u=l[_];_>0?(y+=u[0],m+=u[1]):(y=u[0],m=u[1]),u[0]=i(y),u[1]=n(m)}}if(e&&s)for(let t=0,p=a.length;t<p;t++){const l=a[t];for(let _=0,P=l.length;_<P;_++){const u=l[_];u[2]=e(u[2]),u[3]=s(u[3])}}else if(e)for(let t=0,p=a.length;t<p;t++){const l=a[t];for(let _=0,P=l.length;_<P;_++){const u=l[_];u[2]=e(u[2])}}else if(s)for(let t=0,p=a.length;t<p;t++){const l=a[t];for(let _=0,P=l.length;_<P;_++){const u=l[_];u[2]=s(u[2])}}}:"extent"===r?o=>{o.xmin=i(o.xmin),o.ymin=n(o.ymin),o.xmax=i(o.xmax),o.ymax=n(o.ymax),e&&null!=o.zmax&&null!=o.zmin&&(o.zmax=e(o.zmax),o.zmin=e(o.zmin)),s&&null!=o.mmax&&null!=o.mmin&&(o.mmax=s(o.mmax),o.mmin=s(o.mmin))}:"multipoint"===r?o=>{const a=o.points;let y,m;for(let t=0,p=a.length;t<p;t++){const l=a[t];t>0?(y+=l[0],m+=l[1]):(y=l[0],m=l[1]),l[0]=i(y),l[1]=n(m)}if(e&&s)for(let t=0,p=a.length;t<p;t++){const l=a[t];l[2]=e(l[2]),l[3]=s(l[3])}else if(e)for(let t=0,p=a.length;t<p;t++){const l=a[t];l[2]=e(l[2])}else if(s)for(let t=0,p=a.length;t<p;t++){const l=a[t];l[2]=s(l[2])}}:null}};(0,h._)([(0,d.MZ)({type:String,json:{write:!0}})],g.prototype,"displayFieldName",void 0),(0,h._)([(0,d.MZ)({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],g.prototype,"exceededTransferLimit",void 0),(0,h._)([(0,d.MZ)({type:[D.A],json:{write:!0}})],g.prototype,"features",void 0),(0,h._)([(0,E.w)("features")],g.prototype,"readFeatures",null),(0,h._)([(0,d.MZ)({type:[K.A],json:{write:!0}})],g.prototype,"fields",void 0),(0,h._)([(0,d.MZ)({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:L.read}}})],g.prototype,"geometryType",void 0),(0,h._)([(0,v.K)("geometryType")],g.prototype,"writeGeometryType",null),(0,h._)([(0,d.MZ)({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],g.prototype,"hasM",void 0),(0,h._)([(0,d.MZ)({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],g.prototype,"hasZ",void 0),(0,h._)([(0,d.MZ)({types:U.yR,json:{write:!0}})],g.prototype,"queryGeometry",void 0),(0,h._)([(0,E.w)("queryGeometry")],g.prototype,"readQueryGeometry",null),(0,h._)([(0,d.MZ)({type:B.A,json:{write:!0}})],g.prototype,"spatialReference",void 0),(0,h._)([(0,v.K)("spatialReference")],g.prototype,"writeSpatialReference",null),(0,h._)([(0,d.MZ)({json:{write:!0}})],g.prototype,"transform",void 0),g=C=(0,h._)([(0,M.$)("esri.rest.support.FeatureSet")],g),g.prototype.toJSON.isDefaultToJSON=!0;const W=g}}]);