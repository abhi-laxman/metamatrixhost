"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[126],{18703:($n,Re,I)=>{I.d(Re,{$Q:()=>hn,Sd:()=>qt,b7:()=>V});var Ae=I(10467),wt=I(82663),at=I(28067),l=I(1749),p=I(21980);function hn(b,G,B){return _e.apply(this,arguments)}function _e(){return(_e=(0,Ae.A)(function*(b,G,B){if("extent"===B.type)return function Z(b,G,B){const{width:j,height:g}=b,z=new Uint8Array(j*g),U=G.width/j,P=G.height/g;if(B.width/U<.5||B.height/P<.5)return new p.A({pixelType:b.pixelType,width:j,height:g,mask:z,pixels:[...b.pixels]});const{xmin:R,xmax:ct,ymin:ht,ymax:O}=G,{xmin:ut,xmax:Q,ymin:et,ymax:q}=B,C=Math.max(R,ut),st=Math.min(ct,Q),T=Math.max(ht,et),pt=Math.min(O,q),dt=.5*U,Mt=.5*P;if(st-C<dt||pt-T<Mt||st<R+dt||C>ct-dt||T>O-Mt||pt<ht+Mt)return new p.A({pixelType:b.pixelType,width:j,height:g,mask:z,pixels:[...b.pixels]});const L=Math.max(0,(C-R)/U),rt=Math.min(j,Math.max(0,(st-R)/U)),te=Math.max(0,(O-pt)/P),gt=Math.min(g,Math.max(0,(O-T)/P)),mt=Math.round(L),Bt=Math.round(rt)-1,yt=Math.round(te),we=Math.round(gt)-1;if(mt===Bt&&L%1>.5&&rt%1<.5||yt===we&&te%1>.5&&gt%1<.5)return new p.A({pixelType:b.pixelType,width:j,height:g,mask:z,pixels:[...b.pixels]});if(0===mt&&0===yt&&Bt===j&&we===g)return b;const Ne=b.mask;for(let be=yt;be<=we;be++)for(let Fe=mt;Fe<=Bt;Fe++){const me=be*j+Fe;z[me]=Ne?Ne[me]:255}return new p.A({pixelType:b.pixelType,width:j,height:g,mask:z,pixels:[...b.pixels]})}(b,G,B);const{width:j,height:g}=b,z=new Uint8Array(j*g),{contains:U,intersects:P}=yield Promise.all([I.e(3930),I.e(6041)]).then(I.bind(I,46041));return P(G,B)?"polyline"===B.type?function ve(b,G,B){const{width:j,height:g}=b,z=new Uint8Array(j*g),U=G.width/j,P=G.height/g,{xmin:R,ymax:ct}=G,{paths:ht}=B,O=b.mask;for(let ut=0;ut<ht.length;ut++){const Q=ht[ut];for(let et=0;et<Q.length-1;et++){const[q,C]=Q[et],[st,T]=Q[et+1];let pt=Math.floor((ct-C)/P),dt=Math.floor((ct-T)/P);if(dt<pt){const L=pt;pt=dt,dt=L}pt=Math.max(0,pt),dt=Math.min(g-1,dt);const Mt=(st-q)/(T-C);for(let L=pt;L<=dt;L++){const rt=L===pt?Math.max(C,T):(g+1-L)*P,te=L===dt?Math.min(C,T):rt-P;let gt=Math.floor(T===C?(q-R)/U:(Mt*(rt-C)+q-R)/U),mt=Math.floor(T===C?(st-R)/U:(Mt*(te-C)+q-R)/U);if(mt<gt){const yt=gt;gt=mt,mt=yt}const Bt=L*j;gt=Math.max(0,gt),mt=Math.min(j-1,mt);for(let yt=Bt+gt;yt<=Bt+mt;yt++)z[yt]=O?O[yt]:255}}}return new p.A({pixelType:b.pixelType,width:j,height:g,mask:z,pixels:[...b.pixels]})}(b,G,B):U(B,G)?b:function F(b,G,B){if(!b)return b;const{width:j,height:g}=b,z=G.width/j,U=G.height/g,{xmin:P,ymax:R}=G;let ct;if("extent"===B.type){const C=(B.xmin-P)/z,st=(B.xmax-P)/z,T=(R-B.ymax)/U,pt=(R-B.ymin)/U;ct=[[[C,T],[C,pt],[st,pt],[st,T],[C,T]]]}else ct=B.rings.map(C=>C.map(([st,T])=>[(st-P)/z,(R-T)/U]));const ht=document.createElement("canvas");ht.width=j,ht.height=g;const O=ht.getContext("2d");O.fillStyle="#f00",O.beginPath(),ct.forEach(C=>{O.moveTo(C[0][0],C[0][1]);for(let st=0;st<C.length;st++)O.lineTo(C[st][0],C[st][1]);O.closePath()}),O.fill();const ut=O.getImageData(0,0,j,g).data,Q=b.mask,et=j*g,q=new Uint8Array(et);for(let C=0;C<et;C++)Q&&!Q[C]||(q[C]=ut[4*C+3]>127?255:0);return new p.A({pixelType:b.pixelType,width:j,height:g,mask:q,maskIsAlpha:!1,pixels:[...b.pixels]})}(b,G,B):new p.A({pixelType:b.pixelType,width:j,height:g,mask:z,maskIsAlpha:!1,pixels:[...b.pixels]})})).apply(this,arguments)}function qt(b,G){const{extent:B}=V(b,G,new l.A({x:b.pixelSize.x,y:b.pixelSize.y,spatialReference:b.spatialReference})),{extent:j}=b.extent;if(B.xmax=Math.min(B.xmax,j.xmax),B.ymax=Math.min(B.ymax,j.ymax),B.xmin<B.xmax&&B.ymin<B.ymax){const{x:g,y:z}=b.pixelSize,U=Math.round(B.width/g),P=Math.round(B.height/z);b.extent=B,b.width=U,b.height=P}}function V(b,G,B,j=!0){const{spatialReference:g}=b,{x:z,y:U}=function mn(b,G){if(b.spatialReference.equals(G))return b;const B=(0,wt.GA)(b.spatialReference),j=(0,wt.GA)(G);if(B===j)return b;const g=B/j;return{x:b.x*g,y:b.y*g}}(B,g);let P,R,ct;const ht="extent"===G.type?G:G.extent;let{xmin:O,xmax:ut,ymax:Q,ymin:et}=ht;const{xmin:q,ymax:C}=b.extent;return j?(O=q+(O>q?z*Math.round((O-q)/z):0),Q=C-(Q<C?U*Math.round((C-Q)/U):0),ut=q+(ut>q?z*Math.round((ut-q)/z):0),et=C-(et<C?U*Math.round((C-et)/U):0),P=new at.A({xmin:O,ymax:Q,xmax:ut,ymin:et,spatialReference:g}),R=Math.round(P.width/z),ct=Math.round(P.height/U)):(R=Math.floor((ut-O)/z+.8),ct=Math.floor((Q-et)/U+.8),O=q+(O>q?z*Math.floor((O-q)/z+.1):0),Q=C-(Q<C?U*Math.floor((C-Q)/U+.1):0),ut=O+R*z,et=Q-ct*U,P=new at.A({xmin:O,ymax:Q,xmax:ut,ymin:et,spatialReference:g})),{extent:P,width:R,height:ct}}},90126:($n,Re,I)=>{I.d(Re,{vt:()=>Do,UD:()=>zn});var Ae=I(29430),wt=I(5922),at=I(77806),l=I(8189),p=I(85211),F=(I(3248),I(35150),I(40707),I(76576)),Z=I(96115),ve=I(71065);let qt=class extends ve.A{constructor(){super(...arguments),this.raster=void 0}};(0,l._)([(0,p.MZ)({json:{write:!0}})],qt.prototype,"raster",void 0),qt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.BaseFunctionArguments")],qt);const V=qt;var b;let G=b=class extends V{constructor(){super(...arguments),this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new b({raster:this.raster,raster2:this.raster2,operation:this.operation})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],G.prototype,"operation",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],G.prototype,"raster2",void 0),(0,l._)([(0,p.MZ)({readOnly:!0})],G.prototype,"rasters",null),G=b=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ArithmeticFunctionArguments")],G);const B=G;var j=I(48669),g=I(21980),z=I(83179);const U=new Set(["slope","aspect","curvature","hillshade","shadedrelief","statistics"]);let P=class extends ve.A{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0,this.id=-1,this.isNoopProcess=!1,this.rawInputBandIds=[],this.rawSourceRasterInfos=null,this.isInputBandIdsSwizzled=!1,this.swizzledBandSelection=[],this.isBranch=!1,this._bindingResult=null}get supportsGPU(){return this._bindingResult.supportsGPU}get flatWebGLFunctionChain(){const e=this.getWebGLProcessorDefinition();if(!e)return null;const t=[e],{parameters:n}=e;let s=n.rasters||n.raster&&[n.raster];for(;s?.length;){t.unshift(...s);const r=[];for(let u=0;u<s.length;u++){const{parameters:c}=s[u],m=c.rasters||c.raster&&[c.raster];m?.length&&r.push(...m)}s=r}for(let r=t.length-1;r>=0;r--)t[r].isNoopProcess&&t.splice(r,1);let o=!1;for(let r=0;r<t.length;r++){const u=t[r];u.id=t.length-r-1;const{rasters:c}=u.parameters;o=o||null!=c&&c.length>1}const i=t.some(({name:r})=>U.has(r.toLowerCase())),{rawSourceRasterInfos:a}=this;return{functions:t,hasBranches:o,hasFocalFunction:i,isSourceSingleBand:1===a?.[0]?.bandCount}}bind(e,t=!1,n=-1){this.id=n+1;const s=this._getRasterValues();let o=!0;for(let i=0;i<s.length;i++){const a=s[i];if(null!=a&&this._isRasterFunctionValue(a)){const r=a.bind(e,t,this.id+i);if(!r.success)return this._bindingResult=r,r;o=o&&r.supportsGPU}}return!this.rasterInfo||t?(this.sourceRasterInfos=this._getSourceRasterInfos(e),this._bindingResult=this._bindSourceRasters(),this._bindingResult.success&&this._patchRasterInfo(),this._bindingResult.supportsGPU=o&&this._bindingResult.supportsGPU,this.processInputBandIds(),this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this.processInputBandIds(),this._bindingResult)}process(e){const t=this._getRasterValues(),n=0===t.length?e.pixelBlocks??e.primaryPixelBlocks:t.map(s=>this._readRasterValue(s,e));return this._processPixels({...e,pixelBlocks:n})}processInputBandIds(){const e=this._getRasterValues().filter(this._isRasterFunctionValue);let t;if(e.length>1){const o=e.map(a=>a.processInputBandIds()[0]);this.rawInputBandIds=o,this.isInputBandIdsSwizzled=this.rawInputBandIds.some((a,r)=>a!==r);const i=e.filter(a=>"ExtractBand"===a.functionName);return i.length&&i.forEach((a,r)=>{a.isInputBandIdsSwizzled=!0,a.swizzledBandSelection=[r,r,r]}),this.rawInputBandIds}const n=e[0];if(n){if(t=n.processInputBandIds(),n.isInputBandIdsSwizzled)return this.rawInputBandIds=t,t}else{t=[];const{bandCount:o}=this.sourceRasterInfos[0];for(let i=0;i<o;i++)t.push(i)}const s=this._getInputBandIds(t);return this.isInputBandIdsSwizzled=s.some((o,i)=>o!==i),this.rawInputBandIds=s,this.rawInputBandIds}getPrimaryRasters(){const e=[],t=[];return this._getPrimaryRasters(this,e,t),{rasters:e,rasterIds:t}}getWebGLProcessorDefinition(){const e=this._getWebGLParameters(),{raster:t,rasters:n}=this.functionArguments;return n&&Array.isArray(n)&&n.length?(e.rasters=n.map(s=>this._isRasterFunctionValue(s)?s.getWebGLProcessorDefinition():"number"==typeof s?{name:"Constant",parameters:{value:s},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:s},pixelType:"f32",id:-1,isNoopProcess:!1}),e.rasters.some(s=>null!=s)||(e.rasters=null)):this._isRasterFunctionValue(t)&&(e.raster=t.getWebGLProcessorDefinition()),{name:this.functionName,parameters:e,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}}getClippingGeometries(){const e=[];"Clip"===this.functionName&&e.push(this.functionArguments);const{raster:t,rasters:n}=this.functionArguments;if(n&&Array.isArray(n)&&n.length)n.forEach(s=>{if(this._isRasterFunctionValue(s)){const o=s.getClippingGeometries();e.push(...o)}});else if(this._isRasterFunctionValue(t)){const s=t.getClippingGeometries();e.push(...s)}return e}_getOutputPixelType(e){return"unknown"===this.outputPixelType?e:this.outputPixelType??e}_getWebGLParameters(){return{}}_getInputBandIds(e){return e}_removeStatsHistColormapVAT(e){e.statistics=null,e.histograms=null,e.colormap=null,e.attributeTable=null,e.multidimensionalInfo?.variables.forEach(t=>{t.statistics=void 0,t.histograms=void 0})}_getRasterValues(){const{rasterArgumentNames:e}=this;return"rasters"===e[0]?this.functionArguments.rasters??[]:e.flatMap(t=>this.functionArguments[t])}_getSourceRasterInfos(e){const t=this._getRasterValues(),{rasterInfos:n,rasterIds:s}=e;if(0===t.length)return n;const o=t.map(a=>a&&"object"==typeof a&&"bind"in a&&a.rasterInfo?a.rasterInfo:"string"==typeof a&&s.includes(a)?n[s.indexOf(a)]:"number"!=typeof a?n[0]:void 0),i=o.find(a=>a)??n[0];return o.forEach((a,r)=>{void 0===a&&(o[r]=i)}),o}_getPrimaryRasterId(e){return e?.rasterId}_getPrimaryRasters(e,t=[],n=[]){for(let s=0;s<e.sourceRasters.length;s++){const o=e.sourceRasters[s];if("number"!=typeof o)if("bind"in o)this._getPrimaryRasters(o,t,n);else{const i=o,a=this._getPrimaryRasterId(i);if(null==a)continue;n.includes(a)||(this.mainPrimaryRasterId===a?(t.unshift(i),n.unshift(a)):(t.push(i),n.push(a)))}}}_isRasterFunctionValue(e){return null!=e&&"object"==typeof e&&"getWebGLProcessorDefinition"in e}_readRasterValue(e,t){const{primaryPixelBlocks:n}=t;if(null==e||"$$"===e){const s=n[0];return null==s?null:s.clone()}if("string"==typeof e){const s=t.primaryRasterIds.indexOf(e);return-1===s?null:n[s]}if("number"==typeof e){const s=n[0];if(null==s)return null;const{width:o,height:i,pixelType:a}=s,r=new Float32Array(o*i);r.fill(e);const c=new Array(this.sourceRasterInfos[0].bandCount).fill(r);return new g.A({width:o,height:i,pixelType:a,pixels:c})}return e.process(t)}_patchRasterInfo(){const{rasterInfo:e}=this;if(!e?.keyProperties)return;const{bandCount:t,keyProperties:n,statistics:s,histograms:o}=e,i=n.BandProperties;i&&i.length!==t&&(e.keyProperties={...n,BandProperties:void 0}),s&&s.length!==t&&(e.statistics=s.length>t?s.slice(0,t):null),o&&o.length!==t&&(e.histograms=o.length>t?o.slice(0,t):null),n.BAND_COUNT&&Number(n.BAND_COUNT)!==t&&(e.keyProperties={...n,BAND_COUNT:"string"==typeof n.BAND_COUNT?String(t):t})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],P.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],P.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],P.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}}),(0,j.w)(e=>e?.toLowerCase())],P.prototype,"outputPixelType",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],P.prototype,"mainPrimaryRasterId",void 0),(0,l._)([(0,p.MZ)()],P.prototype,"sourceRasters",void 0),(0,l._)([(0,p.MZ)({type:[z.A],json:{write:!0}})],P.prototype,"sourceRasterInfos",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],P.prototype,"rasterInfo",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],P.prototype,"readingBufferSize",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],P.prototype,"id",void 0),(0,l._)([(0,p.MZ)()],P.prototype,"isNoopProcess",void 0),(0,l._)([(0,p.MZ)()],P.prototype,"supportsGPU",null),(0,l._)([(0,p.MZ)()],P.prototype,"rawInputBandIds",void 0),(0,l._)([(0,p.MZ)()],P.prototype,"rawSourceRasterInfos",void 0),(0,l._)([(0,p.MZ)()],P.prototype,"isInputBandIdsSwizzled",void 0),(0,l._)([(0,p.MZ)()],P.prototype,"swizzledBandSelection",void 0),(0,l._)([(0,p.MZ)()],P.prototype,"isBranch",void 0),(0,l._)([(0,p.MZ)({readOnly:!0})],P.prototype,"flatWebGLFunctionChain",null),(0,l._)([(0,p.MZ)()],P.prototype,"_bindingResult",void 0),P=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.BaseRasterFunction")],P);const R=P,T={userDefined:-1,lineDetectionHorizontal:0,lineDetectionVertical:1,lineDetectionLeftDiagonal:2,lineDetectionRightDiagonal:3,gradientNorth:4,gradientWest:5,gradientEast:6,gradientSouth:7,gradientNorthEast:8,gradientNorthWest:9,smoothArithmeticMean:10,smoothing3x3:11,smoothing5x5:12,sharpening3x3:13,sharpening5x5:14,laplacian3x3:15,laplacian5x5:16,sobelHorizontal:17,sobelVertical:18,sharpen:19,sharpen2:20,pointSpread:21,none:255},L={bitwiseAnd:11,bitwiseLeftShift:12,bitwiseNot:13,bitwiseOr:14,bitwiseRightShift:15,bitwiseXOr:16,booleanAnd:17,booleanNot:18,booleanOr:19,booleanXOr:20,equalTo:24,greaterThan:28,greaterThanEqual:29,lessThan:33,lessThanEqual:34,isNull:31,notEqual:46},rt={acos:6,asin:7,atan:8,atanh:9,cos:21,cosh:22,sin:51,sinh:52,tan:56,tanh:57,acosh:59,asinh:60,atan2:61},gt={setNull:50,conditional:78},mt={plus:1,minus:2,times:3,sqrt:4,power:5,abs:10,divide:23,exp:25,exp10:26,exp2:27,int:30,float:32,ln:35,log10:36,log2:37,mod:44,negate:45,roundDown:48,roundUp:49,square:53,floatDivide:64,floorDivide:65,...L,...rt,majority:38,max:39,mean:40,med:41,min:42,minority:43,range:47,stddev:54,sum:55,variety:58,majorityIgnoreNoData:66,maxIgnoreNoData:67,meanIgnoreNoData:68,medIgnoreNoData:69,minIgnoreNoData:70,minorityIgnoreNoData:71,rangeIgnoreNoData:72,stddevIgnoreNoData:73,sumIgnoreNoData:74,varietyIgnoreNoData:75,...gt},me=new Map([[rt.acos,{domain:[0,Math.PI],isInteger:!1}],[rt.asin,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[rt.atan,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[rt.cos,{domain:[-1,1],isInteger:!1}],[rt.sin,{domain:[-1,1],isInteger:!1}],[L.booleanAnd,{domain:[0,1],isInteger:!0}],[L.booleanNot,{domain:[0,1],isInteger:!0}],[L.booleanOr,{domain:[0,1],isInteger:!0}],[L.booleanXOr,{domain:[0,1],isInteger:!0}],[L.equalTo,{domain:[0,1],isInteger:!0}],[L.notEqual,{domain:[0,1],isInteger:!0}],[L.greaterThan,{domain:[0,1],isInteger:!0}],[L.greaterThanEqual,{domain:[0,1],isInteger:!0}],[L.lessThan,{domain:[0,1],isInteger:!0}],[L.lessThanEqual,{domain:[0,1],isInteger:!0}],[L.isNull,{domain:[0,1],isInteger:!0}]]);function dn(e){return me.get(e)}const gn=[0,2,2,2,1,2,1,1,1,1,1,2,2,1,2,2,2,2,1,2,2,1,1,2,2,1,1,1,2,2,1,1,1,2,2,1,1,1,999,999,999,999,999,999,2,1,2,999,1,1,2,1,1,1,999,999,1,1,999,1,1,2,999,999,2,2,999,999,999,999,999,999,999,999,999,999,3,999,3];function Kn(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]+o[r]);return a}function Xn(e,t,n){const[s]=e,i=g.A.createEmptyBand("f32",s.length);return i.set(s),i}function Yn(e,t,n){const[s]=e,o=s.length,i=g.A.createEmptyBand(n,o);for(let a=0;a<o;a++)t&&!t[a]||(i[a]=s[a]*s[a]);return i}function Qn(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]-o[r]);return a}function qn(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]*o[r]);return a}function ts(e,t,n){const[s]=e,o=s.length,i=g.A.createEmptyBand(n,o);for(let a=0;a<o;a++)t&&!t[a]||(i[a]=Math.sign(s[a])*Math.floor(Math.abs(s[a])));return i}function fn(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]/o[r]);return a}function es(e,t,n){return fn(e,t,"f32")}function ns(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=Math.floor(s[r]/o[r]));return a}function ss(e,t,n,s){const o=e[0],i=o.length,a=g.A.createEmptyBand(n,i);if(s===rt.atanh){for(let u=0;u<i;u++)if(t[u]){const c=o[u];Math.abs(c)>=1?t[u]=0:a[u]=Math.atanh(c)}return a}const r=s===rt.asin?Math.asin:Math.acos;for(let u=0;u<i;u++)if(t[u]){const c=o[u];Math.abs(c)>1?t[u]=0:a[u]=r(c)}return a}function rs(e,t,n,s){const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s(o[r]));return a}function os(e,t,n,s){const[o,i]=e,a=o.length,r=g.A.createEmptyBand(n,a);for(let u=0;u<a;u++)t&&!t[u]||(r[u]=s(o[u],i[u]));return r}function is(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]&o[r]);return a}function as(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]<<o[r]);return a}function us(e,t,n){const[s]=e,o=s.length,i=g.A.createEmptyBand(n,o);for(let a=0;a<o;a++)t&&!t[a]||(i[a]=~s[a]);return i}function ls(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]|o[r]);return a}function cs(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]>>o[r]);return a}function ps(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]^o[r]);return a}function ms(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]&&o[r]?1:0);return a}function hs(e,t,n){const[s]=e,o=s.length,i=g.A.createEmptyBand(n,o);for(let a=0;a<o;a++)t&&!t[a]||(i[a]=s[a]?0:1);return i}function ds(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]||o[r]?1:0);return a}function gs(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=(s[r]?1:0)^(o[r]?1:0));return a}function fs(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]===o[r]?1:0);return a}function Ce(e,t,n,s){const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i),r=s===Math.E;for(let u=0;u<i;u++)t&&!t[u]||(a[u]=r?Math.exp(o[u]):s**o[u]);return a}function ys(e,t,n){return Ce(e,t,n,10)}function xs(e,t,n){return Ce(e,t,n,2)}function As(e,t,n){return Ce(e,t,n,Math.E)}function Be(e,t,n,s){const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(o[r]<=0?t[r]=0:a[r]=s(o[r]));return a}function _s(e,t,n){return Be(e,t,n,Math.log10)}function vs(e,t,n){return Be(e,t,n,Math.log2)}function ws(e,t,n){return Be(e,t,n,Math.log)}function bs(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]>o[r]?1:0);return a}function Fs(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]>=o[r]?1:0);return a}function Ms(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]<o[r]?1:0);return a}function Ts(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]<=o[r]?1:0);return a}function Ps(e,t,n){const[s]=e,o=s.length,i=g.A.createEmptyBand(n,o);if(!t)return i;for(let a=0;a<o;a++)i[a]=t[a]?0:1;return i}function Is(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]%o[r]);return a}function Rs(e,t,n){const[s]=e,o=s.length,i=g.A.createEmptyBand(n,o);for(let a=0;a<o;a++)t&&!t[a]||(i[a]=-s[a]);return i}function Ns(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]===o[r]?0:1);return a}function Cs(e,t,n){const[s,o]=e,i=s.length,a=g.A.createEmptyBand(n,i),r=new Uint8Array(i);for(let u=0;u<i;u++)null!=t&&!t[u]||0!==s[u]||(a[u]=o[u],r[u]=255);return{band:a,mask:r}}function yn(e,t,n){const[s,o,i]=e,a=s.length,r=g.A.createEmptyBand(n,a);for(let u=0;u<a;u++)t&&!t[u]||(r[u]=s[u]?o[u]:i[u]);return r}function xn(e,t,n){const s=e.length;if(s<2)return e[0];const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)if(!t||t[r]){let u=o[r];for(let c=1;c<s;c++){const m=e[c][r];u<m&&(u=m)}a[r]=u}return a}function An(e,t,n){const s=e.length;if(s<2)return e[0];const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)if(!t||t[r]){let u=o[r];for(let c=1;c<s;c++){const m=e[c][r];u>m&&(u=m)}a[r]=u}return a}function _n(e,t,n){const s=e.length;if(s<2)return e[0];const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)if(!t||t[r]){let u=o[r],c=u;for(let m=1;m<s;m++){const h=e[m][r];c<h?c=h:u>h&&(u=h)}a[r]=c-u}return a}function vn(e,t,n){const s=e.length;if(s<2)return e[0];const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)if(!t||t[r]){let u=0;for(let c=0;c<s;c++)u+=e[c][r];a[r]=u/s}return a}function wn(e,t,n){const s=e.length;if(s<2)return e[0];const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)if(!t||t[r])for(let u=0;u<s;u++)a[r]+=e[u][r];return a}function bn(e,t,n){const s=e.length;if(s<2)return e[0];const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)if(!t||t[r]){const u=new Float32Array(s);let c=0;for(let h=0;h<s;h++){const d=e[h];c+=d[r],u[h]=d[r]}c/=s;let m=0;for(let h=0;h<s;h++)m+=(u[h]-c)**2;a[r]=Math.sqrt(m/s)}return a}function Fn(e,t,n){const s=e.length;if(s<2)return e[0];const o=Math.floor(s/2),[i]=e,a=i.length,r=g.A.createEmptyBand(n,a),u=new Float32Array(s),c=s%2==1;for(let m=0;m<a;m++)if(!t||t[m]){for(let h=0;h<s;h++)u[h]=e[h][m];u.sort(),r[m]=c?u[o]:(u[o]+u[o-1])/2}return r}function Mn(e,t,n){const[s,o]=e;if(null==o)return s;const i=s.length,a=g.A.createEmptyBand(n,i);for(let r=0;r<i;r++)t&&!t[r]||(a[r]=s[r]<o[r]?s[r]:o[r]);return a}function Tn(e,t,n){const s=e.length;if(s<=2)return Mn(e,t,n);const o=e[0].length,i=g.A.createEmptyBand(n,o),a=new Map;for(let r=0;r<o;r++)if(!t||t[r]){a.clear();for(let h=0;h<s;h++){const d=e[h][r];a.set(d,a.has(d)?a.get(d)+1:1)}let u=0,c=0;const m=[];for(const h of a.keys())u=a.get(h),u>c?(c=u,m.length=0,m.push(h)):u===c&&m.push(h);m.length>1&&m.sort((h,d)=>h-d),i[r]=m[0]}return i}function Pn(e,t,n){const s=e.length;if(s<=2)return Mn(e,t,n);const o=e[0].length,i=g.A.createEmptyBand(n,o),a=new Map;for(let r=0;r<o;r++)if(!t||t[r]){a.clear();for(let h=0;h<s;h++){const d=e[h][r];a.set(d,a.has(d)?a.get(d)+1:1)}let u=0,c=e.length;const m=[];for(const h of a.keys())u=a.get(h),u<c?(c=u,m.length=0,m.push(h)):u===c&&m.push(h);m.length>1&&m.sort((h,d)=>h-d),i[r]=m[0]}return i}function In(e,t,n){const s=e.length;if(s<2)return e[0];const[o]=e,i=o.length,a=g.A.createEmptyBand(n,i),r=new Set;for(let u=0;u<i;u++)if(!t||t[u]){let c;r.clear();for(let m=0;m<s;m++)c=e[m][u],r.add(c);a[u]=r.size}return a}const tt=new Map,Me=new Map,D=new Map,J=new Map;function Rn(e,t,n={}){!function Bs(){tt.size||(tt.set(4,Math.sqrt),tt.set(6,Math.acos),tt.set(7,Math.asin),tt.set(8,Math.atan),tt.set(9,Math.atanh),tt.set(10,Math.abs),tt.set(21,Math.cos),tt.set(22,Math.cosh),tt.set(48,Math.floor),tt.set(49,Math.ceil),tt.set(51,Math.sin),tt.set(52,Math.sinh),tt.set(56,Math.tan),tt.set(57,Math.tanh),tt.set(59,Math.acosh),tt.set(60,Math.asinh),tt.set(65,Math.floor),Me.set(5,Math.pow),Me.set(61,Math.atan2),D.set(1,Kn),D.set(2,Qn),D.set(3,qn),D.set(11,is),D.set(12,as),D.set(13,us),D.set(14,ls),D.set(15,cs),D.set(16,ps),D.set(17,ms),D.set(18,hs),D.set(19,ds),D.set(20,gs),D.set(23,fn),D.set(24,fs),D.set(25,As),D.set(26,ys),D.set(27,xs),D.set(28,bs),D.set(29,Fs),D.set(30,ts),D.set(31,Ps),D.set(32,Xn),D.set(33,Ms),D.set(34,Ts),D.set(35,ws),D.set(36,_s),D.set(37,vs),D.set(44,Is),D.set(45,Rs),D.set(46,Ns),D.set(53,Yn),D.set(64,es),D.set(65,ns),D.set(76,yn),D.set(78,yn),J.set(38,Tn),J.set(39,xn),J.set(40,vn),J.set(41,Fn),J.set(42,An),J.set(43,Pn),J.set(47,_n),J.set(54,bn),J.set(55,wn),J.set(58,In),J.set(66,Tn),J.set(67,xn),J.set(68,vn),J.set(69,Fn),J.set(70,An),J.set(71,Pn),J.set(72,_n),J.set(73,bn),J.set(74,wn),J.set(75,In))}();let s=function Jn(e,t=!1){const n=e.map(r=>r.mask),s=n.filter(r=>null!=r);if(0===s.length||t&&s.length!==n.length)return new Uint8Array(e[0].pixels[0].length).fill(255);const a=new Uint8Array(s[0]);if(1===s.length)return a;if(!t){for(let r=1;r<s.length;r++){const u=s[r];for(let c=0;c<a.length;c++)a[c]&&(a[c]=u[c]?255:0)}return a}for(let r=1;r<s.length;r++){const u=s[r];for(let c=0;c<a.length;c++)0===a[c]&&(a[c]=u[c]?255:0)}return a}(e,t>=66&&t<=75);const{outputPixelType:o="f32"}=n,i=!J.has(t)||n.processAsMultiband,a=i?e[0].pixels.length:1,r=[];for(let c=0;c<a;c++){const m=J.has(t)&&!i?e.flatMap(f=>f.pixels):e.map(f=>f.pixels[c]);let h,d=!0;if(t===gt.setNull){const f=Cs(m,s,o);h=f.band,s=f.mask,d=!1}else D.has(t)?h=D.get(t)(m,s,"f64"):tt.has(t)?h=t===rt.asin||t===rt.acos||t===rt.atanh?ss(m,s,"f64",t):rs(m,s,"f64",tt.get(t)):Me.has(t)?h=os(m,s,"f64",Me.get(t)):J.has(t)?h=J.get(t)(m,s,"f64"):(h=m[0],d=!1);if(d&&t!==L.isNull&&!me.has(t)){const f=g.A.createEmptyBand(o,h.length);s||(s=new Uint8Array(h.length).fill(255)),(0,Z.$p)(h,s),(0,Z.yM)(h,s,o,f),h=f}r.push(h)}const u=e[0];return new g.A({width:u.width,height:u.height,pixelType:o,mask:t===L.isNull?null:s,pixels:r})}let ee=class extends R{constructor(){super(...arguments),this.functionName="Arithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{operation:e}=this.functionArguments;if(e<1||e>6)return{success:!1,supportsGPU:!1,error:"unsupported operation"};const t=this.sourceRasterInfos[0].clone();return this.outputPixelType=this._getOutputPixelType(t.pixelType),t.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(t),this.rasterInfo=t,{success:!0,supportsGPU:t.bandCount<=3}}_processPixels(e){const{pixelBlocks:t}=e;return null==t?.[0]||null==t?.[1]?null:function ks(e,t,n){return Rn(e,t=[null,1,2,3,23,5,44][t]??1,{outputPixelType:n})}(t,this.functionArguments.operation,this.outputPixelType)}_getWebGLParameters(){const{operation:e}=this.functionArguments,t=["","plus","minus","times","divide","power","mod"][e],n=this.outputPixelType??"f32";let[s,o]=(0,Z.hP)(n);const i=(0,Z.zw)(n);return i&&(s-=1e-4,o+=1e-4),{imageCount:2,operationName:t,domainRange:[s,o],isOutputRounded:i}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],ee.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:B,json:{write:!0,name:"rasterFunctionArguments"}})],ee.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],ee.prototype,"rasterArgumentNames",void 0),ee=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ArithmeticFunction")],ee);const Ss=ee;var ke;let Se=ke=class extends V{clone(){return new ke({raster:this.raster})}};Se=ke=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.AspectFunctionArguments")],Se);const Ds=Se;var ot=I(14870);let kt=class extends R{constructor(){super(...arguments),this.functionName="Aspect",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const e=this.sourceRasterInfos[0];this.isGCS=e.spatialReference?.isGeographic??!1,this.outputPixelType=this._getOutputPixelType("f32");const t=e.clone();return t.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(t),t.statistics=[{min:-1,max:360,avg:180,stddev:30}],t.bandCount=1,this.rasterInfo=t,{success:!0,supportsGPU:!0}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return null;const{extent:n,primaryPixelSizes:s}=e,o=s?.[0];return(0,ot.di)(t,{resolution:o??(n?{x:n.width/t.width,y:n.height/t.height}:{x:1,y:1})})}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],kt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Ds,json:{write:!0,name:"rasterFunctionArguments"}})],kt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],kt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],kt.prototype,"isGCS",void 0),kt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.AspectFunction")],kt);const js=kt;var At=I(15463),_t=I(49976);const Gs=new Set(["+","-","*","/","(",")"]);function Nn(e,t){return e.toLowerCase().startsWith("b")?t[parseInt(e.slice(1),10)-1]:parseFloat(e)}function Us(e,t,n,s){if("number"==typeof n&&"number"==typeof s)return n+s;let o,i,a;"number"==typeof n?(a=s,o=a.length,i=new Float32Array(o),i.fill(n)):(o=n.length,i=n,s.constructor===Number?(a=new Float32Array(o),a.fill(s)):a=s);const r=new Float32Array(o);switch(t){case"+":for(let u=0;u<o;u++)(null==e||e[u])&&(r[u]=i[u]+a[u]);break;case"-":for(let u=0;u<o;u++)(null==e||e[u])&&(r[u]=i[u]-a[u]);break;case"*":for(let u=0;u<o;u++)(null==e||e[u])&&(r[u]=i[u]*a[u]);break;case"/":for(let u=0;u<o;u++)(null==e||e[u])&&a[u]&&(r[u]=i[u]/a[u]);break;case"(":case")":throw new Error("encountered error with custom band index equation")}return r}function zs(e,t){e.splice(t,1);let n=0,s=0;do{n=0,s=0;for(let o=0;o<e.length;o++)if("("===e[o])n=o;else if(")"===e[o]){s=o;break}s===n+1&&e.splice(n,2)}while(s===n+1);return e}function Es(e){if(1===e.length)return{opIndex:0,numIndex:0};let t=0,n=0;for(let a=0;a<e.length;a++)if("("===e[a])t=a;else if(")"===e[a]){n=a;break}const s=0===n?e:e.slice(t+1,n);let o=-1;for(let a=0;a<s.length;a++)if("*"===s[a]||"/"===s[a]){o=a;break}if(o>-1)n>0&&(o+=t+1);else{for(let a=0;a<s.length;a++)if("+"===s[a]||"-"===s[a]){o=a;break}n>0&&(o+=t+1)}let i=0;for(let a=0;a<o;a++)"("===e[a]&&i++;return{opIndex:o,numIndex:o-i}}var $=I(40275);const Vs=new _t.J({0:"custom",1:"ndvi",2:"savi",3:"tsavi",4:"msavi",5:"gemi",6:"pvi",7:"gvitm",8:"sultan",9:"vari",10:"gndvi",11:"sr",12:"ndvi-re",13:"sr-re",14:"mtvi2",15:"rtvi-core",16:"ci-re",17:"ci-g",18:"ndwi",19:"evi",20:"iron-oxide",21:"ferrous-minerals",22:"clay-minerals",23:"wndwi",24:"bai",25:"nbr",26:"ndbi",27:"ndmi",28:"ndsi",29:"mndwi"},{useNumericKeys:!0});function Ls(e,t){if(!(0,$.AB)(e))return e;const{equation:n,method:s}=t,o=t.bandIndexes.map(d=>d-1),{pixels:i,mask:a}=e;let r;switch(s){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":r=Cn(a,i[o[0]],i[o[1]]);break;case"ndwi":r=Cn(a,i[o[1]],i[o[0]]);break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":r=function Hs(e,t,n){const s=n.length,o=new Float32Array(s);for(let i=0;i<s;i++)if(null==e||e[i]){const r=n[i];r&&(o[i]=t[i]/r)}return[o]}(a,i[o[0]],i[o[1]]);break;case"ci-g":case"ci-re":r=function $s(e,t,n){const s=t.length,o=new Float32Array(s);for(let i=0;i<s;i++)if(null==e||e[i]){const r=n[i];r&&(o[i]=t[i]/r-1)}return[o]}(a,i[o[0]],i[o[1]]);break;case"savi":r=function Js(e,t,n,s){const o=n.length,i=new Float32Array(o);for(let a=0;a<o;a++)if(null==e||e[a]){const r=n[a],u=t[a],c=u+r+s;c&&(i[a]=(u-r)/c*(1+s))}return[i]}(a,i[o[0]],i[o[1]],o[2]+1);break;case"tsavi":r=function Ks(e,t,n,s,o,i){const a=n.length,r=new Float32Array(a),u=-o*s+i*(1+s*s);for(let c=0;c<a;c++)if(null==e||e[c]){const m=n[c],h=t[c],d=o*h+m+u;d&&(r[c]=s*(h-s*m-o)/d)}return[r]}(a,i[o[0]],i[o[1]],o[2]+1,o[3]+1,o[4]+1);break;case"msavi":r=function Xs(e,t,n){const s=n.length,o=new Float32Array(s);for(let i=0;i<s;i++)if(null==e||e[i]){const r=t[i],u=2*r+1;o[i]=.5*(u-Math.sqrt(u*u-8*(r-n[i])))}return[o]}(a,i[o[0]],i[o[1]]);break;case"gemi":r=function Ys(e,t,n){const s=n.length,o=new Float32Array(s);for(let i=0;i<s;i++)if(null==e||e[i]){const a=n[i],r=t[i];if(1!==a&&r+a+.5!==0){const u=(2*(r*r-a*a)+1.5*r+.5*a)/(r+a+.5);o[i]=u*(1-.25*u)-(a-.125)/(1-a)}}return[o]}(a,i[o[0]],i[o[1]]);break;case"pvi":r=function Qs(e,t,n,s,o){const i=n.length,a=new Float32Array(i),r=1/Math.sqrt(1+s*s);for(let u=0;u<i;u++)(null==e||e[u])&&(a[u]=(t[u]-s*n[u]-o)*r);return[a]}(a,i[o[0]],i[o[1]],o[2]+1,o[3]+1);break;case"gvitm":r=function qs(e,t){const[n,s,o,i,a,r]=t,u=n.length,c=new Float32Array(u);for(let m=0;m<u;m++)(null==e||e[m])&&(c[m]=-.2848*n[m]-.2435*s[m]-.5436*o[m]+.7243*i[m]+.084*a[m]-.18*r[m]);return[c]}(a,[i[o[0]],i[o[1]],i[o[2]],i[o[3]],i[o[4]],i[o[5]]]);break;case"sultan":r=function tr(e,t){const[n,s,o,i,a]=t,r=n.length,u=new Float32Array(r),c=new Float32Array(r),m=new Float32Array(r);for(let h=0;h<r;h++)(null==e||e[h])&&(u[h]=a[h]?i[h]/a[h]*100:0,c[h]=n[h]?i[h]/n[h]*100:0,m[h]=o[h]?s[h]/o[h]*(i[h]/o[h])*100:0);return[u,c,m]}(a,[i[o[0]],i[o[1]],i[o[2]],i[o[3]],i[o[4]]]);break;case"vari":r=function er(e,t){const[n,s,o]=t,i=n.length,a=new Float32Array(i);for(let r=0;r<i;r++)if(null==e||e[r])for(r=0;r<i;r++){const u=n[r],c=s[r],m=c+u-o[r];m&&(a[r]=(c-u)/m)}return[a]}(a,[i[o[0]],i[o[1]],i[o[2]]]);break;case"mtvi2":r=function nr(e,t){const[n,s,o]=t,i=n.length,a=new Float32Array(i);for(let r=0;r<i;r++)if(null==e||e[r])for(r=0;r<i;r++){const u=n[r],c=s[r],m=o[r],h=Math.sqrt((2*u+1)**2-(6*u-5*Math.sqrt(c))-.5);h&&(a[r]=1.5*(1.2*(u-m)-2.5*(c-m))/h)}return[a]}(a,[i[o[0]],i[o[1]],i[o[2]]]);break;case"rtvi-core":r=function sr(e,t){const[n,s,o]=t,i=n.length,a=new Float32Array(i);for(let r=0;r<i;r++)if(null==e||e[r])for(r=0;r<i;r++){const u=n[r];a[r]=100*(u-s[r])-10*(u-o[r])}return[a]}(a,[i[o[0]],i[o[1]],i[o[2]]]);break;case"evi":r=function rr(e,t){const[n,s,o]=t,i=n.length,a=new Float32Array(i);for(let r=0;r<i;r++)if(null==e||e[r])for(r=0;r<i;r++){const u=n[r],c=s[r],m=u+6*c-7.5*o[r]+1;m&&(a[r]=2.5*(u-c)/m)}return[a]}(a,[i[o[0]],i[o[1]],i[o[2]]]);break;case"wndwi":r=function or(e,t,n=.5){const[s,o,i]=t,a=o.length,r=new Float32Array(a);for(let u=0;u<a;u++)if(null==e||e[u])for(u=0;u<a;u++){const c=s[u],m=o[u],h=i[u],d=c+n*m+(1-n)*h;d&&(r[u]=(c-n*m-(1-n)*h)/d)}return[r]}(a,[i[o[0]],i[o[1]],i[o[2]]],o[3]?o[3]+1:.5);break;case"bai":r=function ir(e,t,n){const s=n.length,o=new Float32Array(s);for(let i=0;i<s;i++)if(null==e||e[i])for(i=0;i<s;i++){const a=(.1-t[i])**2+(.06-n[i])**2;a&&(o[i]=1/a)}return[o]}(a,i[o[0]],i[o[1]]);break;case"custom":r=function Os(e,t,n){let s,{ops:o,nums:i}=function Zs(e,t){(e=e.replaceAll(" ","")).startsWith("-")&&(e="0"+e),e.startsWith("+")&&(e=e.slice(1));const n=e.split(""),s=[],o=[];let i="";for(let a=0;a<n.length;a++){const r=n[a];Gs.has(r)?(i.length&&o.push(Nn(i,t)),s.push(r),i=""):i=i.concat(r)}return i.length&&o.push(Nn(i,t)),{ops:s,nums:o}}(n,t);if(0===o.length){const a=1===i.length?i[0]:t[0];if(a instanceof Float32Array)return[a];const r=new Float32Array(t[0].length);return"number"==typeof a?r.fill(a):r.set(a),[r]}for(;o.length>0;){const{numIndex:a,opIndex:r}=Es(o);if(s=Us(e,o[r],i[a],i[a+1]),1===o.length)break;o=zs(o,r),i.splice(a,2,s)}return[s]}(a,i,n);break;default:return e}const{outputPixelType:u="f32"}=t,c=null!=u&&(0,Z.zw)(u);let m;a?(m=new Uint8Array(e.width*e.height),m.set(a)):c&&(m=new Uint8Array(e.width*e.height).fill(255)),c&&(r=r.map(d=>{const f=g.A.createEmptyBand(u,d.length);return(0,Z.yM)(d,m,u,f),f}));const h=new g.A({width:e.width,height:e.height,pixelType:u,pixels:r,mask:m});return h.updateStatistics(),h}function nt(e){const t=new Float32Array(9);return t[3*e[0]]=1,t[3*e[1]+1]=1,t[3*e[2]+2]=1,t}function Cn(e,t,n){const s=n.length,o=new Float32Array(s);for(let i=0;i<s;i++)if(null==e||e[i]){const a=t[i],r=n[i],u=a+r;u&&(o[i]=(a-r)/u)}return[o]}var De;let he=De=class extends V{constructor(){super(...arguments),this.method="custom"}clone(){return new De({method:this.method,bandIndexes:this.bandIndexes,raster:(0,at.o8)(this.raster)})}};(0,l._)([(0,p.MZ)({json:{type:String,write:!0}})],he.prototype,"bandIndexes",void 0),(0,l._)([(0,At.e)(Vs)],he.prototype,"method",void 0),he=De=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")],he);const ar=he,ur=new Set(["vari","mtvi2","rtvi-core","evi"]);let ne=class extends R{constructor(){super(...arguments),this.functionName="BandArithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const e=this.sourceRasterInfos[0];if(e.bandCount<2)return{success:!1,supportsGPU:!1,error:"band-arithmetic-function: source raster has insufficient amount of raster bands"};const t=e.clone();return t.pixelType=this.outputPixelType,t.bandCount="sultan"===this.functionArguments.method?3:1,this._removeStatsHistColormapVAT(t),t.keyProperties={...t.keyProperties,BandProperties:void 0},this.rasterInfo=t,{success:!0,supportsGPU:!["custom","gvitm","sultan"].includes(this.functionArguments.method)}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return t;const{method:n,bandIndexes:s}=this.functionArguments;return Ls(t,{method:n,bandIndexes:s.split(" ").map(i=>parseFloat(i)),equation:s,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const e=this.functionArguments.bandIndexes.split(" ").map(a=>parseFloat(a)-1);2===e.length&&e.push(0);const t=this.isInputBandIdsSwizzled?[0,1,2]:e;let n,s;const o=new Float32Array(3),{method:i}=this.functionArguments;switch(i){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":n=nt([t[0],t[1],0]),s="ndxi";break;case"ndwi":n=nt([t[1],t[0],0]),s="ndxi";break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":n=nt([t[0],t[1],0]),s="sr";break;case"ci-g":case"ci-re":n=nt([t[0],t[1],0]),s="ci";break;case"savi":n=nt([t[0],t[1],0]),s="savi",o[0]=e[2]+1;break;case"tsavi":n=nt([t[0],t[1],0]),s="tsavi",o[0]=e[2]+1,o[1]=e[3]+1,o[2]=e[4]+1;break;case"msavi":n=nt([t[0],t[1],0]),s="msavi";break;case"gemi":n=nt([t[0],t[1],0]),s="gemi";break;case"pvi":n=nt([t[0],t[1],0]),s="tsavi",o[0]=e[2]+1,o[1]=e[3]+1;break;case"vari":n=nt([t[0],t[1],t[2]]),s="vari";break;case"mtvi2":n=nt([t[0],t[1],t[2]]),s="mtvi";break;case"rtvi-core":n=nt([t[0],t[1],t[2]]),s="rtvicore";break;case"evi":n=nt([t[0],t[1],t[2]]),s="evi";break;case"wndwi":n=nt([t[0],t[1],0]),s="wndwi",o[0]=e[3]?e[3]+1:.5;break;case"bai":n=nt([t[1],t[0],0]),s="bai";break;default:n=nt([0,1,2]),s="custom"}return{bandIndexMat3:n,indexType:s,adjustments:o,isOutputRounded:(0,Z.zw)(this.outputPixelType)}}_getInputBandIds(e){if("custom"===this.functionArguments.method)return e;const t=this.functionArguments.bandIndexes.split(" ").map(a=>parseFloat(a)-1),n=e.length,s=t.map(a=>a>=n?n-1:a),o=ur.has(this.functionArguments.method)?3:2,i=s.slice(0,o).map(a=>e[a]);return 2===i.length&&i.push(0),i}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],ne.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:ar,json:{write:!0,name:"rasterFunctionArguments"}})],ne.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],ne.prototype,"rasterArgumentNames",void 0),ne=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.BandArithmeticFunction")],ne);const lr=ne;var je,cr=I(61320),pr=I(6434);const Bn=new _t.J({1:"outside",2:"inside"},{useNumericKeys:!0});let de=je=class extends V{constructor(){super(...arguments),this.clippingType="outside"}clone(){return new je({clippingGeometry:this.clippingGeometry.clone(),clippingType:this.clippingType})}};(0,l._)([(0,p.MZ)({types:pr.yR,json:{read:cr.rS,write:!0}})],de.prototype,"clippingGeometry",void 0),(0,l._)([(0,p.MZ)({json:{read:Bn.read,write:Bn.write}})],de.prototype,"clippingType",void 0),de=je=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ClipFunctionArguments")],de);const mr=de;var hr=I(18703),kn=I(40018);let St=class extends R{constructor(){super(...arguments),this.functionName="Clip",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const e=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType,this.rasterInfo=e;const{functionArguments:t}=this,{clippingGeometry:n,clippingType:s}=t;if(!n)return{success:!1,supportsGPU:!1,error:"missing clipping geometry"};if("outside"===s)try{const{spatialReference:o}=e,i="extent"===n.type?(0,kn._l)(n,o):(0,kn.uk)(n,o).extent;i&&(0,hr.Sd)(e,i)}catch{}return{success:!0,supportsGPU:!0}}_processPixels(e){return e.pixelBlocks?.[0]}_getWebGLParameters(){const{clippingGeometry:e,clippingType:t}=this.functionArguments;return{clippingGeometry:e.toJSON(),clippingType:t}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],St.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:mr,json:{write:!0,name:"rasterFunctionArguments"}})],St.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],St.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)()],St.prototype,"isNoopProcess",void 0),St=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ClipFunction")],St);const dr=St;var Ze,ge=I(17221),lt=I(32681),Ge=I(54485);let vt=Ze=class extends V{castColormapName(e){if(!e)return null;const t=e.toLowerCase();return lt.L7.includes(t)?t:null}readColorRamp(e){return(0,Ge.r)(e)}readColorRampName(e,t){if(!e)return null;const n=lt.kH.jsonValues.find(s=>s.toLowerCase()===e.toLowerCase());return n?lt.kH.fromJSON(n):null}clone(){return new Ze({colormap:(0,at.o8)(this.colormap),colormapName:this.colormapName,colorRamp:this.colorRamp?.clone(),colorRampName:this.colorRampName})}};(0,l._)([(0,p.MZ)({type:[[Number]],json:{write:!0}})],vt.prototype,"colormap",void 0),(0,l._)([(0,p.MZ)({type:String,json:{write:!0}})],vt.prototype,"colormapName",void 0),(0,l._)([(0,j.w)("colormapName")],vt.prototype,"castColormapName",null),(0,l._)([(0,p.MZ)({types:Ge.g,json:{write:!0}})],vt.prototype,"colorRamp",void 0),(0,l._)([(0,ge.w)("colorRamp")],vt.prototype,"readColorRamp",null),(0,l._)([(0,p.MZ)({type:lt.kH.apiValues,json:{type:lt.kH.jsonValues,write:lt.kH.write}})],vt.prototype,"colorRampName",void 0),(0,l._)([(0,ge.w)("colorRampName")],vt.prototype,"readColorRampName",null),vt=Ze=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ColormapFunctionArguments")],vt);const gr=vt,fr=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[112,75,3],[113,76,3],[114,77,3],[115,77,3],[116,78,3],[117,79,3],[118,79,3],[119,80,3],[121,81,4],[122,82,4],[123,82,4],[124,83,4],[125,84,4],[126,84,4],[127,85,4],[128,86,4],[129,86,4],[130,87,4],[131,88,4],[132,89,4],[133,89,4],[134,90,4],[135,91,4],[136,91,4],[137,92,4],[138,93,4],[139,94,4],[140,94,4],[142,95,5],[143,96,5],[144,96,5],[145,97,5],[146,98,5],[147,99,5],[148,99,5],[149,100,5],[150,101,5],[151,101,5],[152,102,5],[153,103,5],[154,104,5],[155,104,5],[156,105,5],[157,106,5],[158,106,5],[159,107,5],[160,108,5],[161,108,5],[162,109,5],[164,110,6],[165,111,6],[166,111,6],[167,112,6],[168,113,6],[169,113,6],[170,114,6],[171,115,6],[172,116,6],[173,116,6],[174,117,6],[245,0,0],[245,5,0],[245,10,0],[246,15,0],[246,20,0],[246,25,0],[246,30,0],[247,35,0],[247,40,0],[247,45,0],[247,50,0],[247,55,0],[248,60,0],[248,65,0],[248,70,0],[248,75,0],[249,81,0],[249,86,0],[249,91,0],[249,96,0],[250,101,0],[250,106,0],[250,111,0],[250,116,0],[250,121,0],[251,126,0],[251,131,0],[251,136,0],[251,141,0],[252,146,0],[252,151,0],[252,156,0],[252,156,0],[251,159,0],[250,162,0],[249,165,0],[248,168,0],[247,171,0],[246,174,0],[245,177,0],[245,179,0],[244,182,0],[243,185,0],[242,188,0],[241,191,0],[240,194,0],[239,197,0],[238,200,0],[237,203,0],[236,206,0],[235,209,0],[234,212,0],[233,215,0],[232,218,0],[231,221,0],[230,224,0],[230,226,0],[229,229,0],[228,232,0],[227,235,0],[226,238,0],[225,241,0],[224,244,0],[223,247,0],[165,247,0],[163,244,0],[161,240,0],[158,237,0],[156,233,1],[154,230,1],[152,227,1],[149,223,1],[147,220,1],[145,216,1],[143,213,1],[140,210,2],[138,206,2],[136,203,2],[134,200,2],[132,196,2],[129,193,2],[127,189,2],[125,186,3],[123,183,3],[120,179,3],[118,176,3],[116,172,3],[114,169,3],[111,166,3],[109,162,4],[107,159,4],[105,155,4],[103,152,4],[100,149,4],[98,145,4],[96,142,4],[94,138,5],[91,135,5],[89,132,5],[87,128,5],[85,125,5],[82,121,5],[80,118,5],[78,115,6],[76,111,6],[73,108,6],[71,105,6],[69,101,6],[67,98,6],[65,94,6],[62,91,7],[60,88,7],[58,84,7],[56,81,7],[53,77,7],[51,74,7],[49,71,7],[47,67,8],[44,64,8],[42,60,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8]],yr=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[245,20,0],[245,24,0],[245,29,0],[245,31,0],[247,33,0],[247,33,0],[247,37,0],[247,41,0],[247,41,0],[247,41,0],[247,45,0],[247,45,0],[247,47,0],[247,49,0],[247,49,0],[247,54,0],[247,54,0],[247,56,0],[247,58,0],[247,58,0],[250,62,0],[250,62,0],[250,62,0],[250,67,0],[250,67,0],[250,67,0],[250,69,0],[250,71,0],[250,71,0],[250,75,0],[250,75,0],[250,78,0],[250,79,0],[250,79,0],[250,79,0],[250,81,0],[250,83,0],[250,83,0],[250,87,0],[250,87,0],[250,90,0],[250,92,0],[252,93,0],[252,93,0],[252,97,0],[252,97,0],[252,97,0],[252,97,0],[252,101,0],[252,101,0],[252,101,0],[252,101,0],[252,105,0],[252,105,0],[252,107,0],[252,109,0],[252,109,0],[252,113,13],[255,118,20],[255,119,23],[255,121,25],[255,126,33],[255,132,38],[255,133,40],[255,135,43],[255,141,48],[255,144,54],[255,150,59],[255,152,61],[255,153,64],[255,159,69],[255,163,77],[255,165,79],[255,168,82],[255,174,87],[255,176,92],[255,181,97],[255,183,99],[255,186,102],[255,191,107],[255,197,115],[255,201,120],[255,203,123],[255,205,125],[255,209,130],[255,214,138],[255,216,141],[255,218,143],[255,224,150],[255,228,156],[255,234,163],[255,236,165],[255,238,168],[255,243,173],[255,248,181],[255,252,186],[253,252,186],[250,252,187],[244,250,180],[238,247,176],[234,246,173],[231,245,169],[223,240,163],[217,237,157],[211,235,150],[205,233,146],[200,230,142],[195,227,136],[189,224,132],[184,222,126],[180,220,123],[174,217,119],[169,214,114],[163,212,108],[160,210,105],[154,207,101],[148,204,96],[143,201,93],[138,199,88],[134,197,84],[130,194,81],[126,191,77],[117,189,70],[115,186,68],[112,184,64],[106,181,60],[100,179,55],[94,176,49],[92,174,47],[90,173,45],[81,168,37],[75,166,33],[71,163,28],[66,160,24],[62,158,21],[56,156,14],[51,153,0],[51,153,0],[51,153,0],[50,150,0],[50,150,0],[50,150,0],[50,150,0],[49,148,0],[49,148,0],[49,148,0],[48,145,0],[48,145,0],[48,145,0],[48,145,0],[48,143,0],[48,143,0],[48,143,0],[48,143,0],[47,140,0],[47,140,0],[47,140,0],[47,140,0],[46,138,0],[46,138,0],[46,138,0],[46,138,0],[45,135,0],[45,135,0],[45,135,0],[45,135,0],[44,133,0],[44,133,0],[44,133,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[42,128,0],[42,128,0],[42,128,0],[42,125,0],[42,125,0],[42,125,0],[42,125,0],[41,122,0],[41,122,0],[41,122,0],[41,122,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[39,117,0],[39,117,0],[39,117,0],[39,117,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0]];function Ue(e,t){const n=[],s=[];for(let i=0;i<e.length-1;i++)n.push({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:e[i].slice(1),toColor:e[i+1].slice(1)}),s.push(e[i+1][0]-e[i][0]);return(0,lt.iv)({type:"multipart",colorRamps:n},{numColors:e[e.length-1][0],weights:t=t??s})}let bt=class extends R{constructor(){super(...arguments),this.functionName="Colormap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const e=this.sourceRasterInfos[0];if(e.bandCount>1)return{success:!1,supportsGPU:!1,error:"colormap-function: source data must be single band"};let{colormap:t,colormapName:n,colorRamp:s,colorRampName:o}=this.functionArguments;if(!t?.length)if(s)this.colorRamp=s,t=(0,lt.R8)(s,{interpolateAlpha:!0});else if(o){const r=(0,lt.M5)(o);r&&(t=(0,lt.R8)(r),this.colorRamp=(0,Ge.r)(r))}else n&&(t=function br(e){let t;switch(e){case"elevation":t=function xr(){return Ue([[0,0,191,191],[51,0,0,255],[102,255,0,255],[153,255,0,127],[204,191,63,127],[256,20,20,20]])}();break;case"gray":t=function _r(){return(0,lt.iv)({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:[0,0,0],toColor:[255,255,255]})}();break;case"hillshade":t=function wr(){return Ue([[0,38,41,54],[69,79,82,90],[131,156,156,156],[256,253,253,241]],[.268,.238,.495])}();break;case"ndvi":t=fr;break;case"ndvi2":t=function Ar(){const e=Ue([[0,255,255,255],[70,0,255,0],[80,205,173,193],[100,150,150,150],[110,120,51,100],[130,120,100,200],[140,28,3,144],[160,6,0,55],[180,10,25,30],[201,6,7,27]]);for(let t=e.length;t<256;t++)e.push([6,27,7]);return e}();break;case"ndvi3":t=yr;break;case"random":t=function vr(){const e=[];for(let t=0;t<256;t++){const n=[];for(let s=0;s<3;s++)n.push(Math.round(255*Math.random()));e.push(n)}return e}()}return t?(t=t.map((n,s)=>[s,...n]),t):null}(n));if(!t?.length)return{success:!1,supportsGPU:!1,error:"colormap-function: missing colormap argument"};const i=this._getOutputPixelType(e.pixelType);this.outputPixelType=i.startsWith("f")?"s32":i;const a=e.clone();return a.pixelType=this.outputPixelType,a.colormap=t,a.bandCount=1,this.rasterInfo=a,{success:!0,supportsGPU:!0}}_processPixels(e){let t=e.pixelBlocks?.[0];return!t||(0,Z.zw)(t.pixelType)||(t=t.clone(),t.clamp(this.outputPixelType)),t}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],bt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:gr,json:{write:!0,name:"rasterFunctionArguments"}})],bt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],bt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)()],bt.prototype,"isNoopProcess",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],bt.prototype,"indexedColormap",void 0),(0,l._)([(0,p.MZ)()],bt.prototype,"colorRamp",void 0),bt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ColormapFunction")],bt);const Fr=bt;var Ee,ze=I(855);let Oe=Ee=class extends V{clone(){return new Ee({raster:this.raster})}};Oe=Ee=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ColormapToRGBFunctionArguments")],Oe);const Mr=Oe;var Sn=I(78290);let Dt=class extends R{constructor(){super(...arguments),this.functionName="ColormapToRGB",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const e=this.sourceRasterInfos[0];if(e.bandCount>1||!e.colormap?.length)return{success:!1,supportsGPU:!1,error:"colormap-to-rgb-function: source data must be single band with a colormap"};const t=e.clone();t.pixelType=this.outputPixelType=this._getOutputPixelType("u8"),this._removeStatsHistColormapVAT(t),t.bandCount=3,t.statistics=[{min:0,max:255,avg:100,stddev:20},{min:0,max:255,avg:100,stddev:20},{min:0,max:255,avg:100,stddev:20}],this.rasterInfo=t;const n=[...e.colormap].sort((i,a)=>i[0]-a[0]),{indexedColormap:s,offset:o}=(0,$.zg)({colormap:n});return s?(this.lookup={indexedColormap:s,offset:o},{success:!0,supportsGPU:(0,Sn.WN)(s)}):{success:!1,supportsGPU:!1,error:"colormap-to-rgb-function: the colormap is not supported"}}_processPixels(e){let t=e.pixelBlocks?.[0];if(!t||!this.lookup)return t;t=t.clone();const n=t.pixels[0],s=t.mask??new Uint8Array(n.length).fill(255),o=new Uint8Array(n.length),i=new Uint8Array(n.length),a=new Uint8Array(n.length),{indexedColormap:r,offset:u}=this.lookup,c=r.length;for(let m=0;m<n.length;m++)if(s[m]){let h=4*(n[m]-u);h<0||h>c-4?s[m]=0:(o[m]=r[h++],i[m]=r[h++],a[m]=r[h++])}return t.pixels=[o,i,a],t.statistics=[new ze.z(0,255),new ze.z(0,255),new ze.z(0,255)],t.pixelType=this.outputPixelType,t}_getWebGLParameters(){return this.lookup}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Dt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Mr,json:{write:!0,name:"rasterFunctionArguments"}})],Dt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Dt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Dt.prototype,"lookup",void 0),Dt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ColormapToRGBFunction")],Dt);const Tr=Dt;var Ve,Te=I(50305);let fe=Ve=class extends V{constructor(){super(...arguments),this.rasters=[]}writeRasters(e,t){t.rasters=e.map(n=>"number"==typeof n||"string"==typeof n?n:n.toJSON())}clone(){return new Ve({rasters:(0,at.o8)(this.rasters)})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],fe.prototype,"rasters",void 0),(0,l._)([(0,Te.K)("rasters")],fe.prototype,"writeRasters",null),fe=Ve=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")],fe);const Pr=fe;let se=class extends R{constructor(){super(...arguments),this.functionName="CompositeBand",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:e}=this,t=e[0];this.outputPixelType=this._getOutputPixelType(t.pixelType);const n=t.clone();if(n.attributeTable=null,n.colormap=null,n.pixelType=this.outputPixelType,n.bandCount=e.map(({bandCount:o})=>o).reduce((o,i)=>o+i),e.every(({statistics:o})=>null!=o&&o.length)){const o=[];e.forEach(({statistics:i})=>null!=i&&o.push(...i)),n.statistics=o}if(e.every(({histograms:o})=>null!=o&&o.length)){const o=[];e.forEach(({histograms:i})=>null!=i&&o.push(...i)),n.histograms=o}n.multidimensionalInfo&&n.multidimensionalInfo.variables.forEach(o=>{const i=e.map(u=>u.multidimensionalInfo?.variables.find(({name:c})=>c===o.name)),a=i.map(u=>u?.statistics?.length?u.statistics:null),r=i.map(u=>u?.histograms?.length?u.histograms:null);o.statistics=a.every(u=>null!=u)?a.flat():null,o.histograms=r.every(u=>null!=u)?r.flat():null}),n.bandCount>1&&(n.colormap=null,n.attributeTable=null);const s=e.every(o=>o.keyProperties.BandProperties?.length)?e.flatMap(o=>o.keyProperties.BandProperties):void 0;return n.keyProperties={...n.keyProperties,BandProperties:s},this.rasterInfo=n,{success:!0,supportsGPU:n.bandCount<=3}}_processPixels(e){const{pixelBlocks:t}=e;return t?null==t?.[0]?null:(0,$.Wy)(t):null}_getWebGLParameters(){return{bandCount:this.rasterInfo.bandCount}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],se.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Pr,json:{write:!0,name:"rasterFunctionArguments"}})],se.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],se.prototype,"rasterArgumentNames",void 0),se=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.CompositeBandFunction")],se);const Ir=se;var Tt=I(29141);const Rr=new _t.J({0:"difference",1:"relative-difference",2:"categorical",3:"euclidean-distance",4:"angle-difference",5:"band-with-most-change"},{useNumericKeys:!0}),Nr=new _t.J({0:"all",1:"changed",2:"unchanged"},{useNumericKeys:!0});var Le;let jt=Le=class extends V{constructor(){super(...arguments),this.method="difference",this.keepMethod="all",this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new Le({raster:this.raster,raster2:this.raster2,method:this.method,keepMethod:this.keepMethod})}};(0,l._)([(0,At.e)(Rr)],jt.prototype,"method",void 0),(0,l._)([(0,At.e)(Nr)],jt.prototype,"keepMethod",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],jt.prototype,"raster2",void 0),(0,l._)([(0,p.MZ)({readOnly:!0})],jt.prototype,"rasters",null),jt=Le=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ComputeChangeFunctionArguments")],jt);const Gr=jt;let Gt=class extends R{constructor(){super(...arguments),this.functionName="ComputeChange",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{method:e}=this.functionArguments,t=this.sourceRasterInfos[0].clone();if(this.outputPixelType=this._getOutputPixelType(t.pixelType),t.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(t),"categorical"===e){const n=this.sourceRasterInfos.map(i=>i.attributeTable),s=this._getFieldNames(n,"value"),o=n.map(i=>this._getClassFieldName(i));if(null==s[0]||null==s[1]||null==o[0]||null==o[1])return{success:!1,supportsGPU:!1,error:"both inputs must have proper attribute table with value and class fields"};this._updateAttributeTable(t,s,o)}return t.bandCount=1,this.rasterInfo=t,{success:!0,supportsGPU:"difference"===e||"relative-difference"===e}}_processPixels(e){const{pixelBlocks:t}=e;if(null==t?.[0]||null==t?.[1])return null;const{method:n}=this.functionArguments;return function Cr(e,t,n,s){const[o,i]=e,a=(0,Z.zw)(n)&&!(0,Z.zw)(o.pixelType)&&!(0,Z.zw)(i.pixelType),r=[o.mask,i.mask].filter(y=>y),u=g.A.combineBandMasks(r),c=e.map(y=>y.pixels[0]),{width:m,height:h}=o,d=g.A.createEmptyBand(n,m*h);switch(t){case"difference":case"relative-difference":!function Br(e){const{bands:[t,n],mask:s,isRelative:o,isRoundingNeeded:i,outBand:a}=e,r=t.length;for(let u=0;u<r;u++)if(!s||s[u]){let c=t[u]-n[u];if(o){const m=Math.max(Math.abs(t[u])-Math.abs(n[u]));c=m>0?c/m:0}a[u]=i?Math.round(c):c}}({bands:c,mask:u,outBand:d,isRoundingNeeded:a,isRelative:"relative-difference"===t});break;case"categorical":!function kr(e){const{bands:[t,n],categoryIndexLookups:[s,o],classNames:[i,a],mask:r,keepMethod:u,outBand:c}=e,m=t.length,d=a.length,f=i.length*d,y=f+1,A=f+2;for(let x=0;x<m;x++)if(!r||r[x]){const w=s[t[x]],M=o[n[x]],k=i[w],N=a[M];c[x]=null==w||null==M?f:"changed"===u&&k===N?y:"unchanged"===u&&k!==N?A:w*d+M}}({bands:c,mask:u,outBand:d,...s});break;case"euclidean-distance":!function Sr(e){const{pixels:[t,n],mask:s,outBand:o}=e,i=t[0].length,a=t.length;for(let r=0;r<i;r++)if(!s||s[r]){let u=0;for(let c=0;c<a;c++){const m=t[c][r]-n[c][r];u+=m*m}o[r]=Math.sqrt(u)}}({pixels:e.map(y=>y.pixels),mask:u,outBand:d});break;case"angle-difference":!function Dr(e){const{pixels:[t,n],mask:s,outBand:o}=e,i=t[0].length,a=t.length;for(let r=0;r<i;r++)if(!s||s[r]){let u=0,c=0,m=0;for(let d=0;d<a;d++){const f=t[d][r],y=n[d][r];u+=f*y,c+=f*f,m+=y*y}const h=Math.sqrt(c*m);o[r]=h?Math.acos(u/h):1.5707963267948966}}({pixels:e.map(y=>y.pixels),mask:u,outBand:d});break;case"band-with-most-change":!function jr(e){const{pixels:[t,n],mask:s,outBand:o}=e,i=t[0].length,a=t.length;for(let r=0;r<i;r++)if(!s||s[r]){let u=0,c=0;for(let m=0;m<a;m++){const h=Math.abs(t[m][r]-n[m][r]);h>u&&(u=h,c=m)}o[r]=c}}({pixels:e.map(y=>y.pixels),mask:u,outBand:d})}const f=new g.A({width:m,height:h,pixels:[d],pixelType:n,mask:u});return f.updateStatistics(),f}(t,n,this.outputPixelType,this._categoryConfig)}_getWebGLParameters(){const e=this.outputPixelType??"f32";let[t,n]=(0,Z.hP)(e);const s=(0,Z.zw)(e);return s&&(t-=1e-4,n+=1e-4),{method:this.functionArguments.method,domainRange:[t,n],isOutputRounded:s}}_updateAttributeTable(e,t,n){const s=this.sourceRasterInfos.map(w=>w.attributeTable),o=s.map((w,M)=>w.features.map(k=>k.attributes[t[M]])),i=s.map((w,M)=>w.features.map(k=>k.attributes[n[M]])),a=o.map(w=>{const M=[];return w.forEach((k,N)=>M[k]=N),M}),{keepMethod:r}=this.functionArguments;this._categoryConfig={categoryIndexLookups:a,classNames:i,keepMethod:r};const u=s[0].clone();u.fields=[new Tt.A({name:"OID",type:"oid"}),new Tt.A({name:"Value",type:"integer"}),new Tt.A({name:"ClassName",type:"string"}),new Tt.A({name:"Class_From",type:"string"}),new Tt.A({name:"Class_To",type:"string"})];const c=this._getFieldNames(s,"red"),m=this._getFieldNames(s,"green"),h=this._getFieldNames(s,"blue"),d=[],f=2===c.length&&2===m.length&&2===h.length;f&&(d.push(...s.map((w,M)=>w.features.map(k=>[k.attributes[c[M]],k.attributes[m[M]],k.attributes[h[M]]]))),u.fields.push(new Tt.A({name:"Red",type:"integer"}),new Tt.A({name:"Green",type:"integer"}),new Tt.A({name:"Blue",type:"integer"})));const y=u.features[0].clone();y.geometry=null;const A=[],[x,v]=o.map(w=>w.length);let _=1;for(let w=0;w<x;w++){const M=i[0][w];for(let k=0;k<v;k++){const N=i[1][k];if("changed"===r&&M===N||"unchanged"===r&&M!==N)continue;const S=y.clone();S.attributes={OID:_++,Value:w*v+k,ClassName:M===N?M:`${M} -> ${N}`,Class_From:M,Class_To:N},f&&(S.attributes.Red=d[0][w][0]+d[1][k][0]>>1,S.attributes.Green=d[0][w][1]+d[1][k][1]>>1,S.attributes.Blue=d[0][w][2]+d[1][k][2]>>1),A.push(S)}}if("changed"===r){const w=y.clone();w.attributes={OID:_++,Value:x*v+1,ClassName:"No Change",Class_From:"Same",Class_To:"Same"},A.push(w)}else if("unchanged"===r){const w=y.clone();w.attributes={OID:_++,Value:x*v+2,ClassName:"Changed",Class_From:"Any",Class_To:"Any"},A.push(w)}u.features=A,e.attributeTable=u}_getFieldNames(e,t){return e.map(({fields:n})=>n.find(s=>s.name.toLowerCase()===t)?.name).filter(n=>n)}_getClassFieldName(e){return(e.fields.find(n=>"string"===n.type&&n.name.toLowerCase().startsWith("class"))??e.fields.find(n=>"string"===n.type&&n.name.toLowerCase().includes("class")||n.name.toLowerCase().includes("type")||n.name.toLowerCase().includes("name"))??e.fields.find(n=>"string"===n.type))?.name}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Gt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Gr,json:{write:!0,name:"rasterFunctionArguments"}})],Gt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Gt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Gt.prototype,"_categoryConfig",void 0),Gt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ComputeChangeFunction")],Gt);const Zr=Gt;var We;let ye=We=class extends V{constructor(){super(...arguments),this.contrastOffset=0,this.brightnessOffset=0}clone(){return new We({contrastOffset:this.contrastOffset,brightnessOffset:this.brightnessOffset,raster:this.raster})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],ye.prototype,"contrastOffset",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],ye.prototype,"brightnessOffset",void 0),ye=We=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ContrastBrightnessFunctionArguments")],ye);const Ur=ye;var Zt=I(48104);let Ut=class extends R{constructor(){super(...arguments),this.functionName="ContrastBrightness",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const{sourceRasterInfos:e}=this,t=e[0];if("u8"!==t.pixelType)return{success:!1,supportsGPU:!1,error:"Only unsigned 8 bit raster is supported by ContrastBrightness function."};this.outputPixelType=this._getOutputPixelType("u8");const n=t.clone();this._removeStatsHistColormapVAT(n),this.rasterInfo=n;const{contrastOffset:s,brightnessOffset:o}=this.functionArguments;return this.lookup=(0,Zt.zj)(s,o),{success:!0,supportsGPU:!0}}_processPixels(e){const t=e.pixelBlocks?.[0];return null==t?null:(0,$.eH)(t,{lut:t.pixels.map(()=>this.lookup),offset:0,outputPixelType:"u8"})}_getWebGLParameters(){const{contrastOffset:e,brightnessOffset:t}=this.functionArguments;return{contrastOffset:e,brightnessOffset:t}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Ut.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Ur,json:{write:!0,name:"rasterFunctionArguments"}})],Ut.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Ut.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ut.prototype,"lookup",void 0),Ut=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ContrastBrightnessFunction")],Ut);const zr=Ut;function He(e,t,n,s,o){const i=Math.floor(s/2);for(let r=0;r<i;r++)for(let u=0;u<t;u++)e[r*t+u]=e[(o-1-r)*t+u],e[(n-1-r)*t+u]=e[(n-o+r)*t+u];const a=Math.floor(o/2);for(let r=0;r<n;r++){const u=r*t;for(let c=0;c<a;c++)e[u+c]=e[u+o-1-c],e[u+t-c-1]=e[u+t+c-o]}}const K=new Map;function Dn(e,t,n,s,o,i,a){const r=new Float32Array(t*n),u=i.length,c=a?0:s,m=a?s:0,h=a?1:t;for(let d=c;d<n-c;d++){const f=d*t;for(let y=m;y<t-m;y++){if(o&&!o[f+y])continue;let A=0;for(let x=0;x<u;x++)A+=e[f+y+(x-s)*h]*i[x];r[f+y]=A}}return r}function Or(e,t,n,s,o,i,a){const r=new Float32Array(t*n),u=Math.floor(s/2),c=Math.floor(o/2);for(let m=u;m<n-u;m++){const h=m*t;for(let d=c;d<t-c;d++){if(i&&!i[h+d])continue;let f=0;for(let y=0;y<s;y++)for(let A=0;A<o;A++)f+=e[h+d+(y-u)*t+A-c]*a[y*o+A];r[h+d]=f}}return r}var $e;K.set(T.none,[0,0,0,0,1,0,0,0,0]),K.set(T.lineDetectionHorizontal,[-1,-1,-1,2,2,2,-1,-1,-1]),K.set(T.lineDetectionVertical,[-1,2,-1,-1,2,-1,-1,2,-1]),K.set(T.lineDetectionLeftDiagonal,[2,-1,-1,-1,2,-1,-1,-1,2]),K.set(T.lineDetectionRightDiagonal,[-1,-1,2,-1,2,-1,2,-1,-1]),K.set(T.gradientNorth,[-1,-2,-1,0,0,0,1,2,1]),K.set(T.gradientWest,[-1,0,1,-2,0,2,-1,0,1]),K.set(T.gradientEast,[1,0,-1,2,0,-2,1,0,-1]),K.set(T.gradientSouth,[1,2,1,0,0,0,-1,-2,-1]),K.set(T.gradientNorthEast,[0,-1,-2,1,0,-1,2,1,0]),K.set(T.gradientNorthWest,[-2,-1,0,-1,0,1,0,1,2]),K.set(T.smoothArithmeticMean,[.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111]),K.set(T.smoothing3x3,[.0625,.125,.0625,.125,.25,.125,.0625,.125,.0625]),K.set(T.smoothing5x5,[1,1,1,1,1,1,4,4,4,1,1,4,12,4,1,1,4,4,4,1,1,1,1,1,1]),K.set(T.sharpening3x3,[-1,-1,-1,-1,9,-1,-1,-1,-1]),K.set(T.sharpening5x5,[-1,-3,-4,-3,-1,-3,0,6,0,-3,-4,6,21,6,-4,-3,0,6,0,-3,-1,-3,-4,-3,-1]),K.set(T.laplacian3x3,[0,-1,0,-1,4,-1,0,-1,0]),K.set(T.laplacian5x5,[0,0,-1,0,0,0,-1,-2,-1,0,-1,-2,17,-2,-1,0,-1,-2,-1,0,0,0,-1,0,0]),K.set(T.sobelHorizontal,[-1,-2,-1,0,0,0,1,2,1]),K.set(T.sobelVertical,[-1,0,1,-2,0,2,-1,0,1]),K.set(T.sharpen,[0,-.25,0,-.25,2,-.25,0,-.25,0]),K.set(T.sharpen2,[-.25,-.25,-.25,-.25,3,-.25,-.25,-.25,-.25]),K.set(T.pointSpread,[-.627,.352,-.627,.352,2.923,.352,-.627,.352,-.627]);let zt=$e=class extends V{constructor(){super(...arguments),this.rows=3,this.cols=3,this.kernel=[0,0,0,0,1,0,0,0,0]}set convolutionType(e){this._set("convolutionType",e);const t=K.get(e);if(!t||e===T.userDefined||e===T.none)return;const n=Math.sqrt(t.length);this._set("kernel",t),this._set("cols",n),this._set("rows",n)}clone(){return new $e({cols:this.cols,rows:this.rows,kernel:[...this.kernel],convolutionType:this.convolutionType,raster:(0,at.o8)(this.raster)})}};(0,l._)([(0,p.MZ)({json:{type:Number,write:!0}})],zt.prototype,"rows",void 0),(0,l._)([(0,p.MZ)({json:{type:Number,write:!0}})],zt.prototype,"cols",void 0),(0,l._)([(0,p.MZ)({json:{name:"type",type:Number,write:!0}})],zt.prototype,"convolutionType",null),(0,l._)([(0,p.MZ)({json:{type:[Number],write:!0}})],zt.prototype,"kernel",void 0),zt=$e=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")],zt);const Hr=zt;let Et=class extends R{constructor(){super(...arguments),this.functionName="Convolution",this.rasterArgumentNames=["raster"]}get _normalizedKernel(){const{kernel:e,convolutionType:t}=this.functionArguments,n=e.reduce((s,o)=>s+o);return-1===t||0===n||1===n?e:e.map(s=>s/n)}_bindSourceRasters(){const{convolutionType:e,rows:t,cols:n,kernel:s}=this.functionArguments;if(!Object.values(T).includes(e))return{success:!1,supportsGPU:!1,error:`convolution-function: the specified kernel type is not supported ${e}`};if(e!==T.none&&t*n!==s.length)return{success:!1,supportsGPU:!1,error:"convolution-function: the specified rows and cols do not match the length of the kernel"};const o=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(o.pixelType);const i=o.clone();return i.pixelType=this.outputPixelType,(-1===e||"u8"!==this.outputPixelType&&![T.none,T.sharpen,T.sharpen2,T.sharpening3x3,T.sharpening5x5].includes(e))&&(i.statistics=null,i.histograms=null),i.colormap=null,i.attributeTable=null,this.rasterInfo=i,{success:!0,supportsGPU:s.length<=25}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t||this.functionArguments.convolutionType===T.none)return t;const{rows:n,cols:s}=this.functionArguments,{_normalizedKernel:o}=this;return function Wr(e,t){const n=function Er(e){const t=Math.sqrt(e.length),n=e.slice(0,t),s=[1];for(let o=1;o<t;o++){let i=null;for(let a=0;a<t;a++){const r=e[a+o*t],u=e[a];if(null==i)if(0===u){if(r)return{separable:!1,row:null,col:null}}else i=r/u;else if(r/u!==i)return{separable:!1,row:null,col:null}}if(null==i)return{separable:!1,row:null,col:null};s.push(i)}return{separable:!0,row:n,col:s}}(t.kernel),s=!1!==t.mirrorEdges,o=n.separable?function Lr(e,t,n,s=!0){const{pixels:o,width:i,height:a,pixelType:r,mask:u}=e,c=o.length,m=[],h=t.length,d=n.length,f=Math.floor(h/2),y=Math.floor(d/2);for(let A=0;A<c;A++){let x=Dn(o[A],i,a,f,u,t,!0);x=Dn(x,i,a,y,u,n,!1),s&&He(x,i,a,h,d),m.push(x)}return new g.A({width:i,height:a,pixelType:r,pixels:m,mask:u})}(e,n.row,n.col,s):function Vr(e,t,n=!0){const{pixels:s,width:o,height:i,pixelType:a,mask:r}=e,u=s.length,c=[],{kernel:m,rows:h,cols:d}=t;for(let f=0;f<u;f++){const y=Or(s[f],o,i,h,d,r,m);n&&He(y,o,i,h,d),c.push(y)}return new g.A({width:o,height:i,pixelType:a,pixels:c,mask:r})}(e,t,s),{outputPixelType:i}=t;return i&&o.clamp(i),o}(t,{kernel:o,rows:n,cols:s,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const e=new Float32Array(25);return e.set(this._normalizedKernel),{kernelRows:this.functionArguments.rows,kernelCols:this.functionArguments.cols,kernel:e,clampRange:(0,Z.hP)(this.outputPixelType)}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Et.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Hr,json:{write:!0,name:"rasterFunctionArguments"}})],Et.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Et.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)()],Et.prototype,"_normalizedKernel",null),Et=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ConvolutionFunction")],Et);const $r=Et;var Je;const Gn=new _t.J({0:"standard",1:"planform",2:"profile"},{useNumericKeys:!0});let re=Je=class extends V{constructor(){super(...arguments),this.curvatureType="standard",this.zFactor=1}readCurvatureType(e,t){return Gn.fromJSON(t.type??t.curvatureType??0)}clone(){return new Je({curvatureType:this.curvatureType,zFactor:this.zFactor,raster:this.raster})}};(0,l._)([(0,p.MZ)({json:{write:{target:"type"}}}),(0,At.e)(Gn)],re.prototype,"curvatureType",void 0),(0,l._)([(0,ge.w)("curvatureType",["type","curvatureType"])],re.prototype,"readCurvatureType",null),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0}})],re.prototype,"zFactor",void 0),re=Je=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.CurvatureFunctionArguments")],re);const Jr=re;let Ot=class extends R{constructor(){super(...arguments),this.functionName="Curvature",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const e=this.sourceRasterInfos[0].clone();return e.pixelType=this.outputPixelType,e.bandCount=1,this._removeStatsHistColormapVAT(e),this.rasterInfo=e,this.isGCS=e.spatialReference?.isGeographic??!1,{success:!0,supportsGPU:!0}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return null;const{zFactor:n,curvatureType:s}=this.functionArguments,{extent:o,primaryPixelSizes:i}=e,a=i?.[0];return(0,ot.E0)(t,{zFactor:this.isGCS&&n>=1?n*ot.rk:n,curvatureType:s,resolution:a??(o?{x:o.width/t.width,y:o.height/t.height}:{x:1,y:1})})}_getWebGLParameters(){const{zFactor:e,curvatureType:t}=this.functionArguments;return{curvatureType:t,zFactor:this.isGCS&&e>=1?e*ot.rk:e}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Ot.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Jr,json:{write:!0,name:"rasterFunctionArguments"}})],Ot.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Ot.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ot.prototype,"isGCS",void 0),Ot=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.CurvatureFunction")],Ot);const Kr=Ot;var Ke;let Ft=Ke=class extends V{constructor(){super(...arguments),this.bandIds=[],this.bandNames=[],this.bandWavelengths=[],this.missingBandAction=$.Wb.bestMatch}clone(){return new Ke({bandIds:this.bandIds?.slice(),bandNames:this.bandNames?.slice(),bandWavelengths:this.bandWavelengths?.slice(),missingBandAction:this.missingBandAction,method:this.method,wavelengthMatchTolerance:this.wavelengthMatchTolerance})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],Ft.prototype,"bandIds",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ft.prototype,"bandNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ft.prototype,"bandWavelengths",void 0),(0,l._)([(0,At.e)({0:"name",1:"wavelength",2:"id"})],Ft.prototype,"method",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ft.prototype,"missingBandAction",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ft.prototype,"wavelengthMatchTolerance",void 0),Ft=Ke=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")],Ft);const Xr=Ft;let oe=class extends R{constructor(){super(...arguments),this.functionName="ExtractBand",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{functionArguments:e,sourceRasterInfos:t}=this,n=t[0],{method:s,bandNames:o,bandWavelengths:i,bandIds:a,missingBandAction:r}=e,u=o?.length&&("name"===s||"id"!==s&&!a?.length),c=i?.length&&("wavelength"===s||"id"!==s&&!a?.length),m=r===$.Wb.fail,h=u?function Qr(e,t){const n=e.bandInfos.map(({name:o})=>o.toLowerCase()),s=[];for(let o=0;o<t.length;o++){const i=t[o].toLowerCase();let a=n.indexOf(i);if(-1===a&&"nearinfrared"===i&&(a=n.findIndex(r=>r.startsWith("nearinfrared_1")),-1===a&&(a=n.findIndex(r=>r.startsWith("nearinfrared")))),-1===a)return null;s.push(a)}return s}(n,o):c?function to(e,t,{wavelengthMatchTolerance:n},s){const{bandInfos:o}=e,i=[];for(let r=0;r<o.length;r++){const{minWavelength:u,maxWavelength:c}=o[r];if(!u||!c)return null;i.push({minWavelength:u,maxWavelength:c})}const a=[];for(let r=0;r<t.length;r++){const u=t[r];let c=!1,m=-1,h=Number.MAX_VALUE;for(let d=0;d<i.length;d++){const f=i[d],y=u>=f.minWavelength&&u<=f.maxWavelength,A=Math.abs(u-(f.minWavelength+f.maxWavelength)/2);y?A<h&&(c=!0,m=d,h=A):!c&&A<h&&(m=d,h=A)}if(!c&&n&&h<n&&(c=!0),!c&&s)return null;a.push(m)}return a}(n,i,this.functionArguments,m):function qr(e,t,n){const{bandCount:s}=e;return!t?.length||n&&t.some(o=>o<0||o>=s)?null:t}(n,a,m);if(null==h)return{success:!1,supportsGPU:!1,error:`extract-band-function: Invalid ${u?"band names":c?"band wavelengths":"band ids"} for the imagery data source`};this.functionArguments.bandIds=h,this.functionArguments.method="id",this.outputPixelType=this._getOutputPixelType("f32");const d=n.clone();d.pixelType=this.outputPixelType,d.bandCount=h.length;const{statistics:f,histograms:y}=d;null!=f&&f.length&&(d.statistics=h.map(x=>f[x]||f[f.length-1])),null!=y&&y.length&&(d.histograms=h.map(x=>y[x]||y[y.length-1])),d.multidimensionalInfo&&d.multidimensionalInfo.variables.forEach(x=>{const{statistics:v,histograms:_}=x;null!=v&&v.length&&(x.statistics=h.map(w=>v[w]||v[v.length-1])),null!=_&&_.length&&(x.histograms=h.map(w=>_[w]||_[_.length-1]))});let A=d.keyProperties?.BandProperties;return A?.length&&(A=h.map(x=>x>=A.length?A[A.length-1]:A[x]),d.keyProperties={...d.keyProperties,BandProperties:A}),this.rasterInfo=d,{success:!0,supportsGPU:d.bandCount<=3}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return null;const n=t.pixels.length,s=this.functionArguments.bandIds.map(o=>o>=n?n-1:o);return t.extractBands(s)}_getWebGLParameters(){let e;if(this.isInputBandIdsSwizzled)e=this.swizzledBandSelection.length?this.swizzledBandSelection:[0,1,2];else{e=[...this.functionArguments.bandIds],0===e.length?e=[0,1,2]:e.length<3&&(e[1]=e[1]??e[0],e[2]=e[2]??e[1]);for(let t=0;t<3;t++)e[t]=Math.min(e[t],2)}return{bandIndexMat3:nt(e)}}_getInputBandIds(e){const t=e.length;return this.functionArguments.bandIds.map(n=>n>=t?t-1:n).map(n=>e[n])}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],oe.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Xr,json:{write:!0,name:"rasterFunctionArguments"}})],oe.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],oe.prototype,"rasterArgumentNames",void 0),oe=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ExtractBandFunction")],oe);const Yr=oe;var Xe;let Pe=Xe=class extends V{clone(){return new Xe({conversionParameters:[...this.conversionParameters],raster:this.raster})}};(0,l._)([(0,p.MZ)({type:[Number],json:{write:!0}})],Pe.prototype,"conversionParameters",void 0),Pe=Xe=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.GrayscaleFunctionArguments")],Pe);const no=Pe;let Vt=class extends R{constructor(){super(...arguments),this.functionName="Grayscale",this.functionArguments=null,this.rasterArgumentNames=["raster"]}get _normalizedWeights(){const{conversionParameters:e}=this.functionArguments,t=e.reduce((n,s)=>n+s);return e.map(n=>n/t)}_bindSourceRasters(){const{conversionParameters:e}=this.functionArguments;if(!e?.length)return{success:!1,supportsGPU:!1,error:"missing valid conversion parameters."};const t=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(t.pixelType),t.pixelType=this.outputPixelType;const n=3===e.length||3===t.bandCount&&e.length>3;return t.bandCount=1,this._removeStatsHistColormapVAT(t),this.rasterInfo=t,{success:!0,supportsGPU:n}}_processPixels(e){const t=e.pixelBlocks?.[0];return null==t?null:function eo(e,t,n){const{pixels:s,width:o,height:i,mask:a,bandMasks:r}=e,u=o*i,c=r?.length?g.A.combineBandMasks(r):a,m=Math.min(t.length,s.length),h=n.startsWith("f"),d=!h&&n!==e.pixelType,[f,y]=(0,Z.hP)(n),A=g.A.createEmptyBand(n,u);for(let v=0;v<i;v++){let _=v*o;for(let w=0;w<o;w++,_++)if(!c||c[_]){let M=0;for(let k=0;k<m;k++)M+=t[k]*s[k][_];h||(M=Math.round(M),d&&(M=M>y?y:M<f?f:M)),A[_]=M}}const x=new g.A({width:o,height:i,pixels:[A],pixelType:n,mask:c});return x.updateStatistics(),x}(t,this._normalizedWeights,this.outputPixelType)}_getWebGLParameters(){return{weights:this._normalizedWeights}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Vt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:no,json:{write:!0,name:"rasterFunctionArguments"}})],Vt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Vt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)()],Vt.prototype,"_normalizedWeights",null),Vt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.GrayscaleFunction")],Vt);const so=Vt;var Ye;const ro=new _t.J({0:"traditional",1:"multi-directional"},{useNumericKeys:!0}),oo=new _t.J({1:"degree",2:"percent-rise",3:"scaled"},{useNumericKeys:!0});let xt=Ye=class extends V{constructor(){super(...arguments),this.altitude=45,this.azimuth=315,this.hillshadeType="traditional",this.pixelSizePower=.664,this.pixelSizeFactor=.024,this.slopeType="degree",this.zFactor=1,this.removeEdgeEffect=!1}clone(){return new Ye({hillshadeType:this.hillshadeType,altitude:this.altitude,azimuth:this.azimuth,zFactor:this.zFactor,slopeType:this.slopeType,pixelSizeFactor:this.pixelSizeFactor,pixelSizePower:this.pixelSizePower,removeEdgeEffect:this.removeEdgeEffect,raster:this.raster})}};(0,l._)([(0,p.MZ)({type:Number,json:{write:!0}})],xt.prototype,"altitude",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0}})],xt.prototype,"azimuth",void 0),(0,l._)([(0,p.MZ)(),(0,At.e)(ro)],xt.prototype,"hillshadeType",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0,name:"psPower"}})],xt.prototype,"pixelSizePower",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0,name:"psZFactor"}})],xt.prototype,"pixelSizeFactor",void 0),(0,l._)([(0,p.MZ)(),(0,At.e)(oo)],xt.prototype,"slopeType",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0}})],xt.prototype,"zFactor",void 0),(0,l._)([(0,p.MZ)({type:Boolean,json:{write:!0}})],xt.prototype,"removeEdgeEffect",void 0),xt=Ye=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.HillshadeFunctionArguments")],xt);const Zn=xt;let Lt=class extends R{constructor(){super(...arguments),this.functionName="Hillshade",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const e=this.sourceRasterInfos[0];if(e.bandCount>1)return{success:!1,supportsGPU:!1,error:"hillshade-function: source data must be single band"};this.outputPixelType=this._getOutputPixelType("u8");const t=e.clone();return this._removeStatsHistColormapVAT(t),t.pixelType=this.outputPixelType,t.bandCount=1,t.statistics=[{min:0,max:255,avg:60,stddev:10}],this.rasterInfo=t,this.isGCS=t.spatialReference?.isGeographic??!1,{success:!0,supportsGPU:!0}}_processPixels(e){const t=e.pixelBlocks?.[0];if(!t)return null;const{extent:n,primaryPixelSizes:s}=e,o=s?.[0],a=(0,ot.PP)(this.functionArguments,o??(n?{x:n.width/t.width,y:n.height/t.height}:{x:1,y:1}),this.isGCS),r=(0,ot.fw)(t,a);return r.pixelType=this.outputPixelType,r}_getWebGLParameters(){const e=(0,ot.PP)(this.functionArguments,{x:1,y:1},this.isGCS),t=(0,ot.ng)(e),{slopeType:n,zFactor:s,pixelSizeFactor:o,pixelSizePower:i}=this.functionArguments,a="scaled"===n,r=(0,Z.zw)(this.outputPixelType);return{...t,zFactor:s,gcsFactor:this.isGCS?ot.rk:1,pixelSizeFactor:a?o:0,pixelSizePower:a?i:0,isOutputRounded:r}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Lt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Zn,json:{write:!0,name:"rasterFunctionArguments"}})],Lt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Lt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Lt.prototype,"isGCS",void 0),Lt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.HillshadeFunction")],Lt);const io=Lt;var Qe;let Wt=Qe=class extends V{constructor(){super(...arguments),this.rasters=[],this.processAsMultiband=!0}writeRasters(e,t){t.rasters=e.map(n=>"number"==typeof n||"string"==typeof n?n:n.toJSON())}clone(){return new Qe({operation:this.operation,processAsMultiband:this.processAsMultiband,rasters:(0,at.o8)(this.rasters)})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],Wt.prototype,"operation",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Wt.prototype,"rasters",void 0),(0,l._)([(0,Te.K)("rasters")],Wt.prototype,"writeRasters",null),(0,l._)([(0,p.MZ)({json:{write:!0}})],Wt.prototype,"processAsMultiband",void 0),Wt=Qe=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.LocalFunctionArguments")],Wt);const ao=Wt;let ie=class extends R{constructor(){super(...arguments),this.functionName="Local",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:e}=this,t=e[0],{bandCount:n}=t,{processAsMultiband:s}=this.functionArguments;if(e.some(u=>u.bandCount!==n))return{success:!1,supportsGPU:!1,error:"local-function: input rasters do not have same band count"};const{operation:o,rasters:i}=this.functionArguments,a=gn[o];if(!(999===a||i.length===a||i.length<=1&&1===a))return{success:!1,supportsGPU:!1,error:`local-function: the length of functionArguments.rasters does not match operation's requirement: ${a}`};const r=t.clone();return r.bandCount=999!==a||s?n:1,this._removeStatsHistColormapVAT(r),this._updateStatistics(r),this._updatePixelType(r),this.rasterInfo=r,{success:!0,supportsGPU:1===r.bandCount&&a<=3}}_processPixels(e){const{pixelBlocks:t}=e;return null==t||t.some(n=>null==n)?null:Rn(t,this.functionArguments.operation,{processAsMultiband:this.functionArguments.processAsMultiband,outputPixelType:this.outputPixelType??void 0})}_getWebGLParameters(){const{operation:e}=this.functionArguments,t=gn[e],n=Object.keys(mt).find(r=>mt[r]===e)?.toLowerCase()??"undefined",s=this.outputPixelType??"f32";let[o,i]=(0,Z.hP)(s);const a=(0,Z.zw)(s);return a&&(o-=1e-4,i+=1e-4),{imageCount:t,operationName:n,domainRange:[o,i],isOutputRounded:a}}_updateStatistics(e){const t=this.sourceRasterInfos[0],{operation:n}=this.functionArguments,s=dn(n)?.domain;if(s){e.statistics=[];for(let o=0;o<e.bandCount;o++)e.statistics[o]={min:s[0],max:s[1],avg:(s[0]+s[1])/2,stddev:(s[0]+s[1])/10}}else 45===n&&t.statistics?.length&&(e.statistics=t.statistics.map(o=>({min:-o.max,max:-o.min,avg:null!=o.avg?-o.avg:void 0,stddev:null!=o.stddev?-o.stddev:void 0})))}_updatePixelType(e){const{statistics:t,pixelType:n}=this.sourceRasterInfos[0],{operation:s}=this.functionArguments,{domain:o,isInteger:i}=dn(s)??{domain:null,isInteger:!1};let a="f32";if(o&&i)a=(0,Z.X1)(o[0],o[1]);else if(30===s){const r=t?.[0];a=r?(0,Z.X1)(r.min,r.max):(0,Z.zw)(n)?n:"s32"}else if(45===s&&(0,Z.zw)(n)){const r=t?.map(({max:h})=>-h),u=t?.map(({min:h})=>-h),c=r?.length?Math.min(...r):null,m=u?.length?Math.min(...u):null;a=null!=c&&null!=m?(0,Z.X1)(c,m):n.startsWith("s")?n.replace("s","u"):"u1"===n||"u2"===n||"u4"===n?"s8":"u8"===n?"s16":"s32"}e.pixelType=this.outputPixelType=this._getOutputPixelType(a)}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],ie.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:ao,json:{write:!0,name:"rasterFunctionArguments"}})],ie.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],ie.prototype,"rasterArgumentNames",void 0),ie=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.LocalFunction")],ie);const uo=ie;var qe,ae=I(69287);let Ht=qe=class extends V{constructor(){super(...arguments),this.includedRanges=null,this.noDataValues=null,this.noDataInterpretation=$.IB.matchAny}get normalizedNoDataValues(){const{noDataValues:e}=this;if(!e?.length)return null;let t=!1;const n=e.map(s=>{if("number"==typeof s)return t=!0,[s];if("string"==typeof s){const o=s.trim().split(" ").filter(i=>""!==i.trim()).map(i=>Number(i));return t=t||o.length>0,0===o.length?null:o}return null});return t?n:null}clone(){return new qe({includedRanges:this.includedRanges?.slice()??[],noDataValues:this.noDataValues?.slice()??[],noDataInterpretation:this.noDataInterpretation})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],Ht.prototype,"includedRanges",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ht.prototype,"noDataValues",void 0),(0,l._)([(0,p.MZ)()],Ht.prototype,"normalizedNoDataValues",null),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ht.prototype,"noDataInterpretation",void 0),Ht=qe=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.MaskFunctionArguments")],Ht);const lo=Ht;let $t=class extends R{constructor(){super(...arguments),this.functionName="Mask",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const e=this.sourceRasterInfos[0].clone(),{pixelType:t}=e;this.outputPixelType=this._getOutputPixelType(t),e.pixelType=this.outputPixelType,this.rasterInfo=e;const{includedRanges:n,normalizedNoDataValues:s}=this.functionArguments;if(!n?.length&&!s?.length)return{success:!1,supportsGPU:!1,error:"missing includedRanges or noDataValues argument"};let o=[];for(let a=0;a<e.bandCount;a++){const r=(0,$.Wt)(t,n?.slice(2*a,2*a+2),s?.[a]);if(null==r){o=null;break}o.push(r)}this.lookups=o;const i=null!=s&&s.every(a=>a?.length===s[0]?.length);return{success:!0,supportsGPU:(!n||n.length<=2*$.et)&&(!s||i&&s[0].length<=$.et)}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return null;const{outputPixelType:n,lookups:s}=this,{includedRanges:o,noDataInterpretation:i,normalizedNoDataValues:a}=this.functionArguments;return(0,$.dK)(t,{includedRanges:o,noDataValues:a,outputPixelType:n,matchAll:i===$.IB.matchAll,lookups:s})}_getWebGLParameters(){const{includedRanges:e,normalizedNoDataValues:t}=this.functionArguments,n=new Float32Array($.et);n.fill(ae.pq),t?.[0]?.length&&n.set(t[0]);const s=new Float32Array($.et);for(let o=0;o<s.length;o+=2)s[o]=e?.[o]??-ae.pq,s[o+1]=e?.[o+1]??ae.pq;return e?.length&&s.set(e),{bandCount:this.sourceRasterInfos[0].bandCount,noDataValues:n,includedRanges:s}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],$t.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:lo,json:{write:!0,name:"rasterFunctionArguments"}})],$t.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],$t.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],$t.prototype,"lookups",void 0),$t=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.MaskFunction")],$t);const co=$t;var tn;let ue=tn=class extends V{constructor(){super(...arguments),this.visibleBandID=0,this.infraredBandID=1,this.scientificOutput=!1}clone(){const{visibleBandID:e,infraredBandID:t,scientificOutput:n}=this;return new tn({visibleBandID:e,infraredBandID:t,scientificOutput:n})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],ue.prototype,"visibleBandID",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],ue.prototype,"infraredBandID",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],ue.prototype,"scientificOutput",void 0),ue=tn=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.NDVIFunctionArguments")],ue);const po=ue;let le=class extends R{constructor(){super(...arguments),this.functionName="NDVI",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{scientificOutput:e,visibleBandID:t,infraredBandID:n}=this.functionArguments;this.outputPixelType=this._getOutputPixelType(e?"f32":"u8");const s=this.sourceRasterInfos[0],o=Math.max(t,n);if(s.bandCount<2||o>=s.bandCount)return{success:!1,supportsGPU:!1,error:"ndvi-function: source raster has insufficient amount of raster bands"};if(t<0||n<0)return{success:!1,supportsGPU:!1,error:"ndvi-function: invalid visible or infrared band id"};const i=s.clone();i.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(i),i.bandCount=1,i.keyProperties={...i.keyProperties,BandProperties:void 0};const[a,r,u,c]=e?[-1,1,0,.1]:[0,200,100,10];return i.statistics=[{min:a,max:r,avg:u,stddev:c}],this.rasterInfo=i,{success:!0,supportsGPU:!0}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return null;const{visibleBandID:n,infraredBandID:s,scientificOutput:o}=this.functionArguments;return function Ws(e,t,n,s){const{mask:o,pixels:i,width:a,height:r}=e,u=i[n],c=i[t],m=c.length,h=s?new Uint8Array(m):new Float32Array(m),d=s?100:1,f=s?100.5:0;for(let A=0;A<m;A++)if(null==o||o[A]){const x=u[A],v=c[A],_=x+v;_&&(h[A]=(x-v)/_*d+f)}const y=new g.A({width:a,height:r,mask:o,pixelType:s?"u8":"f32",pixels:[h]});return y.updateStatistics(),y}(t,n,s,!o)}_getWebGLParameters(){const{visibleBandID:e,infraredBandID:t,scientificOutput:n}=this.functionArguments;return{bandIndexMat3:nt(this.isInputBandIdsSwizzled?[0,1,2]:[t,e,0]),scaled:!n}}_getInputBandIds(e){const{visibleBandID:t,infraredBandID:n}=this.functionArguments;return[n,t,0].map(s=>e[s])}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],le.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:po,json:{write:!0,name:"rasterFunctionArguments"}})],le.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],le.prototype,"rasterArgumentNames",void 0),le=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.NDVIFunction")],le);const mo=le;var en;let Pt=en=class extends V{constructor(){super(...arguments),this.inputRanges=null,this.outputValues=null,this.noDataRanges=null,this.allowUnmatched=!1,this.isLastInputRangeInclusive=!1}clone(){return new en({inputRanges:[...this.inputRanges],outputValues:[...this.outputValues],noDataRanges:[...this.noDataRanges],allowUnmatched:this.allowUnmatched,isLastInputRangeInclusive:this.isLastInputRangeInclusive})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],Pt.prototype,"inputRanges",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Pt.prototype,"outputValues",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Pt.prototype,"noDataRanges",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Pt.prototype,"allowUnmatched",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Pt.prototype,"isLastInputRangeInclusive",void 0),Pt=en=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.RemapFunctionArguments")],Pt);const ho=Pt;let Jt=class extends R{constructor(){super(...arguments),this.functionName="Remap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const e=this.sourceRasterInfos[0].clone(),{pixelType:t}=e;this.outputPixelType=this._getOutputPixelType(t),e.pixelType=this.outputPixelType,e.bandCount=1;const{statistics:n}=e;this._removeStatsHistColormapVAT(e);const{allowUnmatched:s,outputValues:o,inputRanges:i,noDataRanges:a,isLastInputRangeInclusive:r}=this.functionArguments;if(null!=n&&n.length&&o?.length)if(s){const u=Math.min.apply(null,[...o,n[0].min]),c=Math.max.apply(null,[...o,n[0].max]);e.statistics=[{...n[0],min:u,max:c}]}else{let u=o[0],c=u;for(let m=0;m<o.length;m++)u=u>o[m]?o[m]:u,c=c>o[m]?c:o[m];e.statistics=[{...n[0],min:u,max:c}]}return this.rasterInfo=e,this.lookup=s?null:(0,$.XU)({srcPixelType:t,inputRanges:i,outputValues:o,noDataRanges:a,allowUnmatched:s,isLastInputRangeInclusive:r,outputPixelType:this.outputPixelType}),{success:!0,supportsGPU:(!o||o.length<=$.et)&&(!a||a.length<=$.et)}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return null;const{lookup:n,outputPixelType:s}=this;if(n){const c=(0,$.eH)(t,{lut:[n.lut],offset:n.offset,outputPixelType:s});return null!=c&&n.mask&&(c.mask=(0,$.UK)(t.pixels[0],t.mask,n.mask,n.offset,"u8")),c}const{inputRanges:o,outputValues:i,noDataRanges:a,allowUnmatched:r,isLastInputRangeInclusive:u}=this.functionArguments;return(0,$.Ew)(t,{inputRanges:o,outputValues:i,noDataRanges:a,outputPixelType:s,allowUnmatched:r,isLastInputRangeInclusive:u})}_getWebGLParameters(){const{allowUnmatched:e,noDataRanges:t,isLastInputRangeInclusive:n}=this.functionArguments,s=new Float32Array(3*$.et),o=1e-5,i=this.functionArguments.inputRanges??[],a=this.functionArguments.outputValues??[],r=a.length;for(let c=0;c<$.et;c++)s[3*c]=i[2*c]??ae.pq-1,s[3*c+1]=i[2*c+1]??ae.pq,s[3*c+2]=a[c]??0,c<r&&(c>0&&(s[3*c]-=o),(c<r-1||!n)&&(s[3*c+1]-=o));const u=new Float32Array(2*$.et);return u.fill(ae.pq),t?.length&&u.set(t),{allowUnmatched:e,rangeMaps:s,noDataRanges:u,clampRange:(0,Z.hP)(this.outputPixelType)}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Jt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:ho,json:{write:!0,name:"rasterFunctionArguments"}})],Jt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Jt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Jt.prototype,"lookup",void 0),Jt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.RemapFunction")],Jt);const go=Jt;var nn;let ce=nn=class extends Zn{readColorRamp(e){if("string"==typeof e){const t=lt.kH.jsonValues.find(n=>n.toLowerCase()===e.toLowerCase());return t?(0,lt.M5)(lt.kH.fromJSON(t)):null}return"toJSON"in e?e.toJSON():e}clone(){return new nn({hillshadeType:this.hillshadeType,altitude:this.altitude,azimuth:this.azimuth,zFactor:this.zFactor,slopeType:this.slopeType,pixelSizeFactor:this.pixelSizeFactor,pixelSizePower:this.pixelSizePower,removeEdgeEffect:this.removeEdgeEffect,colorRamp:this.colorRamp,colormap:this.colormap,raster:this.raster})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],ce.prototype,"colorRamp",void 0),(0,l._)([(0,ge.w)("colorRamp")],ce.prototype,"readColorRamp",null),(0,l._)([(0,p.MZ)({type:[[Number]],json:{write:!0}})],ce.prototype,"colormap",void 0),ce=nn=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ShadedReliefFunctionArguments")],ce);const fo=ce;let It=class extends R{constructor(){super(...arguments),this.functionName="ShadedRelief",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const e=this.sourceRasterInfos[0];if(e.bandCount>1)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: source data must be single band"};let{colorRamp:t,colormap:n}=this.functionArguments;if(!t&&!n?.length)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: a color ramp argument must be specified"};this.outputPixelType=this._getOutputPixelType("u8");const s=e.clone();this._removeStatsHistColormapVAT(s),s.pixelType=this.outputPixelType,s.bandCount=3,s.statistics=[{min:0,max:255,avg:60,stddev:10},{min:0,max:255,avg:60,stddev:10},{min:0,max:255,avg:60,stddev:10}],this.rasterInfo=s,this.isGCS=s.spatialReference?.isGeographic??!1,n?.length||(n=(0,lt.R8)(t,{interpolateAlpha:!0}));const{indexedColormap:o,offset:i}=(0,$.zg)({colormap:n});if(!o?.length)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: a valid colorramp is required"};const a=(0,lt.S2)(o);return this.lookup={indexedColormap:o,offset:i,hsvMap:a},{success:!0,supportsGPU:(0,Sn.WN)(o)}}_processPixels(e){const t=e.pixelBlocks?.[0];if(!t||!this.lookup)return null;let n=e.primaryPixelSizes?.[0];if(null==n){const{extent:a}=e;n=a?{x:a.width/t.width,y:a.height/t.height}:{x:1,y:1}}const s=(0,ot.PP)(this.functionArguments,n,this.isGCS),o=(0,ot.fw)(t,s);return(0,ot.SC)(o,t,this.lookup.hsvMap,this.sourceRasterInfos[0].statistics?.[0]??{min:0,max:8e3}),o.pixelType=this.outputPixelType,o}_getWebGLParameters(){const e=(0,ot.PP)(this.functionArguments,{x:1,y:1},this.isGCS),t=(0,ot.ng)(e),{slopeType:n,zFactor:s,pixelSizeFactor:o,pixelSizePower:i}=this.functionArguments,a="scaled"===n,{indexedColormap:r,offset:u}=this.lookup,c=this.sourceRasterInfos[0].statistics?.[0],m=(0,Z.zw)(this.outputPixelType);return{...t,indexedColormap:r,offset:u,zFactor:s,gcsFactor:this.isGCS?ot.rk:1,pixelSizeFactor:a?o:0,pixelSizePower:a?i:0,minValue:c?.min??0,maxValue:c?.max??8e3,isOutputRounded:m}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],It.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:fo,json:{write:!0,name:"rasterFunctionArguments"}})],It.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],It.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],It.prototype,"isGCS",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],It.prototype,"lookup",void 0),It=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.ShadedReliefFunction")],It);const yo=It;var sn;const xo=new _t.J({1:"degree",2:"percent-rise",3:"adjusted"},{useNumericKeys:!0});let Rt=sn=class extends V{constructor(){super(...arguments),this.slopeType="degree",this.zFactor=1,this.pixelSizePower=.664,this.pixelSizeFactor=.024,this.removeEdgeEffect=!1}clone(){return new sn({slopeType:this.slopeType,zFactor:this.zFactor,pixelSizePower:this.pixelSizePower,pixelSizeFactor:this.pixelSizeFactor,removeEdgeEffect:this.removeEdgeEffect,raster:this.raster})}};(0,l._)([(0,At.e)(xo)],Rt.prototype,"slopeType",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0}})],Rt.prototype,"zFactor",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{name:"psPower",write:!0}})],Rt.prototype,"pixelSizePower",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{name:"psZFactor",write:!0}})],Rt.prototype,"pixelSizeFactor",void 0),(0,l._)([(0,p.MZ)({type:Boolean,json:{write:!0}})],Rt.prototype,"removeEdgeEffect",void 0),Rt=sn=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.SlopeFunctionArguments")],Rt);const Ao=Rt;let Kt=class extends R{constructor(){super(...arguments),this.functionName="Slope",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const e=this.sourceRasterInfos[0].clone();return e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),e.statistics="percent-rise"!==this.functionArguments.slopeType?[{min:0,max:90,avg:1,stddev:1}]:null,e.bandCount=1,this.rasterInfo=e,this.isGCS=e.spatialReference?.isGeographic??!1,{success:!0,supportsGPU:!0}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return null;const{zFactor:n,slopeType:s,pixelSizePower:o,pixelSizeFactor:i}=this.functionArguments,{isGCS:a}=this,{extent:r,primaryPixelSizes:u}=e,c=u?.[0];return(0,ot.yy)(t,{zFactor:n,slopeType:s,pixelSizePower:o,pixelSizeFactor:i,isGCS:a,resolution:c??(r?{x:r.width/t.width,y:r.height/t.height}:{x:1,y:1})})}_getWebGLParameters(){const{zFactor:e,slopeType:t,pixelSizeFactor:n,pixelSizePower:s}=this.functionArguments;return{zFactor:this.isGCS&&e>=1?e*ot.rk:e,slopeType:t,pixelSizeFactor:n??0,pixelSizePower:s??0,isOutputRounded:(0,Z.zw)(this.outputPixelType)}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Kt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Ao,json:{write:!0,name:"rasterFunctionArguments"}})],Kt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Kt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Kt.prototype,"isGCS",void 0),Kt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.SlopeFunction")],Kt);const _o=Kt,Un=new _t.J({1:"min",2:"max",3:"mean",4:"stddev",5:"median",6:"majority",7:"minority"},{useNumericKeys:!0});function vo(e,t){const{fillNoDataOnly:n}=t,{band:s,width:o,height:i,mask:a,outBand:r}=e;if(n&&!a)return void r.set(s);const{statisticsType:u,kernelRows:c,kernelCols:m}=t,h="stddev"===u,d=o*i,f=new Float64Array(d),y=new Float64Array(d),A=new Uint32Array(d);for(let N=0;N<i;N++){const S=N*o;let E=0,H=0,X=0;for(let Y=0;Y<m;Y++)a&&!a[S+Y]||(E+=s[S+Y],h&&(H+=s[S+Y]**2),X++);f[S]=E,y[S]=H,A[S]=X;for(let Y=1;Y<=o-m;Y++){const ft=S+Y-1,xe=ft+m;a?(a[ft]&&(X--,E-=s[ft],h&&(H-=s[ft]**2)),a[xe]&&(X++,E+=s[xe],h&&(H+=s[xe]**2))):(E-=s[ft],E+=s[xe],h&&(H-=s[ft]**2,H+=s[xe]**2)),f[S+Y]=E,A[S+Y]=X,h&&(y[S+Y]=H)}}const x=new Float64Array(d),v=new Float64Array(d),_=new Uint32Array(d),w=c*o;for(let N=0;N<=o-m;N++){let S=0,E=0,H=0;for(let X=0;X<c;X++){const Y=X*o+N;S+=f[Y],H+=A[Y],h&&(E+=y[Y])}x[N]=S,v[N]=E,_[N]=H;for(let X=1;X<=i-c;X++){const Y=(X-1)*o+N,ft=Y+w;S-=f[Y],S+=f[ft],H-=A[Y],H+=A[ft],h&&(E-=y[Y],E+=y[ft]),x[X*o+N]=S,v[X*o+N]=E,_[X*o+N]=H}}const M=Math.floor(c/2),k=Math.floor(m/2);for(let N=M;N<i-M;N++){const S=N*o;for(let E=k;E<o-k;E++){const H=(N-M)*o+E-k,X=_[H];if(0===X||n&&(!a||a[S+E]))continue;const Y=x[H]/X,ft=h?Math.sqrt((v[H]-x[H]*Y)/X):Y;r[S+E]=ft,a&&(a[S+E]=255)}}}function wo(e,t){const{fillNoDataOnly:n}=t,{band:s,width:o,height:i,mask:a,outBand:r}=e;if(n&&!a)return void r.set(s);const{kernelRows:u,kernelCols:c,statisticsType:m}=t,h=Math.floor(u/2),d=Math.floor(c/2),f="min"===m,y=r.slice(),A=new Uint32Array(o*i);for(let x=h;x<i-h;x++){const v=x*o;for(let _=d;_<o-d;_++){let w=f?Number.MAX_VALUE:-Number.MAX_VALUE,M=0;for(let k=0;k<u;k++)for(let N=0;N<c;N++){const S=v+_+(k-h)*o+N-d;a&&!a[S]||(w=f?Math.min(w,s[S]):Math.max(w,s[S]),M++)}a?(y[v+_]=0===M?0:w,A[v+_]=M):r[v+_]=0===M?0:w}}if(a)for(let x=h;x<i-h;x++){const v=x*o;for(let _=d;_<o-d;_++)if(A[v+_]){if(n&&a[v+_])continue;r[v+_]=y[v+_],a[v+_]=255}}}function bo(e,t){const{fillNoDataOnly:n}=t,{band:s,width:o,height:i,mask:a,outBand:r}=e;if(n&&!a)return void r.set(s);const{kernelRows:u,kernelCols:c}=t,m=Math.floor(u/2),h=Math.floor(c/2),d=r.slice(),f=new Uint32Array(o*i);for(let y=m;y<i-m;y++){const A=y*o;for(let x=h;x<o-h;x++){if(n&&a?.[A+x])continue;const v=[];for(let _=0;_<u;_++)for(let w=0;w<c;w++){const M=A+x+(_-m)*o+w-h;a&&!a[M]||v.push(s[M])}v.length&&(v.sort((_,w)=>_-w),a?(d[A+x]=v[Math.floor((v.length-1)/2)],f[A+x]=v.length):r[A+x]=v[Math.floor((v.length-1)/2)])}}if(a)for(let y=m;y<i-m;y++){const A=y*o;for(let x=h;x<o-h;x++)if(f[A+x]){if(n&&a[A+x])continue;r[A+x]=d[A+x],a[A+x]=255}}}function Fo(e,t){const{fillNoDataOnly:n}=t,{band:s,width:o,height:i,mask:a,outBand:r}=e;if(n&&!a)return void r.set(s);const{kernelRows:u,kernelCols:c}=t,m=Math.floor(u/2),h=Math.floor(c/2),d="majority"===t.statisticsType,f=u*c,y=r.slice(),A=new Uint32Array(o*i);for(let x=m;x<i-m;x++){const v=x*o;for(let _=h;_<o-h;_++){if(n&&a?.[v+_])continue;const w=new Map;for(let S=0;S<u;S++)for(let E=0;E<c;E++){const H=v+_+(S-m)*o+E-h;if(a&&!a[H])continue;const X=s[H];w.set(X,w.has(X)?w.get(X)+1:1)}if(0===w.size)continue;let M=0,k=0,N=d?0:f+1;for(const S of w.keys())k=w.get(S),d===k>N&&(N=k,M=S);a?(y[v+_]=M,A[v+_]=w.size):r[v+_]=M}}if(a)for(let x=m;x<i-m;x++){const v=x*o;for(let _=h;_<o-h;_++)if(A[v+_]){if(n&&a[v+_])continue;r[v+_]=y[v+_],a[v+_]=255}}}var rn;let Xt=rn=class extends V{constructor(){super(...arguments),this.rows=3,this.cols=3,this.fillNoDataOnly=!1,this.statisticsType="min"}clone(){return new rn({rows:this.rows,cols:this.cols,fillNoDataOnly:this.fillNoDataOnly,statisticsType:this.statisticsType,raster:(0,at.o8)(this.raster)})}};(0,l._)([(0,p.MZ)({json:{write:!0,read:{source:["kernelRows","rows"],reader:(e,t)=>Number(e??t?.kernelRows??3)}}})],Xt.prototype,"rows",void 0),(0,l._)([(0,p.MZ)({json:{write:!0,read:{source:["kernelCols","cols"],reader:(e,t)=>Number(e??t?.kernelCols??3)}}})],Xt.prototype,"cols",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Xt.prototype,"fillNoDataOnly",void 0),(0,l._)([(0,p.MZ)({json:{read:{source:["statisticsType","type"],reader:(e,t)=>Un.fromJSON(t?.statisticsType??t?.type)??"min"},write:{target:"type"}}}),(0,At.e)(Un)],Xt.prototype,"statisticsType",void 0),Xt=rn=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.StatisticsFunctionArguments")],Xt);const To=Xt;let pe=class extends R{constructor(){super(...arguments),this.functionName="Statistics",this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{type:e}=this.functionArguments.toJSON();if(e<1||e>7)return{success:!1,supportsGPU:!1,error:`statistics-function: the given statistics type is not supported ${e}`};const t=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(t.pixelType);const n=t.clone();n.pixelType=this.outputPixelType;const{statisticsType:s}=this.functionArguments;return"stddev"===s&&this._removeStatsHistColormapVAT(n),this.rasterInfo=n,{success:!0,supportsGPU:n.bandCount<=3&&e<5}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return t;const{statisticsType:n,rows:s,cols:o,fillNoDataOnly:i}=this.functionArguments;return function Mo(e,t){const{mask:n}=e,{fillNoDataOnly:s}=t;if(s&&!n)return e;const{pixels:o,width:i,height:a,bandMasks:r,pixelType:u}=e,c=o.length,m=i*a,h=[],{kernelRows:d,kernelCols:f,statisticsType:y,mirrorEdges:A}=t;if(s&&!n)return e;const x=t.outputPixelType??u,v=[];for(let M=0;M<c;M++){const k=o[M],N=g.A.createEmptyBand(x,m);s&&N.set(k);const S=r?.[M]??n,E=S?.slice()??null,H={band:k,width:i,height:a,mask:E,outBand:N};switch(y){case"min":case"max":wo(H,t);break;case"mean":case"stddev":vo(H,t);break;case"median":bo(H,t);break;case"majority":case"minority":Fo(H,t)}A&&!s&&He(N,i,a,d,f),h.push(N),E&&v.push(E)}let _=v[0]??n;v.length!==c&&(v.length=0),c>1&&r?.length&&(_=g.A.combineBandMasks(r));const w=new g.A({pixelType:x,width:i,height:a,pixels:h,bandMasks:r&&v.length?v:null,mask:_});return w.updateStatistics(),w}(t,{kernelRows:s,kernelCols:o,fillNoDataOnly:i,outputPixelType:this.outputPixelType,statisticsType:n,mirrorEdges:!0})}_getWebGLParameters(){const{rows:e,cols:t,statisticsType:n,fillNoDataOnly:s}=this.functionArguments;return{fillNoDataOnly:s,kernelRows:e,kernelCols:t,statisticsType:n,clampRange:(0,Z.hP)(this.outputPixelType)}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],pe.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:To,json:{write:!0,name:"rasterFunctionArguments"}})],pe.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],pe.prototype,"rasterArgumentNames",void 0),pe=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.StatisticsFunction")],pe);const Po=pe;var on;let Yt=on=class extends V{constructor(){super(...arguments),this.statistics=null,this.histograms=null}readStatistics(e,t){if(!e?.length)return null;const n=[];return e.forEach(s=>{n.push({min:s.min,max:s.max,avg:s.avg??s.mean,stddev:s.stddev??s.standardDeviation})}),n}writeStatistics(e,t,n){if(!e?.length)return;const s=[];e.forEach(o=>{const i={...o,mean:o.avg,standardDeviation:o.stddev};delete i.avg,delete i.stddev,s.push(i)}),t[n]=s}clone(){return new on({statistics:(0,at.o8)(this.statistics),histograms:(0,at.o8)(this.histograms)})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],Yt.prototype,"statistics",void 0),(0,l._)([(0,ge.w)("statistics")],Yt.prototype,"readStatistics",null),(0,l._)([(0,Te.K)("statistics")],Yt.prototype,"writeStatistics",null),(0,l._)([(0,p.MZ)({json:{write:!0}})],Yt.prototype,"histograms",void 0),Yt=on=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.StatisticsHistogramFunctionArguments")],Yt);const Io=Yt;let Nt=class extends R{constructor(){super(...arguments),this.functionName="StatisticsHistogram",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const e=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType("u8");const t=e.clone(),{statistics:n,histograms:s}=this.functionArguments;return s&&(t.histograms=s),n&&(t.statistics=n),this.rasterInfo=t,{success:!0,supportsGPU:!0}}_processPixels(e){return e.pixelBlocks?.[0]}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Nt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Io,json:{write:!0,name:"rasterFunctionArguments"}})],Nt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Nt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Nt.prototype,"indexedColormap",void 0),(0,l._)([(0,p.MZ)()],Nt.prototype,"isNoopProcess",void 0),Nt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.StatisticsHistogramFunction")],Nt);const Ro=Nt;var an;const No=new _t.J({0:"none",3:"standard-deviation",4:"histogram-equalization",5:"min-max",6:"percent-clip",9:"sigmoid"},{useNumericKeys:!0});let it=an=class extends V{constructor(){super(...arguments),this.computeGamma=!1,this.dynamicRangeAdjustment=!1,this.gamma=[],this.histograms=null,this.statistics=null,this.stretchType="none",this.useGamma=!1}writeStatistics(e,t,n){e?.length&&(Array.isArray(e[0])||(e=e.map(s=>[s.min,s.max,s.avg,s.stddev])),t[n]=e)}clone(){return new an({stretchType:this.stretchType,outputMin:this.outputMin,outputMax:this.outputMax,useGamma:this.useGamma,computeGamma:this.computeGamma,statistics:(0,at.o8)(this.statistics),gamma:(0,at.o8)(this.gamma),sigmoidStrengthLevel:this.sigmoidStrengthLevel,numberOfStandardDeviations:this.numberOfStandardDeviations,minPercent:this.minPercent,maxPercent:this.maxPercent,histograms:(0,at.o8)(this.histograms),dynamicRangeAdjustment:this.dynamicRangeAdjustment,raster:this.raster})}};(0,l._)([(0,p.MZ)({type:Boolean,json:{write:!0}})],it.prototype,"computeGamma",void 0),(0,l._)([(0,p.MZ)({type:Boolean,json:{name:"dra",write:!0}})],it.prototype,"dynamicRangeAdjustment",void 0),(0,l._)([(0,p.MZ)({type:[Number],json:{write:!0}})],it.prototype,"gamma",void 0),(0,l._)([(0,p.MZ)()],it.prototype,"histograms",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0}})],it.prototype,"maxPercent",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0}})],it.prototype,"minPercent",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0}})],it.prototype,"numberOfStandardDeviations",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{name:"max",write:!0}})],it.prototype,"outputMax",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{name:"min",write:!0}})],it.prototype,"outputMin",void 0),(0,l._)([(0,p.MZ)({type:Number,json:{write:!0}})],it.prototype,"sigmoidStrengthLevel",void 0),(0,l._)([(0,p.MZ)({json:{type:[[Number]],write:!0}})],it.prototype,"statistics",void 0),(0,l._)([(0,Te.K)("statistics")],it.prototype,"writeStatistics",null),(0,l._)([(0,At.e)(No)],it.prototype,"stretchType",void 0),(0,l._)([(0,p.MZ)({type:Boolean,json:{write:!0}})],it.prototype,"useGamma",void 0),it=an=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.StretchFunctionArguments")],it);const Co=it;let Ct=class extends R{constructor(){super(...arguments),this.functionName="Stretch",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null,this.cutOffs=null}_bindSourceRasters(){this.lookup=null,this.cutOffs=null;const e=this.sourceRasterInfos[0],{pixelType:t}=e,{functionArguments:n}=this,{dynamicRangeAdjustment:s,gamma:o,useGamma:i}=n;if(!s&&["u8","u16","s8","s16"].includes(t)){const c=(0,Zt.DP)(n.toJSON(),{rasterInfo:e}),m=(0,Z.zw)(this.outputPixelType)?"round":"float";this.lookup=(0,Zt.RP)({pixelType:t,...c,gamma:i?o:null,rounding:m}),this.cutOffs=c}else s||(this.cutOffs=(0,Zt.DP)(n.toJSON(),{rasterInfo:e}));this.outputPixelType=this._getOutputPixelType(t);const a=e.clone();a.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(a),"u8"===this.outputPixelType&&(a.keyProperties.DataType="processed");const{outputMin:r=0,outputMax:u=255}=this.functionArguments;a.statistics=[];for(let c=0;c<a.bandCount;c++)a.statistics[c]={min:r,max:u};return this.rasterInfo=a,{success:!0,supportsGPU:!s}}_processPixels(e){const t=e.pixelBlocks?.[0];if(null==t)return t;const{lookup:n}=this;if(n)return(0,$.eH)(t,{...n,outputPixelType:this.rasterInfo.pixelType});const{functionArguments:s}=this,o=this.cutOffs||(0,Zt.DP)(s.toJSON(),{rasterInfo:this.sourceRasterInfos[0],pixelBlock:t});return(0,Zt._N)(t,{...o,gamma:s.useGamma?s.gamma:null,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const{outputMin:e=0,outputMax:t=255,gamma:n,useGamma:s}=this.functionArguments,o=this.rasterInfo.bandCount>=2?3:1,i=s&&n?.length?(0,Zt.Nh)(o,n):[1,1,1],{minCutOff:a,maxCutOff:r}=this.cutOffs??{minCutOff:[0,0,0],maxCutOff:[255,255,255]};1===a.length&&(a[1]=a[2]=a[0],r[1]=r[2]=r[0]);const u=r.map((d,f)=>(t-e)/(r[f]-a[f])),c=(0,Z.zw)(this.outputPixelType);return{bandCount:o,minOutput:e,maxOutput:t,minCutOff:a,maxCutOff:r,factor:u,useGamma:s,gamma:s&&n?[n[0],n[1]??n[0],n[2]??n[0]]:[1,1,1],gammaCorrection:s?[i[0],i[1]??i[0],i[2]??i[0]]:[1,1,1],stretchType:this.functionArguments.stretchType,isOutputRounded:c,type:"stretch"}}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Ct.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:Co,json:{write:!0,name:"rasterFunctionArguments"}})],Ct.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Ct.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ct.prototype,"lookup",void 0),(0,l._)([(0,p.MZ)({json:{write:!0}})],Ct.prototype,"cutOffs",void 0),Ct=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.StretchFunction")],Ct);const Bo=Ct;var un;let Ie=un=class extends V{constructor(){super(...arguments),this.attributeTableAsRecordSet=null}clone(){return new un({attributeTableAsRecordSet:(0,at.o8)(this.attributeTableAsRecordSet)})}};(0,l._)([(0,p.MZ)({json:{write:!0}})],Ie.prototype,"attributeTableAsRecordSet",void 0),Ie=un=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.TableFunctionArguments")],Ie);const ko=Ie;let Qt=class extends R{constructor(){super(...arguments),this.functionName="Table",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const e=this.sourceRasterInfos[0];if(e.bandCount>1||e.pixelType.startsWith("f"))return{success:!1,supportsGPU:!1,error:"table-function: Source data must be single band and integer pixel type."};const{attributeTableAsRecordSet:t}=this.functionArguments;if(!t)return{success:!1,supportsGPU:!1,error:"table-function: Missing attributeTableAsRecordSet argument."};this.outputPixelType=this._getOutputPixelType(e.pixelType);const n=e.clone();return n.pixelType=this.outputPixelType,n.bandCount=1,"thematic"!==n.dataType&&(n.keyProperties=n.keyProperties?{...n.keyProperties,DataType:"thematic"}:{DataType:"thematic"}),this.rasterInfo=n,{success:!0,supportsGPU:!0}}_processPixels(e){return e.pixelBlocks?.[0]}};(0,l._)([(0,p.MZ)({json:{write:!0,name:"rasterFunction"}})],Qt.prototype,"functionName",void 0),(0,l._)([(0,p.MZ)({type:ko,json:{write:!0,name:"rasterFunctionArguments"}})],Qt.prototype,"functionArguments",void 0),(0,l._)([(0,p.MZ)()],Qt.prototype,"rasterArgumentNames",void 0),(0,l._)([(0,p.MZ)()],Qt.prototype,"isNoopProcess",void 0),Qt=(0,l._)([(0,F.$)("esri.layers.support.rasterFunctions.TableFunction")],Qt);const So=Qt,W=new Map;function zn(e,t){const{rasterFunctionArguments:n}=e;n&&(n.rasters||[n.raster,n.raster2]).forEach(s=>{s&&"number"!=typeof s&&("string"==typeof s?s.startsWith("http")&&(t.includes(s)||t.push(s)):"rasterFunctionArguments"in s&&zn(s,t))})}function Do(e,t){if(t=t??{},"function"in(e=(0,at.o8)(e))&&"arguments"in e&&e.arguments){const n=Wn(e,new Map,t);if(pn(n),!n.renderingRule)throw new wt.A("raster-function-helper","Unsupported raster function json.");e=n.renderingRule}if("rasterFunction"in e)return On(e=ln(e),t);throw new wt.A("raster-function-helper","unsupported raster function json.")}function En(e){return!!(e&&"object"==typeof e&&e.rasterFunction&&e.rasterFunctionArguments)}function ln(e){const{rasterFunction:t,rasterFunctionArguments:n}=e,s={};for(const o in n){let i=n[o];const a=o.toLowerCase();if("rasters"===a&&Array.isArray(i))s.rasters=i.map(r=>En(r)?ln(r):r);else switch(En(i)&&(i=ln(i)),a){case"dra":s.dra=i;break;case"pspower":s.psPower=i;break;case"pszfactor":s.psZFactor=i;break;case"bandids":s.bandIds=i;break;default:s[o[0].toLowerCase()+o.slice(1)]=i}}return"Local"!==t||s.rasters?.length||(s.rasters=["$$"]),{...e,rasterFunctionArguments:s}}function On(e,t){const{rasterFunction:n,rasterFunctionArguments:s}=e,o=e.outputPixelType?.toLowerCase();if(null==n||!W.has(n))throw new wt.A("raster-function-helper",`unsupported raster function: ${n}`);const i=W.get(n),a=("function"==typeof i.ctor?i.ctor:i.ctor.default).fromJSON({...e,outputPixelType:o}),{rasterArgumentNames:r}=a,u=[],c=function jo(e,t){return"rasters"===t[0]&&Array.isArray(e.rasters)?e.rasters:t.map(n=>e[n])}(s,r),m="rasters"===r[0]||r.length>1,h=[];for(let d=0;d<c.length;d++){const f=c[d];let y;null==f||"string"==typeof f&&f.startsWith("$")?u.push(t?.raster):"string"==typeof f?t[f]&&u.push(t[f]):"number"!=typeof f&&"rasterFunction"in f&&(y=On(f,t),m||(a.functionArguments[r[d]]=y),u.push(y)),m&&h.push(y??f)}if(m&&("rasters"===r[0]?a.functionArguments.rasters=h:r.forEach((d,f)=>{a.functionArguments[d]=h[f]})),t){a.sourceRasters=u;const d=t.raster?.url;d&&(a.mainPrimaryRasterId=d)}return a}function Vn(e,t){if(e&&t)for(const n in e){const s=e[n];s&&"object"==typeof s&&"type"in s&&("RasterFunctionTemplate"===s.type?Vn(s.arguments,t):"RasterFunctionVariable"===s.type&&null!=t[s.name]&&(s.value=t[s.name]))}}function cn(e,t){if(!e||"object"!=typeof e)return e;const{value:n}=e;if(!n||"object"!=typeof n)return e.isDataset?"$$":n;if(Array.isArray(n))return 0===n.length?[]:n.map(o=>"object"==typeof o&&"RasterFunctionVariable"===o.type?cn(o,t):o);if("value"in n&&["number","string","boolean"].includes(typeof n.value))return n.value;if(e.isDataset&&"Scalar"!==n.type)return"$$";if(!("type"in n))return n;let s=n;switch(n.type){case"Scalar":s=n.value;break;case"AlgorithmicColorRamp":s=Ln(n);break;case"MultiPartColorRamp":s={type:"multipart",colorRamps:n.ArrayOfColorRamp.map(Ln)};break;case"ArgumentArray":if(n.elements?.length&&"RasterStatistics"!==n.elements[0].type){const o=[];for(let i=0;i<n.elements.length;i++){const a=n.elements[i],{type:r}=a;if(r)if("RasterFunctionTemplate"===r){const{renderingRule:u}=Wn(a,t);o.push(u),null!=a._object_id&&t.set(a._object_id,u)}else{if("RasterFunctionVariable"!==r)throw new wt.A("raster-function-helper","unsupported raster function json.");{const u=cn(a,t);o.push(u),null!=a._object_id&&t.set(a._object_id,u)}}else o.push(a)}s=o}else s=n.elements}return null!=n._object_id&&t.set(n._object_id,s),s}function Ln(e){const t=e.algorithm??"esriHSVAlgorithm";let{FromColor:n,ToColor:s}=e;if(!Array.isArray(n)){const{r:o,g:i,b:a}=(0,Ae.$)({h:n.Hue,s:n.Saturation,v:n.Value});n=[o,i,a,n.AlphaValue]}if(!Array.isArray(s)){const{r:o,g:i,b:a}=(0,Ae.$)({h:s.Hue,s:s.Saturation,v:s.Value});s=[o,i,a,s.AlphaValue]}return{type:"algorithmic",algorithm:t,fromColor:n,toColor:s}}function Wn(e,t,n){n&&Vn(e,n);const s={renderingRule:{},templates:t};return Hn(e,s),s}function Hn(e,t){if(!e||!t.renderingRule)return;const{renderingRule:n,templates:s}=t,{function:o,arguments:i,_object_id:a}=e;if(!o||!i)return;null!=a&&s.set(a,n),n.rasterFunction=o.type.replace("Function",""),n.outputPixelType=o.pixelType;const r={};n.rasterFunctionArguments=r;for(const u in i){if("type"===u||"object_id"===u||"_object_ref_id"===u)continue;const c=i[u];c&&"object"==typeof c&&"type"in c&&("RasterFunctionTemplate"===c.type||"RasterFunctionVariable"===c.type)?("RasterFunctionVariable"===c.type?r[u]=cn(c,s):(n.rasterFunctionArguments[u]={},Hn(c,{renderingRule:n.rasterFunctionArguments[u],templates:s})),null!=c._object_id&&s.set(c._object_id,r[u])):r[u]=c}switch(r.DEM&&!r.Raster&&(r.Raster=r.DEM,delete r.DEM),n.rasterFunction){case"Stretch":!function Go(e){e.Statistics?.length&&"object"==typeof e.Statistics&&(e.Statistics=e.Statistics.map(t=>[t.min,t.max,t.mean,t.standardDeviation])),null!=e.NumberOfStandardDeviation&&(e.NumberOfStandardDeviations=e.NumberOfStandardDeviation,delete e.NumberOfStandardDeviation)}(r);break;case"Colormap":!function Zo(e){"randomcolorramp"===e.ColorRamp?.type?.toLowerCase()&&(delete e.ColorRamp,e.ColormapName="Random"),0===e.ColorSchemeType&&delete e.ColorRamp}(r);break;case"Convolution":!function Uo(e){null!=e.ConvolutionType&&(e.Type=e.ConvolutionType,delete e.ConvolutionType)}(r);break;case"Mask":!function zo(e){e.NoDataValues?.length&&"string"==typeof e.NoDataValues[0]&&(e.NoDataValues=e.NoDataValues.filter(t=>""!==t).map(t=>Number(t)))}(r)}}function pn(e){const{renderingRule:t,templates:n}=e;if("object"!=typeof t||!t?.rasterFunctionArguments||!n.size)return;const{rasterFunctionArguments:s}=t;for(const o in s){const i=s[o],a="_object_ref_id"===o?i:i&&"object"==typeof i&&"_object_ref_id"in i?i._object_ref_id:null;if(null==a)i&&"object"==typeof i&&(i.rasterFunctionArguments&&pn({renderingRule:i,templates:n}),Array.isArray(i)&&i.forEach((r,u)=>{if("object"==typeof r)if(null!=r._object_ref_id){if(!n.has(r._object_ref_id))throw new wt.A("raster-function-helper",`unsupported raster function json. _object_ref_id: ${i} does not exist`);const c=n.get(a);c&&"object"==typeof c?Object.assign(r,c):i[u]=c}else pn({renderingRule:r,templates:n})}));else{if(!n.has(a))throw new wt.A("raster-function-helper",`unsupported raster function json. _object_ref_id: ${a} does not exist`);const r=n.get(a);"_object_ref_id"!==o?s[o]=r:r&&"object"==typeof r&&Object.assign(s,r)}}}W.set("Arithmetic",{desc:"Arithmetic Function",ctor:Ss,rasterArgumentNames:["rasters"]}),W.set("Aspect",{desc:"Aspect Function",ctor:js,rasterArgumentNames:["raster"]}),W.set("BandArithmetic",{desc:"Band Arithmetic Function",ctor:lr,rasterArgumentNames:["raster"]}),W.set("Colormap",{desc:"Colormap Function",ctor:Fr,rasterArgumentNames:["raster"]}),W.set("ColormapToRGB",{desc:"ColormapToRGB Function",ctor:Tr,rasterArgumentNames:["raster"]}),W.set("CompositeBand",{desc:"CompositeBand Function",ctor:Ir,rasterArgumentNames:["rasters"]}),W.set("ComputeChange",{desc:"ComputeChange Function",ctor:Zr,rasterArgumentNames:["rasters"]}),W.set("Convolution",{desc:"Convolution Function",ctor:$r,rasterArgumentNames:["raster"]}),W.set("ContrastBrightness",{desc:"Contrast Brightness Function",ctor:zr,rasterArgumentNames:["raster"]}),W.set("ExtractBand",{desc:"ExtractBand Function",ctor:Yr,rasterArgumentNames:["raster"]}),W.set("Curvature",{desc:"Curvature Function",ctor:Kr,rasterArgumentNames:["raster"]}),W.set("Hillshade",{desc:"Hillshade Function",ctor:io,rasterArgumentNames:["raster"]}),W.set("ShadedRelief",{desc:"ShadedRelief Function",ctor:yo,rasterArgumentNames:["raster"]}),W.set("Grayscale",{desc:"Grayscale Function",ctor:so,rasterArgumentNames:["raster"]}),W.set("Clip",{desc:"Clip Function",ctor:dr,rasterArgumentNames:["raster"]}),W.set("Local",{desc:"Local Function",ctor:uo,rasterArgumentNames:["rasters"]}),W.set("Mask",{desc:"Mask Function",ctor:co,rasterArgumentNames:["raster"]}),W.set("NDVI",{desc:"NDVI Function",ctor:mo,rasterArgumentNames:["raster"]}),W.set("Remap",{desc:"Remap Function",ctor:go,rasterArgumentNames:["raster"]}),W.set("Slope",{desc:"Slope Function",ctor:_o,rasterArgumentNames:["raster"]}),W.set("Statistics",{desc:"Focal Statistics Function",ctor:Po,rasterArgumentNames:["raster"]}),W.set("StatisticsHistogram",{desc:"Statistics Histogram Function",ctor:Ro,rasterArgumentNames:["raster"]}),W.set("Stretch",{desc:"Stretch Function",ctor:Bo,rasterArgumentNames:["raster"]}),W.set("Table",{desc:"Attribute Table Function",ctor:So,rasterArgumentNames:["raster"]})}}]);