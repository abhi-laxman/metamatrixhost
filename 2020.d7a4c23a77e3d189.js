"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[2020],{81396:(mt,W,G)=>{G.d(W,{c:()=>w});var k=G(62257);function w(b,A){const d=b.getGeometryType();return d===k.G.enumPoint?b:(0,k.h)(d)?function i(b){if(function I(b){for(let A=0,d=b.getPathCount();A<d;A++){const q=b.getPathSize(A);if(0===q||1===q&&(0===b.getSegmentCountPath(A)||b.getSegmentType(b.getPathStart(A))===k.G.enumLine||!b.isClosedPath(A)))return!1}return!0}(b))return b;const A=b.createInstance();for(let d=0,q=b.getPathCount();d<q;d++){const X=b.getPathSize(d);if(0!==X){if(1===X&&(0===b.getSegmentCountPath(d)||b.getSegmentType(b.getPathStart(d))===k.G.enumLine||!b.isClosedPath(d)))continue;A.addPath(b,d,!0)}}return A}(b):(d===k.G.enumMultiPoint||d===k.G.enumEnvelope||d===k.G.enumMultipatch&&(0,k.b)("not implemented for multipatch"),b)}},22020:(mt,W,G)=>{G.r(W),G.d(W,{OperatorGeodesicBuffer:()=>ft});var k=G(1469),w=G(62257),T=G(87571),i=G(3037),D=G(8189),I=G(95944),b=G(7085),A=G(23558),d=G(33165),q=G(83875),X=G(81396),at=G(9279);class ut{constructor(t){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=t}bufferPolygon(t){const s=new I.a,e=new st(this,t,s);return this.processGnomonicBufferPiecesCursor(!0,e)}bufferPolyline(t){const s=new st(this,t,null);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferMultiPoint(t){const s=new lt(this,t);return this.processGnomonicBufferPiecesCursor(!1,s)}bufferPoint(t){const s=t.getXY();s.scale(this.m_rpu);let e=new I.a;if(this.bufferPoint2D(s,!1,e)){const a=(0,b.b)(null,e,!0);e=(0,i.y)(e,a,!0,!0,-1,this.m_progressTracker,0,!1)}return e=(new i.v).foldInto360RangeGeodetic(e,this.m_gcs,2),e}processGnomonicBufferPiecesCursor(t,s){const e=s;let a=e.getGnomonic();const m=(0,i.z)((0,i.A)());let r=new i.L,o=(new i.h).executeMany(r,m,this.m_progressTracker,2);const n=(0,d.d)(6,!1),_=(0,d.m)(T.J,6);this.initializeGrid(n,_);const h=[null,null,null,null,null,null],l=[null,null,null,null,null,null],u=[null,null,null,null,null,null];let f,c,g;for(;null!==(f=e.next());){if(c=e.getGnomonic(),c!==a){if(null!==a){let P=o.next();if(r=null,o=null,null!=P){const v=(0,b.b)(m,P,!0),y=(0,b.d)(v);P=a.unproject(P,y,this.m_progressTracker),this.putInGridCursors(t,P,m,!0,n,_,h,l,u)}}null!==c&&(r=new i.L,o=(new i.h).executeMany(r,m,this.m_progressTracker,2)),a=c}if(e.isRunningInGnomonic()){if(c.project(f),e.needsSimplify()){const P=(0,b.b)(null,f,!0);f=(0,i.y)(f,P,!0,!0,-1,this.m_progressTracker,0,!1)}r.tick(Y(f)),o.tock()}else this.putInGridCursors(t,f,m,!0,n,_,h,l,u)}let p=!1;for(let P=0;P<6;P++)if(null!=u[P]){p=!0;break}if(p){let P=!1;const v=[null,null,null,null,null,null];if(t){const C=e.m_densified;if(e.m_densified=null,null!==C){const S=new A.T;S.scale(1/this.m_rpu,1/this.m_rpu),C.applyTransformation(S),this.m_distance>0?this.putInGridCursors(t,C,m,!1,n,_,h,l,u):(this.processInGrid(t,C,!1,n,_,h,v),P=!0)}}const y=new i.L,E=(new i.h).executeMany(y,this.m_gcs,this.m_progressTracker,2);if(null!==o){let C=o.next();r=null,o=null;const S=(0,b.b)(m,C,!0),N=(0,b.d)(S);C=a.unproject(C,N,this.m_progressTracker),this.putInGridCursors(t,C,m,!0,n,_,h,l,u)}for(let C=0;C<6;C++)if(null!=u[C]){let S=u[C].next();u[C]=null,l[C]=null,P&&null!==v[C]&&(S=(new i.e).execute(v[C],S,m,this.m_progressTracker));const N=(0,b.b)(m,S,!0),M=(0,b.d)(N);S=h[C].unproject(S,M,this.m_progressTracker),S=(new i.g).execute(S,this.m_gcs,!0,this.m_progressTracker),y.tick(Y(S)),E.tock()}g=E.next()}else{let P,v=!1;if(t){let S=e.m_densified;if(e.m_densified=null,null!==S){const N=new A.T;N.scale(1/this.m_rpu,1/this.m_rpu),S.applyTransformation(N),c.project(S);const M=(0,b.b)(null,S,!0);S=(0,i.y)(S,M,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(r.tick(Y(S)),o.tock()):(P=S,v=!0)}}let y=o.next();r=null,o=null,v&&(y=(new i.e).execute(P,y,m,this.m_progressTracker));const E=(0,b.b)(m,y,!0),C=(0,b.d)(E);g=a.unproject(y,C,this.m_progressTracker),g=(new i.g).execute(g,this.m_gcs,!0,this.m_progressTracker)}return g=(new i.v).foldInto360RangeGeodetic(g,this.m_gcs,2),g}putInGridCursors(t,s,e,a,m,r,o,n,_){const h=[null,null,null,null,null,null];this.processInGrid(t,s,a,m,r,o,h);for(let l=0;l<6;l++)null!==h[l]&&(null===n[l]&&(n[l]=new i.L,_[l]=(new i.h).executeMany(n[l],e,this.m_progressTracker,2)),n[l].tick(Y(h[l])),_[l].tock())}processInGrid(t,s,e,a,m,r,o){const _=this.insertGeodeticPointsAlongGrid(s,m,.01);for(let h=0;h<6;h++){if(a[h])continue;const l=m[h].clone();l.inflateCoords(.01,.01);const u=(0,b.e)(s,l),f=(0,b.a)(null,u,!1).total();let c=(0,q.c)(_,l,f,Number.NaN,this.m_progressTracker);if(null!==c&&!c.isEmpty()){if(c===_&&(c=c.clone()),null===r[h]){const p=new d.P;p.setCoords(0,h<3?1:-1);const P=new d.P;P.setAdd(m[h].getCenter(),p),r[h]=B(this.m_gcs,P)}r[h].project(c);const g=(0,b.b)(null,c,!0);c=(0,i.y)(c,g,e,!0,-1,this.m_progressTracker,0,!1),o[h]=c}}}insertGeodeticPointsAlongGrid(t,s,e){const a=T.J.construct(s[3].xmin,s[3].ymin,s[2].xmax,s[2].ymax),m=(0,i.B)(this.m_gcs,a,t,!0,this.m_progressTracker),r=new I.E,o=r.addGeometry(m);return(0,i.D)(r,o,this.m_gcs,0,2,!0,s[0].xmax+e),(0,i.D)(r,o,this.m_gcs,0,2,!0,s[1].xmax+e),(0,i.D)(r,o,this.m_gcs,0,2,!1,s[1].ymin+e),0!==e&&((0,i.D)(r,o,this.m_gcs,0,2,!0,s[0].xmax-e),(0,i.D)(r,o,this.m_gcs,0,2,!0,s[1].xmax-e),(0,i.D)(r,o,this.m_gcs,0,2,!1,s[1].ymin-e)),r.getGeometry(o)}initializeGrid(t,s){for(let e=0;e<6;e++)t[e]=!1;s[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),s[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),s[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),s[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),s[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),s[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,s,e,a,m,r){const o=t[0],n=t.at(-1),h=o.y>n.y?o.y:n.y,l=i.t.q(this.m_a,this.m_eSquared,o.y<n.y?o.y:n.y),u=i.t.q(this.m_a,this.m_eSquared,h);if(this.m_q90-(l+s+this.m_absDistance)>.001&&this.m_q90+(u-s-this.m_absDistance)>.001)return!1;const f=e-d.l,c=a+d.l,g=f-Math.PI,p=f+Math.PI,P=c+Math.PI,v=[Number.NaN],y=[Number.NaN],E=[Number.NaN],C=[Number.NaN];let S=!1;if(V(this.m_a,this.m_eSquared,0,this.m_absDistance,o,f,g,n,c,v,y),V(this.m_a,this.m_eSquared,0,this.m_absDistance,n,P,c,o,g,E,C),(c<v[0]&&v[0]<P||c<y[0]&&y[0]<P)&&(S=!0),S||(g<E[0]&&E[0]<f||g<C[0]&&C[0]<f)&&(S=!0),!S&&m)return!1;const N=[];for(let R=t.length-1;R>=0;R--)N.push(t[R]);r.setEmpty(),r.addPathPoint2D(null,0,!0);let M=0;M=K(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,t,f,c,m,M,r),M=z(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,n,c,P,this.m_cornerStep,m,M,r,v[0],y[0]),M=K(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,N,P,p,m,M,r),M=z(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,g,f,this.m_cornerStep,m,M,r,E[0],C[0]);let O=!1;return m||(O=this.checkAndPrepForPole(r)),S||O}bufferPoint2D(t,s,e){e.setEmpty(),e.addPathPoint2D(null,0,!0),z(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,t,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,s,0,e);let m=!1;return s||(m=this.checkAndPrepForPole(e)),m}checkAndPrepForPole(t){const s=this.checkAndPrepForPoleTouch(t),e=this.checkAndPrepForPoleWrap(t);return s||e}checkAndPrepForPoleTouch(t){const s=new T.J;return t.queryEnvelope(s),!(!(0,i.P)(s.ymax,this.m_gcs90)&&!(0,i.P)(s.ymin,-this.m_gcs90)||(this.prepPoleTouch(t),0))}checkAndPrepForPoleWrap(t){const s=t.getXY(0),e=t.getXY(t.getPointCount()-1);return Math.abs(s.x-e.x)>this.m_gcs180?(this.prepSinglePoleWrap(t),!0):this.checkAndPrepForDoublePoleWrap(t)}checkAndPrepForDoublePoleWrap(t){return t.calculateArea2D()<0&&(this.prepDoublePoleWrap(t),!0)}prepPoleTouch(t){const s=new I.a;s.insertPath2D(-1,null,0,0,!0);const e=t.getPathStart(0),a=t.getPathEnd(0),m=a-e;let r=-1;for(r=e;r<a;r++){const h=t.getXY(r),l=(0,i.P)(h.y,this.m_gcs90),u=(0,i.P)(h.y,-this.m_gcs90);if(!l&&!u)break}let o=r,n=!1,_=Number.NaN;do{const h=t.getXY(o),l=(0,i.P)(h.y,this.m_gcs90),u=(0,i.P)(h.y,-this.m_gcs90),f=e+(o+1-e)%m;if(l||u){let c=d.P.construct(_,h.y);s.insertPoint2D(0,-1,c);const g=t.getXY(f),p=(0,i.P)(g.y,this.m_gcs90),P=(0,i.P)(g.y,-this.m_gcs90);p||P||(c=d.P.construct(g.x,h.y),n?s.setXY(s.getPointCount()-1,c):s.insertPoint2D(0,-1,c)),n=!0}else s.insertPoint2D(0,-1,h),_=h.x,n=!1;o=f}while(o!==r);t.setEmpty(),t.add(s,!1)}prepSinglePoleWrap(t){const s=new I.a,e=new I.a,a=new A.T,m=t.getXY(t.getPathStart(0)),r=t.getXY(t.getPathEnd(0)-1),o=this.m_gcs360,n=this.m_gcs180,_=new T.J;_.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const h=new T.J;t.queryEnvelope(h);const l=Math.ceil(h.width()/o);let u,f;m.x>r.x?(u=-o,f=this.m_gcs90):(u=o,f=-this.m_gcs90),a.setShiftCoords(u,0),s.addPath(t,0,!0),e.add(s,!1);const c=new b.P;for(let F=0;F<l;F++)e.applyTransformation(a),e.getPointByVal(0,c),s.lineToPoint(c),s.addSegmentsFromPath(e,0,0,e.getSegmentCount()-1,!1);const g=s.getXY(0),p=s.getXY(s.getPointCount()-1);g.y=f,p.y=f,s.lineTo(p);const P=new d.P;for(P.setCoordsPoint2D(p),P.x-=.5*u;Math.abs(P.x-g.x)>n;)s.lineTo(P),P.x-=.5*u;s.lineTo(g);const v=_.getCenterX(),y=new T.J;s.queryEnvelope(y);let E=0;const C=y.getCenter().x;C-v>n?E=-Math.ceil((C-v-n)/o):v-C>n&&(E=Math.ceil((v-C-n)/o)),0!==E&&(a.setShiftCoords(E*o,0),s.applyTransformation(a));const S=new I.E,N=S.addGeometry(s);(0,i.D)(S,N,this.m_gcs,0,2,!0,_.xmin),(0,i.D)(S,N,this.m_gcs,0,2,!0,_.xmax);const M=S.getGeometry(N),O=(0,b.e)(M,_);O.inflateCoords(0,1);const R=(0,b.a)(null,O,!0).total(),J=(0,q.c)(M,_,R,Number.NaN,this.m_progressTracker);t.setEmpty(),t.add(J,!1)}prepDoublePoleWrap(t){const s=this.m_gcs360,e=this.m_gcs180,a=new T.J;a.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const m=a.getCenter().x,r=new T.J;t.queryPathEnvelope(0,r);let o,n=0,_=r.getCenter().x;if(_-m>e?n=-Math.ceil((_-m-e)/s):m-_>e&&(n=Math.ceil((m-_-e)/s)),0!==n){const f=new A.T;f.setShiftCoords(n*s,0),t.getImpl().applyTransformationToPath(f,0),t.queryPathEnvelope(0,r),_=r.getCenter().x}const h=new T.J;a.containsExclusiveEnvelope(r)?(o=!1,h.setCoords({env2D:a})):(o=!0,h.setCoords({env2D:a}),h.xmin-=s,h.xmax+=s);let l=t.createInstance();l.addPathPoint2D(null,0,!0);const u=new d.P;if(u.setCoords(h.xmin,h.ymin),l.insertPoint2D(0,-1,u),u.setCoords(h.xmin,h.ymax),l.insertPoint2D(0,-1,u),u.setCoords(.5*(h.xmin+h.xmax),h.ymax),l.insertPoint2D(0,-1,u),u.setCoords(h.xmax,h.ymax),l.insertPoint2D(0,-1,u),u.setCoords(h.xmax,h.ymin),l.insertPoint2D(0,-1,u),u.setCoords(.5*(h.xmin+h.xmax),h.ymin),l.insertPoint2D(0,-1,u),o){l.addPath(t,0,!0);const f=new A.T;f.setShiftCoords(_<m?s:-s,0),t.getImpl().applyTransformationToPath(f,0),l.addPath(t,0,!0);const c=new I.E,g=c.addGeometry(l);(0,i.D)(c,g,this.m_gcs,0,2,!0,a.xmin),(0,i.D)(c,g,this.m_gcs,0,2,!0,a.xmax),l=c.getGeometry(g);const p=(0,b.e)(l,a);p.inflateCoords(0,1);const P=(0,b.a)(null,p,!0).total();l=(0,q.c)(l,a,P,Number.NaN,this.m_progressTracker)}else l.addPath(t,0,!0);t.setEmpty(),t.add(l,!1)}setMinCornerStep(){const t={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);const e=new d.P;e.setCoords(0,10*this.m_rpu);const a=0;let m=45*this.m_rpu;const r=(0,D.b)(t,new d.S(new i.E,new i.E),!1),o=(0,D.b)(t,new d.S(new i.E,new i.E),!1),n=(0,D.b)(t,new d.S(new i.E,new i.E),!1),_=(0,D.b)(t,new d.S(new i.E,new i.E),!1),h=new d.P,l=new d.P,u=new d.P,f=new d.P;for(i.F.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,a,r.at(0),r.at(1)),h.setCoords(r.at(0).val,r.at(1).val),i.F.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,m,o.at(0),o.at(1)),l.setCoords(o.at(0).val,o.at(1).val);;){const p={stack:[],error:void 0,hasError:!1};try{i.F.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,.5*(a+m),n.at(0),n.at(1)),u.setCoords(n.at(0).val,n.at(1).val);const v=(0,D.b)(p,new i.E,!1),y=(0,D.b)(p,new i.E,!1);i.F.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,l.x,l.y,v,y,null,2),i.F.geodeticCoordinate(this.m_a,this.m_eSquared,h.x,h.y,.5*v.val,y.val,_.at(0),_.at(1),2),f.setCoords(_.at(0).val,_.at(1).val);const E=(0,D.b)(p,new i.E,!1);if(i.F.geodeticDistance(this.m_a,this.m_eSquared,u.x,u.y,f.x,f.y,E,null,null,2),E.val<=this.m_convergenceOffset)break;m*=.9,i.F.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,m,o.at(0),o.at(1)),l.setCoords(o.at(0).val,o.at(1).val)}catch(P){p.error=P,p.hasError=!0}finally{(0,D.c)(p)}}const g=2*Math.PI/Math.ceil(2*Math.PI/(m-a));this.m_cornerStep=g}catch(s){t.error=s,t.hasError=!0}finally{(0,D.c)(t)}}setMinSegmentStep(){const t={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);const e=new d.P,a=new d.P;e.setCoords(0,10*this.m_rpu),a.setCoords(10*this.m_rpu,10*this.m_rpu);const m=(0,D.b)(t,new i.E,!1),r=(0,D.b)(t,new i.E,!1),o=(0,D.b)(t,new i.E,!1);i.F.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,a.x,a.y,o,m,r,this.m_curveType);const n=(0,D.b)(t,new d.S(new i.E,new i.E),!1),_=(0,D.b)(t,new d.S(new i.E,new i.E),!1),h=new d.P,l=(0,D.b)(t,new i.E,!1),u=(0,D.b)(t,new d.S(new i.E,new i.E),!1),f=(0,D.b)(t,new d.S(new i.E,new i.E),!1),c=(0,D.b)(t,new d.S(new i.E,new i.E),!1),g=(0,D.b)(t,new d.S(new i.E,new i.E),!1),p=new d.P,P=new d.P,v=new d.P,y=new d.P,E=0;let C=1;const S=m.val,M=S-.5*Math.PI,O=r.val+.5*Math.PI,R=o.val;for(i.F.geodesicCoordinate(this.m_a,this.m_eSquared,e.x,e.y,s,M,u.at(0),u.at(1)),p.setCoords(u.at(0).val,u.at(1).val),i.F.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,s,O,f.at(0),f.at(1)),P.setCoords(f.at(0).val,f.at(1).val);;){const F={stack:[],error:void 0,hasError:!1};try{i.F.geodeticCoordinate(this.m_a,this.m_eSquared,e.x,e.y,.5*(E+C)*R,S,n.at(0),n.at(1),this.m_curveType),h.setCoords(n.at(0).val,n.at(1).val),i.F.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,h.x,h.y,null,null,l,this.m_curveType);const dt=l.val+.5*Math.PI;i.F.geodesicCoordinate(this.m_a,this.m_eSquared,h.x,h.y,s,dt,c.at(0),c.at(1)),v.setCoords(c.at(0).val,c.at(1).val);const it=(0,D.b)(F,new i.E,!1),rt=(0,D.b)(F,new i.E,!1);i.F.geodeticDistance(this.m_a,this.m_eSquared,p.x,p.y,P.x,P.y,it,rt,null,2),i.F.geodeticCoordinate(this.m_a,this.m_eSquared,p.x,p.y,.5*it.val,rt.val,g.at(0),g.at(1),2),y.setCoords(g.at(0).val,g.at(1).val);const ot=(0,D.b)(F,new i.E,!1);if(i.F.geodeticDistance(this.m_a,this.m_eSquared,v.x,v.y,y.x,y.y,ot,null,null,2),ot.val<=this.m_convergenceOffset)break;{const L={stack:[],error:void 0,hasError:!1};try{C*=.9,i.F.geodeticCoordinate(this.m_a,this.m_eSquared,e.x,e.y,C*R,S,_.at(0),_.at(1),this.m_curveType),a.setCoords(_.at(0).val,_.at(1).val);const j=(0,D.b)(L,new i.E,!1);i.F.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,a.x,a.y,null,null,j,this.m_curveType);const gt=j.val+.5*Math.PI;i.F.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,s,gt,f.at(0),f.at(1)),P.setCoords(f.at(0).val,f.at(1).val)}catch(j){L.error=j,L.hasError=!0}finally{(0,D.c)(L)}}}catch(H){F.error=H,F.hasError=!0}finally{(0,D.c)(F)}}let J=C*R;J>1e5&&(J=1e5),this.m_segmentStep=J}catch(s){t.error=s,t.hasError=!0}finally{(0,D.c)(t)}}setConvergenceOffset(){let t;t=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/t<500&&(t=this.m_absDistance/500),t<.01&&(t=.01),this.m_convergenceOffset=t}}function U(x,t,s,e,a,m,r){if(x.isEmpty())return new I.a({vd:x.getDescription()});let o=x;if((0,w.j)(o)){const p=10*t.getTolerance(0);o=(new at.O).execute(o,0,p,0,r,12e3)}const n=new ut(r);n.m_sr=t,n.m_gcs=t.getGCS(),n.m_transform=(0,i.p)(t,n.m_gcs,null);const _=(0,i.G)();n.m_gcs.querySpheroidData(_);const h=new T.J;o.queryEnvelope(h),n.m_a=_.majorSemiAxis,n.m_eSquared=_.e2,n.m_rpu=n.m_gcs.getUnit().getUnitToBaseFactor(),n.m_gcs90=.5*Math.PI/n.m_rpu,n.m_gcs180=Math.PI/n.m_rpu,n.m_gcs360=2*Math.PI/n.m_rpu,n.m_gcs60=n.m_gcs360/6,n.m_q90=i.t.q90(n.m_a,n.m_eSquared),n.m_ellipticToGeodesicMaxRatio=.5*n.m_a*Math.PI/n.m_q90;const l=n.m_gcs.getTolerance(0);n.m_radTolerance=l*n.m_rpu,4===s?(n.m_curveType=2,n.m_bShapePreserving=!0):(n.m_curveType=s,n.m_bShapePreserving=!1),n.m_distance=e,n.m_absDistance=Math.abs(e),Number.isNaN(a)||a<=0?n.setConvergenceOffset():n.m_convergenceOffset=Math.max(a,.001),n.m_convergenceOffset/=m;let u,f=o.getGeometryType();if((0,w.f)(f)){const p=new I.P({vd:o.getDescription()});p.addSegment(o,!0),u=p,f=w.G.enumPolyline}else if(f===w.G.enumEnvelope){const p=o,P=new T.J;p.queryEnvelope(P);const v=(0,b.d)((0,b.a)(n.m_sr,h,!0));if(P.minDimension()<=v)if(0===P.maxDimension()){const y=new b.P({vd:o.getDescription()});p.getCenter(y),u=y,f=w.G.enumPoint}else{const y=new I.P({vd:o.getDescription()});y.addEnvelope(p,!1),u=y,f=w.G.enumPolyline}else{const y=new I.a({vd:o.getDescription()});y.addEnvelope(p,!1),u=y,f=w.G.enumPolygon}}else u=o;if(n.setMinCornerStep(),(0,w.e)(f)||n.setMinSegmentStep(),n.m_absDistance<=.5*n.m_convergenceOffset)return f!==w.G.enumPolygon?new I.a({vd:u.getDescription()}):n.m_bShapePreserving?u:(0,i.u)(u,n.m_sr,n.m_curveType,n.m_segmentStep,-1,r);if(n.m_distance<0&&f!==w.G.enumPolygon)return new I.a({vd:u.getDescription()});if(n.m_bShapePreserving&&(0,w.h)(f)){const p=(0,i.u)(u,t,4,Number.NaN,n.m_convergenceOffset,r);u=(new i.v).execute(p,n.m_transform,r)}else u=(new i.v).execute(u,n.m_transform,r);if(u=(0,i.w)(u,n.m_gcs),u.isEmpty())return new I.a({vd:u.getDescription()});!n.m_bShapePreserving&&(0,w.h)(f)&&(u=(0,i.x)(n.m_rpu,u)),u=function ct(x,t){const s=x.getGeometryType();let e;if(e=(0,w.h)(s)?x.getPathCount():s===w.G.enumMultiPoint?x.getPointCount():1,1===e)return x;const a=[],m=[];for(let o=0;o<e;o++){a.push(o);const n=new d.P;if((0,w.h)(s)){const h=new T.J;x.queryPathEnvelope(o,h),n.assign(h.getCenter())}else n.assign(x.getXY(o));const _=t.toGeohash(n);m.push(_)}a.sort((o,n)=>m[o]<m[n]?-1:m[o]>m[n]?1:0);const r=x.createInstance();for(let o=0;o<e;o++){const n=a[o];(0,w.h)(s)?r.addPath(x,n,!0):r.addPoints(x,n,n+1)}return r}(u,n.m_gcs);let c=new I.a;switch(f){case w.G.enumPolygon:c=n.bufferPolygon(u);break;case w.G.enumPolyline:c=n.bufferPolyline(u);break;case w.G.enumMultiPoint:c=n.bufferMultiPoint(u);break;case w.G.enumPoint:c=n.bufferPoint(u);break;default:(0,w.k)("")}const g=(new i.v).execute(c,n.m_transform.getInverse(),r);return g.mergeVertexDescription(u.getDescription()),g}function K(x,t,s,e,a,m,r,o,n,_,h){const l={stack:[],error:void 0,hasError:!1};try{const u=new d.P;u.setNAN(),n||h.getPointCount()>0&&(u.setCoordsPoint2D(h.getXY(h.getPointCount()-1)),u.scale(s));const f=(0,D.b)(l,new i.E,!1),c=(0,D.b)(l,new d.S(new i.E,new i.E),!1),g=new d.P,p=new d.P,P=m.at(-1),v=1/s;for(let y=0;y<m.length;y++){const E=m[y];let C;0===y?C=r:y===m.length-1?C=o:(i.F.geodeticDistance(x,t,P.x,P.y,E.x,E.y,null,null,f,a),C=f.val-.5*Math.PI),i.F.geodesicCoordinate(x,t,E.x,E.y,e,C,c.at(0),c.at(1)),n?p.setCoords(c.at(0).val,c.at(1).val):(g.setCoords(c.at(0).val,c.at(1).val),_=Q(E.x,g.x,u.x,_),p.setCoords(_+g.x,g.y),u.setCoordsPoint2D(p)),p.scale(v),h.insertPoint2D(0,-1,p)}return _}catch(u){l.error=u,l.hasError=!0}finally{(0,D.c)(l)}}function z(x,t,s,e,a,m,r,o,n,_,h,l=Number.NaN,u=Number.NaN){const f={stack:[],error:void 0,hasError:!1};try{if(r-m<o)return _;const c=(0,D.b)(f,new d.S(new i.E,new i.E),!1),g=new d.P,p=new d.P,P=new d.P;p.setNAN(),n||h.getPointCount()>0&&(p.setCoordsPoint2D(h.getXY(h.getPointCount()-1)),p.scale(s));let v=Math.ceil(m/o),y=v++*o;y===m&&(y=v++*o);let E=m;const C=1/s;for(;y<r+o&&(E<l&&l<y?(y=l,v--):E<u&&u<y&&(y=u,v--),!(y>=r));)i.F.geodesicCoordinate(x,t,a.x,a.y,e,y,c.at(0),c.at(1)),n?P.setCoords(c.at(0).val,c.at(1).val):(g.setCoords(c.at(0).val,c.at(1).val),_=Q(a.x,g.x,p.x,_),P.setCoords(_+g.x,g.y),p.setCoordsPoint2D(P)),P.scale(C),h.insertPoint2D(0,-1,P),E=y,y=v++*o;return _}catch(c){f.error=c,f.hasError=!0}finally{(0,D.c)(f)}}function V(x,t,s,e,a,m,r,o,n,_,h){const l={stack:[],error:void 0,hasError:!1};try{const u=new d.P,f=new d.P,c=(0,D.b)(l,new d.S(new i.E,new i.E),!1);i.F.geodesicCoordinate(x,t,a.x,a.y,e,m,c.at(0),c.at(1)),u.setCoords(c.at(0).val,c.at(1).val),i.F.geodesicCoordinate(x,t,a.x,a.y,e,r,c.at(0),c.at(1)),f.setCoords(c.at(0).val,c.at(1).val);const g=(0,D.b)(l,new i.E,!1);for(i.F.geodeticDistance(x,t,o.x,o.y,u.x,u.y,null,g,null,0),_[0]=g.val,i.F.geodeticDistance(x,t,o.x,o.y,f.x,f.y,null,g,null,0),h[0]=g.val;_[0]<=h[0];)_[0]+=d.k;for(;_[0]>h[0];)_[0]-=d.k;for(;_[0]>=n;)_[0]-=d.k,h[0]-=d.k;for(;_[0]<n;)_[0]+=d.k,h[0]+=d.k}catch(u){l.error=u,l.hasError=!0}finally{(0,D.c)(l)}}function Q(x,t,s,e){if(Number.isNaN(s)){for(;e+t-x>Math.PI;)e-=d.k;for(;x-(e+t)>Math.PI;)e+=d.k;return e}return e+t-s>Math.PI?e-=d.k:s-(e+t)>Math.PI&&(e+=d.k),e}function Z(x,t,s,e,a,m){const r={stack:[],error:void 0,hasError:!1};try{if(e>=m)return!1;const o=s[0],n=s.at(-1),_=(0,D.b)(r,new i.E,!1),h=(0,D.b)(r,new i.E,!1),l=(0,D.b)(r,new i.E,!1);i.F.greatEllipticDistance(x,t,a.x,a.y,o.x,o.y,_,null,null),i.F.greatEllipticDistance(x,t,a.x,a.y,n.x,n.y,h,null,null),i.F.greatEllipticDistance(x,t,o.x,o.y,n.x,n.y,l,null,null);let u=Math.min(_.val,h.val)+l.val,f=u+e;if(f<m)return!0;const c=(0,D.b)(r,new i.E,!1);u=Math.max(_.val,h.val);for(let g=1;g<s.length-1;g++){const p=s[g];i.F.greatEllipticDistance(x,t,a.x,a.y,p.x,p.y,c,null,null),c.val>u&&(u=c.val)}return f=u+e,f<m}catch(o){r.error=o,r.hasError=!0}finally{(0,D.c)(r)}}function $(x,t,s,e,a,m,r,o){let n;if(e.length%2==0){const l=e.length>>1;n=d.P.lerp(e[l],e[l-1],.5)}else n=e[e.length-1>>1].clone();const _=n.clone(),h=(0,i.I)(x,t,_,75/180*Math.PI);return!!Z(x,t,e,a,_,h)&&(null!==m&&(m.setCoordsPoint2D(n),m.scale(1/s)),null!==r&&r.setCoordsPoint2D(_),null!==o&&(o[0]=h),!0)}function tt(x,t,s,e,a,m){const r={stack:[],error:void 0,hasError:!1};try{if(e>=m)return!1;const o=(0,D.b)(r,new i.E,!1);return i.F.greatEllipticDistance(x,t,a.x,a.y,s.x,s.y,o,null,null),o.val+e<m}catch(o){r.error=o,r.hasError=!0}finally{(0,D.c)(r)}}function B(x,t){return new i.H(x,t)}function Y(x){return(0,b.f)(x,0)||(0,b.s)(x,0),x}class et{constructor(t){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new d.P,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=t}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class st extends et{constructor(t,s,e){super(t.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new I.a,this.m_densifiedPoints=[],this.m_bufferer=t,this.m_multiPath=s,this.m_densified=e,this.m_bNeedsSimplify=!0;const a=new T.J;this.m_multiPath.queryEnvelope(a);const m=a.getCenter(),r=m.clone();r.scale(this.m_bufferer.m_rpu),this.m_gnomonic=B(this.m_bufferer.m_gcs,m),this.m_gnomonicCenterRad=r.clone(),this.m_minGnomonicRadius=(0,i.I)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,r,75/180*Math.PI)}next(){let t;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t;if(null===this.m_segIter){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;null!==this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;null!=this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}let s=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;let a=0;const m=new d.P,r=new d.P;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<16;){const o=this.m_segIter.nextSegment();if(m.setCoordsPoint2D(o.getStartXY()),r.setCoordsPoint2D(o.getEndXY()),m.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),(0,i.J)(m,r))m.x=r.x;else if((0,i.K)(m,r))r.x=m.x;else{let _=-1,h=-1;const l=this.m_segIter.getPathIndex(),u=this.m_multiPath.getPathStart(l),f=this.m_multiPath.getPathEnd(l);if(_=this.m_segIter.getStartPointIndex()-1,h=this.m_segIter.getEndPointIndex()+1,_<u&&(_=this.m_multiPath.isClosedPath(l)?f-1:-1),h>f-1&&(h=this.m_multiPath.isClosedPath(l)?u:-1),-1!==_){const c=this.m_multiPath.getXY(_);c.scale(this.m_bufferer.m_rpu),(0,i.K)(c,m)&&(m.x=c.x)}if(-1!==h){const c=this.m_multiPath.getXY(h);c.scale(this.m_bufferer.m_rpu),(0,i.J)(r,c)&&(r.x=c.x)}}this.m_densifiedPoints.length=0;const n=(0,i.M)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,m,r,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(0===a)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if($(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(0===n||(0,i.N)(m,r)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(m,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(n,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),null===s&&(s=new I.a,s.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(s),a++}if(this.m_currentDensifiedDelta=[0],a>0){const o=this.m_segIter.getStartPointIndex(),n=this.m_segIter.getPathIndex();for(;a>0;){if(this.m_segIter.previousSegment(),m.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),m.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if((0,i.J)(m,r))m.x=r.x;else if((0,i.K)(m,r))r.x=m.x;else{let _=-1,h=-1;const l=this.m_segIter.getPathIndex(),u=this.m_multiPath.getPathStart(l),f=this.m_multiPath.getPathEnd(l);if(_=this.m_segIter.getStartPointIndex()-1,h=this.m_segIter.getEndPointIndex()+1,_<u&&(_=this.m_multiPath.isClosedPath(l)?f-1:-1),h>f-1&&(h=this.m_multiPath.isClosedPath(l)?u:-1),-1!==_){const c=this.m_multiPath.getXY(_);c.scale(this.m_bufferer.m_rpu),(0,i.K)(c,m)&&(m.x=c.x)}if(-1!==h){const c=this.m_multiPath.getXY(h);c.scale(this.m_bufferer.m_rpu),(0,i.J)(r,c)&&(r.x=c.x)}}this.m_densifiedPoints.length=0,(0,i.M)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,r,m,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(s),a--}return m.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),m.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,m,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,s),this.m_segIter.resetToVertex(o,n),this.m_segIter.nextSegment(),s}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),t=this.m_bufferHelper.clone(),t}isSegmentBufferInCurrentGnomonic(t){return null!==this.m_gnomonic&&Z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){const s=new d.P,e=new d.P,a=[0];return $(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,e,a)?(this.m_gnomonicCenterRad.setCoordsPoint2D(e),this.m_minGnomonicRadius=a[0],this.m_gnomonic=B(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(t,s){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,t,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,s)}addJoinAndBufferLeftSide(t){const s=this.m_densifiedPoints[0];let e=Number.NaN,a=this.m_startAzimuth[0]-d.l;const m=this.m_endAzimuth[0]+d.l;let r=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(e=this.m_lastAzimuth+d.l,a=e+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(e=this.m_lastAzimuth+d.l,a=e+Math.PI-(d.k-(this.m_startAzimuth[0]-this.m_lastAzimuth))),r=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI||this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let o=!1;if(Math.abs(a-e)<=.5*this.m_bufferer.m_cornerStep&&(r||(o=!0)),o){if(t.removePointFromPath(0,t.getPointCount()-1),!this.m_bRunningInGnomonic){const n=new d.P;n.setCoordsPoint2D(t.getXY(t.getPointCount()-1)),n.scale(this.m_bufferer.m_rpu),n.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=d.k:n.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=d.k)}a=.5*(a+e)}else if(r){const n=new d.P;n.setCoordsPoint2D(s),n.scale(1/this.m_bufferer.m_rpu),t.insertPoint2D(0,-1,n)}else z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],e,a,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,K(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,a,m,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_lastAzimuth=this.m_endAzimuth[0]}}class lt extends et{constructor(t,s){super(t.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=t,this.m_multiPoint=s,this.m_bNeedsSimplify=!1;const e=new T.J;this.m_multiPoint.queryEnvelope(e);const a=e.getCenter(),m=a.clone();m.scale(this.m_bufferer.m_rpu),this.m_gnomonic=B(this.m_bufferer.m_gcs,a),this.m_gnomonicCenterRad=m.clone(),this.m_minGnomonicRadius=(0,i.I)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,m,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const t=this.m_multiPoint.getXY(this.m_pointIndex);t.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(t),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(t));const s=new I.a,e=this.m_bufferer.bufferPoint2D(t,this.m_bRunningInGnomonic,s);return this.m_bNeedsSimplify=e,s}isPointBufferInCurrentGnomonic(t){return null!==this.m_gnomonic&&tt(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(t){const s=new d.P,e=new d.P,a=[0];return function _t(x,t,s,e,a,m,r,o){const n=(0,i.I)(x,t,e,.4166666666666667*Math.PI);return!!tt(x,t,e,a,e,n)&&(null!==m&&(m.setCoordsPoint2D(e),m.scale(1/s)),null!==r&&r.setCoordsPoint2D(e),null!==o&&(o[0]=n),!0)}(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,t,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,e,a)?(this.m_gnomonicCenterRad.setCoordsPoint2D(e),this.m_minGnomonicRadius=a[0],this.m_gnomonic=B(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}}class ft{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(t,s,e){return!1}canAccelerateGeometry(t){return!1}executeMany(t,s,e,a,m,r,o,n){if(o){const _=new nt(t,s,e,a,m,!1,r,n);return(new i.h).executeMany(_,s,n)}return new nt(t,s,e,a,m,!1,r,n)}execute(t,s,e,a,m,r,o){const n=new k.S([t]),h=this.executeMany(n,s,e,[a],m,!1,r,o).next();return h||(0,w.c)("geodesic buffer null output"),h}}class nt extends k.G{constructor(t,s,e,a,m,r,o,n){super(),this.m_currentUnionEnvelope2D=new T.J,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=n,r&&(0,w.b)(""),s||(0,w.t)(""),0===s.getCoordinateSystemType()&&(0,w.t)(""),this.m_inputGeoms=t,this.m_spatialReference=s,this.m_curveType=e,this.m_distances=a,this.m_convergenceOffset=m,this.m_bOutlineOnly=r,this.m_bUnion=o}next(){let t;for(;t=this.m_inputGeoms.next();)return(0,w.d)(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(t,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(t,s){return function ht(x,t,s,e,a,m){e<Number.MAX_VALUE&&e>-Number.MAX_VALUE||(0,w.t)("Geodesic_bufferer.buffer - bad distance"),(0,w.d)(x);const r=(0,X.c)(x),o=r.getGeometryType();if((0,w.i)(o)){const n=r.getPointCount(),_=8e6;if(Math.abs(e)>_&&(n>50||o!==w.G.enumMultiPoint&&4===s&&n>2)){let h=r;const l=e>0?1:-1,u=7e6;let f=e,c=1;do{c++,f=(Math.abs(f)-u)*l}while(Math.abs(f)>_);f=e;for(let g=0;g<c-1;g++)h=U(h,t,s,u*l,a,c,m),f=(Math.abs(f)-u)*l;return h=U(h,t,s,f,a,c,m),h}}return U(r,t,s,e,a,1,m)}(t,this.m_spatialReference,this.m_curveType,s,this.m_convergenceOffset,this.m_progressTracker)}}}}]);