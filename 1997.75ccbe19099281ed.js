"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[1997,9557],{11445:(ot,q,F)=>{F.d(q,{Qf:()=>C,Qh:()=>R,RS:()=>D,ez:()=>j,i5:()=>K,lM:()=>U,qK:()=>A});var Q=F(79139);const D=16;function U(E){if(!E)return 0;let B=A;for(const g in E)E.hasOwnProperty(g)&&(B+=S(E[g],!1));return B}function R(E){if(!E)return 0;if("number"==typeof E[0])return C(E);if(Array.isArray(E))return function v(E){const B=E.length;if(0===B||"number"==typeof E[0])return x(E,8);let g=j;for(let I=0;I<B;I++)g+=S(E[I]);return g}(E);let B=A;for(const g in E)E.hasOwnProperty(g)&&(B+=S(E[g]));return B}function S(E,B=!0){switch(typeof E){case"object":return B?R(E):A;case"string":return function k(E){return 32+E.length}(E);case"number":return D;case"boolean":return 4;default:return 8}}function C(...E){return E.reduce((B,g)=>B+(g?(0,Q.iu)(g)?g.byteLength+K:Array.isArray(g)?x(g,D):0:0),0)}function x(E,B){return j+E.length*B}const A=32,j=16,K=145},721:(ot,q,F)=>{function k(l){return l?{originPosition:"upper-left"===l.originPosition?"upperLeft":"lower-left"===l.originPosition?"lowerLeft":l.originPosition,scale:l.tolerance?[l.tolerance,l.tolerance,1,1]:[1,1,1,1],translate:null!=l.extent?[l.extent.xmin,l.extent.ymax,l.extent.zmin??0,l.extent.mmin??0]:[0,0,0,0]}:null}function U(l){if(function D(l){return"lowerLeft"===l.originPosition&&4===l.scale.length&&4===l.translate.length}(l))return l;const{originPosition:s,scale:a,translate:_}=l,T=a[1]??1;return{originPosition:"lowerLeft",scale:[a[0]??1,"lowerLeft"===s?T:-T,a[2]??1,a[3]??1],translate:[_[0]??0,_[1]??0,_[2]??0,_[3]??0]}}function R({scale:l,translate:s},a){return Math.round((a-s[0])/l[0])}function v({scale:l,translate:s},a){return Math.round((a-s[1])/l[1])}function S({scale:l,translate:s},a){return Math.round(((a??0)-s[2])/l[2])}function C({scale:l,translate:s},a){return a?Math.round((a-s[3])/l[3]):0}function x(l,s){return l&&s?E:l&&!s?j:!l&&s?K:A}F.d(q,{$X:()=>It,B2:()=>v,Gy:()=>lt,IE:()=>R,P5:()=>Mt,Q1:()=>U,QE:()=>st,SW:()=>yt,Tr:()=>_t,VV:()=>k,wp:()=>it}),F(61320);const A=(l,s)=>{const a=[];if(!s.length)return null;const _=s[0];let N=R(l,_[0]),T=v(l,_[1]);a.push([N,T]);for(let G=1;G<s.length;G++){const[V,H]=s[G],X=R(l,V),W=v(l,H);X===N&&W===T||a.push([X-N,W-T]),N=X,T=W}return a},j=(l,s)=>{const a=[];if(!s.length)return null;const _=s[0];let N=R(l,_[0]),T=v(l,_[1]),G=S(l,_[2]);a.push([N,T,G]);for(let V=1;V<s.length;V++){const[H,X,W]=s[V],$=R(l,H),nt=v(l,X),rt=S(l,W);$===N&&nt===T&&rt===G||a.push([$-N,nt-T,rt]),N=$,T=nt,G=rt}return a},K=(l,s)=>{const a=[];if(!s.length)return null;const _=s[0];let N=R(l,_[0]),T=v(l,_[1]),G=C(l,_[2]);a.push([N,T,G]);for(let V=1;V<s.length;V++){const[H,X,W]=s[V],$=R(l,H),nt=v(l,X),rt=C(l,W);$===N&&nt===T&&rt===G||a.push([$-N,nt-T,rt]),N=$,T=nt,G=rt}return a},E=(l,s)=>{const a=[];if(!s.length)return null;const _=s[0];let N=R(l,_[0]),T=v(l,_[1]),G=S(l,_[2]),V=C(l,_[3]);a.push([N,T,G,V]);for(let H=1;H<s.length;H++){const[X,W,$,nt]=s[H],rt=R(l,X),ct=v(l,W),dt=S(l,$),pt=C(l,nt);rt===N&&ct===T&&dt===G&&pt===V||a.push([rt-N,ct-T,dt,pt]),N=rt,T=ct,G=dt,V=pt}return a};function O({scale:l,translate:s},a){return a*l[0]+s[0]}function Y({scale:l,translate:s},a){return a*l[1]+s[1]}function L({scale:l,translate:s},a){return(a??0)*l[2]+s[2]}function d({scale:l,translate:s},a){return a?a*l[3]+s[3]:0}function M(l,s){return l&&s?u:l&&!s?w:!l&&s?tt:P}const P=(l,s)=>{const a=new Array(s.length);if(!s.length)return a;const _=s[0];let N=O(l,_[0]),T=Y(l,_[1]);a[0]=[N,T];const{scale:G,originPosition:V}=l,H=G[0],X="lowerLeft"===V?G[1]:-G[1];for(let W=1;W<s.length;W++){const[$,nt]=s[W];N+=H*$,T+=X*nt,a[W]=[N,T]}return a},w=(l,s)=>{const a=new Array(s.length);if(!s.length)return a;const _=s[0];let N=O(l,_[0]),T=Y(l,_[1]);a[0]=[N,T,L(l,_[2])];const{scale:G,originPosition:V}=l,H=G[0],X="lowerLeft"===V?G[1]:-G[1];for(let W=1;W<s.length;W++){const[$,nt,rt]=s[W];N+=H*$,T+=X*nt,a[W]=[N,T,L(l,rt)]}return a},tt=(l,s)=>{const a=new Array(s.length);if(!s.length)return a;const _=s[0];let N=O(l,_[0]),T=Y(l,_[1]);a[0]=[N,T,d(l,_[2])];const{scale:G,originPosition:V}=l,H=G[0],X="lowerLeft"===V?G[1]:-G[1];for(let W=1;W<s.length;W++){const[$,nt,rt]=s[W];N+=H*$,T+=X*nt,a[W]=[N,T,d(l,rt)]}return a},u=(l,s)=>{const a=new Array(s.length);if(!s.length)return a;const _=s[0];let N=O(l,_[0]),T=Y(l,_[1]);a[0]=[N,T,L(l,_[2]),d(l,_[3])];const{scale:G,originPosition:V}=l,H=G[0],X="lowerLeft"===V?G[1]:-G[1];for(let W=1;W<s.length;W++){const[$,nt,rt,ct]=s[W];N+=H*$,T+=X*nt,a[W]=[N,T,L(l,rt),d(l,ct)]}return a};function b(l,s,a){const _=new Array(a.length);for(let N=0;N<a.length;N++)_[N]=s(l,a[N]);return _}function lt(l,s,a){const _=U(l);return s.x=R(_,a.x),s.y=v(_,a.y),null!=a.z&&(s.z=S(_,a.z)),null!=a.m&&(s.m=C(_,a.m)),s}function it(l,s,a){const _=function g(l,s,a,_){const N=[],T=x(a,_);for(let G=0;G<s.length;G++){const V=T(l,s[G]);V&&V.length>=3&&N.push(V)}return N.length?N:null}(U(l),a.rings,a.hasZ,a.hasM);return _?(s.rings=_,s.hasZ=a.hasZ??!1,s.hasM=a.hasM??!1,s):null}function st(l,s,a){const _=function I(l,s,a,_){const N=[],T=x(a,_);for(let G=0;G<s.length;G++){const V=T(l,s[G]);V&&V.length>=2&&N.push(V)}return N.length?N:null}(U(l),a.paths,a.hasZ,a.hasM);return _?(s.paths=_,s.hasZ=a.hasZ??!1,s.hasM=a.hasM??!1,s):null}function yt(l,s,a,_=a?.hasZ??!1,N=a?.hasM??!1){if(null!=a){const T=U(l);s.points=M(_,N)(T,a.points),s.hasZ=_,s.hasM=N}return s}function _t(l,s,a,_=null!=a?.z,N=null!=a?.m){if(null==a)return s;const T=U(l);return s.x=O(T,a.x),s.y=Y(T,a.y),_&&(s.z=L(T,a.z)),N&&(s.m=d(T,a.m)),s}function It(l,s,a,_=a?.hasZ??!1,N=a?.hasM??!1){if(null!=a){const T=U(l);s.rings=b(T,M(_,N),a.rings),s.hasZ=_,s.hasM=N}return s}function Mt(l,s,a,_=a?.hasZ??!1,N=a?.hasM??!1){if(null!=a){const T=U(l);s.paths=b(T,M(_,N),a.paths),s.hasZ=_,s.hasM=N}return s}},42086:(ot,q,F)=>{F.d(q,{N3:()=>R,Om:()=>U});var Q=F(11445),k=F(27999),D=F(13682);class U{constructor(C=null,x={},A,j,K=0){this.geometry=C,this.attributes=x,this.centroid=A,this.objectId=j,this.displayId=K}static fromJSON(C){const x=C.geometry?D.A.fromJSON(C.geometry):null,A=C.centroid?D.A.fromJSON(C.centroid):null;return new U(x,C.attributes,A,C.objectId)}weakClone(){const C=new U(this.geometry,this.attributes,this.centroid,this.objectId);return C.displayId=this.displayId,C}clone(){const C=this.geometry?.clone(),x=new U(C,{...this.attributes},this.centroid?.clone(),this.objectId);return x.displayId=this.displayId,x}ensureCentroid(C){return this.centroid??=(0,k.Q)(new D.A,this.geometry,C.hasZ,C.hasM),this.centroid}get usedMemory(){return 128+(0,Q.lM)(this.attributes)+(this.geometry?.usedMemory??0)}}function R(S){return!!S.geometry?.coords?.length}},61808:(ot,q,F)=>{F.d(q,{A:()=>Q});class Q{constructor(){this.objectIdFieldName=null,this.globalIdFieldName=null,this.geohashFieldName=null,this.geometryProperties=null,this.geometryType=null,this.spatialReference=null,this.hasZ=!1,this.hasM=!1,this.features=[],this.fields=[],this.transform=null,this.exceededTransferLimit=!1,this.uniqueIdField=null,this.queryGeometryType=null,this.queryGeometry=null}weakClone(){const D=new Q;return D.objectIdFieldName=this.objectIdFieldName,D.globalIdFieldName=this.globalIdFieldName,D.geohashFieldName=this.geohashFieldName,D.geometryProperties=this.geometryProperties,D.geometryType=this.geometryType,D.spatialReference=this.spatialReference,D.hasZ=this.hasZ,D.hasM=this.hasM,D.features=this.features,D.fields=this.fields,D.transform=this.transform,D.exceededTransferLimit=this.exceededTransferLimit,D.uniqueIdField=this.uniqueIdField,D.queryGeometry=this.queryGeometry,D.queryGeometryType=this.queryGeometryType,D}}},13682:(ot,q,F)=>{F.d(q,{A:()=>D});var Q=F(11445);class D{constructor(R=[],v=[]){this.lengths=R??[],this.coords=v??[]}static fromJSON(R){return new D(R.lengths,R.coords)}static fromRect(R){const[v,S,C,x]=R,A=C-v,j=x-S;return new D([5],[v,S,A,0,0,j,-A,0,0,-j])}get isPoint(){return 0===this.lengths.length&&this.coords.length>=2}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((R,v)=>R+v)}get usedMemory(){return 64+(0,Q.Qf)(this.lengths,this.coords)}area(){let R=0,v=0;if(!this.lengths.length)return 0;for(let S=0;S<this.lengths.length;S++){const C=this.lengths[S];if(C<3)continue;let x=this.coords[2*v],A=this.coords[2*v+1];for(let j=1;j<C;j+=1){const K=this.coords[2*(j+v)],E=this.coords[2*(j+v)+1];R+=-.5*(K-x)*(E+A),x=K,A=E}v+=C}return R}forEachVertex(R){let v=0;this.lengths.length||R(this.coords[0],this.coords[1]);for(let S=0;S<this.lengths.length;S++){const C=this.lengths[S];for(let x=0;x<C;x++)R(this.coords[2*(x+v)],this.coords[2*(x+v)+1]);v+=C}}deltaDecode(){const R=this.clone(),{coords:v,lengths:S}=R;let C=0;for(const x of S){for(let A=1;A<x;A++)v[2*(C+A)]+=v[2*(C+A)-2],v[2*(C+A)+1]+=v[2*(C+A)-1];C+=x}return R}clone(R){if(0===this.lengths.length)return new D([],[this.coords[0],this.coords[1]]);const v=2*(0===this.lengths.length?1:this.lengths.reduce((C,x)=>C+x)),S=this.coords.slice(0,v);return R?(R.set(S),new D(this.lengths,R)):new D(Array.from(this.lengths),Array.from(S))}}},27999:(ot,q,F)=>{function Q(x,A){return x?A?4:3:A?3:2}function k(x,A,j,K){if(!A?.lengths.length)return null;x.lengths.length&&(x.lengths.length=0),x.coords.length&&(x.coords.length=0);const E=x.coords,B=[],g=j?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:I,coords:O}=A,Y=Q(j,K);let L=0;for(const d of I){const M=D(g,O,L,d,j,K);M&&B.push(M),L+=d*Y}if(B.sort((d,M)=>{let P=d[2]-M[2];return 0===P&&j&&(P=d[4]-M[4]),P}),B.length){let d=6*B[0][2];E[0]=B[0][0]/d,E[1]=B[0][1]/d,j&&(d=6*B[0][4],E[2]=0!==d?B[0][3]/d:0),(E[0]<g[0]||E[0]>g[1]||E[1]<g[2]||E[1]>g[3]||j&&(E[2]<g[4]||E[2]>g[5]))&&(E.length=0)}if(!E.length){const d=A.lengths[0]?function U(x,A,j,K,E){const B=Q(K,E);let g=A,I=A+B,O=0,Y=0,L=0,d=0;for(let M=0,P=j-1;M<P;M++,g+=B,I+=B){const w=x[g],tt=x[g+1],u=x[g+2],b=x[I],Z=x[I+1],z=x[I+2],J=K?v(w,tt,u,b,Z,z):R(w,tt,b,Z);if(J)if(O+=J,K){const et=C(w,tt,u,b,Z,z);Y+=J*et[0],L+=J*et[1],d+=J*et[2]}else{const et=S(w,tt,b,Z);Y+=J*et[0],L+=J*et[1]}}return O>0?K?[Y/O,L/O,d/O]:[Y/O,L/O]:j>0?K?[x[A],x[A+1],x[A+2]]:[x[A],x[A+1]]:null}(O,0,I[0],j,K):null;if(!d)return null;E[0]=d[0],E[1]=d[1],j&&d.length>2&&(E[2]=d[2])}return x}function D(x,A,j,K,E,B){const g=Q(E,B);let I=j,O=j+g,Y=0,L=0,d=0,M=0,P=0;for(let tt=0,u=K-1;tt<u;tt++,I+=g,O+=g){const b=A[I],Z=A[I+1],z=A[I+2],J=A[O],et=A[O+1],ut=A[O+2];let at=b*et-J*Z;M+=at,Y+=(b+J)*at,L+=(Z+et)*at,E&&(at=b*ut-J*z,d+=(z+ut)*at,P+=at),b<x[0]&&(x[0]=b),b>x[1]&&(x[1]=b),Z<x[2]&&(x[2]=Z),Z>x[3]&&(x[3]=Z),E&&(z<x[4]&&(x[4]=z),z>x[5]&&(x[5]=z))}if(M>0&&(M*=-1),P>0&&(P*=-1),!M)return null;const w=[Y,L,.5*M];return E&&(w[3]=d,w[4]=.5*P),w}function R(x,A,j,K){const E=j-x,B=K-A;return Math.sqrt(E*E+B*B)}function v(x,A,j,K,E,B){const g=K-x,I=E-A,O=B-j;return Math.sqrt(g*g+I*I+O*O)}function S(x,A,j,K){return[x+.5*(j-x),A+.5*(K-A)]}function C(x,A,j,K,E,B){return[x+.5*(K-x),A+.5*(E-A),j+.5*(B-j)]}F.d(q,{Q:()=>k})},94782:(ot,q,F)=>{F.d(q,{CI:()=>v,fk:()=>S}),F(3248);var k=F(69287),D=F(58701);function v(g,I){return g===I||null!=g&&null!=I&&(0,D.aI)(g.spatialReference,I.spatialReference)&&g.x===I.x&&g.y===I.y&&g.z===I.z&&g.m===I.m}function S(g,I,O){return g===I||null!=g&&null!=I&&(0,D.aI)(g.spatialReference,I.spatialReference)&&(0,k.Sp)(g.x,I.x,O)&&(0,k.Sp)(g.y,I.y,O)&&(0,k.Sp)(g.z??0,I.z??0,O)&&(0,k.Sp)(g.m??0,I.m??0,O)}},3782:(ot,q,F)=>{F.d(q,{HP:()=>j,N3:()=>K,RW:()=>w,Uz:()=>tt,gR:()=>O,iQ:()=>P,jy:()=>E,w9:()=>M}),F(3248);var k=F(11445),U=(F(32034),F(2296)),R=F(51995),x=(F(721),F(6434),F(29141),F(18622));F(94782);class j{constructor(b,Z,z){this.uid=b,this.geometry=Z,this.attributes=z,this.visible=!0,this.objectId=null,this.centroid=null}}function K(u){return null!=u.geometry}class E{constructor(){this.exceededTransferLimit=!1,this.features=[],this.fields=[],this.hasM=!1,this.hasZ=!1,this.geometryType=null,this.objectIdFieldName=null,this.globalIdFieldName=null,this.geometryProperties=null,this.geohashFieldName=null,this.spatialReference=null,this.transform=null}}function O(u){if(null==u)return 0;switch(u.type){case"point":return k.qK+10+8+24;case"polyline":case"polygon":{let b=0;const Z=2+(u.hasZ?1:0)+(u.hasM?1:0),z="polyline"===u.type?u.paths:u.rings;if(("polyline"===u.type?u.curvePaths:u.curveRings)?.length){const et=3*(0,x.B1)()*128;b=8*et*Z+128*et+32*(z.length+1)}else b=(0,k.Qh)(z);return k.qK+64+b+34}case"multipoint":{const b=(0,k.Qh)(u.points);return k.qK+b+64+34+32}case"extent":return k.qK+10+64+34;case"mesh":{const b=u.vertexAttributes;return k.qK+(0,k.Qf)(b.position,b.normal,b.uv,b.tangent)}default:return k.qK}}function M(u,b){switch((0,U.Ie)(b),"mesh"===u.type&&(u=u.extent),u.type){case"point":b[0]=b[3]=u.x,b[1]=b[4]=u.y,u.hasZ&&(b[2]=b[5]=u.z);break;case"polyline":for(let Z=0;Z<u.paths.length;Z++)(0,U.Jf)(b,u.paths[Z],!!u.hasZ);break;case"polygon":for(let Z=0;Z<u.rings.length;Z++)(0,U.Jf)(b,u.rings[Z],!!u.hasZ);break;case"multipoint":(0,U.Jf)(b,u.points,!!u.hasZ);break;case"extent":b[0]=u.xmin,b[1]=u.ymin,b[3]=u.xmax,b[4]=u.ymax,null!=u.zmin&&(b[2]=u.zmin),null!=u.zmax&&(b[5]=u.zmax)}}function P(u,b){switch((0,R.Ie)(b),"mesh"===u.type&&(u=u.extent),u.type){case"point":b[0]=b[2]=u.x,b[1]=b[3]=u.y;break;case"polyline":for(let Z=0;Z<u.paths.length;Z++)(0,R.Jf)(b,u.paths[Z]);break;case"polygon":for(let Z=0;Z<u.rings.length;Z++)(0,R.Jf)(b,u.rings[Z]);break;case"multipoint":(0,R.Jf)(b,u.points);break;case"extent":b[0]=u.xmin,b[1]=u.ymin,b[2]=u.xmax,b[3]=u.ymax}}function w(u,b){return null!=u.objectId?u.objectId:u.attributes&&b?u.attributes[b]:null}function tt(u,b,Z,z){if(b?.size&&null!=Z&&u)for(const J in u){if(!b.has(J))continue;const et=u[J];"string"==typeof et&&et.length>Z&&(z(J),u[J]="")}}},18622:(ot,q,F)=>{F.d(q,{B1:()=>D,ab:()=>R,bR:()=>U,mK:()=>k});var Q=F(3248);function k(){return(0,Q.A)("curve-densification-coarse-segments")}function D(){return(0,Q.A)("curve-densification-max-segments")}function U(){return(0,Q.A)("curve-densification-min-segments")}function R(){return(0,Q.A)("curve-densification-pixels-per-segment")}},86377:(ot,q,F)=>{F.r(q),F.d(q,{default:()=>Y});var Q=F(69690),k=F(33894),D=F(32034),U=F(23743),R=F(3782),v=F(31732),S=F(29141);function C(L,d){return d}function x(L,d,M,P){switch(M){case 0:return E(L,d+P,0);case 1:return"lowerLeft"===L.originPosition?E(L,d+P,1):function B({translate:L,scale:d},M,P){return L[P]-M*d[P]}(L,d+P,1)}}function A(L,d,M,P){return 2===M?E(L,d,2):x(L,d,M,P)}function j(L,d,M,P){return 2===M?E(L,d,3):x(L,d,M,P)}function K(L,d,M,P){return 3===M?E(L,d,3):A(L,d,M,P)}function E({translate:L,scale:d},M,P){return L[P]+M*d[P]}class g{constructor(d){this._options=d,this.geometryTypes=["point","multipoint","polyline","polygon"],this._previousCoordinate=[0,0],this._transform=null,this._applyTransform=C,this._lengths=[],this._currentLengthIndex=0,this._toAddInCurrentPath=0,this._vertexDimension=0,this._coordinateBuffer=null,this._coordinateBufferPtr=0,this._attributesConstructor=class{},this._missingAttributes=[]}get missingAttributes(){return this._missingAttributes}createFeatureResult(){return new R.jy}finishFeatureResult(d){if(this._options.applyTransform&&(d.transform=null),this._attributesConstructor=class{},this._coordinateBuffer=null,this._lengths.length=0,!d.hasZ)return;const M=(0,U.N)(d.geometryType,this._options.sourceSpatialReference,d.spatialReference);if(null!=M)for(const P of d.features)M(P.geometry)}createSpatialReference(){return new D.A}addField(d,M){d.fields.push(S.A.fromJSON(M));const P=d.fields.map(w=>w.name);this._attributesConstructor=function(){for(const w of P)this[w]=null}}addFeature(d,M){(0,R.Uz)(M.attributes,this._options.maxStringAttributeFields,this._options.maxStringAttributeLength,tt=>{const u=M.attributes[d.objectIdFieldName];null!=u&&this._missingAttributes.push({objectId:u,attribute:tt})}),d.features.push(M)}addQueryGeometry(d,M){const{queryGeometry:P,queryGeometryType:w}=M,tt=this._transform?(0,v.Ch)(P.clone(),P,!1,!1,this._transform):P.clone(),u=(0,v.zv)(tt,w,!1,!1);switch(w){case"esriGeometryPoint":u.type="point";break;case"esriGeometryPolygon":u.type="polygon";break;case"esriGeometryPolyline":u.type="polyline";break;case"esriGeometryMultipoint":u.type="multipoint"}d.queryGeometryType=w,d.queryGeometry=u}prepareFeatures(d){switch(this._transform=d.transform??null,this._options.applyTransform&&d.transform&&(this._applyTransform=this._deriveApplyTransform(d)),this._vertexDimension=2,d.hasZ&&this._vertexDimension++,d.hasM&&this._vertexDimension++,d.geometryType){case"point":this.addCoordinate=(M,P,w)=>this.addCoordinatePoint(M,P,w),this.createGeometry=M=>this.createPointGeometry(M);break;case"polygon":this.addCoordinate=(M,P,w)=>this._addCoordinatePolygon(M,P,w),this.createGeometry=M=>this._createPolygonGeometry(M);break;case"polyline":this.addCoordinate=(M,P,w)=>this._addCoordinatePolyline(M,P,w),this.createGeometry=M=>this._createPolylineGeometry(M);break;case"multipoint":this.addCoordinate=(M,P,w)=>this._addCoordinateMultipoint(M,P,w),this.createGeometry=M=>this._createMultipointGeometry(M);break;case"mesh":case"extent":break;default:(0,Q.Xb)(d.geometryType)}}createFeature(){return this._lengths.length=0,this._currentLengthIndex=0,this._previousCoordinate[0]=0,this._previousCoordinate[1]=0,new R.HP((0,k.c)(),null,new this._attributesConstructor)}allocateCoordinates(){const d=this._lengths.reduce((M,P)=>M+P,0);this._coordinateBuffer=new Float64Array(d*this._vertexDimension),this._coordinateBufferPtr=0}addLength(d,M){0===this._lengths.length&&(this._toAddInCurrentPath=M),this._lengths.push(M)}createPointGeometry(d){const M={type:"point",x:0,y:0,spatialReference:d.spatialReference,hasZ:!!d.hasZ,hasM:!!d.hasM};return M.hasZ&&(M.z=0),M.hasM&&(M.m=0),M}addCoordinatePoint(d,M,P){const w=this._transform?this._applyTransform(this._transform,M,P,0):M;if(null!=w)switch(P){case 0:d.x=w;break;case 1:d.y=w;break;case 2:d.hasZ?d.z=w:d.m=w;break;case 3:d.m=w}}_transformPathLikeValue(d,M){let P=0;return M<=1&&(P=this._previousCoordinate[M],this._previousCoordinate[M]+=d),this._transform?this._applyTransform(this._transform,d,M,P):d}_addCoordinatePolyline(d,M,P){this._dehydratedAddPointsCoordinate(d.paths,M,P)}_addCoordinatePolygon(d,M,P){this._dehydratedAddPointsCoordinate(d.rings,M,P)}_addCoordinateMultipoint(d,M,P){0===P&&d.points.push([]);const w=this._transformPathLikeValue(M,P);d.points[d.points.length-1].push(w)}_createPolygonGeometry(d){return{type:"polygon",rings:[[]],spatialReference:d.spatialReference,hasZ:!!d.hasZ,hasM:!!d.hasM}}_createPolylineGeometry(d){return{type:"polyline",paths:[[]],spatialReference:d.spatialReference,hasZ:!!d.hasZ,hasM:!!d.hasM}}_createMultipointGeometry(d){return{type:"multipoint",points:[],spatialReference:d.spatialReference,hasZ:!!d.hasZ,hasM:!!d.hasM}}_dehydratedAddPointsCoordinate(d,M,P){0===P&&0==this._toAddInCurrentPath--&&(d.push([]),this._toAddInCurrentPath=this._lengths[++this._currentLengthIndex]-1,this._previousCoordinate[0]=0,this._previousCoordinate[1]=0);const w=this._transformPathLikeValue(M,P),u=this._coordinateBuffer;if(u){if(0===P){const b=this._coordinateBufferPtr*Float64Array.BYTES_PER_ELEMENT;d[d.length-1].push(new Float64Array(u.buffer,b,this._vertexDimension))}u[this._coordinateBufferPtr++]=w}}_deriveApplyTransform(d){const{hasZ:M,hasM:P}=d;return M&&P?K:M?A:P?j:x}}var I=F(78304);class O{_parseFeatureQuery(d){const M=new g(d.options),P=(0,I.m)(d.buffer,M),w={...P,spatialReference:P.spatialReference?.toJSON(),fields:P.fields?P.fields.map(tt=>tt.toJSON()):void 0,missingAttributes:M.missingAttributes};return Promise.resolve(w)}}function Y(){return new O}}}]);