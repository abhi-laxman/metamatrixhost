"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[1298],{29430:(tr,Z,T)=>{T.d(Z,{$:()=>$,IB:()=>U,Iy:()=>i,N2:()=>Y,QP:()=>hr,RH:()=>ur,Vl:()=>fr,Ws:()=>X,ZD:()=>Q,_L:()=>er,bJ:()=>q,e$:()=>rr,f6:()=>a,pW:()=>H,pf:()=>ir});var R=T(68677),z=T(89952),G=T(77806),A=(T(69287),T(53781),T(89141));function U(s){return"r"in s&&"g"in s&&"b"in s}function D(s){return"h"in s&&"s"in s&&"v"in s}function b(s){return"l"in s&&"a"in s&&"b"in s}function S(s){return"l"in s&&"c"in s&&"h"in s}const _=[[.4124,.3576,.1805],[.2126,.7152,.0722],[.0193,.1192,.9505]],v=[[3.2406,-1.5372,-.4986],[-.9689,1.8758,.0415],[.0557,-.204,1.057]];function x(s,c){const m=[];let M,p;if(s[0].length!==c.length)throw new Error("dimensions do not match");const y=s.length,I=s[0].length;let O=0;for(M=0;M<y;M++){for(O=0,p=0;p<I;p++)O+=s[M][p]*c[p];m.push(O)}return m}function E(s){const c=[s.r/255,s.g/255,s.b/255].map(M=>M<=.04045?M/12.92:((M+.055)/1.055)**2.4),m=x(_,c);return{x:100*m[0],y:100*m[1],z:100*m[2]}}function C(s){const c=x(v,[s.x/100,s.y/100,s.z/100]).map(m=>Math.min(1,Math.max(m<=.0031308?12.92*m:1.055*m**.4166666666666667-.055,0)));return{r:Math.round(255*c[0]),g:Math.round(255*c[1]),b:Math.round(255*c[2])}}function P(s){const c=[s.x/95.047,s.y/100,s.z/108.883].map(m=>m>.008856451679035631?m**.3333333333333333:7.787037037037035*m+.13793103448275862);return{l:116*c[1]-16,a:500*(c[0]-c[1]),b:200*(c[1]-c[2])}}function N(s){const c=s.l,m=[(c+16)/116+s.a/500,(c+16)/116,(c+16)/116-s.b/200].map(M=>M>6/29?M**3:3*(6/29)**2*(M-4/29));return{x:95.047*m[0],y:100*m[1],z:108.883*m[2]}}function $(s){return U(s)?s:S(s)?function or(s){return C(N(function B(s){const m=s.c,M=s.h;return{l:s.l,a:m*Math.cos(M),b:m*Math.sin(M)}}(s)))}(s):b(s)?function j(s){return C(N(s))}(s):function h(s){return"x"in s&&"y"in s&&"z"in s}(s)?C(s):D(s)?function J(s){const c=(s.h+360)%360/60,M=s.v/100*255,p=M*(s.s/100),y=p*(1-Math.abs(c%2-1));let I;switch(Math.floor(c)){case 0:I={r:p,g:y,b:0};break;case 1:I={r:y,g:p,b:0};break;case 2:I={r:0,g:p,b:y};break;case 3:I={r:0,g:y,b:p};break;case 4:I={r:y,g:0,b:p};break;case 5:case 6:I={r:p,g:0,b:y};break;default:I={r:0,g:0,b:0}}return I.r=Math.round(I.r+M-p),I.g=Math.round(I.g+M-p),I.b=Math.round(I.b+M-p),I}(s):s}function Y(s){return D(s)?s:function sr(s){const c=s.r,m=s.g,M=s.b,p=Math.max(c,m,M),y=p-Math.min(c,m,M);let I=p,O=0===y?0:p===c?(m-M)/y%6:p===m?(M-c)/y+2:(c-m)/y+4,W=0===y?0:y/I;return O<0&&(O+=6),O*=60,W*=100,I*=100/255,{h:O,s:W,v:I}}($(s))}function Q(s){return b(s)?s:function K(s){return P(E(s))}($(s))}function ur(s){return S(s)?s:function nr(s){return function L(s){const c=s.l,m=s.a,M=s.b,p=Math.sqrt(m*m+M*M);let y=Math.atan2(M,m);return y=y>0?y:y+2*Math.PI,{l:c,c:p,h:y}}(P(E(s)))}($(s))}function X(s,c){const{r:m,g:M,b:p}=c?.ignoreAlpha?s:function ar(s){let{r:c,g:m,b:M,a:p}=s;return p<1&&(c=Math.round(p*c+255*(1-p)),m=Math.round(p*m+255*(1-p)),M=Math.round(p*M+255*(1-p))),new R.A({r:c,g:m,b:M})}(s);return.2126*m+.7152*M+.0722*p}var H,s;function q(s,c=H.High){return X(s,{ignoreAlpha:!0})>c?new R.A([0,0,0,s.a]):new R.A([255,255,255,s.a])}function rr(s,c){const m=Q(s);m.l*=1-c;const M=$(m),p=s.clone();return p.setColor(M),p.a=s.a,p}function er(s,c){const m=s.clone();return m.a*=c,m}function fr(s,c){const m=Y(s);m.s*=c;const M=$(m),p=s.clone();return p.setColor(M),p.a=s.a,p}function hr(s){return R.A.toUnitRGBA(s)}function ir(s){return(0,A.fA)(s[0],s[1],s[2],s.length>3?s[3]:1)}function a(s,c){const m=R.A.toUnitRGBA(s);return m[3]*=c,m}function i(s,c,m={}){if(0===s.length||c<=0)return[];if(1===(s=s.map(M=>"string"==typeof M?new R.A(M):M)).length||1===c){const M=[],p=s[0];for(let y=0;y<c;y++)M.push(p.clone());return M}if(m.shuffle&&(s=(0,z.k4)((0,G.o8)(s),m.seed)),s.length>=c){const M=[],p=(s.length-1)/(c-1);for(let y=0;y<c;y++){const I=Math.round(y*p);M.push(s[I].clone())}return M}return function f(s,c,m={}){const M=[],p=s.length-1,y=Math.ceil((c-s.length)/p);r:for(let I=0;I<p;I++){const O=s[I],W=s[I+1];for(let F=1;F<=y;F++)if(M.push(d(O,W,F/(y+1),m)),M.length+s.length===c)break r}return[...s.map(I=>I.clone()),...(0,z.k4)(M,m.seed??1)]}(s,c,m)}(s=H||(H={}))[s.Low=160]="Low",s[s.High=225]="High";const g=(s,c)=>{const m=Math.floor(10*c())-5;return Math.min(255,Math.max(0,s+m))};function d(s,c,m,M={}){const p=s.r,y=s.g,I=s.b,W=c.g,F=c.b,V=Math.round(p+(c.r-p)*m),Mr=Math.round(y+(W-y)*m),gr=Math.round(I+(F-I)*m);if(!M.offset)return new R.A([V,Mr,gr]);const cr=(0,z.Mo)(M.seed);return new R.A([g(V,cr),g(Mr,cr),g(gr,cr)])}},721:(tr,Z,T)=>{function z(l){return l?{originPosition:"upper-left"===l.originPosition?"upperLeft":"lower-left"===l.originPosition?"lowerLeft":l.originPosition,scale:l.tolerance?[l.tolerance,l.tolerance,1,1]:[1,1,1,1],translate:null!=l.extent?[l.extent.xmin,l.extent.ymax,l.extent.zmin??0,l.extent.mmin??0]:[0,0,0,0]}:null}function w(l){if(function G(l){return"lowerLeft"===l.originPosition&&4===l.scale.length&&4===l.translate.length}(l))return l;const{originPosition:a,scale:i,translate:f}=l,d=i[1]??1;return{originPosition:"lowerLeft",scale:[i[0]??1,"lowerLeft"===a?d:-d,i[2]??1,i[3]??1],translate:[f[0]??0,f[1]??0,f[2]??0,f[3]??0]}}function k({scale:l,translate:a},i){return Math.round((i-a[0])/l[0])}function A({scale:l,translate:a},i){return Math.round((i-a[1])/l[1])}function U({scale:l,translate:a},i){return Math.round(((i??0)-a[2])/l[2])}function D({scale:l,translate:a},i){return i?Math.round((i-a[3])/l[3]):0}function b(l,a){return l&&a?v:l&&!a?h:!l&&a?_:S}T.d(Z,{$X:()=>ir,B2:()=>A,Gy:()=>q,IE:()=>k,P5:()=>lr,Q1:()=>w,QE:()=>er,SW:()=>mr,Tr:()=>pr,VV:()=>z,wp:()=>rr}),T(61320);const S=(l,a)=>{const i=[];if(!a.length)return null;const f=a[0];let g=k(l,f[0]),d=A(l,f[1]);i.push([g,d]);for(let s=1;s<a.length;s++){const[c,m]=a[s],M=k(l,c),p=A(l,m);M===g&&p===d||i.push([M-g,p-d]),g=M,d=p}return i},h=(l,a)=>{const i=[];if(!a.length)return null;const f=a[0];let g=k(l,f[0]),d=A(l,f[1]),s=U(l,f[2]);i.push([g,d,s]);for(let c=1;c<a.length;c++){const[m,M,p]=a[c],y=k(l,m),I=A(l,M),O=U(l,p);y===g&&I===d&&O===s||i.push([y-g,I-d,O]),g=y,d=I,s=O}return i},_=(l,a)=>{const i=[];if(!a.length)return null;const f=a[0];let g=k(l,f[0]),d=A(l,f[1]),s=D(l,f[2]);i.push([g,d,s]);for(let c=1;c<a.length;c++){const[m,M,p]=a[c],y=k(l,m),I=A(l,M),O=D(l,p);y===g&&I===d&&O===s||i.push([y-g,I-d,O]),g=y,d=I,s=O}return i},v=(l,a)=>{const i=[];if(!a.length)return null;const f=a[0];let g=k(l,f[0]),d=A(l,f[1]),s=U(l,f[2]),c=D(l,f[3]);i.push([g,d,s,c]);for(let m=1;m<a.length;m++){const[M,p,y,I]=a[m],O=k(l,M),W=A(l,p),F=U(l,y),V=D(l,I);O===g&&W===d&&F===s&&V===c||i.push([O-g,W-d,F,V]),g=O,d=W,s=F,c=V}return i};function P({scale:l,translate:a},i){return i*l[0]+a[0]}function N({scale:l,translate:a},i){return i*l[1]+a[1]}function L({scale:l,translate:a},i){return(i??0)*l[2]+a[2]}function B({scale:l,translate:a},i){return i?i*l[3]+a[3]:0}function K(l,a){return l&&a?sr:l&&!a?nr:!l&&a?or:j}const j=(l,a)=>{const i=new Array(a.length);if(!a.length)return i;const f=a[0];let g=P(l,f[0]),d=N(l,f[1]);i[0]=[g,d];const{scale:s,originPosition:c}=l,m=s[0],M="lowerLeft"===c?s[1]:-s[1];for(let p=1;p<a.length;p++){const[y,I]=a[p];g+=m*y,d+=M*I,i[p]=[g,d]}return i},nr=(l,a)=>{const i=new Array(a.length);if(!a.length)return i;const f=a[0];let g=P(l,f[0]),d=N(l,f[1]);i[0]=[g,d,L(l,f[2])];const{scale:s,originPosition:c}=l,m=s[0],M="lowerLeft"===c?s[1]:-s[1];for(let p=1;p<a.length;p++){const[y,I,O]=a[p];g+=m*y,d+=M*I,i[p]=[g,d,L(l,O)]}return i},or=(l,a)=>{const i=new Array(a.length);if(!a.length)return i;const f=a[0];let g=P(l,f[0]),d=N(l,f[1]);i[0]=[g,d,B(l,f[2])];const{scale:s,originPosition:c}=l,m=s[0],M="lowerLeft"===c?s[1]:-s[1];for(let p=1;p<a.length;p++){const[y,I,O]=a[p];g+=m*y,d+=M*I,i[p]=[g,d,B(l,O)]}return i},sr=(l,a)=>{const i=new Array(a.length);if(!a.length)return i;const f=a[0];let g=P(l,f[0]),d=N(l,f[1]);i[0]=[g,d,L(l,f[2]),B(l,f[3])];const{scale:s,originPosition:c}=l,m=s[0],M="lowerLeft"===c?s[1]:-s[1];for(let p=1;p<a.length;p++){const[y,I,O,W]=a[p];g+=m*y,d+=M*I,i[p]=[g,d,L(l,O),B(l,W)]}return i};function J(l,a,i){const f=new Array(i.length);for(let g=0;g<i.length;g++)f[g]=a(l,i[g]);return f}function q(l,a,i){const f=w(l);return a.x=k(f,i.x),a.y=A(f,i.y),null!=i.z&&(a.z=U(f,i.z)),null!=i.m&&(a.m=D(f,i.m)),a}function rr(l,a,i){const f=function E(l,a,i,f){const g=[],d=b(i,f);for(let s=0;s<a.length;s++){const c=d(l,a[s]);c&&c.length>=3&&g.push(c)}return g.length?g:null}(w(l),i.rings,i.hasZ,i.hasM);return f?(a.rings=f,a.hasZ=i.hasZ??!1,a.hasM=i.hasM??!1,a):null}function er(l,a,i){const f=function C(l,a,i,f){const g=[],d=b(i,f);for(let s=0;s<a.length;s++){const c=d(l,a[s]);c&&c.length>=2&&g.push(c)}return g.length?g:null}(w(l),i.paths,i.hasZ,i.hasM);return f?(a.paths=f,a.hasZ=i.hasZ??!1,a.hasM=i.hasM??!1,a):null}function mr(l,a,i,f=i?.hasZ??!1,g=i?.hasM??!1){if(null!=i){const d=w(l);a.points=K(f,g)(d,i.points),a.hasZ=f,a.hasM=g}return a}function pr(l,a,i,f=null!=i?.z,g=null!=i?.m){if(null==i)return a;const d=w(l);return a.x=P(d,i.x),a.y=N(d,i.y),f&&(a.z=L(d,i.z)),g&&(a.m=B(d,i.m)),a}function ir(l,a,i,f=i?.hasZ??!1,g=i?.hasM??!1){if(null!=i){const d=w(l);a.rings=J(d,K(f,g),i.rings),a.hasZ=f,a.hasM=g}return a}function lr(l,a,i,f=i?.hasZ??!1,g=i?.hasM??!1){if(null!=i){const d=w(l);a.paths=J(d,K(f,g),i.paths),a.hasZ=f,a.hasM=g}return a}},51298:(tr,Z,T)=>{T.r(Z),T.d(Z,{OverrideHelper:()=>b});var R=T(10467),z=T(68677),G=T(29430),w=T(77806),k=T(48218),A=T(32117),U=T(46191);const D=S=>{if(!S)return[0,0,0,0];const{r:h,g:_,b:v,a:x}=S;return[h,_,v,255*x]};class b{static findApplicableOverrides(h,_,v){if(h&&_){if(h.primitiveName){let x=!1;for(const E of v)if(E.primitiveName===h.primitiveName){x=!0;break}if(!x)for(const E of _)E.primitiveName===h.primitiveName&&v.push(E)}switch(h.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(h.effects)for(const x of h.effects)b.findApplicableOverrides(x,_,v);if(h.symbolLayers)for(const x of h.symbolLayers)b.findApplicableOverrides(x,_,v);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(h.effects)for(const x of h.effects)b.findApplicableOverrides(x,_,v);if(h.markerPlacement&&b.findApplicableOverrides(h.markerPlacement,_,v),"CIMVectorMarker"===h.type){if(h.markerGraphics)for(const x of h.markerGraphics)b.findApplicableOverrides(x,_,v),b.findApplicableOverrides(x.symbol,_,v)}else"CIMCharacterMarker"===h.type?b.findApplicableOverrides(h.symbol,_,v):"CIMHatchFill"===h.type?b.findApplicableOverrides(h.lineSymbol,_,v):"CIMPictureMarker"===h.type&&b.findApplicableOverrides(h.animatedSymbolProperties,_,v)}}}static findEffectOverrides(h,_){if(!h)return null;if("CIMGeometricEffectDashes"===h.type&&(0,A.FH)(h),!_||!h.primitiveName)return{type:"cim-effect-param",effect:h,overrides:[]};const v=(0,A.rB)(h),x=h.primitiveName,E=[];for(const C of _)C.primitiveName===x&&E.push((0,A.rB)(C));return{type:"cim-effect-param",effect:v,overrides:(0,A.pk)(E)}}static resolveSymbolOverrides(h,_,v,x,E,C,P){return(0,R.A)(function*(){if(!h?.symbol)return null;let{symbol:N,primitiveOverrides:L}=h;const B=!!L;if(!B&&!x)return N;N=(0,w.o8)(N),L=(0,w.o8)(L);let K=!0;if(_||(_={attributes:{}},K=!1),B){if(K||(L=L.filter(j=>!j.valueExpressionInfo?.expression.includes("$feature"))),P||(L=L.filter(j=>!j.valueExpressionInfo?.expression.includes("$view"))),L.length>0){const j={spatialReference:v,fields:(0,A.O2)(_.attributes),geometryType:E};yield b.createRenderExpressions(L,j),b.evaluateOverrides(L,_,E??"esriGeometryPoint",C,P)}b.applyOverrides(N,L)}return x&&b.applyDictionaryTextOverrides(N,_,x,null),N})()}static createRenderExpressions(h,_){return(0,R.A)(function*(){const v=[];for(const x of h){const E=x.valueExpressionInfo;if(!E||b._expressionToRenderExpression.has(E.expression))continue;const C=(0,k.Ad)(E.expression,_.spatialReference,_.fields);v.push(C),C.then(P=>b._expressionToRenderExpression.set(E.expression,P))}v.length>0&&(yield Promise.all(v))})()}static evaluateOverrides(h,_,v,x,E){const C={$view:{scale:E?.scale}};for(const P of h){P.value&&"object"==typeof P.value&&(0,G.IB)(P.value)&&("Color"===P.propertyName||"StrokeColor"===P.propertyName)&&(P.value=D(P.value));const N=P.valueExpressionInfo;if(!N)continue;const L=b._expressionToRenderExpression.get(N.expression);L&&(P.value=(0,U.default)(L,_,C,v,x))}}static applyDictionaryTextOverrides(h,_,v,x,E="Normal"){if(h?.type)switch(h.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const C=h.symbolLayers;if(!C)return;for(const P of C)P&&"CIMVectorMarker"===P.type&&b.applyDictionaryTextOverrides(P,_,v,x,"CIMTextSymbol"===h.type?h.textCase:E)}break;case"CIMVectorMarker":{const C=h.markerGraphics;if(!C)return;for(const P of C)P&&b.applyDictionaryTextOverrides(P,_,v,x)}break;case"CIMMarkerGraphic":{const C=h.textString;if(C&&C.includes("[")){const P=(0,A.gQ)(C,v);h.textString=(0,A.FM)(_,P,x,E)}}}}static applyOverrides(h,_,v,x){if(h.primitiveName)for(const E of _)if(E.primitiveName===h.primitiveName){const C=(0,A.YF)(E.propertyName);if(x&&x.push({cim:h,nocapPropertyName:C,value:h[C]}),v){let P=!1;for(const N of v)N.primitiveName===h.primitiveName&&(P=!0);P||v.push(E)}null!=E.value&&(h[C]=E.value)}switch(h.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(h.effects)for(const E of h.effects)b.applyOverrides(E,_,v,x);if(h.symbolLayers)for(const E of h.symbolLayers)b.applyOverrides(E,_,v,x);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(h.effects)for(const E of h.effects)b.applyOverrides(E,_,v,x);if("CIMVectorMarker"===h.type&&h.markerGraphics)for(const E of h.markerGraphics)b.applyOverrides(E,_,v,x),b.applyOverrides(E.symbol,_,v,x)}}static restoreOverrides(h){for(const _ of h)_.cim[_.nocapPropertyName]=_.value}static buildOverrideKey(h){let _="";for(const v of h)void 0!==v.value&&(_+=`${v.primitiveName}${v.propertyName}${JSON.stringify(v.value)}`);return _}static toValue(h,_){if("DashTemplate"===h)return _.split(" ").map(v=>Number(v));if("Color"===h){const v=new z.A(_).toRgba();return v[3]*=255,v}return _}}b._expressionToRenderExpression=new Map},46191:(tr,Z,T)=>{T.r(Z),T.d(Z,{default:()=>w});var R=T(5922),z=T(35150),G=T(721);function w(D,b,S,h,_){if(null==D)return null;const v=D.references("geometry")&&_?function A(D,b,S){const{transform:h,hasZ:_,hasM:v}=S;k.has(b)||k.set(b,function U(D){const b={};switch(D){case"esriGeometryPoint":return(S,h,_,v)=>(0,G.Tr)(h,b,S,_,v);case"esriGeometryPolygon":return(S,h,_,v)=>(0,G.$X)(h,b,S,_,v);case"esriGeometryPolyline":return(S,h,_,v)=>(0,G.P5)(h,b,S,_,v);case"esriGeometryMultipoint":return(S,h,_,v)=>(0,G.SW)(h,b,S,_,v);default:return z.A.getLogger("esri.views.2d.support.arcadeOnDemand").error(new R.A("mapview-arcade",`Unable to handle geometryType: ${D}`)),S=>S}}(b));const x=k.get(b)(D.geometry,h,_,v);return{...D,geometry:x}}(b,h,_):b,x=D.repurposeFeature(v);try{return D.evaluate({...S,$feature:x},D.services)}catch(E){return z.A.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:",E),null}}const k=new Map}}]);