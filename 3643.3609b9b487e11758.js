"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[3643],{84035:(ut,Z,x)=>{x.d(Z,{Y7:()=>w,HS:()=>X,mm:()=>nt,A:()=>dt,k2:()=>ct,ZA:()=>E,E8:()=>m,hF:()=>l,C5:()=>J,uK:()=>d,Pi:()=>c});var F=x(8189),U=(x(3248),x(35150)),O=x(1119),Q=x(3902);function y(L,r,n){const h=r.split("\n");for(const f of h)if(f.trim().length){{let _="";null!=n&&(_+=`/*id:${n??"000"}*/   `),L.body+=_.padEnd(14)}L.body+=" ".repeat(L.indent)+f+"\n"}}class B{write(r){for(const n of r.rootOutputNodes())r.shouldPruneOutputNode(n)||(n.variableName=this._write(r,n.node));return r}_createVarName(r,n){let h="";return"boolean"!=typeof n&&"number"!=typeof n&&n.debugInfo.name&&(h=`${n.debugInfo.name}_`),`${h}v${r.varCount++}`}_write(r,n,h=!1){if("number"==typeof n||"boolean"==typeof n)return n.toString();let f=r.getEmit(n);if(f)return f;switch(n.shaderType){case"scope-node":f=this._writeScopeNode(r,n);break;case"primitive-node":f=this._writePrimitiveNode(r,n,h);break;case"function-node":f=this._writeFunctionNode(r,n);break;case"property-access-node":f=this._writePropertyAccessNode(r,n);break;case"property-access-2d-node":f=this._writePropertyAccess2DNode(r,n);break;case"text-node":f=n.text;break;case"block-node":f=this._writeBlockNode(r,n);break;case"condition-node":f=this._writeConditionNode(r,n)}return r.setEmit(n,f),f}_writeScopeNode(r,n){const h=new n.child.constructor;h.setDebugName(n.debugInfo.name);const f=this._write(r,h,!0);return y(r,`{ /*ScopeStart: ${n.uid} ${n.debugInfo.name}*/`),r.indent+=2,y(r,`${f} = ${this._write(r,n.child)};`),r.indent-=2,y(r,`} /*ScopeEnd: ${n.uid} ${n.debugInfo.name}*/`),f}_writeConditionNode(r,n){const h=new n.ifTrue.constructor,f=this._write(r,h,!0);y(r,`if (${this._write(r,n.condition)}) {`),r.indent+=2;const _=r.createSubgraphContext(),A=this._write(_,n.ifTrue);if(r.body+=_.body,A&&y(r,`${f} = ${A};`),r.indent-=2,y(r,"}"),n.ifFalse){y(r,"else {"),r.indent+=2;const C=r.createSubgraphContext(),P=this._write(C,n.ifFalse);r.body+=C.body,P&&y(r,`${f} = ${P};`),r.indent-=2,y(r,"}")}return f}_writeBlockNode(r,n){const{captureList:h,generator:f,returnType:_}=n,A={};for(const D in h){if(!h[D])continue;const W=this._write(r,h[D]);A[D]=W}const C=new _,P=this._write(r,C,!0);if(A.out=P,n.subgraph){const D=r.createSubgraphContext(),W=this._write(D,n.subgraph.child);A.subgraph={varName:W,body:D.body}}const M=f(A);return y(r,"{\n"),r.indent+=2,y(r,M),r.indent-=2,y(r,"}\n"),P}_writePropertyAccessNode(r,n){const h=this._write(r,n.target);return"string"==typeof n.property&&n.property.includes("[")?`${h}${n.property}`:"string"!=typeof n.property?`${h}[${this._write(r,n.property)}]`:`${h}.${n.property}`}_writePropertyAccess2DNode(r,n){return`${this._write(r,n.target)}[${this._write(r,n.x)}][${this._write(r,n.y)}]`}_writeFunctionNode(r,n){const h=n.returnType.type;if(n.isInfix){const[A,C]=n.children.map(M=>this._write(r,M)),P=this._createVarName(r,n);return y(r,`${h.padEnd(5)} ${P} = ${A} ${n.token} ${C};`,n.uid),P}const f=n.children.map(A=>this._write(r,A)).join(", "),_=this._createVarName(r,n);return y(r,`${h.padEnd(5)} ${_} = ${n.token}(${f});`,n.uid),_}_writePrimitiveNode(r,n,h=!1){const f=r.getInput(n);if(f)return f.isUsed=!0,f.variableName;if(!n.isMutable&&(n.isImplicit||1===n.children.length&&n.children[0]?.type===n.type))return this._write(r,n.children[0]);const A=this._createVarName(r,n);if(h)return y(r,`${n.type.padEnd(5)} ${A};`,n.uid),A;const C=!n.debugInfo.name&&!n.isMutable;if(C&&"float"===n.type&&"number"==typeof n.children[0])return Number.isInteger(n.children[0])?n.children[0].toFixed(1):n.children[0].toString();if(C&&"int"===n.type&&"number"==typeof n.children[0]&&Number.isInteger(n.children[0]))return n.children[0].toString();const P=n.children.map(M=>this._write(r,M)).join(", ");return"array"===n.type?(y(r,`${n.type.padEnd(5)} ${A} = [${P}];`,n.uid),A):C?`${n.type}(${P})`:(y(r,`${n.type.padEnd(5)} ${A} = ${n.type}(${P});`,n.uid),A)}}var G=x(92779);class k{constructor(r,n,h){this.variableName=r,this.variableInputType=n,this.node=h,this.type="shader-input",this.isUsed=!1}clone(){return new k(this.variableName,this.variableInputType,(0,G.vA)(this.node))}}class z{constructor(r,n,h){this.outVariableName=r,this.outVariableType=n,this.node=h,this.type="shader-output"}clone(){const r=new z(this.outVariableName,this.outVariableType,(0,G.vA)(this.node));return r.variableName=this.variableName,r}}class K{static createVertex(r,n,h,f,_,A){const C=[];for(const M in r){const D=r[M],W=h.get(M);C.push(W?new k(W,"builtin",D):new k("a_"+M,"in",D))}for(const M of f)C.push(new k(M.uniformName,"uniform",M.uniformHydrated));const P=[];for(const M in n){const D=n[M];P.push("glPosition"===M?new z("gl_Position","builtin",D):"glPointSize"===M?new z("gl_PointSize","builtin",D):new z("v_"+M,"out",D))}return new K(C,P,_,A)}static createFragment(r,n,h,f,_,A){const C=[],P=Array.from(_.rootOutputNodes());for(const D in r){const W=r[D],q=h.get(D);if(q){C.push(new k(q,"builtin",W));continue}const H=P.find(ht=>ht.node===W);H&&C.push(new k(H.outVariableName,"in",W))}for(const D of f)C.push(new k(D.uniformName,"uniform",D.uniformHydrated));const M=[];for(const D in n){const W=n[D],q=h.get(D);M.push("discard"===D?new z(null,"discard",W):q?new z(q,"builtin",W):new z(D,"out",W))}return new K(C,M,A)}constructor(r,n,h,f){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const _ of r)this._inputShaderTypesByNodeUid.set(_.node.uid,_);this._outputShaderTypes=n,this._transformFeedbackBindings=h,this._transformFeedbackNames=new Set(h.map(_=>"v_"+_.propertyKey)),this._usedInFragmentShader=f}shouldPruneOutputNode(r){return!!this._usedInFragmentShader&&"builtin"!==r.outVariableType&&!this._transformFeedbackNames.has(r.outVariableName)&&!this._usedInFragmentShader.has(r.node.uid)}setEmit(r,n){this._nodeEmitMap.set(r.uid,n)}getEmit(r){return this._nodeEmitMap.get(r.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(r){return this._inputShaderTypesByNodeUid.get(r.uid)}*rootOutputNodes(){for(const r of this._outputShaderTypes)yield r}*nodes(){const r=[];for(const n of this._outputShaderTypes.values())r.push(n.node);for(;r.length;){const n=r.pop();"number"!=typeof n&&"boolean"!=typeof n&&r.push(...n.children.filter(Boolean)),yield n}}*nodesOfTypeOrFunction(){for(const r of this.nodes())"number"!=typeof r&&"boolean"!=typeof r&&(yield r)}createSubgraphContext(){const r=this.clone();return r.body="",r.indent=this.indent+2,r._nodeEmitMap=new Map(this._nodeEmitMap),r}clone(){const r=new K([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return r._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,r.indent=this.indent,r.body=this.body,r.varCount=this.varCount,r._nodeEmitMap=this._nodeEmitMap,r}insertVertexShader(r){r.vertex.code.add(""),this._insertInputs(r,"vertex"),r.vertex.code.add(""),r.vertex.code.add("// OUTPUTS: "),r.vertex.code.add("// --------------------------------------------------------- ");for(const n of this.rootOutputNodes()){const h="builtin"===n.outVariableType;this.shouldPruneOutputNode(n)||r.vertex.code.add(h?`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`:`${n.outVariableType.padEnd(10)} ${n.node.type.padEnd(9)} ${n.outVariableName};`)}r.vertex.code.add(""),r.vertex.code.add("void main() {"),r.vertex.code.add("  "+this.body.split("\n").join("\n  "));for(const n of this.rootOutputNodes())this.shouldPruneOutputNode(n)||r.vertex.code.add(`  ${n.outVariableName} = ${n.variableName};`);r.vertex.code.add("}")}insertFragmentShader(r){this._insertInputs(r,"fragment"),r.fragment.code.add(""),r.fragment.code.add("// OUTPUTS: "),r.fragment.code.add("// --------------------------------------------------------- ");let n=0;for(const h of this.rootOutputNodes())"builtin"===h.outVariableType?r.fragment.code.add(`// ${h.outVariableType.padEnd(7)} ${h.node.type.padEnd(9)} ${h.outVariableName};`):r.outputs.add(h.outVariableName,h.node.type,n++);r.fragment.code.add(""),r.fragment.code.add("void main() {"),r.fragment.code.add("  "+this.body.split("\n").join("\n  "));for(const h of this.rootOutputNodes())"discard"===h.outVariableType?(r.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),r.fragment.code.add(`  if (${h.variableName}) {`),r.fragment.code.add("    discard;"),r.fragment.code.add("  }"),r.fragment.code.add("  ")):r.fragment.code.add(`  ${h.outVariableName} = ${h.variableName};`);r.fragment.code.add("}")}_insertInputs(r,n){r[n].code.add("// INPUTS: "),r[n].code.add("// --------------------------------------------------------- ");for(const h of this.inputs())h.isUsed&&"builtin"!==h.variableInputType&&r[n].code.add("array"===h.node.type?`${h.variableInputType.padEnd(10)} ${h.node.elementType.type.padEnd(9)} ${h.variableName}[${h.node.size}];`:"array-2d"===h.node.type?`${h.variableInputType.padEnd(10)} ${h.node.elementType.type.padEnd(9)} ${h.variableName}[${h.node.size}]; // Emulated 2D Array. Not supported by ES3.0`:`${h.variableInputType.padEnd(10)} ${h.node.type.padEnd(9)} ${h.variableName};`)}}var V=x(20872),b=x(43713);function $(L){return new L}function T(L,r,n){const h=L.constructor[r]??[];L.constructor.hasOwnProperty(r)||Object.defineProperty(L.constructor,r,{value:h.slice()}),L.constructor[r].push(n)}function J(L,r){return(n,h)=>{T(n,"locations",{typeCtor:r,propertyKey:h,parameterIndex:null,index:L})}}const l=L=>(r,n,h)=>{T(r,"inputs",{inputCtor:L,propertyKey:n,parameterIndex:h})},c=L=>(r,n)=>{T(r,"uniforms",{typeCtor:L,propertyKey:n})},d=L=>(r,n)=>{T(r,"options",{typeCtor:L,propertyKey:n})},m=(L,r)=>{T(L,"defines",{propertyKey:r})},N=(L,r)=>(n,h)=>{n.constructor.builtins.push({builtin:L,propertyKey:h,typeCtor:r})};class E{}E.builtins=[],(0,F._)([N("gl_VertexID",Q.Ai)],E.prototype,"glVertexID",void 0);class w{}class X{}X.builtins=[],(0,F._)([N("gl_FragCoord",Q.Zb)],X.prototype,"glFragCoord",void 0),(0,F._)([N("gl_PointCoord",Q.ZY)],X.prototype,"glPointCoord",void 0);class nt{}(0,F._)([("gl_FragDepth",(r,n)=>{T(r,"builtins",{builtin:"gl_FragDepth",propertyKey:n})})],nt.prototype,"glFragDepth",void 0);class ct{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}class dt{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const r=this._shaderModuleClass.inputs.findLast(n=>"vertex"===n.propertyKey&&0===n.parameterIndex);if(!r)throw new Error("Unable to find vertex input parameter");return r}get computeInput(){return this._shaderModuleClass.inputs.findLast(r=>"vertex"===r.propertyKey&&1===r.parameterIndex)}get fragmentInput(){const r=this._shaderModuleClass.inputs.findLast(n=>"fragment"===n.propertyKey);if(!r)throw new Error("Unable to find fragment input parameter");return r}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const r=new Map,n=new Set;for(const h of this.locations)n.has(h.index)?U.A.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${h.propertyKey} to ${h.index}. Index already in use`,{locationsMap:r}):(r.set(h.propertyKey,h.index),n.add(h.index));return r}get locationInfo(){if(!this._locationInfo){const r=this.locationsMap,n=Array.from(r.entries()).map(([_,A])=>`${_}.${A}`).join("."),h=(0,O.Wm)(n);this._locationInfo={hash:h,stringHash:n,locations:r,computeAttributeMap:this.computeAttributes}}return this._locationInfo}get renamedLocationsMap(){const r=new Map;for(const n of this.locations)r.set("a_"+n.propertyKey,n.index);return r}get optionPropertyKeys(){if(!this._optionPropertyKeys){const r=new Set;for(const n of this._options)r.add(n.propertyKey);this._optionPropertyKeys=r}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(r,n,h,f){try{const{vertex:_,fragment:A,uniformBindings:C}=this._generateShaders(r,n,h,f);return new V.K(_,A,this.renamedLocationsMap,this.locationInfo,C,this.transformFeedbackBindings)}catch{return new V.K("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(r){const n=this._options.find(f=>f.propertyKey===r);if(n)return{type:"option",className:n.typeCtor};const h=this._uniforms.find(f=>f.propertyKey===r);if(!h)throw new Error(`Unable to find uniform class type for property: ${r}`);return{type:"required",className:h.typeCtor}}getShaderKey(r,n,h,f){const _=Object.keys(r).map(M=>`${M}.${r[M]}`).join("."),A=Object.keys(h).map(M=>`${M}.${h[M]}`).join("."),C=Object.keys(f).map(M=>`${M}.${f[M]}`).join("."),P=Object.keys(n).filter(M=>this.optionPropertyKeys.has(M)&&n[M]).join(".");return`${this.type}.${_}.${A}.${C}.${P}`}_generateShaders(r,n,h,f){const _=[];this._setDefines(h),this._setOptionalUniforms(_,n),this._setRequiredUniforms(_);const A=this._hydrateVertexInput(f),C=this._injectPackPrecisionFactor(A,r),P=this._hydrateComputeInput(),M=P&&this._injectComputePackPrecisionFactor(P,r),D=this.vertex(C,M),W=this._hydrateFragmentInput(D),q=this.fragment(W),H=new Set;for(const It in q)(0,G.rz)(H,q[It]);const ht=this._getVertexInputBuiltins(),Y=K.createVertex({...A,...P},D,ht,_,this.transformFeedbackBindings,H);(new B).write(Y);const lt=this._getFragmentInputBuiltins(q);lt.set("glPointCoord","gl_PointCoord");const pt=K.createFragment(W,q,lt,_,Y,this.transformFeedbackBindings);(new B).write(pt);const ft=this._createShaderBuilder(Y,pt),gt=ft.generate("vertex"),bt=ft.generate("fragment");return this.logShader&&(console.log(gt),console.log(bt)),{vertex:gt,fragment:bt,uniformBindings:_}}_setDefines(r){for(const n in r)this[n]=r[n]}_setOptionalUniforms(r,n){for(const h of this._options)this[h.propertyKey]=n[h.propertyKey]?this._hydrateUniformGroup(r,h):null}_setRequiredUniforms(r){for(const n of this._uniforms)this[n.propertyKey]=this._hydrateUniformGroup(r,n)}_hydrateUniformGroup(r,n){const h=new n.typeCtor;for(const f of h._uniforms??[]){const _=$(f.typeCtor),A=`u_${n.propertyKey}_${f.propertyKey}`,C=_.type,P=[n.propertyKey,f.propertyKey].join(".");r.push("type"in f.typeCtor&&"array"===f.typeCtor.type||"type"in f.typeCtor&&"array-2d"===f.typeCtor.type?{shaderModulePath:P,uniformName:A,uniformType:C,uniformArrayLength:_.size,uniformArrayElementType:_.elementType.type,uniformHydrated:_}:{shaderModulePath:P,uniformName:A,uniformType:C,uniformHydrated:_}),h[f.propertyKey]=_}return h}_hydrateVertexInput(r){const n=this.vertexInput.inputCtor,h=n.locations.reduce((f,_)=>!1===r[_.propertyKey]?f:{...f,[_.propertyKey]:$(_.typeCtor)},{});for(const{propertyKey:f,typeCtor:_}of n.builtins){const A=$(_);h[f]=A}return h}_hydrateComputeInput(){return null==this.computeInput?null:this.computeInput.inputCtor.locations.reduce((r,n)=>({...r,[n.propertyKey]:$(n.typeCtor)}),{})}_injectPackPrecisionFactor(r,n){const h={};for(const f in r){const _=r[f],A=n[f];if(A){if("float"!==_.type&&"vec2"!==_.type&&"vec3"!==_.type&&"vec4"!==_.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${_.type}`);h[f]=_.divide(new Q.nt(A))}else h[f]=_}return h}_injectComputePackPrecisionFactor(r,n){const h={},f=new Map;for(const _ in this.computeAttributes)for(const A of this.computeAttributes[_]??[])f.set(A,_);for(const _ in r){const A=r[_],C=f.get(_);if(!C)continue;const P=n[C];if(P){if("float"!==A.type&&"vec2"!==A.type&&"vec3"!==A.type&&"vec4"!==A.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${A.type}`);h[_]=A.divide(new Q.nt(P))}else h[_]=A}return h}_hydrateFragmentInput(r){const n={};for(const h in r)n[h]=r[h];for(const{propertyKey:h,typeCtor:f}of X.builtins){const _=$(f);n[h]=_}return n}_getVertexInputBuiltins(){const r=this.vertexInput.inputCtor,n=new Map;for(const{builtin:h,propertyKey:f}of r.builtins)n.set(f,h);return n}_getFragmentInputBuiltins(r){const n=r.constructor,h=new Map;for(const f of n.builtins??[])h.set(f.propertyKey,f.builtin);return h}_createShaderBuilder(r,n){const h=new b.N5;return this._insertDebugInfo(h),r.insertVertexShader(h),n.insertFragmentShader(h),h}_insertDebugInfo(r){r.vertex.code.add("// DEFINES: "),r.vertex.code.add("// --------------------------------------------------------- ");for(const n of this._defines)r.vertex.code.add(this[n.propertyKey]?`//   ${n.propertyKey}: true`:`//   ${n.propertyKey}: false`);r.vertex.code.add(""),r.vertex.code.add("// OPTIONS: "),r.vertex.code.add("// --------------------------------------------------------- ");for(const n of this._options)r.vertex.code.add(this[n.propertyKey]?`//   ${n.propertyKey}: true`:`//   ${n.propertyKey}: false`)}}},92779:(ut,Z,x)=>{function a(V,b){const $=[];for($.push(b);$.length;){const T=$.pop();if("object"==typeof T&&!V.has(T.uid)){V.add(T.uid);for(const J of T.children)$.push(J)}}}x.d(Z,{XL:()=>k,aw:()=>K,ff:()=>G,rR:()=>z,rz:()=>a,vA:()=>O,vL:()=>Q,zg:()=>B});class U{constructor(){this.uid=U.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(b){return b=function F(V){return V.split(" ").map((b,$)=>$>0?b.charAt(0).toUpperCase()+b.slice(1):b).join("")}(b),this._debugName=b,this.isImplicit&&this.children[0]instanceof U&&this.children[0].setDebugName(b),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(b){b._debugName=this._debugName,b._isMutable=this._isMutable,b.isImplicit=this.isImplicit,b.uid=this.uid}}function O(V){return"object"==typeof V?V.clone():V}U.NodeCount=0;class Q extends U{constructor(){super(...arguments),this.shaderType="primitive-node"}}class j extends U{constructor(b){super(),this.child=b,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const b=new j(O(this.child));return this.cloneInto(b),b}}class B extends U{constructor(b,$,T){super(),this.property=b,this.target=$,this.returnType=T,this.shaderType="property-access-node"}get children(){const b=[this.target];return"string"!=typeof this.property&&b.push(this.property),b}clone(){const b=new B(this.property,O(this.target),this.returnType);return this.cloneInto(b),b}}class G extends U{constructor(b,$,T,J){super(),this.x=b,this.y=$,this.target=T,this.returnType=J,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const b=new G(this.x,this.y,O(this.target),this.returnType);return this.cloneInto(b),b}}class k extends U{constructor(b,$,T){super(),this.condition=b,this.ifTrue=$,this.ifFalse=T,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const b=O(this.ifTrue),$=this.ifFalse?O(this.ifFalse):null,T=new k(this.condition,b,$);return this.cloneInto(T),T}}class z extends U{constructor(b,$,T,J){super(),this.captureList=b,this.returnType=$,this.generator=J,this.shaderType="block-node",T&&(this.subgraph=new j(T))}get children(){return Object.keys(this.captureList).map(b=>this.captureList[b]).concat(this.subgraph??[])}clone(){const b={};for(const T in this.captureList)b[T]=O(this.captureList[T]);const $=new z(b,this.returnType,this.subgraph?O(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto($),$}}class K extends U{constructor(b,$,T,J,g,l=!1){super(),this.token=b,this._children=$,this.isInfix=T,this.isPropertyAccess=J,this.returnType=g,this.isTernary=l,this.shaderType="function-node"}get children(){return this._children}clone(){const b=new K(this.token,this._children.map(O),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(b),b}}},3902:(ut,Z,x)=>{x.d(Z,{$5:()=>ie,$I:()=>It,AU:()=>xe,Ai:()=>Y,Bw:()=>_e,F8:()=>kt,Gb:()=>qt,Io:()=>pe,LC:()=>ne,LI:()=>Ae,MM:()=>se,My:()=>dt,Ny:()=>gt,Om:()=>fe,PM:()=>Ne,RI:()=>me,RZ:()=>Se,S8:()=>we,Sj:()=>te,T9:()=>ge,TF:()=>Ie,Tk:()=>Bt,U:()=>bt,US:()=>Me,Uo:()=>Ut,Wh:()=>Gt,Xe:()=>re,ZY:()=>h,Zb:()=>_,Zc:()=>Vt,aX:()=>oe,eB:()=>f,eR:()=>Xt,fV:()=>Ot,gn:()=>jt,j1:()=>Jt,jc:()=>ye,jh:()=>ve,jk:()=>be,ln:()=>Wt,lw:()=>at,mk:()=>de,n7:()=>Ee,nf:()=>ee,nt:()=>n,om:()=>Nt,or:()=>Lt,qE:()=>le,rY:()=>he,tn:()=>ae,w0:()=>Yt,x:()=>D,z7:()=>r,ze:()=>Rt,zi:()=>Te});var U,O,Q,j,y,B,G,k,z,K,V,b,$,T,F=x(8189),a=x(92779);function E(t){return new Proxy(t,{get(o,i){if("constructor"===i)return new Proxy(o.constructor,{construct:(p,S,R)=>E(new p(...S))});if(i in o)return o[i];if("string"==typeof i){const p=function N(t){const o=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const i of o)if(i.includes(t))return i.map(p=>Ft[p]);throw new Error("Unable to find type family")}(t.type);return ot(t,i,p[i.length-1])}}})}function w(t){return new Proxy(t,{construct:(o,i,p)=>E(new o(...i))})}class ct extends Error{}let dt=U=class extends a.vL{constructor(t,o){super(),this.elementType=t,this.size=o,this.children=[],this.type="array"}clone(){const t=new U(this.elementType,this.size);return super.cloneInto(t),t}get(t,o){const i=new Y(t),p=null!=o?new Y(o):null;return null!=p?St(this,i,p,function m(t){switch(t.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return D;case"float":case"vec2":case"vec3":case"vec4":return n;case"int":case"ivec2":case"ivec3":case"ivec4":return Y;case"uint":case"uvec2":case"uvec3":case"uvec4":return A;default:throw new Error("Unable to handle type")}}(this.elementType.constructor)):ot(this,i,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(t,o,i){return function Zt(t,o,i=0,p=t.size){const S=new Y(i).setMutable().setDebugName("FindIndexIterator"),R=o(t.get(S)).setDebugName("FindIndexPredicate");return Nt({iter:S},Y,R,({out:rt,iter:it,subgraph:mt})=>`\n${rt} = -1;\n\nfor (; ${it} < ${p}; ${it}++) {\n\n${mt.body}\n\n  if (${mt.varName}) {\n    ${rt} = ${it};\n    break;\n  }\n\n}\n`).setDebugName("FindIndexBlock")}(this,t,o,i)}glslFindIndex(t,o,i){return function Qt(t,o,i=0,p=t.size){return Nt({array:t},Y,null,({out:R,array:st})=>`\n${R} = -1;\nfor (int i = ${i}; i < ${p}; i++) {\n  bool condition;\n  ${o({array:st,i:"i",out:"condition"})}\n  if (condition) {\n    ${R} = i;\n    break;\n  }\n}\n`).setDebugName("GlslFindIndexBlock")}(this,t,o,i)}static ofType(t,o){const i={construct:(p,S)=>new U(new t,o)};return new Proxy(U,i)}};dt.type="array",dt=U=(0,F._)([function nt(t){return new Proxy(t,{construct:(o,i,p)=>function X(t){return new Proxy(t,{get(o,i){if(i in o)return o[i];if("string"==typeof i){const p=parseInt(i,10);if(!isNaN(p))return ot(t,`[${p}]`,t.elementType.constructor)}}})}(new o(...i))})}],dt);let r=(()=>{class t extends a.vL{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const i=new t;return i.children=this.children.map(a.vA),super.cloneInto(i),i}}return t.type="sampler2D",t})(),n=(()=>{class t extends a.vL{constructor(i){super(),this.type="float",this.children=[i]}clone(){const i=new t((0,a.vA)(this.children[0]));return super.cloneInto(i),i}multiply(i){return at(this,"number"==typeof i?H(i,t):i)}divide(i){return Tt(this,"number"==typeof i?H(i,t):i)}add(i){return _t(this,"number"==typeof i?H(i,t):i)}subtract(i){return wt(this,"number"==typeof i?H(i,t):i)}}return t.type="float",t})(),h=O=class extends a.vL{constructor(t,o){super(),this.type="vec2",this.children=[t,o].filter(i=>null!=i)}clone(){const t=new O((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]));return super.cloneInto(t),t}get 0(){return ot(this,"[0]",n)}get 1(){return ot(this,"[1]",n)}get 2(){throw new ct}get 3(){throw new ct}multiply(t){return at(this,"number"==typeof t?H(t,n):t)}divide(t){return Tt(this,"number"==typeof t?H(t,n):t)}add(t){return _t(this,"number"==typeof t?H(t,n):t)}subtract(t){return wt(this,"number"==typeof t?H(t,n):t)}};h.type="vec2",h=O=(0,F._)([w],h);let f=Q=class extends a.vL{constructor(t,o,i){super(),this.type="vec3",this.children=[t,o,i].filter(p=>null!=p)}get 0(){return ot(this,"[0]",n)}get 1(){return ot(this,"[1]",n)}get 2(){return ot(this,"[2]",n)}get 3(){throw new ct}clone(){const t=new Q((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]));return super.cloneInto(t),t}multiply(t){return at(this,"number"==typeof t?H(t,n):t)}divide(t){return Tt(this,"number"==typeof t?H(t,n):t)}add(t){return _t(this,"number"==typeof t?H(t,n):t)}subtract(t){return wt(this,"number"==typeof t?H(t,n):t)}};f.type="vec3",f=Q=(0,F._)([w],f);let _=j=class extends a.vL{constructor(t,o,i,p){super(),this.type="vec4",this.children=[t,o,i,p].filter(S=>null!=S)}clone(){const t=new j((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]),(0,a.vA)(this.children[3]));return super.cloneInto(t),t}get 0(){return ot(this,"[0]",n)}get 1(){return ot(this,"[1]",n)}get 2(){return ot(this,"[2]",n)}get 3(){return ot(this,"[3]",n)}multiply(t){return at(this,"number"==typeof t?H(t,n):t)}divide(t){return Tt(this,"number"==typeof t?H(t,n):t)}add(t){return _t(this,"number"==typeof t?H(t,n):t)}subtract(t){return wt(this,"number"==typeof t?H(t,n):t)}};_.type="vec4",_=j=(0,F._)([w],_);let A=y=class extends a.vL{constructor(t){super(),this.type="uint",this.children=[t]}clone(){const t=new y((0,a.vA)(this.children[0]));return super.cloneInto(t),t}};A.type="uint",A=y=(0,F._)([w],A);let C=B=class extends a.vL{constructor(t,o){super(),this.type="uvec2",this.children=[t,o].filter(i=>null!=i)}clone(){const t=new B((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]));return super.cloneInto(t),t}};C.type="uvec2",C=B=(0,F._)([w],C);let P=G=class extends a.vL{constructor(t,o,i){super(),this.type="uvec3",this.children=[t,o,i].filter(p=>null!=p)}clone(){const t=new G((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]));return super.cloneInto(t),t}};P.type="uvec3",P=G=(0,F._)([w],P);let M=k=class extends a.vL{constructor(t,o,i,p){super(),this.type="uvec4",this.children=[t,o,i,p].filter(S=>null!=S)}clone(){const t=new k((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]),(0,a.vA)(this.children[3]));return super.cloneInto(t),t}};M.type="uvec4",M=k=(0,F._)([w],M);let D=(()=>{class t extends a.vL{constructor(i){super(),this.type="bool",this.children=[i]}and(i){return Ut(this,i)}or(i){return Lt(this,i)}clone(){const i=new t((0,a.vA)(this.children[0]));return super.cloneInto(i),i}}return t.type="bool",t})(),W=z=class extends a.vL{constructor(t,o){super(),this.type="bvec2",this.children=[t,o].filter(i=>null!=i)}all(){return $t(this)}any(){return Dt(this)}clone(){const t=new z((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]));return super.cloneInto(t),t}};W.type="bvec2",W=z=(0,F._)([w],W);let q=K=class extends a.vL{constructor(t,o,i){super(),this.type="bvec3",this.children=[t,o,i].filter(p=>null!=p)}all(){return $t(this)}any(){return Dt(this)}clone(){const t=new K((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]));return super.cloneInto(t),t}};function H(t,o){return"number"==typeof t?new o(t):t}q.type="bvec3",q=K=(0,F._)([w],q);let ht=V=class extends a.vL{constructor(t,o,i,p){super(),this.type="bvec4",this.children=[t,o,i,p].filter(S=>null!=S)}all(){return $t(this)}any(){return Dt(this)}clone(){const t=new V((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]),(0,a.vA)(this.children[3]));return super.cloneInto(t),t}};ht.type="bvec4",ht=V=(0,F._)([w],ht);let Y=(()=>{class t extends a.vL{constructor(i){super(),this.type="int",this.children=[i]}multiply(i){return at(this,H(i,t))}add(i){return _t(this,H(i,t))}subtract(i){return wt(this,H(i,t))}divide(i){return Tt(this,H(i,t))}clone(){const i=new t((0,a.vA)(this.children[0]));return super.cloneInto(i),i}}return t.type="int",t})(),lt=b=class extends a.vL{constructor(t,o){super(),this.type="ivec2",this.children=[t,o].filter(i=>null!=i)}clone(){const t=new b((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]));return super.cloneInto(t),t}};lt.type="ivec2",lt=b=(0,F._)([w],lt);let pt=$=class extends a.vL{constructor(t,o,i){super(),this.type="ivec3",this.children=[t,o,i].filter(p=>null!=p)}clone(){const t=new $((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]));return super.cloneInto(t),t}};pt.type="ivec3",pt=$=(0,F._)([w],pt);let ft=T=class extends a.vL{constructor(t,o,i,p){super(),this.type="ivec4",this.children=[t,o,i,p].filter(S=>null!=S)}clone(){const t=new T((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]),(0,a.vA)(this.children[3]));return super.cloneInto(t),t}};ft.type="ivec4",ft=T=(0,F._)([w],ft);let gt=(()=>{class t extends a.vL{constructor(i,p,S,R){super(),this.type="mat2",this.children=[i,p,S,R]}clone(){const i=new t((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]),(0,a.vA)(this.children[3]));return super.cloneInto(i),i}get(i,p){return St(this,new Y(i),new Y(p),n)}multiply(i){return at(this,i)}}return t.type="mat2",t})(),bt=(()=>{class t extends a.vL{static identity(){return new t(1,0,0,0,1,0,0,0,1)}static fromRotation(i){const p=kt(i),S=jt(i);return new t(S,p,0,Rt(p),S,0,0,0,1)}constructor(i,p,S,R,st,rt,it,mt,yt){super(),this.type="mat3",this.children=[i,p,S,R,st,rt,it,mt,yt]}add(i){return _t(this,i)}multiply(i){return at(this,i)}get(i,p){return St(this,new Y(i),new Y(p),n)}clone(){const i=new t((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]),(0,a.vA)(this.children[3]),(0,a.vA)(this.children[4]),(0,a.vA)(this.children[5]),(0,a.vA)(this.children[6]),(0,a.vA)(this.children[7]),(0,a.vA)(this.children[8]));return super.cloneInto(i),i}}return t.type="mat3",t})(),It=(()=>{class t extends a.vL{static identity(){return new t(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(i,p,S,R,st,rt,it,mt,yt,xt,Mt,Ct,Kt,Pt,Et,At){super(),this.type="mat4",this.children=[i,p,S,R,st,rt,it,mt,yt,xt,Mt,Ct,Kt,Pt,Et,At]}static fromColumns(i,p,S,R){return new t(i.x,i.y,i.z,i.w,p.x,p.y,p.z,p.w,S.x,S.y,S.z,S.w,R.x,R.y,R.z,R.w)}multiply(i){return at(this,i)}get(i,p){return St(this,new Y(i),new Y(p),n)}clone(){const i=new t((0,a.vA)(this.children[0]),(0,a.vA)(this.children[1]),(0,a.vA)(this.children[2]),(0,a.vA)(this.children[3]),(0,a.vA)(this.children[4]),(0,a.vA)(this.children[5]),(0,a.vA)(this.children[6]),(0,a.vA)(this.children[7]),(0,a.vA)(this.children[8]),(0,a.vA)(this.children[9]),(0,a.vA)(this.children[10]),(0,a.vA)(this.children[11]),(0,a.vA)(this.children[12]),(0,a.vA)(this.children[13]),(0,a.vA)(this.children[14]),(0,a.vA)(this.children[15]));return super.cloneInto(i),i}}return t.type="mat4",t})();const Ft={float:n,vec2:h,vec3:f,vec4:_,int:Y,ivec2:lt,ivec3:pt,ivec4:ft,uint:A,uvec2:C,uvec3:P,uvec4:M,bool:D,bvec2:W,bvec3:q,bvec4:ht},Gt=(...t)=>new Y(...t),Ot=(...t)=>new n(...t),Vt=(...t)=>new h(...t),Xt=(...t)=>new f(...t),Wt=(...t)=>new _(...t),Yt=(...t)=>new bt(...t);function ot(t,o,i){const p=new i(new a.zg(o,t,i));return p.isImplicit=!0,p}function St(t,o,i,p){const S=new p(new a.ff(o,i,t,p));return S.isImplicit=!0,S}function tt(t,o,i,p=null){if(p){const R=new p,st=new p(new a.aw(t,[o,i],!0,!1,R));return st.isImplicit=!0,st}if("float"===o.type||"int"===o.type){const R=new i.constructor(new a.aw(t,[o,i],!0,!1,i.constructor));return R.isImplicit=!0,R}if(("mat2"===o.type||"mat3"===o.type||"mat4"===o.type)&&"float"!==i.type){const R=new i.constructor(new a.aw(t,[o,i],!0,!1,i.constructor));return R.isImplicit=!0,R}const S=new o.constructor(new a.aw(t,[o,i],!0,!1,o.constructor));return S.isImplicit=!0,S}function I(t,o,i=o.constructor){const p=new i(new a.aw(t,[o],!1,!1,i));return p.isImplicit=!0,p}function et(t,o,i,p=o.constructor){const S=new p(new a.aw(t,[o,i],!1,!1,p));return S.isImplicit=!0,S}function vt(t,o,i,p,S=o.constructor){const R=new S(new a.aw(t,[o,i,p],!1,!1,S));return R.isImplicit=!0,R}function Rt(t){return at(t,Ot(-1))}function Nt(t,o,i,p){return new o(new a.rR(t,o,i,p))}function Bt(t,o,i){const p="function"==typeof o?o():o,S="function"==typeof i?i():i,R=new p.constructor(new a.XL(t,p,S));return R.isImplicit=!0,R}function Jt(...t){const o=t.map(([rt,it])=>"function"==typeof it?[rt,it()]:[rt,it]),i=o[0][1].constructor,p=o.findIndex(rt=>!0===rt[0]);if(-1===p)throw new Error("A cond must have a fallthrough case with `true`/; ");const st=new i(o.slice(0,p).reduceRight((rt,it)=>Bt(it[0],it[1],rt),o[p][1]));return st.isImplicit=!0,st}function at(t,o){return tt("*",t,o)}function Tt(t,o){return tt("/",t,o)}function _t(t,o){return tt("+",t,o)}function wt(t,o){return tt("-",t,o)}function qt(t,o){return tt("%",t,o)}function te(t,o){return tt(">>",t,o)}function ee(t,o){return tt("&",t,o)}function ne(t,o){return tt("==",t,o,D)}function re(t,o){return tt("<",t,o,D)}function ie(t,o){return tt("<=",t,o,D)}function se(t,o){return tt(">",t,o,D)}function oe(t,o){return tt(">=",t,o,D)}function Lt(...t){return t.length<=1?t[0]:t.slice(1).reduce((o,i)=>function ce(t,o){return tt("||",t,o,D)}(o,i),t[0])}function Ut(...t){return t.length<=1?t[0]:t.slice(1).reduce((o,i)=>function ue(t,o){return tt("&&",t,o,D)}(o,i),t[0])}function ae(t){return I("abs",t)}function $t(t){return I("all",t,D)}function Dt(t){return I("any",t,D)}function he(t,o){return null==o?I("atan",t):et("atan",t,o,t.constructor)}function de(t){return I("ceil",t)}function le(t,o,i){return vt("clamp",t,o,i,t.constructor)}function jt(t){return I("cos",t)}function pe(t,o){return et("distance",t,o,n)}function fe(t,o){return et("dot",t,o,n)}function me(t){return I("floor",t)}function ye(t){return I("fract",t)}function _e(t){return I("length",t,n)}function ge(t,o){return et("max",t,o)}function be(t,o){return et("min",t,o)}function ve(t,o,i){return vt("mix",t,o,i)}function Te(t,o){return et("mod",t,o)}function we(t){return I("normalize",t)}function xe(t){return I("bool"===t.type?"!":"not",t)}function Ee(t,o){return et("pow",t,o)}function Ae(t){return I("round",t)}function kt(t){return I("sin",t)}function Ie(t,o,i){return vt("smoothstep",t,o,i)}function Se(t){return I("sqrt",t)}function Ne(t,o){return et("step",t,o,o.constructor)}function Me(t,o){return et("texture",t,o,_)}},14089:(ut,Z,x)=>{x.d(Z,{j:()=>a});var F=x(69473);class a{constructor(){this.drawPhase=F.S5.MAP|F.S5.HITTEST|F.S5.HIGHLIGHT|F.S5.DEBUG}startup(){}shutdown(O){}}},8137:(ut,Z,x)=>{var F,a;x.d(Z,{N:()=>F}),(a=F||(F={}))[a.AnimatedMarker=0]="AnimatedMarker",a[a.Blend=1]="Blend",a[a.ComplexFill=2]="ComplexFill",a[a.ComplexOutlineFill=3]="ComplexOutlineFill",a[a.DotDensity=4]="DotDensity",a[a.Fill=5]="Fill",a[a.GradientFill=6]="GradientFill",a[a.GradientStroke=7]="GradientStroke",a[a.Grid=8]="Grid",a[a.Heatmap=9]="Heatmap",a[a.Label=10]="Label",a[a.Line=11]="Line",a[a.Magnifier=12]="Magnifier",a[a.Marker=13]="Marker",a[a.OutlineFill=14]="OutlineFill",a[a.Overlay=15]="Overlay",a[a.PatternFill=16]="PatternFill",a[a.PatternOutlineFill=17]="PatternOutlineFill",a[a.PieChart=18]="PieChart",a[a.Test=19]="Test",a[a.Text=20]="Text",a[a.TexturedLine=21]="TexturedLine",a[a.Bitmap=22]="Bitmap"},20872:(ut,Z,x)=>{x.d(Z,{K:()=>T});var F=x(5922),a=x(35150),U=x(89221),G=(x(3248),x(40707),x(77440),x(50915),x(79061),x(23063)),z=(x(68165),x(76169)),K=x(4931);function V(J,g,l){const c=new K.R(g.width,g.height);return c.dataType=g.dataType,g.depth&&(c.depth=g.depth),g.flipped&&(c.flipped=g.flipped),g.hasMipmap&&(c.hasMipmap=g.hasMipmap),c.internalFormat=g.internalFormat,g.isImmutable&&(c.isImmutable=g.isImmutable),g.isOpaque&&(c.isOpaque=g.isOpaque),g.maxAnisotropy&&(c.maxAnisotropy=g.maxAnisotropy),c.pixelFormat=g.pixelFormat,g.preMultiplyAlpha&&(c.preMultiplyAlpha=g.preMultiplyAlpha),g.samplingMode&&(c.samplingMode=g.samplingMode),g.target&&(c.target=g.target),c.uniform=g.uniform,g.unpackAlignment&&(c.unpackAlignment=g.unpackAlignment),g.wrapMode&&(c.wrapMode=g.wrapMode),new z.g(J,c,l)}function $(J,g,l){const c=g.length;if(c!==l){const d=new F.A("Invalid Uniform",`Invalid length, expected ${l} but got ${c}`,{uniformName:J,values:g});a.A.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram").errorOnce(d)}}class T{constructor(g,l,c,d,m,v){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=g,this.fragmentShader=l,this._locations=c,this._locationInfo=d,this._uniformBindings=m,this._transformFeedbackBindings=v}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(g){this._uniforms=g}cleanupTemporaryTextures(){for(const g of this._temporaryTextures)g.dispose();this._temporaryTextures=[]}bind(g){const l=this._uniforms;if(!this._program){const d=new Map;for(const[v,N]of this._locations)d.set(v,N);const m=[];for(const v of this._transformFeedbackBindings??[]){const{index:N,propertyKey:E}=v;m[N]=`v_${E}`}this._program=new G.B(g,this.vertexShader,this.fragmentShader,d,new Map,m)}const c=this._program;g.useProgram(c);for(const d of this._uniformBindings){const{shaderModulePath:m,uniformName:v,uniformType:N,uniformArrayLength:E}=d,w=(0,U.wc)(m,l);if(null==w){if("sampler2D"===N)continue;throw new Error(`Failed to find uniform value for ${m}`)}switch("array"===N||"array-2d"===N?d.uniformArrayElementType:N){case"sampler2D":{const{unit:X,texture:nt}=w;if(c.setUniform1i(v,X),"type"in nt)g.bindTexture(nt,X);else{const ct=V(g,nt.descriptor,nt.data);g.bindTexture(ct,X)}break}case"int":if(!E){c.setUniform1i(v,w);break}$(d.uniformName,w,E),c.setUniform1iv(v,w);break;case"float":if(!E){c.setUniform1f(v,w);break}$(d.uniformName,w,E),c.setUniform1fv(v,w);break;case"vec2":if(!E){c.setUniform2f(v,w[0],w[1]);break}$(d.uniformName,w,E),c.setUniform2fv(v,w.flat());break;case"vec3":if(!E){c.setUniform3f(v,w[0],w[1],w[2]);break}$(d.uniformName,w,E),c.setUniform3fv(v,w.flat());break;case"vec4":if(!E){c.setUniform4f(v,w[0],w[1],w[2],w[3]);break}$(d.uniformName,w,E),c.setUniform4fv(v,w.flat());break;case"mat3":c.setUniformMatrix3fv(v,w);break;case"mat4":c.setUniformMatrix4fv(v,w);break;default:throw new Error(`Unable to set uniform for type ${N}`)}}}}},2006:(ut,Z,x)=>{var F,a;x.d(Z,{c:()=>F}),(a=F||(F={}))[a.Bind=0]="Bind",a[a.Pass=1]="Pass",a[a.Draw=2]="Draw"},79061:(ut,Z,x)=>{x.d(Z,{H:()=>K});var F=x(10467),U=(x(3248),x(35150)),O=x(11432),Q=x(32788),j=x(77440),y=x(50915),B=x(68165),G=x(17107),k=x(76169);class K{constructor(l,c,d=null){this._context=l,this._glName=null,this._colorAttachments=new Map,this._depthStencilBuffer=null,this._depthStencilTexture=null,this._initialized=!1,l.instanceCounter.increment(y.vt.FramebufferObject,this);const m=V(c)?c:new k.g(this._context,c);if(this._colorAttachments.set(y.Nm.COLOR_ATTACHMENT0,m),this._validateTextureDescriptor(m.descriptor),this._validateColorAttachmentPoint(y.Nm.COLOR_ATTACHMENT0),null!=d)if(function $(g){return V(g)||null!=g&&"pixelFormat"in g}(d))this._depthStencilTexture=V(d)?d:new k.g(this._context,d),this._validateTextureDescriptor(this._depthStencilTexture.descriptor);else{const v=function b(g){return null!=g&&"type"in g&&g.type===B.p.RenderBuffer}(d)?d:new G.l(this._context,d);this._depthStencilBuffer=v,this._validateRenderBufferDescriptor(v.descriptor)}}dispose(){if(0===this._colorAttachments.size&&!this._glName)return;const l=this._context.getBoundFramebufferObject();this._colorAttachments.forEach((c,d)=>this.detachColorTexture(d)?.dispose()),this.detachDepthStencilBuffer()?.dispose(),this.detachDepthStencilTexture()?.dispose(),this._glName&&(this._context.gl.deleteFramebuffer(this._glName),this._glName=null),this._context.bindFramebuffer(l),this._context.instanceCounter.decrement(y.vt.FramebufferObject,this)}get glName(){return this._glName}get colorTexture(){return this._colorAttachments.get(y.Nm.COLOR_ATTACHMENT0)}get depthStencil(){return this._depthStencilTexture||this._depthStencilBuffer}get depthStencilTexture(){return this._depthStencilTexture}get width(){return this._colorAttachments.get(y.Nm.COLOR_ATTACHMENT0)?.descriptor?.width??0}get height(){return this._colorAttachments.get(y.Nm.COLOR_ATTACHMENT0)?.descriptor?.height??0}get usedMemory(){return[...this._colorAttachments].reduce((l,[c,d])=>l+d.usedMemory,this.depthStencil?.usedMemory??0)}getColorTexture(l){const c=this._colorAttachments.get(l);return c&&V(c)?c:null}get colorAttachments(){return[...this._colorAttachments.keys()]}attachColorTexture(l,c=y.Nm.COLOR_ATTACHMENT0){l&&(this._validateColorAttachmentPoint(c),this._validateTextureDescriptor(l.descriptor),this.detachColorTexture(c)?.dispose(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(l.glName,c)),this._colorAttachments.set(c,l))}detachColorTexture(l=y.Nm.COLOR_ATTACHMENT0){const c=this._colorAttachments.get(l);if(c){if(this._initialized){const d=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this),this._framebufferTexture2D(null,l),this._context.bindFramebuffer(d)}return this._colorAttachments.delete(l),c}}setColorTextureTarget(l,c=y.Nm.COLOR_ATTACHMENT0){const d=this._colorAttachments.get(c);d&&this._framebufferTexture2D(d.glName,c,l)}attachDepthStencil(l){if(l)switch(l.type){case B.p.Texture:return this._attachDepthStencilTexture(l);case B.p.RenderBuffer:return this._attachDepthStencilBuffer(l)}}_attachDepthStencilTexture(l){if(null==l)return;const c=l.descriptor;c.pixelFormat!==y.Ab.DEPTH_STENCIL&&c.pixelFormat!==y.Ab.DEPTH24_STENCIL8&&console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"),c.dataType!==y.ld.UNSIGNED_INT_24_8&&console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"),this._validateTextureDescriptor(c),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(l.glName,y.nI)),this._depthStencilTexture?.dispose(),this._depthStencilTexture=l}detachDepthStencilTexture(){const l=this._depthStencilTexture;if(l&&this._initialized){const c=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this),this._framebufferTexture2D(null,y.nI),this._context.bindFramebuffer(c)}return this._depthStencilTexture=null,l}_attachDepthStencilBuffer(l){if(null==l)return;const c=l.descriptor;if(this._validateRenderBufferDescriptor(c),this._disposeDepthStencilAttachments(),this._initialized){this._context.bindFramebuffer(this);const d=this._context.gl,m=this._getGLAttachmentPoint(c);d.framebufferRenderbuffer(y.R.FRAMEBUFFER,m,d.RENDERBUFFER,l.glName)}this._depthStencilBuffer=l}detachDepthStencilBuffer(){const l=this._depthStencilBuffer;if(l&&this._initialized){const c=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this);const d=this._context.gl,m=this._getGLAttachmentPoint(l.descriptor);d.framebufferRenderbuffer(y.R.FRAMEBUFFER,m,d.RENDERBUFFER,null),this._context.bindFramebuffer(c)}return this._depthStencilBuffer=null,l}copyToTexture(l,c,d,m,v,N,E){(l<0||c<0||v<0||N<0)&&console.error("Offsets cannot be negative!"),(d<=0||m<=0)&&console.error("Copy width and height must be greater than zero!");const w=E.descriptor;E.descriptor.target!==y.Ap.TEXTURE_2D&&console.error("Texture target must be TEXTURE_2D!"),(null==w?.width||null==w?.height||l+d>this.width||c+m>this.height||v+d>w.width||N+m>w.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");const X=this._context,nt=X.bindTexture(E,k.g.TEXTURE_UNIT_FOR_UPDATES);X.setActiveTexture(k.g.TEXTURE_UNIT_FOR_UPDATES),X.bindFramebuffer(this),X.gl.copyTexSubImage2D(y.Ap.TEXTURE_2D,0,v,N,l,c,d,m),X.bindTexture(nt,k.g.TEXTURE_UNIT_FOR_UPDATES)}readPixels(l,c,d,m,v,N,E){(d<=0||m<=0)&&console.error("Copy width and height must be greater than zero!"),E||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(l,c,d,m,v,N,E)}readPixelsAsync(l,c,d,m,v,N,E){var w=this;return(0,F.A)(function*(){const{gl:X}=w._context,nt=Q.g.createPixelPack(w._context,y._U.STREAM_READ,E.byteLength);w._context.bindBuffer(nt);const ct=w._context.getBoundFramebufferObject();w._context.bindFramebuffer(w),X.readPixels(l,c,d,m,v,N,0),w._context.unbindBuffer(y.NZ.PIXEL_PACK_BUFFER),w._context.bindFramebuffer(ct),yield nt.getSubDataAsync(E),nt.dispose()})()}resize(l,c){if(this.width===l&&this.height===c)return;const d={width:l,height:c};T(d,this._context.parameters.maxTextureSize),this._colorAttachments.forEach(m=>m.resize(d.width,d.height)),this._depthStencilTexture?.resize(d.width,d.height),this._initialized&&(T(d,this._context.parameters.maxRenderbufferSize),this._depthStencilBuffer?.resize(d.width,d.height),this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1)}initializeAndBind(l=y.R.FRAMEBUFFER){const c=this._context.gl;if(this._initialized)return void c.bindFramebuffer(l,this.glName);this._glName&&c.deleteFramebuffer(this._glName);const d=c.createFramebuffer();if(c.bindFramebuffer(l,d),this._colorAttachments.forEach((m,v)=>this._framebufferTexture2D(m.glName,v,J(m),l)),this._depthStencilBuffer){const m=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);c.framebufferRenderbuffer(l,m,c.RENDERBUFFER,this._depthStencilBuffer.glName)}else this._depthStencilTexture&&this._framebufferTexture2D(this._depthStencilTexture.glName,c.DEPTH_STENCIL_ATTACHMENT,J(this._depthStencilTexture),l);(0,j.en)()&&c.checkFramebufferStatus(l)!==c.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=d,this._initialized=!0}_framebufferTexture2D(l,c=y.Nm.COLOR_ATTACHMENT0,d=y.Ap.TEXTURE_2D,m=y.R.FRAMEBUFFER,v=0){this._context.gl.framebufferTexture2D(m,c,d,l,v)}_disposeDepthStencilAttachments(){const l=this._context.gl;if(this._depthStencilBuffer){if(this._initialized){this._context.bindFramebuffer(this);const c=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);l.framebufferRenderbuffer(y.R.FRAMEBUFFER,c,l.RENDERBUFFER,null)}this._depthStencilBuffer=(0,O.WD)(this._depthStencilBuffer)}this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,l.DEPTH_STENCIL_ATTACHMENT)),this._depthStencilTexture=(0,O.WD)(this._depthStencilTexture))}_validateTextureDescriptor(l){l.target!==y.Ap.TEXTURE_2D&&l.target!==y.Ap.TEXTURE_CUBE_MAP&&console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"),T(l,this._context.parameters.maxTextureSize),this._validateBufferDimensions(l)}_validateRenderBufferDescriptor(l){T(l,this._context.parameters.maxRenderbufferSize),this._validateBufferDimensions(l)}_validateBufferDimensions(l){l.width<=0&&(l.width=this.width),l.height<=0&&(l.height=this.height),this.width>0&&this.height>0&&(this.width===l.width&&this.height===l.height||console.error("Attachment size must match framebuffer size!"))}_getGLAttachmentPoint(l){switch(l.internalFormat){case y.yQ.DEPTH_COMPONENT16:case y.yQ.DEPTH_COMPONENT24:case y.yQ.DEPTH_COMPONENT32F:return this._context.gl.DEPTH_ATTACHMENT;case y.yQ.DEPTH24_STENCIL8:case y.yQ.DEPTH32F_STENCIL8:case y.yQ.DEPTH_STENCIL:return this._context.gl.DEPTH_STENCIL_ATTACHMENT;case y.yQ.STENCIL_INDEX8:return this._context.gl.STENCIL_ATTACHMENT}}_validateColorAttachmentPoint(l){if(-1===K._MAX_COLOR_ATTACHMENTS){const{gl:d}=this._context;K._MAX_COLOR_ATTACHMENTS=d.getParameter(d.MAX_COLOR_ATTACHMENTS)}const c=l-y.Nm.COLOR_ATTACHMENT0;c+1>K._MAX_COLOR_ATTACHMENTS&&U.A.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${c+1}. Implementation supports up to ${K._MAX_COLOR_ATTACHMENTS} color attachments`)}}function V(g){return null!=g&&"type"in g&&g.type===B.p.Texture}function T(g,l){const c=Math.max(g.width,g.height);if(c>l){U.A.getLogger("esri.views.webgl.FramebufferObject").warn(`Resizing FBO attachment size ${g.width}x${g.height} to device limit ${l}`);const d=l/c;return g.width=Math.round(g.width*d),g.height=Math.round(g.height*d),!1}return!0}function J(g){return g.descriptor.target===y.Ap.TEXTURE_CUBE_MAP?y.Ap.TEXTURE_CUBE_MAP_POSITIVE_X:y.Ap.TEXTURE_2D}K._MAX_COLOR_ATTACHMENTS=-1},17107:(ut,Z,x)=>{x.d(Z,{l:()=>O});var F=x(50915),a=x(68165),U=x(49950);class O{constructor(j,y){this._context=j,this._descriptor=y,this.type=a.p.RenderBuffer,this._context.instanceCounter.increment(F.vt.Renderbuffer,this);const B=this._context.gl;this.glName=B.createRenderbuffer(),this._context.bindRenderbuffer(this);const{width:G,height:k,internalFormat:z,multisampled:K}=y;K?B.renderbufferStorageMultisample(B.RENDERBUFFER,this.samples,z,G,k):B.renderbufferStorage(B.RENDERBUFFER,z,G,k),this._context.bindRenderbuffer(null)}get descriptor(){return this._descriptor}get samples(){const j=this._descriptor.samples,y=this._context.parameters.maxSamples;return j?Math.min(j,y):y}get usedMemory(){return(0,U.e)(this._descriptor)}resize(j,y){const B=this._descriptor;if(B.width===j&&B.height===y)return;B.width=j,B.height=y;const G=this._context.gl;this._context.bindRenderbuffer(this),B.multisampled?G.renderbufferStorageMultisample(G.RENDERBUFFER,this.samples,B.internalFormat,B.width,B.height):G.renderbufferStorage(G.RENDERBUFFER,B.internalFormat,B.width,B.height),this._context.bindRenderbuffer(null)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(F.vt.Renderbuffer,this),this._context=null)}}},49950:(ut,Z,x)=>{x.d(Z,{e:()=>U,q:()=>a});var F=x(84757);class a{constructor(Q,j,y=j){this.internalFormat=Q,this.width=j,this.height=y,this.multisampled=!1,this.samples=1}}function U(O){return O.width<=0||O.height<=0||null==O.internalFormat?0:O.width*O.height*(0,F.IB)(O.internalFormat)}},43713:(ut,Z,x)=>{x.d(Z,{N5:()=>y});var F=x(5922),U=(x(3248),x(35150)),O=x(2006);const Q=()=>U.A.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class j{constructor(){this._includedModules=new Map}include(c,d){this._includedModules.has(c)?this._includedModules.get(c):(this._includedModules.set(c,d),c(this.builder,d))}}class y extends j{constructor(){super(...arguments),this.vertex=new z,this.fragment=new z,this.attributes=new K,this.varyings=new V,this.extensions=new b,this.outputs=new $}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(c,d=!1){const m=this.extensions.generateSource(c),v=this.attributes.generateSource(c),N=this.varyings.generateSource(c),E="vertex"===c?this.vertex:this.fragment,w=E.uniforms.generateSource(),X=E.code.generateSource(),nt=E.main.generateSource(d),ct="vertex"===c?g:J,dt=E.constants.generateSource(),L=this.outputs.generateSource(c);return`#version 300 es\n${m.join("\n")}\n${ct}\n${dt.join("\n")}\n${w.join("\n")}\n${v.join("\n")}\n${N.join("\n")}\n${L.join("\n")}\n${X.join("\n")}\n${nt.join("\n")}`}generateBind(c){const d=new Map;this.vertex.uniforms.entries.forEach(N=>{const E=N.bind[O.c.Bind];E&&d.set(N.name,E)}),this.fragment.uniforms.entries.forEach(N=>{const E=N.bind[O.c.Bind];E&&d.set(N.name,E)});const m=Array.from(d.values()),v=m.length;return N=>{for(let E=0;E<v;++E)m[E](c,N)}}generateBindPass(c){const d=new Map;this.vertex.uniforms.entries.forEach(N=>{const E=N.bind[O.c.Pass];E&&d.set(N.name,E)}),this.fragment.uniforms.entries.forEach(N=>{const E=N.bind[O.c.Pass];E&&d.set(N.name,E)});const m=Array.from(d.values()),v=m.length;return(N,E)=>{for(let w=0;w<v;++w)m[w](c,N,E)}}generateBindDraw(c){const d=new Map;this.vertex.uniforms.entries.forEach(N=>{const E=N.bind[O.c.Draw];E&&d.set(N.name,E)}),this.fragment.uniforms.entries.forEach(N=>{const E=N.bind[O.c.Draw];E&&d.set(N.name,E)});const m=Array.from(d.values()),v=m.length;return(N,E,w)=>{for(let X=0;X<v;++X)m[X](c,w,N,E)}}}class B{constructor(c){this._stage=c,this._entries=new Map}add(...c){for(const d of c)this._add(d);return this._stage}get(c){return this._entries.get(c)}_add(c){if(null!=c){if(this._entries.has(c.name)&&!this._entries.get(c.name).equals(c))throw new F.A(`Duplicate uniform name ${c.name} for different uniform type`);this._entries.set(c.name,c)}else Q().error(`Trying to add null Uniform from ${(new Error).stack}.`)}generateSource(){return Array.from(this._entries.values()).map(c=>null!=c.arraySize?`uniform ${c.type} ${c.name}[${c.arraySize}];`:`uniform ${c.type} ${c.name};`)}get entries(){return Array.from(this._entries.values())}}class G{constructor(c){this._stage=c,this._bodies=new Array}add(c){return this._bodies.push(c),this._stage}generateSource(c){if(this._bodies.length>0)return[`void main() {\n ${this._bodies.join("\n")||""} \n}`];if(c)throw new F.A("Shader does not contain main function body.");return[]}}class k{constructor(c){this._stage=c,this._entries=new Array}add(c){return this._entries.push(c),this._stage}generateSource(){return this._entries}}class z extends j{constructor(){super(...arguments),this.uniforms=new B(this),this.main=new G(this),this.code=new k(this),this.constants=new T(this)}get builder(){return this}}class K{constructor(){this._entries=new Array}add(c,d){this._entries.push([c,d])}generateSource(c){return"fragment"===c?[]:this._entries.map(d=>`in ${d[1]} ${d[0]};`)}}class V{constructor(){this._entries=new Map}add(c,d){this._entries.has(c)?Q().warn(`Ignoring duplicate varying ${d} ${c}`):this._entries.set(c,d)}generateSource(c){const d=new Array;return this._entries.forEach((m,v)=>d.push("vertex"===c?`out ${m} ${v};`:`in ${m} ${v};`)),d}}class b{constructor(){this._entries=new Set}add(c){this._entries.add(c)}generateSource(c){const d="vertex"===c?b.ALLOWLIST_VERTEX:b.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter(m=>d.includes(m)).map(m=>`#extension ${m} : enable`)}}b.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],b.ALLOWLIST_VERTEX=[];class ${constructor(){this._entries=new Map}add(c,d,m=0){const v=this._entries.get(m);v?.name!==c||v?.type!==d?this._entries.set(m,{name:c,type:d}):Q().warn(`Fragment shader output location ${m} occupied`)}generateSource(c){if("vertex"===c)return[];0===this._entries.size&&this._entries.set(0,{name:$.DEFAULT_NAME,type:$.DEFAULT_TYPE});const d=new Array;return this._entries.forEach((m,v)=>d.push(`layout(location = ${v}) out ${m.type} ${m.name};`)),d}}$.DEFAULT_TYPE="vec4",$.DEFAULT_NAME="fragColor";class T{constructor(c){this._stage=c,this._entries=new Set}add(c,d,m){let v="ERROR_CONSTRUCTOR_STRING";switch(d){case"float":v=T._numberToFloatStr(m);break;case"int":v=T._numberToIntStr(m);break;case"bool":v=m.toString();break;case"vec2":v=`vec2(${T._numberToFloatStr(m[0])},                            ${T._numberToFloatStr(m[1])})`;break;case"vec3":v=`vec3(${T._numberToFloatStr(m[0])},                            ${T._numberToFloatStr(m[1])},                            ${T._numberToFloatStr(m[2])})`;break;case"vec4":v=`vec4(${T._numberToFloatStr(m[0])},                            ${T._numberToFloatStr(m[1])},                            ${T._numberToFloatStr(m[2])},                            ${T._numberToFloatStr(m[3])})`;break;case"ivec2":v=`ivec2(${T._numberToIntStr(m[0])},                             ${T._numberToIntStr(m[1])})`;break;case"ivec3":v=`ivec3(${T._numberToIntStr(m[0])},                             ${T._numberToIntStr(m[1])},                             ${T._numberToIntStr(m[2])})`;break;case"ivec4":v=`ivec4(${T._numberToIntStr(m[0])},                             ${T._numberToIntStr(m[1])},                             ${T._numberToIntStr(m[2])},                             ${T._numberToIntStr(m[3])})`;break;case"mat2":case"mat3":case"mat4":v=`${d}(${Array.prototype.map.call(m,N=>T._numberToFloatStr(N)).join(", ")})`}return this._entries.add(`const ${d} ${c} = ${v};`),this._stage}static _numberToIntStr(c){return c.toFixed(0)}static _numberToFloatStr(c){return Number.isInteger(c)?c.toFixed(1):c.toString()}generateSource(){return Array.from(this._entries)}}const J="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp int;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump int;\n  precision mediump sampler2D;\n#endif",g="precision highp float;\nprecision highp sampler2D;"}}]);