"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[579,1469],{81396:(yt,lt,T)=>{T.d(lt,{c:()=>P});var k=T(62257);function P(c,g){const B=c.getGeometryType();return B===k.G.enumPoint?c:(0,k.h)(B)?function L(c){if(function I(c){for(let g=0,B=c.getPathCount();g<B;g++){const at=c.getPathSize(g);if(0===at||1===at&&(0===c.getSegmentCountPath(g)||c.getSegmentType(c.getPathStart(g))===k.G.enumLine||!c.isClosedPath(g)))return!1}return!0}(c))return c;const g=c.createInstance();for(let B=0,at=c.getPathCount();B<at;B++){const d=c.getPathSize(B);if(0!==d){if(1===d&&(0===c.getSegmentCountPath(B)||c.getSegmentType(c.getPathStart(B))===k.G.enumLine||!c.isClosedPath(B)))continue;g.addPath(c,B,!0)}}return g}(c):(B===k.G.enumMultiPoint||B===k.G.enumEnvelope||B===k.G.enumMultipatch&&(0,k.b)("not implemented for multipatch"),c)}},89675:(yt,lt,T)=>{T.d(lt,{O:()=>g});var k=T(8189),P=T(1469),A=T(62257),L=T(95944),H=T(7085),I=T(33165),c=T(9279);class g{getOperatorType(){return 10204}supportsCurves(){return!0}accelerateGeometry(d,G,j){return!1}canAccelerateGeometry(d){return!1}executeMany(d,G,j,p){return new B(d,G,j,p)}execute(d,G,j,p){return d||(0,A.t)("null param is not allowed."),new B(null,G,j,p).generalize(d)}}class B extends P.G{constructor(d,G,j,p){super(),this.m_pline=null,this.m_point=new H.P,this.m_stack=[],this.m_resultstack=[],this.m_callCount=0,this.m_progressTracker=p,this.m_geoms=d,this.m_maxDeviation=G,this.m_bRemoveDegenerateParts=j}tock(){return!0}getRank(){return 1}next(){const d=this.m_geoms.next();return null===d?null:((0,A.d)(d),this.generalize(d))}getGeometryID(){return this.m_geoms.getGeometryID()}generalize(d){const G=d.getGeometryType();if((0,A.e)(G))return d;if(G===A.G.enumEnvelope){const V=new L.a({vd:d.getDescription()});return V.addEnvelope(d,!1),this.generalize(V)}if((0,A.f)(G)){const V=new L.P({vd:d.getDescription()});return V.addSegment(d,!0),this.generalize(V)}if((0,A.h)(G)||(0,A.b)(""),d.isEmpty()||this.m_maxDeviation<=0)return d;const j=(new c.O).execute(d,0,.05*this.m_maxDeviation,0,this.m_progressTracker);d.hasNonLinearSegments()&&(this.m_maxDeviation*=.95);const p=j,X=d.createInstance();X.getGeometryType()===A.G.enumPolygon&&X.setFillRule(d.getFillRule()),this.m_xy=p.getAttributeStreamRef(0);{const V={stack:[],error:void 0,hasError:!1};try{const et=new L.L;this.m_pline=et,(0,k.b)(V,(0,I.h)(()=>{this.m_pline=null},!1),!1);for(let J=0,Z=p.getPathCount();J<Z;J++)this.generalizePath(p.getImpl(),J,X.getImpl())}catch(et){V.error=et,V.hasError=!0}finally{(0,k.c)(V)}}return this.m_resultstack.length=0,this.m_stack.length=0,X}generalizePath(d,G,j){if(d.getPathSize(G)<2)return;this.m_resultstack.length=0,this.m_stack.length=0;const p=d.getPathStart(G),X=d.getPathEnd(G)-1,V=d.isClosedPath(G),et=d.isClosedPathInXYPlane(G);let J=0,Z=-1;this.m_stack.push(V?p:X),this.m_stack.push(p);let ct=!1,ut=!1;for(!this.m_bRemoveDegenerateParts&&et&&(ct=!0,ut=!0);this.m_stack.length>1;){const z=this.m_stack.at(-1);this.m_stack.pop();const ft=this.m_stack.at(-1);let dt=d.getXY(z);this.m_pline.setStartXY(dt),dt=d.getXY(ft),this.m_pline.setEndXY(dt);const gt=[Number.NaN];let _t=this.findGreatestDistance(z,ft,X,gt);_t>=0&&(ct?ct=!1:(ut&&gt[0]>J&&(J=gt[0],Z=_t),gt[0]<=this.m_maxDeviation&&(_t=-1))),_t>=0?(this.m_stack.push(_t),this.m_stack.push(z)):this.m_resultstack.push(z)}V||this.m_resultstack.push(this.m_stack[0]);const mt=this.m_resultstack.length;if(mt===d.getPathSize(G)&&mt===this.m_stack.length)j.addPath(d,G,!0);else if(this.m_resultstack.length>0){if(this.m_bRemoveDegenerateParts&&this.m_resultstack.length<=2&&(V||1===this.m_resultstack.length||I.P.distance(d.getXY(this.m_resultstack[0]),d.getXY(this.m_resultstack[1]))<=this.m_maxDeviation))return;if(ut&&Z>=0&&J<=this.m_maxDeviation){const z=this.m_resultstack.at(-1)>Z;this.m_resultstack.push(Z),z&&(this.m_resultstack[this.m_resultstack.length-2]=(0,I.b)(this.m_resultstack[this.m_resultstack.length-1],this.m_resultstack[this.m_resultstack.length-1]=this.m_resultstack[this.m_resultstack.length-2]))}for(let z=0,ft=this.m_resultstack.length;z<ft;z++)d.getPointByVal(this.m_resultstack[z],this.m_point),0===z?j.startPathPoint(this.m_point):j.lineToPoint(this.m_point);if(V){for(let z=this.m_resultstack.length;z<3;z++)j.lineToPoint(this.m_point);j.closePathWithLine()}}}findGreatestDistance(d,G,j,p){let X=G-1;G<=d&&(X=j);let V=-1,et=0;const J=new I.P;for(let Z=d+1;Z<=X;Z++){this.m_xy.queryPoint2D(2*Z,J);const ct=J.x,ut=J.y,mt=this.m_pline.getClosestCoordinate(J,!1);J.assign(this.m_pline.getCoord2D(mt)),J.x-=ct,J.y-=ut;const z=J.length();z>et&&(V=Z,et=z),this.m_callCount++}return p[0]=et,V}}},1469:(yt,lt,T)=>{T.d(lt,{G:()=>k,S:()=>A});class k{*[Symbol.iterator](){let H=this.next();for(;H;)yield H,H=this.next()}}class A extends k{constructor(H){super(),this.m_iGeom=-1,this.m_aGeoms=H?H.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const H=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,H}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}},40579:(yt,lt,T)=>{T.d(lt,{g7:()=>vt,yv:()=>Tt,fz:()=>wt});var p,o,k=T(1469),P=T(62257),A=T(3037),L=T(87571),H=T(8189),I=T(7085),c=T(33165),g=T(95944),B=T(23558),at=T(81396),d=T(89675);class G{getOperatorType(){return 10104}accelerateGeometry(t,s,n){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}isSimple(t,s,n,i,r){return 5===(0,A.aj)(t,s,n,i,r)}executeMany(t,s,n,i){return new j(t,s,n,i)}execute(t,s,n,i){const r=new k.S([t]),m=this.executeMany(r,s,n,i).next();return m||(0,P.c)("null output"),m}}class j extends k.G{constructor(t,s,n,i){super(),t||(0,P.t)(""),this.m_progressTracker=i,this.m_bForceSimplify=n,this.m_index=-1,this.m_inputGeometryCursor=t,this.m_spatialReference=s}next(){const t=this.m_inputGeometryCursor.next();return t?((0,P.d)(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(t)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(t){return t||(0,P.t)(""),(0,A.ak)(t,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}function X(o,t,s,n,i,r){return{m_from:o.clone(),m_to:t.clone(),m_center:s.clone(),m_next:i,m_type:n}}function V(o,t,s,n,i){return{m_from:o.clone(),m_to:t.clone(),m_next:s,m_type:4,m_center:new c.P}}(o=p||(p={}))[o.enumDummy=256]="enumDummy",o[o.enumLine=1]="enumLine",o[o.enumArc=2]="enumArc",o[o.enumMiter=8]="enumMiter",o[o.enumBevel=16]="enumBevel",o[o.enumJoinMask=26]="enumJoinMask",o[o.enumConnectionMask=27]="enumConnectionMask";class et extends k.G{constructor(t,s,n,i,r,m,a,l,u,h){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=h,this.m_parent=t,this.m_mp=s,this.m_distance=n,this.m_spatialReference=i,this.m_densifyDist=l,this.m_maxVertexInCompleteCircle=u,this.m_joins=r,this.m_caps=m,this.m_miterLimit=a}next(){const t=new I.P;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(1===this.m_caps)return this.m_index=this.m_mp.getPointCount(),new g.a({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,t),this.m_index++,!t.isEmpty())break}let s,n=!1;if(null===this.m_bufferedPolygon&&(this.m_x=t.getX(),this.m_y=t.getY(),this.m_bufferedPolygon=this.m_parent.buffer(t,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),n=!0),s=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!n){const i=new B.T,r=t.getX()-this.m_x,m=t.getY()-this.m_y;i.setShiftCoords(r,m),s.applyTransformation(i)}return(0,I.s)(s,0),s}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class J extends k.G{constructor(t){super(),this.m_currentPathIndex=0,this.m_polyline=t}next(){if(!this.m_polyline)return null;const t=this.m_polyline.getImpl(),s=t.getPathCount();if(this.m_currentPathIndex<s){const n=this.m_currentPathIndex;if(this.m_currentPathIndex++,!t.isClosedPathInXYPlane(n)){let r=t.getXY(t.getPathEnd(n)-1);for(;this.m_currentPathIndex<t.getPathCount();){const m=t.getXY(t.getPathStart(this.m_currentPathIndex));if(t.isClosedPathInXYPlane(this.m_currentPathIndex)||!m.equals(r))break;r=t.getXY(t.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(0===n&&this.m_currentPathIndex===this.m_polyline.getPathCount()){const r=this.m_polyline;return this.m_polyline=null,r}const i=new g.P({vd:this.m_polyline.getDescription()});i.addPath(this.m_polyline,n,!0);for(let r=n+1;r<this.m_currentPathIndex;r++)i.addSegmentsFromPath(this.m_polyline,r,0,t.getSegmentCountPath(r),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),i}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Z extends k.G{constructor(t,s,n){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=t,this.m_geoms=s,this.m_index=0,this.m_bFilter=n}next(){if(null===this.m_geometry&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;const t=this.m_geometry.getImpl();if(this.m_index<t.getPathCount()){const s=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,s,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class ct extends k.G{constructor(t){super(),this.m_index=0,this.m_bufferer=t}next(){const t=this.m_bufferer.m_geometry;if(this.m_index<t.getPathCount()){const s=this.m_index,n=t.calculateRingArea2D(this.m_index);for((0,P.g)(n>0),this.m_index++;this.m_index<t.getPathCount()&&!(t.calculateRingArea2D(this.m_index)>0);)this.m_index++;let i;return i=0===s&&this.m_index===t.getPathCount()?this.m_bufferer.bufferPolygonImpl(t,0,t.getPathCount()):this.m_bufferer.bufferPolygonImpl(t,s,this.m_index),i}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class ut{constructor(t){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=P.G.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new I.C(0,0),this.m_smallTolerance=new I.C(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=Number.NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new g.L,this.m_helperLine2=new g.L,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=g.D.constructDefault(t),this.m_progressTracker=t}buffer(t,s,n,i,r,m,a,l){if(t||(0,P.t)("Geometry.Bufferer.Impl.Buffer"),a<0&&(0,P.t)("Geometry.Bufferer.Impl.Buffer"),(0,P.o)(t.getGeometryType())&&(0,P.b)("Unsupported geometry type."),t.isEmpty())return new g.a({vd:t.getDescription()});if(this.m_joins=i,this.m_caps=r,this.m_bRoundBuffer=!1,this.m_miterLimit=m,this.m_originalGeomType=t.getGeometryType(),(0,P.p)(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_joins:(0,P.e)(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_caps:(0,P.q)(this.m_originalGeomType)&&(this.m_bRoundBuffer=0===this.m_joins&&0===this.m_caps),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=(0,at.c)(t),this.m_geometry.isEmpty())return new g.a({vd:t.getDescription()});const u=new L.J;this.m_geometry.queryLooseEnvelope(u),s>0&&u.inflateCoords(s,s),this.m_tolerance=(0,I.a)(n,u,!0),this.m_smallTolerance=(0,I.a)(null,u,!0),l<=0&&(l=96),this.m_spatialReference=n,this.m_distance=s,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=0!==this.m_absDistance?1/this.m_absDistance:0,Number.isNaN(a)||0===a?a=1e-5*this.m_absDistance:a>.5*this.m_absDistance&&(a=.5*this.m_absDistance),l<12&&(l=12);const h=Math.abs(s)*(1-Math.cos(Math.PI/l));if(h>a)a=h;else if(0!==s){const f=Math.PI/Math.acos(1-a/Math.abs(s));f<l-1&&(l=Math.trunc(f))<12&&(l=12,a=Math.abs(s)*(1-Math.cos(Math.PI/l)))}this.m_densifyDist=a,this.m_maxVertexInCompleteCircle=l,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&(0,P.j)(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,0!==this.m_joins,(0,c.i)()));const _=this.bufferImpl();return this.m_geometry=null,_}generateCircleTemplate(){if(this.m_circleTemplate.length)return;const s=Math.trunc((this.m_circleTemplateSize+3)/4),n=.5*Math.PI/s;this.m_dA=n,this.m_circleTemplate=(0,c.m)(c.P,4*s);const i=Math.cos(n),r=Math.sin(n),m=c.P.construct(0,1);for(let a=0;a<s;a++)this.m_circleTemplate[a+0*s].setCoords(m.y,-m.x),this.m_circleTemplate[a+1*s].setCoords(-m.x,-m.y),this.m_circleTemplate[a+2*s].setCoords(-m.y,m.x),this.m_circleTemplate[a+3*s].setCoords(m.x,m.y),m.rotateReverse(i,r)}bufferImpl(){const t=this.m_geometry.getGeometryType();if((0,P.f)(t)){const s=new g.P({vd:this.m_geometry.getDescription()});return s.addSegment(this.m_geometry,!0),this.m_geometry=s,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!(0,P.p)(t))return new g.a({vd:this.m_geometry.getDescription()});if(this.m_distance<0){const s=new L.J;if(this.m_geometry.queryEnvelope(s),s.width()<=2*this.m_absDistance||s.height()<=2*this.m_absDistance)return new g.a({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case P.G.enumPoint:return this.bufferPoint();case P.G.enumMultiPoint:return this.bufferMultiPoint();case P.G.enumPolyline:return this.bufferPolyline();case P.G.enumPolygon:return this.bufferPolygon();case P.G.enumEnvelope:return this.bufferEnvelope();default:(0,P.c)("")}}bufferPolyline(){if(this.isDegenerateGeometry(this.m_geometry)){const u=new I.P;this.m_geometry.getPointByVal(0,u);const h=new L.J;return this.m_geometry.queryEnvelope(h),u.setXY(h.getCenter()),this.bufferDegeneratePath(u,!0)}const t=this.m_geometry,s=this.m_geometry.getDescription();this.m_geometry=null;const n=new J(t);let i,r;i=0===this.m_joins?(new d.O).executeMany(n,.25*this.m_densifyDist,!1,this.m_progressTracker):n,r=this.m_bRoundBuffer?(new G).executeMany(i,null,!0,this.m_progressTracker):i;const m=new Z(this,r,this.m_bFilter),a=(new A.h).executeMany(m,this.m_spatialReference,this.m_progressTracker,2),l=(new A.g).executeMany(a,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==l?l:new g.a({vd:s})}bufferPolygon(){if(0===this.m_distance)return this.m_geometry;this.generateCircleTemplate();const t=(new A.g).execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=t,this.m_geometry.isEmpty())return this.m_geometry;const s=this.m_geometry,n=this.bufferPolygonImpl(s,0,s.getPathCount());return(new A.g).execute(n,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=t,this.isDegenerateGeometry(this.m_geometry)){const r=new I.P;this.m_geometry.getPointByVal(0,r);const m=new L.J;return this.m_geometry.queryEnvelope(m),r.setXY(m.getCenter()),this.bufferDegeneratePath(r,!0)}const s=new ct(this),n=(new A.h).executeMany(s,this.m_spatialReference,this.m_progressTracker,2),i=(new A.g).executeMany(n,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==i?i:new g.a({vd:this.m_geometry.getDescription()})}}bufferPolygonImpl(t,s,n){const i=t,r=i.getImpl();let m=new g.a({vd:t.getDescription()});for(let a=s;a<n;a++){if(r.getPathSize(a)<1)continue;const l=r.calculateRingArea2D(a),u=new L.J;if(r.queryPathEnvelope(a,u),this.m_distance>0)if(l>0)if(this.isDegeneratePath(r,a)){const h=new I.P;r.getPointByVal(r.getPathStart(a),h),h.setXY(u.getCenter()),m.add(this.bufferDegeneratePath(h,!0),!1)}else{const h=new g.P({vd:t.getDescription()}),_=h.getImpl();if((0,g.i)(this.m_geometry,a)){const f=this.bufferConvexPath(i,a);m.add(f,!1)}else{this.bufferClosedPath(this.m_geometry,a,_,this.m_bRoundBuffer,1);const f=this.bufferCleanup(h);m.add(f,!1)}}else{if(u.width()+this.m_tolerance.total()<=2*this.m_absDistance||u.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const h=new g.P({vd:t.getDescription()}),_=h.getImpl();if(this.bufferClosedPath(this.m_geometry,a,_,this.m_bRoundBuffer,1),!h.isEmpty()){const f=u,y=Math.max(1,this.m_absDistance),b=f.clone();b.inflateCoords(y,y),_.addEnvelope(b,!1);const w=this.bufferCleanup(h);m.reserve(m.getPointCount()+w.getPointCount()-4),xt(w,m,b,!0)}}else if(l>0){if(u.width()+this.m_tolerance.total()<=2*this.m_absDistance||u.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const h=new g.P({vd:t.getDescription()}),_=h.getImpl();if(this.bufferClosedPath(this.m_geometry,a,_,this.m_bRoundBuffer,-1),!h.isEmpty()){const f=new L.J;_.queryLooseEnvelope(f);const y=Math.max(1,this.m_absDistance),b=f.clone();b.inflateCoords(y,y),_.addEnvelope(b,!1),xt(this.bufferCleanup(h),m,b,!0)}}else{const h=new g.P({vd:t.getDescription()}),_=h.getImpl();this.bufferClosedPath(this.m_geometry,a,_,this.m_bRoundBuffer,-1);const f=this.bufferCleanup(h);for(let y=0,b=f.getPathCount();y<b;y++)m.addPath(f,y,!0)}}if(this.m_distance>0)return m.getPathCount()>1?this.bufferCleanup(m):mt(m);{const a=new L.J;if(m.queryLooseEnvelope(a),m.isEmpty())return mt(m);{const l=Math.max(1,this.m_absDistance),u=a.clone();u.inflateCoords(l,l),m.addEnvelope(u,!1);const h=this.bufferCleanup(m);m=new g.a;const _=new g.a({vd:h.getDescription()});return xt(h,_,u,!1),mt(_)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(t){const s=new g.a({vd:t.getDescription()});return 0===this.m_caps?(this.addCircle(s.getImpl(),t),this.setStrongSimple(s)):2===this.m_caps?(this.addSquare(s.getImpl(),t),this.setStrongSimple(s)):s}bufferDegeneratePath(t,s){const n=new g.a({vd:t.getDescription()});return s&&0===this.m_joins||!s&&0===this.m_caps?(this.addCircle(n.getImpl(),t),this.setStrongSimple(n)):s||2!==this.m_caps?n:(this.addSquare(n.getImpl(),t),this.setStrongSimple(n))}bufferMultiPoint(){const t=new et(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return(new A.h).executeMany(t,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let t=new g.a({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(0===this.m_distance)t.addEnvelope(this.m_geometry,!1),z(this.m_geometry,this.m_tolerance.total())&&(t=this.setStrongSimple(t));else{const n=new I.E;this.m_geometry.queryEnvelope(n),n.inflateCoords(this.m_distance,this.m_distance),t.addEnvelope(n,!1),z(n,this.m_tolerance.total())&&(t=this.setStrongSimple(t))}return t}if(1===this.m_joins){const n=new I.E({copy:this.m_geometry});return n.inflateCoords(this.m_absDistance,this.m_absDistance),t.addEnvelope(n,!1),t}const s=this.m_geometry.clone();if(0===s.width()||0===s.height()){if(0===s.width()&&0===s.height()){const r=new I.P({vd:this.m_geometry.getDescription()});return s.queryCornerByVal(0,r),this.m_geometry=r,this.bufferImpl()}const n=new g.P({vd:this.m_geometry.getDescription()}),i=new I.P;return s.queryCornerByVal(0,i),n.startPathPoint(i),s.queryCornerByVal(2,i),n.lineToPoint(i),this.m_geometry=n,this.bufferImpl()}return t.addEnvelope(this.m_geometry,!1),this.m_geometry=t,this.bufferConvexPath(t,0)}bufferConvexPath(t,s){this.generateCircleTemplate();const n=t.hasAttribute(10),i=new g.a({vd:t.getDescription()}),r=i.getImpl();i.reserve((this.m_circleTemplate.length/10+4)*t.getPathSize(s));const m=new c.P,a=new c.P,l=new c.P,u=new c.P(0,0),h=new c.P,_=new c.P,f=t.getImpl(),y=t.getPathSize(s),b=t.getPathStart(s);for(let w=0,v=t.getPathSize(s);w<v;w++){const x=f.getXY(b+w),S=f.getXY(b+(w+1)%y),Y=f.getXY(b+(w+2)%y);h.setSub(S,x),0===h.length()&&(0,P.c)("");const E=n&&!!(1&f.getAttributeAsInt(10,(w+1)%y,0));h.normalize();const D=h.clone();h.leftPerpendicularThis(),h.scale(this.m_absDistance),m.setAdd(h,x),a.setAdd(h,S),0===w?r.startPath(m):r.lineTo(m),r.lineTo(a),_.setSub(Y,S),0===_.length()&&(0,P.c)(""),_.normalize();const U=_.clone();_.leftPerpendicularThis(),_.scale(this.m_absDistance),l.setAdd(_,S);let q=p.enumArc;const $=E?0:this.m_joins;if(2===$)q=p.enumBevel;else if(1===$){const ht=-D.crossProduct(U);u.setSub(D,U),u.scale(this.m_absDistance/ht),u.length()<this.m_miterLimit*this.m_absDistance?(u.addThis(S),q=p.enumMiter):q=p.enumBevel}else u.assign(S);this.addJoin(q,r,u,a,l,!1,!1)}return mt(i)}bufferPolylinePath(t,s,n){this.generateCircleTemplate();const i=t,r=i.getImpl();if(r.getPathSize(s)<1)return null;let m;if(m=this.m_bRoundBuffer?r.isClosedPathInXYPlane(s):r.isClosedPath(s),this.isDegeneratePath(r,s)&&this.m_distance>0){const u=new I.P;r.getPointByVal(r.getPathStart(s),u);const h=new L.J;return r.queryPathEnvelope(s,h),u.setXY(h.getCenter()),this.bufferDegeneratePath(u,m)}const a=new g.P({vd:t.getDescription()});a.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*r.getPathSize(s));const l=a.getImpl();return m?2!==this.bufferClosedPath(i,s,l,n,1)&&this.bufferClosedPath(i,s,l,n,-1):this.bufferOpenPath(i,s,l,n),this.bufferCleanup(a)}progress_(){}bufferCleanup(t,s=!1){return(0,A.y)(t,s?this.m_tolerance:this.m_smallTolerance,!0,!s,-1,this.m_progressTracker,0,!1)}calcN(){if(0===this.m_densifyDist)return this.m_maxVertexInCompleteCircle;const s=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed);let n=4;return n=s<-1?4:2*Math.PI/Math.acos(s)+.5,n<4?n=4:n>this.m_maxVertexInCompleteCircle&&(n=this.m_maxVertexInCompleteCircle),Math.trunc(n)}addJoin(t,s,n,i,r,m,a){if(this.generateCircleTemplate(),m&&(s.startPath(i),m=!1),t===p.enumBevel)return void(a&&s.lineTo(r));if(t===p.enumMiter){const x=n.clone();return s.lineTo(x),void(a&&s.lineTo(r))}const l=new c.P;l.setSub(i,n),l.scale(this.m_absDistanceReversed);const u=new c.P;u.setSub(r,n),u.scale(this.m_absDistanceReversed);let h=Math.atan2(l.y,l.x)/this.m_dA;h<0&&(h=this.m_circleTemplate.length+h),h=this.m_circleTemplate.length-h;let _=Math.atan2(u.y,u.x)/this.m_dA;_<0&&(_=this.m_circleTemplate.length+_),_=this.m_circleTemplate.length-_,_<h&&(_+=this.m_circleTemplate.length);let f=Math.trunc(_),y=Math.ceil(h),b=this.m_circleTemplate[y%this.m_circleTemplate.length].clone();b.scaleAddThis(this.m_absDistance,n);const w=10*this.m_tolerance.total();b.sub(i).length()<w&&(y+=1),b=this.m_circleTemplate[f%this.m_circleTemplate.length].clone(),b.scaleAddThis(this.m_absDistance,n),b.sub(r).length()<w&&(f-=1);let v=f-y;v++;for(let x=0,S=y%this.m_circleTemplate.length;x<v;x++,S=(S+1)%this.m_circleTemplate.length)b=this.m_circleTemplate[S].clone(),b.scaleAddThis(this.m_absDistance,n),s.lineTo(b),this.progress_();a&&s.lineTo(r)}bufferClosedPath(t,s,n,i,r){const m=new g.E,a=m.addPathFromMultiPath(t,s,!0);return this.bufferClosedPathImpl(m,a,n,i,r)}bufferClosedPathImpl(t,s,n,i,r){const m=t.getFirstVertex(t.getFirstPath(s)),a=new I.P;if(t.queryPoint(m,a),t.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),t.getPointCount(s)<2)return r<0?0:(this.m_bRoundBuffer&&this.addCircle(n,a),2);(0,P.g)(t.getFirstPath(s)!==g.n),(0,P.g)(t.getFirstVertex(t.getFirstPath(s))!==g.n);const l=t.getXY(t.getFirstVertex(t.getFirstPath(s))),u=new B.T;if(u.setShift(l.negate()),t.applyTransformation(u),i){const R=function _t(o,t,s,n,i,r,m){return function gt(o,t,s,n,i,r,m){const a={stack:[],error:void 0,hasError:!1};try{const l=o.getFirstPath(t),u=o.createUserIndex();(0,H.b)(a,(0,c.h)(()=>{o.removeUserIndex(u)},!1),!1),function dt(o,t,s,n){let i=-1;const r=new c.P,m=new c.P,a=new c.P;for(let l=0,u=o.getPathSize(n),h=o.getFirstVertex(n);l<u;++l){-1===i&&(o.queryXY(h,m),i=o.getPrevVertex(h),-1!==i&&(o.queryXY(i,r),a.setSub(m,r),a.normalize()));const _=o.getNextVertex(h);if(-1===_)break;const f=o.getXY(_),y=f.sub(m);y.normalize(),-1!==i&&y.dotProduct(a)<-.99&&Math.abs(y.crossProduct(a))<1e-7&&o.setUserIndex(h,t,1),i=h,h=_,r.assign(m),m.assign(f),a.assign(y)}}(o,u,0,l);for(let h=0;h<100;++h){if(0===o.getPathSize(l))return 1;let _=o.getFirstVertex(l),f=o.getPathSize(l);if(f<3)return 1;o.isClosedPath(l)||(f-=1);const y=64;let b=0,w=!1;for(let v=0;v<f&&_!==g.n;v++){let x=0,S=_;for(let Y=1,E=Math.min(y,f-v);Y<E;Y++)if(S=o.getNextVertexEx(S,s),Y>1){const D=ft(o,u,_,S,s,i,m,y);if(-1===D)break;x+=D,f-=D}if(b+=x,w=x>0,w){const Y=o.getPrevVertexEx(_,s);if(-1!==Y){_=Y,f++;continue}}_=o.getNextVertexEx(_,s)}if(0===b)break}return o.filterClosePoints(r,!1,!1,!1,-1),1}catch(l){a.error=l,a.hasError=!0}finally{(0,H.c)(a)}}(o,t,s,0,i,r,m)}(t,s,r,0,this.m_absDistance,this.m_filterTolerance,this.m_densifyDist);if((0,P.g)(1===R),t.getPointCount(s)<2)return r<0?0:(this.addCircle(n,a),2)}const h=0!==this.m_joins&&t.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;const _=t.getFirstPath(s);let f=t.getFirstVertex(_),y=1===r?t.getPrevVertex(f):t.getNextVertex(f),b=1===r?t.getNextVertex(f):t.getPrevVertex(f),w=!0;const v=new c.P,x=new c.P,S=new c.P,Y=new c.P,E=new c.P,D=new c.P,U=new c.P,q=new c.P,$=this.m_absDistance,ht=t.getPathSize(_),st=new c.P(0,0);for(let R=0;R<ht;R++){x.assign(t.getXY(b)),w&&(v.assign(t.getXY(f)),S.assign(t.getXY(y)),D.setSub(v,S),D.normalize(),q.leftPerpendicularOther(D),q.scale($),Y.setAdd(q,v));const C=h&&!!(1&t.getAttributeAsDbl(10,f,0));E.setSub(x,v),E.normalize(),U.leftPerpendicularOther(E),U.scale($);const Q=new c.P;Q.setAdd(v,U);const it=D.crossProduct(E),M=D.dotProduct(E);if(it<0||M<0&&it<Math.abs(M)*Number.EPSILON*8){let tt=!1;const nt=C?0:this.m_joins;if(1===nt){const W=-it;st.setSub(D,E),st.scale(this.m_absDistance/W),st.length()<this.m_miterLimit*this.m_absDistance&&(st.addThis(v),tt=!0),this.m_bufferCommands.push(X(Y,Q,st,tt?p.enumMiter:p.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(X(Y,Q,v,0===nt?p.enumArc:p.enumBevel,this.m_bufferCommands.length+1))}else Y.equals(Q)||(this.m_bufferCommands.push(V(Y,v,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(V(v,Q,this.m_bufferCommands.length+1)));const O=new c.P;O.setAdd(x,U),this.m_bufferCommands.push(X(Q,O,v,p.enumLine,this.m_bufferCommands.length+1)),Y.setCoordsPoint2D(O),q.setCoordsPoint2D(U),S.setCoordsPoint2D(v),v.setCoordsPoint2D(x),D.setCoordsPoint2D(E),y=f,f=b,w=!1,b=1===r?t.getNextVertex(f):t.getPrevVertex(f)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(n),u.setShift(l),n.applyTransformationToPath(u,n.getPathCount()-1),1}bufferOpenPath(t,s,n,i){if(this.m_bRoundBuffer){const C=new g.P({vd:t.getDescription()});return C.addPath(t,s,!1),C.addSegmentsFromPath(t,s,0,t.getSegmentCountPath(s),!1),this.bufferClosedPath(C,0,n,i,1)}let r=0;const m=new g.P({vd:t.getDescription()}),a=new c.P(0,0);{const C=new g.E,Q=C.addPathFromMultiPath(t,s,!1),it=C.getFirstVertex(C.getFirstPath(Q)),M=new I.P;if(C.queryPoint(it,M),a.assign(M.getXY()),C.filterClosePoints(0,!1,!1,!1,-1),C.getPointCount(Q)<2)return this.m_bRoundBuffer&&this.addCircle(n,M),2;const O=C.getGeometry(C.getFirstGeometry());m.addPath(O,0,!1),r=m.getPointCount()-1,m.addSegmentsFromPath(O,0,0,O.getSegmentCountPath(0)-1,!1)}const l=new g.E,u=l.addPathFromMultiPath(m,0,!0);(0,P.g)(l.getFirstPath(u)!==g.n),(0,P.g)(l.getFirstVertex(l.getFirstPath(u))!==g.n);const h=new B.T;h.setShift(a.negate()),l.applyTransformation(h),this.m_bufferCommands.length=0;const _=l.getFirstPath(u),f=0!==this.m_joins&&l.getVertexDescription().hasAttribute(10);let y=l.getFirstVertex(_),b=l.getPrevVertex(y),w=l.getNextVertex(y),v=!0;const x=new c.P,S=new c.P,Y=new c.P,E=new c.P,D=new c.P,U=new c.P,q=new c.P,$=new c.P,ht=this.m_absDistance,st=l.getPathSize(_),R=new c.P(0,0);for(let C=0;C<st;C++){let Q=!1;0!==C&&C!==r||(Q=!0),S.assign(l.getXY(w)),v&&(x.assign(l.getXY(y)),Y.assign(l.getXY(b)),U.setSub(x,Y),U.normalize(),$.leftPerpendicularOther(U),$.scale(ht),E.setAdd($,x));const it=f&&!!(1&l.getAttributeAsDbl(10,y,0));D.setSub(S,x),D.normalize(),q.leftPerpendicularOther(D),q.scale(ht);const M=new c.P;M.setAdd(x,q);const O=U.crossProduct(D),tt=U.dotProduct(D);if(O<0||tt<0&&O<Math.abs(tt)*Number.EPSILON*8)if(Q)if(0===this.m_caps)this.m_bufferCommands.push(X(E,M,x,p.enumArc,this.m_bufferCommands.length+1));else if(1===this.m_caps)this.m_bufferCommands.push(X(E,M,x,p.enumLine,this.m_bufferCommands.length+1));else{const W=D.mul(this.m_absDistance).negate(),rt=W.clone();W.addThis(E),rt.addThis(M),this.m_bufferCommands.push(X(E,W,x,p.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(X(W,rt,x,p.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(X(rt,M,x,p.enumLine,this.m_bufferCommands.length+1))}else{let W=!1;const rt=it?0:this.m_joins;if(1===rt){const F=-O;R.setSub(U,D),R.scale(this.m_absDistance/F),R.length()<this.m_miterLimit*this.m_absDistance&&(R.addThis(x),W=!0),this.m_bufferCommands.push(X(E,M,R,W?p.enumMiter:p.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(X(E,M,x,0===rt?p.enumArc:p.enumBevel,this.m_bufferCommands.length+1))}else E.equals(M)||(this.m_bufferCommands.push(V(E,x,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(V(x,M,this.m_bufferCommands.length+1)));const nt=new c.P;nt.setAdd(S,q),this.m_bufferCommands.push(X(M,nt,x,p.enumLine,this.m_bufferCommands.length+1)),E.setCoordsPoint2D(nt),$.setCoordsPoint2D(q),Y.setCoordsPoint2D(x),x.setCoordsPoint2D(S),U.setCoordsPoint2D(D),b=y,y=w,v=!1,w=l.getNextVertex(y)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(n),h.setShift(a),n.applyTransformationToPath(h,n.getPathCount()-1),1}processBufferCommands(t){const s=this.cleanupBufferCommands();let n=!0,i=s+1;for(let r=s;i!==s;r=i){const m=this.m_bufferCommands[r];i=-1!==m.m_next?m.m_next:(r+1)%this.m_bufferCommands.length,m.m_type&&(n&&(t.startPath(m.m_from),n=!1),m.m_type&p.enumJoinMask?this.addJoin(m.m_type,t,m.m_center,m.m_from,m.m_to,!1,!0):t.lineTo(m.m_to))}}cleanupBufferCommands(){this.m_helperArray=(0,c.m)(c.P,9);let t=0;for(let n=0,i=this.m_bufferCommands.length;n<i;){const r=this.m_bufferCommands[n];if(r.m_type&p.enumConnectionMask){t=n;break}n=r.m_next}let s=t+1;for(let n=t;s!==t;n=s){const i=this.m_bufferCommands[n];s=i.m_next;let r=1,m=null;for(;s!==n&&(m=this.m_bufferCommands[s],!(m.m_type&p.enumConnectionMask));)s=m.m_next,r++;1!==r&&(i.m_type&m.m_type)===p.enumLine&&(this.m_helperLine1.setStartXY(i.m_from),this.m_helperLine1.setEndXY(i.m_to),this.m_helperLine2.setStartXY(m.m_from),this.m_helperLine2.setEndXY(m.m_to),1===this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())&&(i.m_to.assign(this.m_helperArray[0]),m.m_from.assign(this.m_helperArray[0]),i.m_next=s))}return t}isDegeneratePath(t,s){if(1===t.getPathSize(s))return!0;if(0===this.m_joins&&0===this.m_caps){const n=new L.J;if(t.queryPathEnvelope(s,n),Math.max(n.width(),n.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(t){if(0===this.m_joins&&0===this.m_caps){const s=new L.J;if(t.queryEnvelope(s),Math.max(s.width(),s.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(t,s){const n=s.getXY();if(0!==this.m_circleTemplate.length){let u=this.m_circleTemplate[0].clone();u.scaleAddThis(this.m_absDistance,n),t.startPath(u);for(let h=1,_=this.m_circleTemplate.length;h<_;h++)u=this.m_circleTemplate[h].clone(),u.scaleAddThis(this.m_absDistance,n),t.lineTo(u);return}const r=Math.trunc((this.m_circleTemplateSize+3)/4),m=.5*Math.PI/r;t.reserve(4*r);const a=Math.cos(m),l=Math.sin(m);for(let u=3;u>=0;u--){const h=c.P.construct(0,this.m_absDistance);switch(u){case 0:for(let _=0;_<r;_++)t.lineToCoords(h.x+n.x,h.y+n.y),h.rotateReverse(a,l);break;case 1:for(let _=0;_<r;_++)t.lineToCoords(-h.y+n.x,h.x+n.y),h.rotateReverse(a,l);break;case 2:for(let _=0;_<r;_++)t.lineToCoords(-h.x+n.x,-h.y+n.y),h.rotateReverse(a,l);break;default:t.startPathCoords(h.y+n.x,-h.x+n.y);for(let _=1;_<r;_++)h.rotateReverse(a,l),t.lineToCoords(h.y+n.x,-h.x+n.y)}this.progress_()}}addSquare(t,s){const n=new I.E({vd:s.getDescription()});n.setCoords(s.getX(),s.getY(),s.getX(),s.getY()),n.inflateCoords(this.m_absDistance,this.m_absDistance),t.addEnvelope(n,!1)}setStrongSimple(t){return t.getImpl().setIsSimple(4,this.m_tolerance.total()),t.getImpl().updateOGCFlagsProtected(),t}}function mt(o){return(0,I.s)(o,0),o}function z(o,t){return!!o.isEmpty()||Math.min(o.width(),o.height())>t}function ft(o,t,s,n,i,r,m,a){const l=o.getXY(s),u=o.getXY(n);if(l.equals(u))return-1;const h=.25*m,_=.25*m,f=new c.P;f.setSub(u,l);const y=f.length(),b=y*y*.25,w=r*r-b;if(w<=b)return-1;const v=Math.sqrt(w);f.normalize();const x=f.clone();x.rightPerpendicularThis();const S=b/v,Y=S<=_,E=c.P.lerp(u,l,.5),D=x.clone();D.scaleAddThis(Math.max(0,S-h),E),x.negate().scaleAddThis(v,E);const q=3.61*(0,c.s)(r-_),$=D.sub(l),ht=D.sub(u);let st=!1,R=0;const C=(0,c.d)(64,0);(0,P.g)(a===C.length);{for(let K=o.getPrevVertexEx(n,i);K!==s;){if(1===o.getUserIndex(K,t))return-1;if(!o.getXY(K).equals(u))break;{const ot=o.getPrevVertexEx(K,i);o.removeVertex(K,!1),K=ot}}const F=new c.P,N=l.clone();C[R++]=1;for(let K=o.getNextVertexEx(s,i);K!==n;){if(1===o.getUserIndex(K,t))return-1;const ot=o.getXY(K);if(ot.equals(N)){const St=o.getNextVertexEx(K,i);o.removeVertex(K,!1),K=St;continue}C[R++]=0;const Ct=new c.P;if(Ct.setSub(ot,l),Ct.dotProduct(x)<0)return 0;(c.P.sqrDistance(ot,l)>q||c.P.sqrDistance(ot,u)>q)&&(st=!0);let Pt=0;if(ot.sub(l).crossProduct($)>=0&&(Pt=1),ot.sub(u).crossProduct(ht)<=0&&(Pt|=2),0===Pt)return 0;C[R-1]=Pt,F.assign(N),N.assign(ot),K=o.getNextVertexEx(K,i)}if(1===R)return 0;(0,P.g)(R<C.length),C[R++]=2}let Q=!0;for(let F=1,N=0;F<R;F++)if(C[F]!==C[F-1]&&(N++,Q=N<3&&(1===N&&3===C[F]||2===N&&2===C[F]),!Q))return 0;if(R>2&&Q&&(3===R||!st)){let F=0,N=o.getNextVertexEx(s,i);for(Y||(o.setXY(N,D),N=o.getNextVertexEx(N,i));N!==n;){const K=o.getNextVertexEx(N,i);o.removeVertex(N,!1),N=K,++F}return F}if((0,P.g)(3!==R),st&&R>3)return 0;const it=l.clone();let M=s;const O=l.clone();let tt=1,nt=-1,W=M,rt=0;for(R=1;W!==n;){W=o.getNextVertexEx(W,i);const F=C[R++];if(0===F){if(W===n)break;continue}const N=o.getXY(W);if(-1!==nt){if(nt&tt&F&3){o.removeVertex(M,!0),rt++,M=W,O.setCoordsPoint2D(N),tt=F;continue}if(3===tt&&0!==nt&&0!==F){if(O.setCoordsPoint2D(D),Y||O.equals(it)){o.removeVertex(M,!0),rt++,M=W,O.setCoordsPoint2D(N),tt=F;continue}o.setXY(M,O)}}nt=tt,it.setCoordsPoint2D(O),M=W,tt=F,O.setCoordsPoint2D(N)}return rt}function xt(o,t,s,n){for(let i=0,r=o.getPathCount();i<r;i++){const m=o.getXY(o.getPathStart(i));m.x!==s.xmin&&m.x!==s.xmax&&t.addPath(o,i,n)}}class bt extends k.G{constructor(t,s,n,i,r,m,a){super(),this.m_currentUnionEnvelope2D=new L.J,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=a,this.m_bufferer=new ut(a),this.m_inputGeoms=t,this.m_spatialReference=s,this.m_distances=n,this.m_maxDeviation=i,this.m_maxVerticesInFullCircle=r}tock(){return!0}getRank(){return 1}next(){{let t;for(;t=this.m_inputGeoms.next();)return(0,P.d)(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.buffer(t,this.m_distances[this.m_dindex]);return null}}getGeometryID(){return this.m_index}buffer(t,s){return this.m_bufferer.buffer(t,s,this.m_spatialReference,0,0,4,this.m_maxDeviation,this.m_maxVerticesInFullCircle)}}const pt=new class Dt{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(t,s,n){return!1}canAccelerateGeometry(t){return!1}executeMany(t,s,n,i,r){return this.executeManyEx(t,s,n,Number.NaN,96,i,r)}execute(t,s,n,i){Number.isFinite(n)||(0,P.t)("Invalid distance for buffer operation");const r=new k.S([t]),a=this.executeMany(r,s,[n],!1,i).next();return a||(0,P.c)("null buffer output"),a}executeManyEx(t,s,n,i,r,m,a){if(void 0!==n.find(l=>!Number.isFinite(l))&&(0,P.t)("Invalid distance for buffer operation"),m){const l=new bt(t,s,n,i,r,!1,a);return(new A.h).executeMany(l,s,a,2)}return new bt(t,s,n,i,r,!1,a)}};function vt(o,t,s){return pt.execute(o,t,s,null)}function Tt(o,t,s,n,i,r){const m=pt.executeManyEx(new k.S(o),t,s,n,i,r,null);return Array.from(m)}function wt(){return pt.supportsCurves()}}}]);