"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[3037],{7085:(Do,Ui,ze)=>{ze.d(Ui,{$:()=>pn,A:()=>Re,B:()=>Qe,C:()=>li,D:()=>Ie,E:()=>Mn,F:()=>je,G:()=>Ao,H:()=>Or,I:()=>nr,J:()=>Is,K:()=>_e,L:()=>ir,M:()=>ar,N:()=>Br,O:()=>Se,P:()=>Ns,Q:()=>qs,R:()=>hr,S:()=>fe,T:()=>re,U:()=>wi,V:()=>ue,W:()=>Oe,X:()=>xe,Y:()=>lr,Z:()=>mr,_:()=>Fn,a:()=>rr,a0:()=>No,a1:()=>zr,a2:()=>qe,a3:()=>or,a4:()=>Be,a5:()=>rn,a6:()=>ks,b:()=>Hr,c:()=>Qs,d:()=>Gn,e:()=>To,f:()=>dn,g:()=>Us,h:()=>me,i:()=>Ur,j:()=>Ut,k:()=>Ti,l:()=>Yt,m:()=>se,n:()=>Vt,o:()=>ee,p:()=>Ee,q:()=>de,r:()=>Jt,s:()=>Qi,t:()=>Te,u:()=>Pe,v:()=>Ls,w:()=>jt,x:()=>Ii,y:()=>ms,z:()=>ve});var R=ze(33165),F=ze(87571),c=ze(62257);const dt=[0,0,Number.NaN,0,0,0,0,0,-1,-1,0,0,0,0],Y=[2,1,1,1,3,1,2,3,2,4,1,1,2,1],vt=[1,1,1,0,2,1,1,1,0,0,0,0,0,1],Wt=[1,1,1,2,0,0,0,0,2,2,4,2,2,1],Rt=[4,8,4,8,1],Se=25;function ee(){return(0,R.d)(Se,Number.NaN)}let ue=class An{getAttributeCount(){return this.m_attributeCount}getSemantics(w){return this.m_indexToSemantics[w]}getSemanticsBitArray(){return this.m_semanticsBitArray}getAttributeIndex(w){return this.m_semanticsToIndexMap[w]}static getInterpolation(w){return vt[w]}static getPersistence(w){return Wt[w]}static getPersistenceSize(w){return Rt[w]}static getPersistenceSizeFromSemantics(w){return An.getPersistenceSize(An.getPersistence(w))*An.getComponentCount(w)}static getComponentCount(w){return Y[w]}static maxComponentCount(){return 4}static isInteger(w){return 2===w||3===w||4===w}static isIntegerSemantics(w){return An.isInteger(An.getPersistence(w))}static isTexture(w){return 5===w||6===w||7===w}hasAttribute(w){return!!(this.m_semanticsBitArray&1<<w)}hasAttributesFrom(w){return(this.m_semanticsBitArray&w.m_semanticsBitArray)===w.m_semanticsBitArray}hasZ(){return this.hasAttribute(1)}hasM(){return this.hasAttribute(2)}hasID(){return this.hasAttribute(3)}getTotalComponentCount(){return this.m_totalComponentCount}static getDefaultValue(w){return dt[w]}static isDefaultValue(w,V){return(0,R.a3)(dt[w],V)}equals(w){return this===w}getDefaultPointAttributes(){return this.m_defaultPointAttributes}getPointAttributeOffset(w){return this.m_pointAttributeOffsets[w]}constructor(w){this.m_semanticsBitArray=w,this.m_attributeCount=0,this.m_totalComponentCount=0,this.m_semanticsToIndexMap=new Int32Array(14),this.m_indexToSemantics=new Int32Array(14),this.m_pointAttributeOffsets=new Int32Array(14),this.m_defaultPointAttributes=(0,R.d)(Se,Number.NaN),this.m_semanticsToIndexMap.fill(-1),this.m_indexToSemantics.fill(-1);let V=0,W=1,it=14;for(;V<it;V++)w&W&&(this.m_semanticsToIndexMap[V]=this.m_attributeCount,this.m_indexToSemantics[this.m_attributeCount]=V,this.m_attributeCount++,this.m_totalComponentCount+=An.getComponentCount(V)),W<<=1;let lt=0;for(V=0,it=this.getAttributeCount();V<it;V++){const xt=this.getSemantics(V),Ct=An.getComponentCount(xt),It=An.getDefaultValue(xt);this.m_pointAttributeOffsets[V]=lt;for(let Lt=0;Lt<Ct;Lt++)this.m_defaultPointAttributes[lt]=It,lt++}}};var hs=ue;function Ee(){return(0,R.d)(14,0)}class As{static getInstance(){return As.s_thisInstance}constructor(){this.m_map=new Map,this.m_vd2D=new hs(1),this.m_map.set(1,this.m_vd2D),this.m_vd3D=new hs(3),this.m_map.set(3,this.m_vd2D)}GetVD2D(){return this.m_vd2D}GetVD3D(){return this.m_vd3D}FindOrAdd(w){if(1===w)return this.GetVD2D();if(3===w)return this.GetVD3D();const V=this.m_map.get(w);if(V)return V;const W=new hs(w);return this.m_map.set(w,W),W}}function Ve(Gt){return As.getInstance().FindOrAdd(Gt)}function Yt(Gt,w){if(!Gt||!w)return w||Gt;const V=Gt.getSemanticsBitArray()|w.getSemanticsBitArray();return(V&Gt.getSemanticsBitArray())===V?Gt:(V&w.getSemanticsBitArray())===V?w:Ve(V)}function se(Gt,w){const V=Gt.getSemanticsBitArray()|1<<w;return(V&Gt.getSemanticsBitArray())===V?Gt:Ve(V)}function Jt(Gt,w){const V=(Gt.getSemanticsBitArray()|1<<w)-(1<<w);return V===Gt.getSemanticsBitArray()?Gt:Ve(V)}function Ut(){return As.getInstance().GetVD2D()}function jt(){return As.getInstance().GetVD3D()}function de(Gt,w,V){if(V.fill(-1),null!==Gt&&null!==w)for(let W=0,it=Gt.getAttributeCount();W<it;W++)V[W]=w.getAttributeIndex(Gt.getSemantics(W))}As.s_thisInstance=new As;let me=(()=>{class Gt{static construct(V,W,it){return new Gt(V,W,it)}constructor(V,W,it){void 0!==V?(this.x=V,this.y=W,this.z=it):this.x=this.y=this.z=Number.NaN}get 0(){return this.x}get 1(){return this.y}get 2(){return this.z}set 0(V){this.x=V}set 1(V){this.y=V}set 2(V){this.z=V}clone(){return new Gt(this.x,this.y,this.z)}assign(V){return this.x=V.x,this.y=V.y,this.z=V.z,this}setCoords(V,W,it){return this.x=V,this.y=W,this.z=it,this}setCoordsPoint2DZ(V,W){return this.setCoords(V.x,V.y,W)}setCoordsPoint3D(V){this.x=V.x,this.y=V.y,this.z=V.z}setZero(){this.x=0,this.y=0,this.z=0}setNormalized(V){this.assign(V),this.normalizeThis()}normalizeThis(){const V=this.length();return V?(this.x/=V,this.y/=V,this.z/=V):(this.x=1,this.y=0,this.z=0),this}getUnitVector(){const V=new Gt;return V.setNormalized(this),V}sqrLength(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthXY(){return(0,c.g)(0),0}static sqrDistance(V,W){return(0,R.s)(V.x-W.x)+(0,R.s)(V.y-W.y)+(0,R.s)(V.z-W.z)}static sqrDistanceCoords(V,W,it,lt,xt,Ct){return(0,R.s)(V-lt)+(0,R.s)(W-xt)+(0,R.s)(it-Ct)}static distance(V,W){return Math.sqrt(Gt.sqrDistance(V,W))}isEqual(V,W){return void 0===W&&(W=0),Math.abs(this.x-V.x)<=W&&Math.abs(this.y-V.y)<=W&&(0,R.I)(this.z,V.z,W)}static compareByLength(V,W,it,lt){return(0,c.g)(0),0}isEqualCoords(V,W,it,lt){return(0,c.g)(0),this.x===V&&this.y===W&&this.z===it}isEqualsTols(V,W,it){return(0,c.g)(0),!1}isEqualCoordsTols(V,W,it,lt,xt){return(0,c.g)(0),!1}static st_isEqual(V,W,it,lt){return(0,c.g)(0),!1}equals(V,W){return this.isEqual(V,W)}equalsTols(V,W,it){return(0,c.g)(0),!1}divThis(V){return this.x/=V,this.y/=V,this.z/=V,this}subThis(V){return this.x-=V.x,this.y-=V.y,this.z-=V.z,this}setSub(V,W){return this.x=V.x-W.x,this.y=V.y-W.y,this.z=V.z-W.z,this}sub(V){return Gt.construct(this.x-V.x,this.y-V.y,this.z-V.z)}addThis(V){return this.x+=V.x,this.y+=V.y,this.z+=V.z,this}add(V){return this.clone().addThis(V)}setAdd(V,W){return this.x=V.x+W.x,this.y=V.y+W.y,this.z=V.z+W.z,this}mul(V){return Gt.construct(this.x*V,this.y*V,this.z*V)}dotProduct(V){return this.x*V.x+this.y*V.y+this.z*V.z}crossProductVector(V){return new Gt(this.y*V.z-V.y*this.z,V.x*this.z-this.x*V.z,this.x*V.y-V.x*this.y)}setCrossProductVector(V,W){const lt=W.x*V.z-V.x*W.z,xt=V.x*W.y-W.x*V.y;return this.x=V.y*W.z-W.y*V.z,this.y=lt,this.z=xt,this}setScaled(V,W){return this.x=V*W.x,this.y=V*W.y,this.z=V*W.z,this}scaleThis(V){return this.x*=V,this.y*=V,this.z*=V,this}scaleZThis(V){return this.z*=V,this}setNAN(){return(0,c.g)(0),this}isNAN(){return Number.isNaN(this.x)||Number.isNaN(this.y)||Number.isNaN(this.z)}static getNAN(){return Gt.construct(Number.NaN,Number.NaN,Number.NaN)}isFinite(){return(0,c.g)(0),!1}isZero(){return 0===this.x&&0===this.y&&0===this.z}norm(V){return(0,c.g)(0),0}sqrDistanceFromCenterToSpheroidSurface(V,W){return(0,c.g)(0),0}distanceFromCenterToSpheroidSurface(V,W){return Math.sqrt(this.sqrDistanceFromCenterToSpheroidSurface(V,W))}static getClosestCoordinate(V,W,it,lt=!1){return(0,c.g)(0),0}compare(V){return this.y<V.y?-1:this.y>V.y?1:this.x<V.x?-1:this.x>V.x?1:this.z<V.z?-1:this.z>V.z?1:0}compareXYZ(V){return(0,c.g)(0),0}negateThis(){this.x=-this.x,this.y=-this.y,this.z=-this.z}static averageFast(V,W){return(0,c.g)(0),{}}static average(V,W){return(0,c.g)(0),{}}static size(){return Gt.dimensions}static lerp(V,W,it){const lt=new Gt;return(0,R.x)(V,W,it,lt),lt}static slerp(V,W,it){return(0,c.g)(0),{}}static compareVectors(V,W){return(0,c.g)(0),0}static selectRightHandedBasisFromNormal(V,W,it){const lt=V.getUnitVector(),xt=lt.createAPerpendicular(),Ct=new Gt;Ct.setCrossProductVector(lt,xt),Ct.normalizeThis(),W.setCoordsPoint3D(xt),it.setCoordsPoint3D(Ct)}createAPerpendicular(){const V=[this.crossProductVector(new Gt(0,0,1)),this.crossProductVector(new Gt(1,0,0)),this.crossProductVector(new Gt(0,1,0))],W=[V[0].sqrLength(),V[1].sqrLength(),V[2].sqrLength()],it=V[W.reduce((lt,xt,Ct)=>W[lt]>W[Ct]?lt:Ct,0)];return it.normalizeThis(),it}calculateAngle(V){return(0,c.g)(0),0}static crossDotSign(V,W,it){return(0,c.g)(0),0}static isBisectorRobust(V,W,it){return(0,c.g)(0),0}static compareZOrder(V,W){return(0,c.g)(0),!1}}return Gt.dimensions=3,Gt})();class Vt{static constructEmpty(){return new Vt(Number.NaN,Number.NaN,Number.NaN,Number.NaN,Number.NaN,Number.NaN)}constructor(w,V,W,it,lt,xt){this.m_EnvelopeType=3,this.xmin=w,this.ymin=V,this.zmin=W,this.xmax=it,this.ymax=lt,this.zmax=xt,this.normalize()}inflate(w){this.inflateCoords(w,w,w)}inflateCoords(w,V,W){(0,c.g)(0)}getEnvelope2D(){return new F.J(this.xmin,this.ymin,this.xmax,this.ymax)}getEnvelopeZs(){return new R.E(this.zmin,this.zmax)}setEmptyZ(){this.zmin=Number.NaN,this.zmax=Number.NaN}normalize(){let w=!1;this.xmin<=this.xmax||(this.xmax=(0,R.b)(this.xmin,this.xmin=this.xmax),w=!0),this.ymin<=this.ymax||(this.ymax=(0,R.b)(this.ymin,this.ymin=this.ymax),w=!0),!w||this.xmin<=this.xmax&&this.ymin<=this.ymax?this.zmin<=this.zmax||(this.zmax=(0,R.b)(this.zmin,this.zmin=this.zmax),this.zmin<=this.zmax||this.setEmptyZ()):this.setEmpty()}isEmpty(){return Number.isNaN(this.xmin)||Number.isNaN(this.ymin)||Number.isNaN(this.xmax)||Number.isNaN(this.ymax)}isEmptyZ(){return Number.isNaN(this.zmin)||Number.isNaN(this.zmax)}setEmpty(){this.xmin=Number.NaN,this.ymin=Number.NaN,this.zmin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN,this.zmax=Number.NaN}mergeEnv3D(w){w.isEmpty()||(this.mergeCoords(w.xmin,w.ymin,w.zmin),this.mergeCoords(w.xmax,w.ymax,w.zmax))}mergeNe(w){this.mergeNeCoords(w.x,w.y,w.z)}mergeNeCoords(w,V,W){this.xmin>w?this.xmin=w:this.xmax<w&&(this.xmax=w),this.ymin>V?this.ymin=V:this.ymax<V&&(this.ymax=V),this.zmin>W?this.zmin=W:this.zmax<W&&(this.zmax=W)}mergeCoords(w,V,W){this.isEmpty()?(this.xmin=w,this.xmax=w,this.ymin=V,this.ymax=V,this.zmin=W,this.zmax=W):(this.isEmptyZ()&&(this.zmin=W,this.zmax=W),this.mergeNeCoords(w,V,W))}setCoords(w,V,W,it,lt,xt){this.xmin=w,this.ymin=V,this.zmin=W,this.xmax=it,this.ymax=lt,this.zmax=xt,this.normalize()}sqrDistanceEnvelope3DAndPoints(w,V,W,it=1){return(0,c.g)(0),0}sqrMaxDistance(w,V=1){return(0,c.g)(0),0}}const xe=-559038737;var $t=ue;function _e(Gt,w,V){switch(Gt){case 0:return new we(w,V);case 1:return new ms(w,V);case 2:return new Re(w,V);case 3:throw new Error("64 bit int attribute stream not implemented");case 4:return new Be(w,V);default:(0,c.t)("")}}function Te(Gt,w){const V=$t.getComponentCount(Gt);return _e($t.getPersistence(Gt),w*V,$t.getDefaultValue(Gt))}function Pe(Gt,w){const V=$t.getComponentCount(Gt);return _e($t.getPersistence(Gt),w*V)}function ve(Gt,w){return new Re(Gt,w)}function Ie(Gt,w){return new Be(Gt,w)}function je(Gt,w){return new ms(Gt,w)}class Le{size(){return this.m_size}checkResize(w,V){w>this.m_size&&this.resize(w,V)}resize(w,V){if((w=Math.trunc(w))===this.m_size)return;const W=!!V||Number.isNaN(V);if(w<this.m_a.length)this.m_a.length>Le.s_resizeMin&&1.25*w<this.m_a.length&&(this.m_a=this.m_a.slice(0,w)),W&&w>this.m_size&&this.m_a.fill(V,this.m_size,w);else if(w>=this.m_a.length){const lt=new this.m_a.constructor(1.25*w);lt.set(this.m_a),this.m_a=lt,W&&this.m_a.fill(V,this.m_size,w)}this.m_size=w}resizeRounded(w,V){return this.resize(w,V)}reserve(w){}read(w){return this.m_a[w]}readAsDbl(w){return this.read(w)}write(w,V){this.m_a[w]=V}writeAsDbl(w,V){this.write(w,V)}setRange(w,V,W){(V<0||W<0||W+V>this.size())&&(0,c.t)(),this.m_a.fill(w,V,V+W)}add(w){this.resize(this.m_size+1),this.m_a[this.m_size-1]=w}addArray(w,V){const W=this.m_size;void 0===V?(this.resize(this.m_size+w.length),this.m_a.set(w,W)):(this.resize(this.m_size+V),this.m_a.set(w.slice(0,V),W))}equals(w,V,W,it){return this.getPersistence()===w.getPersistence()&&function Ss(Gt,w,V,W,it){if(Gt.getPersistence()!==w.getPersistence())return!1;const lt=Gt.getPersistence()<=1,xt=Gt.size(),Ct=w.size();if(W>xt||W>Ct)return!1;if(it)if(lt){for(let It=V;It<W;It++)if(!(0,R.I)(Gt.read(It),w.read(It),it))return!1}else for(let It=V;It<W;It++){let Lt=Gt.read(It)-w.read(It);if(Lt<0&&(Lt=-Lt),Lt>it)return!1}else for(let It=V;It<W;It++){const Lt=Gt.read(It),te=w.read(It);if(Lt!==te){if(lt&&Number.isNaN(Lt)&&Number.isNaN(te))continue;return!1}}return!0}(this,w,V,W,it)}insertRange(w,V,W,it){const lt=this.m_size;this.checkResize(Math.max(0,it)+W),this.m_a.copyWithin(w+W,w,it>=0?it:lt),this.m_a.fill(V,w,w+W)}readRange(w,V){return this.m_a.slice(w,w+V)}insertRangeFromStream(w,V,W,it,lt,xt,Ct){(0,c.g)(this.getPersistence()===V.getPersistence());const It=V,Lt=this.m_size;it&&this.checkResize(Math.max(0,Ct)+it),this.m_a.copyWithin(w+it,w,Ct>=0?Ct:Lt),this.m_a.set(It.readRange(W,it),w),lt||this.reverseRange(w,it,xt)}writeRange(w,V,W,it,lt,xt){(0,c.g)(this.getPersistence()===W.getPersistence());const Ct=W;if((w<0||V<0||it<0)&&(0,c.t)(),Ct.size()<it+V&&(0,c.t)(),0===V)return;this.size()<V+w&&this.resize(V+w);const It=Ct.m_a.subarray(it,it+V);!function Ze(Gt,w,V,W,it,lt){if((w<0||V<0)&&(0,c.t)(),0===V)return;if(1===V)return void(Gt[w]=W[0]);let xt=W;V<W.length&&(xt=W.subarray(0,V)),Gt.set(xt,w)}(this.m_a,w,V,It)}insertAttributes(w,V,W,it){const lt=$t.getComponentCount(W);this.m_a.copyWithin(w+lt,w,it>=0?it:this.m_size);for(let xt=0;xt<lt;xt++)this.m_a[w+xt]=V.getAttributeAsDbl(W,xt)}insertAttributesFromPoints(w,V,W,it,lt){(0,c.g)($t.getPersistence(it)===this.getPersistence());const xt=$t.getComponentCount(it),Ct=this.m_size;if(this.checkResize(Math.max(0,lt)+xt*W),this.m_a.copyWithin(w+xt*W,w,lt>=0?lt:Ct),0===it){const It=new R.P;for(let Lt=w,te=0;te<W;te++,Lt+=2)V[te].queryXY(It),this.m_a[Lt]=It.x,this.m_a[Lt+1]=It.y}else if(1===xt)for(let It=w,Lt=0;Lt<W;Lt++,It++)this.m_a[It]=V[Lt].getAttributeAsDbl(it,0);else for(let It=w,Lt=0;Lt<W;Lt++,It+=xt)for(let te=0;te<xt;te++)this.m_a[It+te]=V[Lt].getAttributeAsDbl(it,te)}eraseRange(w,V,W){this.m_size<w+V&&(0,c.t)(),this.m_a.copyWithin(w,w+V),this.m_size-=V}reverseRange(w,V,W){if((W<1||V%W!=0)&&(0,c.t)(),this.m_a.subarray(w,w+V).reverse(),W>1)for(let it=w,lt=w+V;it<lt;it+=W){let xt=it,Ct=it+W-1;for(;xt<Ct;){const It=this.m_a[xt];this.m_a[xt]=this.m_a[Ct],this.m_a[Ct]=It,xt++,Ct--}}}rotate(w,V,W){(V<w||V>W||w>W)&&(0,c.n)("rotate"),V!==w&&V!==W&&(this.reverseRange(w,V-w,1),this.reverseRange(V,W-V,1),this.reverseRange(w,W-w,1))}sort(w,V,W){this.m_a.subarray(w,V).sort(W)}constructor(w){if(w.move)this.m_a=w.move.m_a,this.m_size=w.move.m_size,w.move.m_a=w.move.m_a.slice(0,0),w.move.m_size=0;else if(w.copy)this.m_size=w.copy.m_size,w.maxSize&&(this.m_size=Math.min(w.maxSize,this.m_size)),this.m_a=w.copy.m_a.slice(0,this.m_size);else{const V=Math.max(w.size,Le.s_constructMin);this.m_a=new w.ctor(V),(w.defaultValue||Number.isNaN(w.defaultValue))&&this.m_a.fill(w.defaultValue),this.m_size=w.size}}}Le.s_constructMin=2,Le.s_resizeMin=30;class Be extends Le{setBits(w,V){this.m_a[w]|=V}clearBits(w,V){this.m_a[w]&=~V}getPersistence(){return 4}clone(){return new Be({ctor:Int8Array,copy:this})}restrictedClone(w){return new Be({ctor:Int8Array,copy:this,maxSize:w})}constructor(w,V){super("number"==typeof w?{ctor:Int8Array,size:w,defaultValue:V}:w)}}class Re extends Le{getPersistence(){return 2}clone(){return new Re({ctor:Int32Array,copy:this})}restrictedClone(w){return new Re({ctor:Int32Array,copy:this,maxSize:w})}write(w,V){(0,c.g)(V<=(0,R.i)()),super.write(w,V)}constructor(w,V){super("number"==typeof w?{ctor:Int32Array,size:w,defaultValue:V}:w)}}class we extends Le{getPersistence(){return 0}clone(){return new we({ctor:Float32Array,copy:this})}restrictedClone(w){return new we({ctor:Float32Array,copy:this,maxSize:w})}constructor(w,V){super("number"==typeof w?{ctor:Float32Array,size:w,defaultValue:V}:w)}}class ms extends Le{getPersistence(){return 1}getArray(){return this.m_a}applyTransformation(w,V,W){(1&V||V+2*W>this.size())&&(0,c.t)();const it=0===V?this.m_a:this.m_a.subarray(V);w.transformInterleavedPoints(it,W,it)}readPoint2D(w){return new R.P(this.m_a[w],this.m_a[w+1])}queryPoint2D(w,V){return V.x=this.m_a[w],V.y=this.m_a[w+1],V}writePoint2D(w,V){this.write(w,V.x),this.write(w+1,V.y)}insert(w,V,W){this.checkResize(W+2),this.m_a.copyWithin(w+2,w,W),this.m_a[w]=V.x,this.m_a[w+1]=V.y}insertRangeFromPoints(w,V,W,it,lt,xt){const Ct=this.m_size;if(this.checkResize(Math.max(xt,0)+2*it),this.m_a.copyWithin(w+2*it,w,xt>=0?xt:Ct),lt)for(let It=W,Lt=w,te=0;te<it;++te,++It){const le=V[It];this.m_a[Lt++]=le.x,this.m_a[Lt++]=le.y}else for(let It=W+it-1,Lt=w,te=0;te<it;++te,--It){const le=V[It];this.m_a[Lt++]=le.x,this.m_a[Lt++]=le.y}}queryRange(w,V,W,it,lt){if((w<0||V<0)&&(0,c.t)(),!it&&(lt<=0||V%lt!=0)&&(0,c.t)(),0===V)return;if(1===V)return void(W[0]=this.m_a[w]);const xt=this.m_a.subarray(w,w+V);W.set(xt)}writeRangeFromArray(w,V,W,it,lt){if((w<0||V<0)&&(0,c.t)(),0===V)return;if(1===V)return void(this.m_a[w]=W[0]);let xt=W;V<W.length&&(xt=W.subarray(0,V)),this.m_a.set(xt,w)}clone(){return new ms({ctor:Float64Array,copy:this})}restrictedClone(w){return new ms({ctor:Float64Array,copy:this,maxSize:w})}constructor(w,V){super("number"==typeof w?{ctor:Float64Array,size:w,defaultValue:V}:w)}}let Qe=(()=>{class Gt{constructor(){this.m_minValue=-1,this.m_maxValue=-1,this.m_dy=Number.NaN,this.m_buckets=new Re(0),this.m_bucketedIndices=new Re(0)}static sortEx(V,W,it,lt,xt=32){it-W<=xt?lt.userSort(W,it,V):(new Gt).sort(V,W,it,lt,xt)}sort(V,W,it,lt,xt=32){if(it-W<=xt)return void lt.userSort(W,it,V);let Ct=!0,It=Number.POSITIVE_INFINITY,Lt=Number.NEGATIVE_INFINITY;for(let le=W;le<it;le++){const he=lt.getValue(V.read(le));he<It&&(It=he),he>Lt&&(Lt=he)}if(this.reset(it-W,It,Lt,it-W)){for(let he=W;he<it;he++){const Ye=V.read(he),Ys=lt.getValue(Ye),Je=this.getBucket(Ys);this.m_buckets.write(Je,this.m_buckets.read(Je)+1),this.m_bucketedIndices.write(he-W,Ye)}let le=this.m_buckets.read(0);this.m_buckets.write(0,0);for(let he=1,Ye=this.m_buckets.size();he<Ye;he++){const Ys=this.m_buckets.read(he);this.m_buckets.write(he,le),le+=Ys}for(let he=W;he<it;he++){const Ye=this.m_bucketedIndices.read(he-W),Ys=lt.getValue(Ye),Je=this.getBucket(Ys),ns=this.m_buckets.read(Je);V.write(ns+W,Ye),this.m_buckets.write(Je,ns+1)}Ct=!1}if(Ct)return void lt.userSort(W,it,V);let te=0;for(let le=0,he=this.m_buckets.size();le<he;le++){const Ye=te;te=this.m_buckets.read(le),te>Ye&&lt.userSort(W+Ye,W+te,V)}this.m_buckets.size()>100&&(this.m_buckets.resize(0),this.m_bucketedIndices.resize(0))}reset(V,W,it,lt){if(V<2||it===W)return!1;const xt=Math.min(Gt.c_maxBuckets,V);return this.m_buckets.resize(xt),this.m_buckets.setRange(0,0,this.m_buckets.size()),this.m_minValue=W,this.m_maxValue=it,this.m_bucketedIndices.resize(lt),this.m_dy=(it-W)/(xt-1),!0}getBucket(V){return Math.trunc((V-this.m_minValue)/this.m_dy)}getBucketCount(){return this.m_buckets.size()}}return Gt.c_maxBuckets=65536,Gt})();class fe{constructor(w){this.m_buffer=null,this.m_firstFree=-1,this.m_last=0,this.m_size=0,this.m_capacity=0,this.m_bufferSize=0,this.m_stride=0,this.m_stride=w,this.m_realStride=w,this.m_blockSize=Math.trunc(fe.st_realBlockSize/this.m_realStride)}dbgdelete_(w){return this.m_buffer[w>>fe.st_blockPower][1+(w&fe.st_blockMask)]=fe.st_deadVertex,!0}deleteElement(w){(w>>fe.st_blockPower)*this.m_blockSize*this.m_realStride+(w&fe.st_blockMask)<this.m_last*this.m_realStride?(this.m_buffer[w>>fe.st_blockPower][w&fe.st_blockMask]=this.m_firstFree,this.m_firstFree=w):this.m_last--,this.m_size--}getField(w,V){return this.m_buffer[w>>fe.st_blockPower][(w&fe.st_blockMask)+V]}setField(w,V,W){this.m_buffer[w>>fe.st_blockPower][(w&fe.st_blockMask)+V]=W}getStride(){return this.m_stride}newElement(){let w=this.m_firstFree;if(-1===w){if(this.m_last===this.m_capacity){const it=0!==this.m_capacity?Math.trunc(2*(this.m_capacity+1)):1;this.grow(it)}w=(this.m_last/this.m_blockSize<<fe.st_blockPower)+this.m_last%this.m_blockSize*this.m_realStride,this.m_last++}else this.m_firstFree=this.m_buffer[w>>fe.st_blockPower][w&fe.st_blockMask];this.m_size++;const V=this.m_buffer[w>>fe.st_blockPower],W=w&fe.st_blockMask;for(let it=0;it<this.m_stride;it++)V[W+it]=-1;return w}elementToIndex(w){return(w>>fe.st_blockPower)*this.m_blockSize+(w&fe.st_blockMask)/this.m_realStride}deleteAll(w){this.m_firstFree=-1,this.m_last=0,this.m_size=0,w&&(this.m_buffer=null,this.m_capacity=0)}size(){return this.m_size}setCapacity(w){w>this.m_capacity&&this.grow(w)}capacity(){return this.m_capacity}swap(w,V){const W=this.m_buffer[w>>fe.st_blockPower],it=this.m_buffer[V>>fe.st_blockPower],lt=w&fe.st_blockMask,xt=V&fe.st_blockMask;for(let Ct=0;Ct<this.m_stride;Ct++){const It=W[lt+Ct];W[lt+Ct]=it[xt+Ct],it[xt+Ct]=It}}swapField(w,V,W){const it=this.m_buffer[w>>fe.st_blockPower],lt=this.m_buffer[V>>fe.st_blockPower],xt=(w&fe.st_blockMask)+W,Ct=(V&fe.st_blockMask)+W,It=it[xt];it[xt]=lt[Ct],lt[Ct]=It}static impossibleIndex2(){return-2}static impossibleIndex3(){return-3}static isValidElement(w){return w>=0}ensureBufferBlocksCapacity(w){if(this.m_buffer.length<w){const V=new Array(w);for(let W=0;W<this.m_buffer.length;W++)V[W]=this.m_buffer[W];this.m_buffer=V}}grow(w){null===this.m_buffer&&(this.m_bufferSize=0,this.m_buffer=new Array(8));const V=Math.trunc((w+this.m_blockSize-1)/this.m_blockSize);if(this.ensureBufferBlocksCapacity(V),1===V){let W=0;const it=w*this.m_realStride;for(;it>fe.st_sizes[W];)W++;const lt=new Int32Array(fe.st_sizes[W]);1===this.m_bufferSize?(lt.set(this.m_buffer[0]),this.m_buffer[0]=lt):(this.m_buffer[this.m_bufferSize]=lt,this.m_bufferSize++),this.m_capacity=Math.trunc(lt.length/this.m_realStride)}else{if(1===this.m_bufferSize&&this.m_buffer[0].length<fe.st_realBlockSize){const W=new Int32Array(fe.st_realBlockSize);W.set(this.m_buffer[0]),this.m_buffer[0]=W,this.m_capacity=this.m_blockSize}for(;this.m_bufferSize<V;)this.m_buffer[this.m_bufferSize++]=new Int32Array(fe.st_realBlockSize),this.m_capacity+=this.m_blockSize}}}fe.st_realBlockSize=16384,fe.st_blockMask=16383,fe.st_blockPower=14,fe.st_sizes=[16,32,64,128,256,512,1024,2048,4096,8192,16384],fe.st_deadVertex=-2125315821;class ye{constructor(w,V,W){this.m_extent=new F.J,this.m_dataExtent=new F.J,this.m_childExtents=[new F.J,new F.J,new F.J,new F.J],this.m_elementNodes=new fe(4),this.m_data=[],this.m_freeData=[],this.m_root=-1,this.m_height=8,void 0===W&&(W=!1),this.m_quadTreeNodes=new fe(W?11:10),this.m_bStoreDuplicates=W,this.reset_(w,V)}reset(w,V){this.m_quadTreeNodes.deleteAll(!1),this.m_elementNodes.deleteAll(!1),this.m_data.length=0,this.m_freeData.length=0,this.reset_(w,V)}insert(w,V){if(-1===this.m_root&&this.createRoot_(),this.m_bStoreDuplicates){const it=this.insertDuplicates_(w,V,0,this.m_extent,this.m_root,!1,-1);return-1!==it&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:V}):this.m_dataExtent.mergeEnvelope2D(V)),it}const W=this.insert_(w,V,0,this.m_extent,this.m_root,!1,-1);return-1!==W&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:V}):this.m_dataExtent.mergeEnvelope2D(V)),W}insertEx(w,V,W){if(-1===this.m_root&&this.createRoot_(),this.m_bStoreDuplicates){const It=this.insertDuplicates_(w,V,0,this.m_extent,this.m_root,!1,-1);return-1!==It&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:V}):this.m_dataExtent.mergeEnvelope2D(V)),It}let it;it=-1===W?this.m_root:this.getQuad_(W);const lt=this.getHeight(it),xt=this.getExtent(it),Ct=this.insert_(w,V,lt,xt,it,!1,-1);return-1!==Ct&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:V}):this.m_dataExtent.mergeEnvelope2D(V)),Ct}removeElement(w){(0,c.g)(0)}getElement(w){return this.getElementValue_(this.getData_(w))}getElementAtIndex(w){return(0,c.g)(0),0}getElementExtent(w){const V=this.getData_(w);return this.getBoundingBoxValue_(V).clone()}getElementExtentAtIndex(w){return(0,c.g)(0),{}}getDataExtent(){return this.m_dataExtent.clone()}getQuadTreeExtent(){return(0,c.g)(0),{}}getHeight(w){return this.m_quadTreeNodes.getField(w,6)>>ye.m_heightBitShift}getMaxHeight(){return this.m_height}getExtent(w){const V=new F.J;if(V.setCoords({env2D:this.m_extent}),w===this.m_root)return V;const W=[];let it=w;do{W.push(this.getQuadrant_(it)),it=this.getParent_(it)}while(it!==this.m_root);const lt=W.length;for(let xt=0;xt<lt;xt++){const Ct=W.at(-1);W.pop(),0===Ct?(V.xmin=.5*(V.xmin+V.xmax),V.ymin=.5*(V.ymin+V.ymax)):1===Ct?(V.xmax=.5*(V.xmin+V.xmax),V.ymin=.5*(V.ymin+V.ymax)):2===Ct?(V.xmax=.5*(V.xmin+V.xmax),V.ymax=.5*(V.ymin+V.ymax)):(V.xmin=.5*(V.xmin+V.xmax),V.ymax=.5*(V.ymin+V.ymax))}return V}getQuad(w){return this.getQuad_(w)}getElementCount(){return-1===this.m_root?0:this.getSubTreeElementCount_(this.m_root)}getSubTreeElementCount(w){return this.getSubTreeElementCount_(w)}getContainedSubTreeElementCount(w){return this.m_bStoreDuplicates?this.getContainedSubTreeElementCount_(w):this.getSubTreeElementCount_(w)}getIntersectionCount(w,V,W){if(-1===this.m_root)return 0;const it=new F.J;it.setCoords({env2D:w}),it.inflateCoords(V,V);const lt=[],xt=[];lt.push(this.m_root),xt.push(this.m_extent.clone());const Ct=(0,R.m)(F.J,4);let It=0;for(;lt.length>0;){let Lt=!1;const te=lt.at(-1),le=xt.at(-1);if(lt.pop(),xt.pop(),it.containsEnvelope(le)){if(It+=this.getSubTreeElementCount(te),W>0&&It>=W)return W}else if(it.isIntersecting(le)){for(let he=this.getFirstElement_(te);-1!==he;he=this.getNextElement_(he)){const Ye=this.getData_(he);if(this.getBoundingBoxValue_(Ye).isIntersecting(it)&&(It++,W>0&&It>=W))return W}Lt=this.getHeight(te)+1<=this.m_height}if(Lt){ye.setChildExtents_(le,Ct);for(let he=0;he<4;he++){const Ye=this.getChild_(te,he);-1!==Ye&&this.getSubTreeElementCount_(Ye)>0&&it.isIntersecting(Ct[he])&&(lt.push(Ye),xt.push(Ct[he].clone()))}}}return It}hasData(w,V){return this.getIntersectionCount(w,V,1)>=1}getIterator(w,V){return new gs(this,w,V)}getIteratorForQT(){return new gs(this)}getSortedIterator(w,V){return new Ts(this.getIterator(w,V))}getSortedIteratorForQT(){return new Ts(this.getIteratorForQT())}visitLeavesNearest(w,V,W,it){(0,c.g)(0)}reset_(w,V){(V<0||V>127)&&(0,c.t)("invalid height"),this.m_height=V,this.m_extent.setCoords({env2D:w}),this.m_dataExtent.setEmpty(),this.m_root=-1}insert_(w,V,W,it,lt,xt,Ct){if(!it.containsEnvelope(V))return 0===W?-1:this.insert_(w,V,0,this.m_extent,this.m_root,xt,Ct);if(!xt)for(let le=lt;-1!==le;le=this.getParent_(le))this.setSubTreeElementCount_(le,this.getSubTreeElementCount_(le)+1);const It=new F.J;It.setCoords({env2D:it});let Lt,te=lt;for(Lt=W;Lt<this.m_height&&this.canPushDown_(te);Lt++){ye.setChildExtents_(It,this.m_childExtents);let le=!1;for(let he=0;he<4;he++)if(this.m_childExtents[he].containsEnvelope(V)){le=!0;let Ye=this.getChild_(te,he);-1===Ye&&(Ye=this.createChild_(te,he)),this.setSubTreeElementCount_(Ye,this.getSubTreeElementCount_(Ye)+1),te=Ye,It.setCoords({env2D:this.m_childExtents[he]});break}if(!le)break}return this.insertAtQuad_(w,V,Lt,It,te,xt,lt,Ct,-1)}insertDuplicates_(w,V,W,it,lt,xt,Ct){if(!xt){if(!it.containsEnvelope(V))return-1;this.setSubTreeElementCount_(lt,this.getSubTreeElementCount_(lt)+1),this.setContainedSubTreeElementCount_(lt,this.getContainedSubTreeElementCount_(lt)+1)}const It=Math.max(V.width(),V.height());let Lt=-1;const te=[],le=[],he=[];te.push(lt),le.push(it.clone()),he.push(W);const Ye=(0,R.m)(F.J,4);for(;te.length>0;){let Ys=!1;const Je=te.at(-1),ns=le.at(-1),_s=he.at(-1);if(te.pop(),le.pop(),he.pop(),_s+1<this.m_height&&this.canPushDown_(Je)&&It<=Math.max(ns.width(),ns.height())/2&&(Ys=!0),Ys){ye.setChildExtents_(ns,Ye);let as=!1;for(let Ne=0;Ne<4;Ne++)if(as=Ye[Ne].containsEnvelope(V),as){let ls=this.getChild_(Je,Ne);-1===ls&&(ls=this.createChild_(Je,Ne)),te.push(ls),le.push(Ye[Ne].clone()),he.push(_s+1),this.setSubTreeElementCount_(ls,this.getSubTreeElementCount_(ls)+1),this.setContainedSubTreeElementCount_(ls,this.getContainedSubTreeElementCount_(ls)+1);break}if(!as)for(let Ne=0;Ne<4;Ne++)if(Ye[Ne].isIntersecting(V)){let ls=this.getChild_(Je,Ne);-1===ls&&(ls=this.createChild_(Je,Ne)),te.push(ls),le.push(Ye[Ne].clone()),he.push(_s+1),this.setSubTreeElementCount_(ls,this.getSubTreeElementCount_(ls)+1)}}else Lt=this.insertAtQuad_(w,V,_s,ns,Je,xt,lt,Ct,Lt),xt=!1}return 0}insertAtQuad_(w,V,W,it,lt,xt,Ct,It,Lt){this.getFirstElement_(lt);const te=this.getLastElement_(lt);let le=-1;if(xt){if(lt===Ct)return It;this.disconnectElementHandle_(It),le=It}else-1===Lt?(le=this.createElement_(),this.setDataValues_(this.getData_(le),w,V)):le=this.createElementFromDuplicate_(Lt);return this.setQuad_(le,lt),-1!==te?(this.setPrevElement_(le,te),this.setNextElement_(te,le)):this.setFirstElement_(lt,le),this.setLastElement_(lt,le),this.setLocalElementCount_(lt,this.getLocalElementCount_(lt)+1),this.canFlush_(lt)&&this.flush_(W,it,lt),le}static setChildExtents_(w,V){const W=.5*(w.xmin+w.xmax),it=.5*(w.ymin+w.ymax);V[0].setCoords({xmin:W,ymin:it,xmax:w.xmax,ymax:w.ymax}),V[1].setCoords({xmin:w.xmin,ymin:it,xmax:W,ymax:w.ymax}),V[2].setCoords({xmin:w.xmin,ymin:w.ymin,xmax:W,ymax:it}),V[3].setCoords({xmin:W,ymin:w.ymin,xmax:w.xmax,ymax:it})}disconnectElementHandle_(w){const V=this.getQuad_(w),W=this.getFirstElement_(V),it=this.getLastElement_(V),lt=this.getPrevElement_(w),xt=this.getNextElement_(w);W===w?(-1!==xt?this.setPrevElement_(xt,-1):this.setLastElement_(V,-1),this.setFirstElement_(V,xt)):it===w?(this.setNextElement_(lt,-1),this.setLastElement_(V,lt)):(this.setPrevElement_(xt,lt),this.setNextElement_(lt,xt)),this.setPrevElement_(w,-1),this.setNextElement_(w,-1),this.setLocalElementCount_(V,this.getLocalElementCount_(V)-1)}canFlush_(w){return this.getLocalElementCount_(w)===ye.m_flushingCount&&!this.hasChildren_(w)}flush_(w,V,W){let it;const lt=new F.J;let xt=this.getFirstElement_(W),Ct=-1,It=-1;do{It=this.getData_(xt),it=this.getElementValue_(It),lt.setCoords({env2D:this.getBoundingBoxValue_(It)}),Ct=this.getNextElement_(xt),this.m_bStoreDuplicates?this.insertDuplicates_(it,lt,w,V,W,!0,xt):this.insert_(it,lt,w,V,W,!0,xt),xt=Ct}while(-1!==xt)}canPushDown_(w){return this.getLocalElementCount_(w)>=ye.m_flushingCount||this.hasChildren_(w)}hasChildren_(w){return-1!==this.getChild_(w,0)||-1!==this.getChild_(w,1)||-1!==this.getChild_(w,2)||-1!==this.getChild_(w,3)}createChild_(w,V){const W=this.m_quadTreeNodes.newElement();return this.setChild_(w,V,W),this.setSubTreeElementCount_(W,0),this.setLocalElementCount_(W,0),this.setParent_(W,w),this.setHeightAndQuadrant_(W,this.getHeight_(w)+1,V),this.m_bStoreDuplicates&&this.setContainedSubTreeElementCount_(W,0),W}createRoot_(){this.m_root=this.m_quadTreeNodes.newElement(),this.setSubTreeElementCount_(this.m_root,0),this.setLocalElementCount_(this.m_root,0),this.setHeightAndQuadrant_(this.m_root,0,0),this.m_bStoreDuplicates&&this.setContainedSubTreeElementCount_(this.m_root,0)}createElement_(){const w=this.m_elementNodes.newElement();let V;return this.m_freeData.length>0?(V=this.m_freeData.at(-1),this.m_freeData.pop()):(V=this.m_data.length,this.m_data.length=V+1),this.setData_(w,V),w}createElementFromDuplicate_(w){const V=this.m_elementNodes.newElement(),W=this.getData_(w);return this.setData_(V,W),V}freeElementAndBoxNode_(w){(0,c.g)(0)}getChild_(w,V){return this.m_quadTreeNodes.getField(w,V)}setChild_(w,V,W){this.m_quadTreeNodes.setField(w,V,W)}getFirstElement_(w){return this.m_quadTreeNodes.getField(w,4)}setFirstElement_(w,V){this.m_quadTreeNodes.setField(w,4,V)}getLastElement_(w){return this.m_quadTreeNodes.getField(w,5)}setLastElement_(w,V){this.m_quadTreeNodes.setField(w,5,V)}getQuadrant_(w){return this.m_quadTreeNodes.getField(w,6)&ye.m_quadrantMask}getHeight_(w){return this.m_quadTreeNodes.getField(w,6)>>ye.m_heightBitShift}setHeightAndQuadrant_(w,V,W){this.m_quadTreeNodes.setField(w,6,V<<ye.m_heightBitShift|W)}getLocalElementCount_(w){return this.m_quadTreeNodes.getField(w,7)}setLocalElementCount_(w,V){this.m_quadTreeNodes.setField(w,7,V)}getSubTreeElementCount_(w){return this.m_quadTreeNodes.getField(w,8)}setSubTreeElementCount_(w,V){this.m_quadTreeNodes.setField(w,8,V)}getParent_(w){return this.m_quadTreeNodes.getField(w,9)}setParent_(w,V){this.m_quadTreeNodes.setField(w,9,V)}getContainedSubTreeElementCount_(w){return this.m_quadTreeNodes.getField(w,10)}setContainedSubTreeElementCount_(w,V){this.m_quadTreeNodes.setField(w,10,V)}getData_(w){return this.m_elementNodes.getField(w,0)}setData_(w,V){this.m_elementNodes.setField(w,0,V)}getPrevElement_(w){return this.m_elementNodes.getField(w,1)}getNextElement_(w){return this.m_elementNodes.getField(w,2)}setPrevElement_(w,V){this.m_elementNodes.setField(w,1,V)}setNextElement_(w,V){this.m_elementNodes.setField(w,2,V)}getQuad_(w){return this.m_elementNodes.getField(w,3)}setQuad_(w,V){this.m_elementNodes.setField(w,3,V)}getElementValue_(w){return this.m_data[w].element}getBoundingBoxValue_(w){return this.m_data[w].box}setDataValues_(w,V,W){this.m_data[w]=function os(Gt,w){return{element:Gt,box:w.clone()}}(V,W)}}ye.m_quadrantMask=3,ye.m_heightBitShift=2,ye.m_flushingCount=5;class gs{constructor(w,V,W){this.m_bLinear=!1,this.m_queryStart=new R.P,this.m_queryEnd=new R.P,this.m_queryBox=new F.J,this.m_tolerance=0,this.m_currentElementHandle=-1,this.m_nextElementHandle=-1,this.m_quadsStack=[],this.m_extentsStack=[],this.m_childExtents=[new F.J,new F.J,new F.J,new F.J],this.m_quadTree=w,V&&this.resetIterator(V,W)}resetIterator(w,V){if(void 0===V&&(V=0),w instanceof F.J)return this.m_quadsStack.length=0,this.m_extentsStack.length=0,this.m_currentElementHandle=-1,this.m_queryBox.setCoords({env2D:w}),this.m_queryBox.inflateCoords(V,V),this.m_tolerance=Number.NaN,void(-1!==this.m_quadTree.m_root&&this.m_queryBox.isIntersecting(this.m_quadTree.m_extent)?(this.m_quadsStack.push(this.m_quadTree.m_root),this.m_extentsStack.push(this.m_quadTree.m_extent.clone()),this.m_nextElementHandle=this.m_quadTree.getFirstElement_(this.m_quadTree.m_root),this.m_bLinear=!1):this.m_nextElementHandle=-1);if(this.m_quadsStack.length=0,this.m_extentsStack.length=0,this.m_currentElementHandle=-1,w.queryLooseEnvelope(this.m_queryBox),this.m_queryBox.inflateCoords(V,V),-1!==this.m_quadTree.m_root&&this.m_queryBox.isIntersecting(this.m_quadTree.m_extent)){const W=w.getGeometryType();if(this.m_bLinear=W===c.G.enumLine,this.m_bLinear){const it=w;this.m_queryStart.assign(it.getStartXY()),this.m_queryEnd.assign(it.getEndXY()),this.m_tolerance=V}else this.m_tolerance=Number.NaN;this.m_quadsStack.push(this.m_quadTree.m_root),this.m_extentsStack.push(this.m_quadTree.m_extent.clone()),this.m_nextElementHandle=this.m_quadTree.getFirstElement_(this.m_quadTree.m_root)}else this.m_nextElementHandle=-1}next(){if(0===this.m_quadsStack.length)return-1;this.m_currentElementHandle=this.m_nextElementHandle;const w=new R.P,V=new R.P,W=new F.J;let it=!1;for(;!it;){for(;-1!==this.m_currentElementHandle;){const lt=this.m_quadTree.getData_(this.m_currentElementHandle);if(W.setCoords({env2D:this.m_quadTree.getBoundingBoxValue_(lt)}),W.isIntersecting(this.m_queryBox)){if(!this.m_bLinear){it=!0;break}if(w.setCoordsPoint2D(this.m_queryStart),V.setCoordsPoint2D(this.m_queryEnd),W.inflateCoords(this.m_tolerance,this.m_tolerance),W.clipLine(w,V)>0){it=!0;break}}this.m_currentElementHandle=this.m_quadTree.getNextElement_(this.m_currentElementHandle)}if(-1===this.m_currentElementHandle){const lt=this.m_quadsStack.at(-1),xt=this.m_extentsStack.at(-1);ye.setChildExtents_(xt,this.m_childExtents),this.m_quadsStack.pop(),this.m_extentsStack.pop();for(let Ct=0;Ct<4;Ct++){const It=this.m_quadTree.getChild_(lt,Ct);if(-1!==It&&this.m_quadTree.getSubTreeElementCount(It)>0&&this.m_childExtents[Ct].isIntersecting(this.m_queryBox))if(this.m_bLinear){w.setCoordsPoint2D(this.m_queryStart),V.setCoordsPoint2D(this.m_queryEnd);const Lt=new F.J;Lt.setCoords({env2D:this.m_childExtents[Ct]}),Lt.inflateCoords(this.m_tolerance,this.m_tolerance),Lt.clipLine(w,V)>0&&(this.m_quadsStack.push(It),this.m_extentsStack.push(this.m_childExtents[Ct].clone()))}else this.m_quadsStack.push(It),this.m_extentsStack.push(this.m_childExtents[Ct].clone())}if(0===this.m_quadsStack.length)return-1;this.m_currentElementHandle=this.m_quadTree.getFirstElement_(this.m_quadsStack.at(-1))}}return this.m_nextElementHandle=this.m_quadTree.getNextElement_(this.m_currentElementHandle),this.m_currentElementHandle}clone(){return(0,c.g)(0),{}}}class Ts{constructor(w){this.m_bucketSort=new Qe,this.m_sortedHandles=new Re(0),this.m_index=-1,this.m_quadTreeIteratorImpl=w}resetIterator(w,V){this.m_quadTreeIteratorImpl.resetIterator(w,V),this.m_sortedHandles.resize(0),this.m_index=-1}next(){if(-1===this.m_index){let w=-1;for(;-1!==(w=this.m_quadTreeIteratorImpl.next());)this.m_sortedHandles.add(w);const V=this,W={userSort(it,lt,xt){xt.sort(it,lt,(Ct,It)=>V.m_quadTreeIteratorImpl.m_quadTree.getElement(Ct)-V.m_quadTreeIteratorImpl.m_quadTree.getElement(It))},getValue:it=>V.m_quadTreeIteratorImpl.m_quadTree.getElement(it)};this.m_bucketSort.sort(this.m_sortedHandles,0,this.m_sortedHandles.size(),W)}return this.m_index===this.m_sortedHandles.size()-1?-1:(this.m_index++,this.m_sortedHandles.read(this.m_index))}clone(){return(0,c.g)(0),{}}}class ks{constructor(w=!1){this.m_bNotifyOnActions=w}onDelete(w){}onSet(w){}onEndSearch(w){}onAddUniqueElementFailed(w){}onDeleteImpl(w,V){this.m_bNotifyOnActions&&this.onDelete(w.getElement(V))}onSetImpl(w,V){this.m_bNotifyOnActions&&this.onSet(w.getElement(V))}onAddUniqueElementFailedImpl(w){this.m_bNotifyOnActions&&this.onAddUniqueElementFailed(w)}onEndSearchImpl(w){this.m_bNotifyOnActions&&this.onEndSearch(w)}}class re{static st_nullNode(){return-1}constructor(){this.m_defaultTreap=-1,this.m_random=124234251,this.m_comparator=null,this.m_treapData=new fe(7),this.m_treapCount=0,this.m_maxDepthEver=0,this.m_bBalancing=!0}setComparator(w){this.m_comparator=w}getComparator(){return this.m_comparator}disableBalancing(){this.m_bBalancing=!1}enableBalancing(){this.m_bBalancing||((0,c.g)(this.m_treapCount<=1),this.rebalance(-1),this.m_bBalancing=!0)}isAutoBalancing(){return this.m_bBalancing}rebalance(w){if(this.m_bBalancing||(-1===w&&(w=this.m_defaultTreap),0===this.size(w)))return;const V=[];for(let W=this.getFirst(w);-1!==W;W=this.getNext(W))V.push(W),this.setParent_(W,-1),this.setRight_(W,-1),this.setLeft_(W,-1);this.setRoot_(-1,w),this.setFirst_(-1,w),this.setLast_(-1,w),this.setSize_(0,w),this.m_bBalancing=!0;for(const W of V)this.addBiggestElement_(W,w);this.m_bBalancing=!1}setCapacity(w){this.m_treapData.setCapacity(w)}createTreap(w){const V=this.m_treapData.newElement();return this.setSize_(0,V),this.setTreapData_(w,V),this.m_treapCount++,V}deleteTreap(w){this.m_treapData.deleteElement(w),this.m_treapCount--}addElement(w,V=-1){return-1===V&&(this.m_defaultTreap===re.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),V=this.m_defaultTreap),this.addElement_(w,0,V)}addUniqueElement(w,V=-1){return-1===V&&(this.m_defaultTreap===re.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),V=this.m_defaultTreap),this.addElement_(w,1,V)}addBiggestElement(w,V=-1){-1===V&&(this.m_defaultTreap===re.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),V=this.m_defaultTreap);const W=this.newNode_(w);return this.addBiggestElement_(W,V),W}addElementAtPosition(w,V,W,it,lt,xt=-1){if(-1===xt&&(this.m_defaultTreap===re.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),xt=this.m_defaultTreap),this.getRoot_(xt)===re.st_nullNode()){const Je=this.newNode_(W);return this.setRoot_(Je,xt),this.addToList_(-1,Je,xt),Je}let Ct,It,Lt,te,le;if(lt?(Ct=V!==re.st_nullNode()?this.m_comparator.compare(this,W,V):-1,It=w!==re.st_nullNode()?this.m_comparator.compare(this,W,w):1):(Ct=-1,It=1),it&&(0===Ct||0===It))return this.m_comparator.onAddUniqueElementFailedImpl(W),this.setDuplicateElement_(0===Ct?V:w,xt),-1;le=V!==re.st_nullNode()&&w!==re.st_nullNode()?this.m_random>(0,R.A)(this.m_random)>>1:V!==re.st_nullNode(),le?(te=Ct,Lt=V):(te=It,Lt=w);let he=-1,Ye=-1,Ys=!0;for(;;){if(te<0){const Je=this.getLeft(Lt);if(Je===re.st_nullNode()){Ye=Lt,he=this.newNode_(W),this.setLeft_(Lt,he),this.setParent_(he,Lt);break}Lt=Je}else{const Je=this.getRight(Lt);if(Je===re.st_nullNode()){Ye=this.getNext(Lt),he=this.newNode_(W),this.setRight_(Lt,he),this.setParent_(he,Lt);break}Lt=Je}Ys&&(te*=-1,Ys=!1)}return this.bubbleUp_(he),this.getParent(he)===re.st_nullNode()&&this.setRoot_(he,xt),this.addToList_(Ye,he,xt),he}replaceElementAtPosition(w,V,W,it,lt=-1){if(it){const xt=this.getNext(w);let Ct=-1;xt!==re.st_nullNode()&&(Ct=this.m_comparator.compare(this,V,xt));const It=this.getPrev(w);let Lt=-1;if(It!==re.st_nullNode()&&(Lt=this.m_comparator.compare(this,V,It)),W&&(0===Ct||0===Lt)){this.m_comparator.onAddUniqueElementFailedImpl(V);const te=0===Ct?xt:It;return lt===re.st_nullNode()&&(this.m_defaultTreap===re.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),lt=this.m_defaultTreap),this.setDuplicateElement_(te,lt),-1}}return this.setElement_(w,V),w}getDuplicateElement(w=-1){return this.getDuplicateElement_(-1===w?this.m_defaultTreap:w)}deleteNode(w,V=-1){this.m_comparator&&this.m_comparator.onDeleteImpl(this,w),-1===V&&(V=this.m_defaultTreap),this.m_bBalancing?this.deleteNode_(w,V):this.unbalancedDelete_(w,V)}search(w,V=-1){let W=this.getRoot(V);for(;W!==re.st_nullNode();){const it=this.m_comparator.compare(this,w,W);if(!it)return W;W=it<0?this.getLeft(W):this.getRight(W)}return this.m_comparator.onEndSearchImpl(w),re.st_nullNode()}searchLowerBound(w,V=-1){let W=this.getRoot(V),it=-1;for(;W!==re.st_nullNode();){const lt=w.compare(this,W);if(!lt)return W;lt<0?W=this.getLeft(W):(it=W,W=this.getRight(W))}return it}searchUpperBound(w,V=-1){let W=this.getRoot(V),it=-1;for(;W!==re.st_nullNode();){const lt=w.compare(this,W);if(!lt)return W;lt<0?(it=W,W=this.getLeft(W)):W=this.getRight(W)}return it}getElement(w){return this.m_treapData.getField(w,3)}getLeft(w){return this.m_treapData.getField(w,0)}getRight(w){return this.m_treapData.getField(w,1)}getParent(w){return this.m_treapData.getField(w,2)}getNext(w){return this.m_treapData.getField(w,6)}getPrev(w){return this.m_treapData.getField(w,5)}getFirst(w=-1){return this.getFirst_(-1===w?this.m_defaultTreap:w)}getLast(w=-1){return this.getLast_(-1===w?this.m_defaultTreap:w)}getTreapData(w=-1){return this.getTreapData_(-1===w?this.m_defaultTreap:w)}setElement(w,V){null!==this.m_comparator&&this.m_comparator.onSetImpl(this,w),this.setElement_(w,V)}getRoot(w=-1){return this.getRoot_(-1===w?this.m_defaultTreap:w)}clear(){this.m_treapData.deleteAll(!1),this.m_defaultTreap=re.st_nullNode(),this.m_treapCount=0,this.m_maxDepthEver=0}addToList_(w,V,W){let it;-1!==w?(it=this.getPrev(w),this.setPrev_(w,V)):it=this.getLast_(W),this.setPrev_(V,it),-1!==it&&this.setNext_(it,V),this.setNext_(V,w),w===this.getFirst_(W)&&this.setFirst_(V,W),-1===w&&this.setLast_(V,W),this.setSize_(this.getSize_(W)+1,W)}size(w=-1){return this.getSize_(-1===w?this.m_defaultTreap:w)}getMaxDepth(w=-1){return this.getMaxDepthHelper_(this.getRoot(w))}getMaxDepthEver(){return this.m_maxDepthEver}static st_isValidNode(w){return fe.isValidElement(w)}dbgCheck_(w){}getPriority_(w){return this.m_treapData.getField(w,4)}bubbleDown_(w){let V=this.getLeft(w),W=this.getRight(w);const it=this.getPriority_(w);for(;V!==re.st_nullNode()||W!==re.st_nullNode();){const lt=V!==re.st_nullNode()?this.getPriority_(V):(0,R.j)(),xt=W!==re.st_nullNode()?this.getPriority_(W):(0,R.j)();if(it<=Math.min(lt,xt))return;lt<=xt?this.rotateRight_(V):this.rotateLeft_(w),V=this.getLeft(w),W=this.getRight(w)}}bubbleUp_(w){if(!this.m_bBalancing)return;const V=this.getPriority_(w);let W=this.getParent(w);for(;W!==re.st_nullNode()&&this.getPriority_(W)>V;)this.getLeft(W)===w?this.rotateRight_(w):this.rotateLeft_(W),W=this.getParent(w)}rotateLeft_(w){const V=w,W=this.getRight(w);let it;this.setParent_(W,this.getParent(V)),this.setParent_(V,W),it=this.getLeft(W),this.setRight_(V,it),it!==re.st_nullNode()&&this.setParent_(it,V),this.setLeft_(W,V),it=this.getParent(W),it!==re.st_nullNode()&&(this.getLeft(it)===V?this.setLeft_(it,W):this.setRight_(it,W))}rotateRight_(w){const V=this.getParent(w),W=w;let it;this.setParent_(W,this.getParent(V)),this.setParent_(V,W),it=this.getRight(W),this.setLeft_(V,it),it!==re.st_nullNode()&&this.setParent_(it,V),this.setRight_(W,V),it=this.getParent(W),it!==re.st_nullNode()&&(this.getLeft(it)===V?this.setLeft_(it,W):this.setRight_(it,W))}setParent_(w,V){this.m_treapData.setField(w,2,V)}setLeft_(w,V){this.m_treapData.setField(w,0,V)}setRight_(w,V){this.m_treapData.setField(w,1,V)}setPriority_(w,V){this.m_treapData.setField(w,4,V)}setPrev_(w,V){this.m_treapData.setField(w,5,V)}setNext_(w,V){this.m_treapData.setField(w,6,V)}setRoot_(w,V){this.m_treapData.setField(V,0,w)}setFirst_(w,V){this.m_treapData.setField(V,1,w)}setLast_(w,V){this.m_treapData.setField(V,2,w)}setDuplicateElement_(w,V){this.m_treapData.setField(V,3,w)}setSize_(w,V){this.m_treapData.setField(V,4,w)}setTreapData_(w,V){this.m_treapData.setField(V,5,w)}getRoot_(w){return-1===w?re.st_nullNode():this.m_treapData.getField(w,0)}getFirst_(w){return-1===w?re.st_nullNode():this.m_treapData.getField(w,1)}getLast_(w){return-1===w?re.st_nullNode():this.m_treapData.getField(w,2)}getDuplicateElement_(w){return-1===w?re.st_nullNode():this.m_treapData.getField(w,3)}getSize_(w){return-1===w?0:this.m_treapData.getField(w,4)}getTreapData_(w){return this.m_treapData.getField(w,5)}newNode_(w){const V=this.m_treapData.newElement();return this.setPriority_(V,this.generatePriority_()),this.setElement_(V,w),V}freeNode_(w,V){w!==re.st_nullNode()&&this.m_treapData.deleteElement(w)}generatePriority_(){return this.m_random=(0,R.A)(this.m_random),this.m_random&(0,R.j)()>>1}maxPriority(){return(0,c.g)(0),0}getMaxDepthHelper_(w){return w===re.st_nullNode()?0:1+Math.max(this.getMaxDepthHelper_(this.getLeft(w)),this.getMaxDepthHelper_(this.getRight(w)))}addElement_(w,V,W){if(this.getRoot(W)===re.st_nullNode()){const It=this.newNode_(w);return this.setRoot_(It,W),this.addToList_(-1,It,W),this.m_maxDepthEver=Math.max(this.m_maxDepthEver,1),It}let it=this.getRoot_(W),lt=-1,xt=-1,Ct=1;for(;;){const It=-1===V?1:this.m_comparator.compare(this,w,it);if(It<0){const Lt=this.getLeft(it);if(Lt===re.st_nullNode()){xt=it,lt=this.newNode_(w),this.setLeft_(it,lt),this.setParent_(lt,it);break}it=Lt}else{if(1===V&&0===It)return this.m_comparator.onAddUniqueElementFailedImpl(w),this.setDuplicateElement_(it,W),-1;const Lt=this.getRight(it);if(Lt===re.st_nullNode()){xt=this.getNext(it),lt=this.newNode_(w),this.setRight_(it,lt),this.setParent_(lt,it);break}it=Lt}Ct++}return this.bubbleUp_(lt),this.getParent(lt)===re.st_nullNode()&&this.setRoot_(lt,W),this.addToList_(xt,lt,W),this.m_maxDepthEver=Math.max(Ct,this.m_maxDepthEver),lt}removeFromList_(w,V){const W=this.getPrev(w),it=this.getNext(w);-1!==W?this.setNext_(W,it):this.setFirst_(it,V),-1!==it?this.setPrev_(it,W):this.setLast_(W,V),this.setSize_(this.getSize_(V)-1,V)}unbalancedDelete_(w,V){this.removeFromList_(w,V);let W=this.getLeft(w),it=this.getRight(w),lt=this.getParent(w),xt=w;if(-1!==W&&-1!==it){let It;this.m_random=(0,R.A)(this.m_random),It=this.m_random>(0,R.j)()>>1?this.getNext(w):this.getPrev(w);const Lt=this.getParent(It)===w;this.m_treapData.swapField(w,It,0),this.m_treapData.swapField(w,It,1),this.m_treapData.swapField(w,It,2),-1!==lt?this.getLeft(lt)===w?this.setLeft_(lt,It):this.setRight_(lt,It):this.setRoot_(It,V),Lt?(W===It?(this.setLeft_(It,w),this.setParent_(it,It)):it===It&&(this.setRight_(It,w),this.setParent_(W,It)),this.setParent_(w,It),lt=It):(this.setParent_(W,It),this.setParent_(it,It),lt=this.getParent(w),xt=It),W=this.getLeft(w),it=this.getRight(w),-1!==W&&this.setParent_(W,w),-1!==it&&this.setParent_(it,w)}const Ct=-1!==W?W:it;-1===lt?this.setRoot_(Ct,V):this.getLeft(lt)===xt?this.setLeft_(lt,Ct):this.setRight_(lt,Ct),-1!==Ct&&this.setParent_(Ct,lt),this.freeNode_(w,V)}deleteNode_(w,V){this.setPriority_(w,(0,R.j)());let W=re.st_nullNode(),it=re.st_nullNode();const lt=this.getRoot_(V),xt=lt===w;if(xt&&(W=this.getLeft(lt),it=this.getRight(lt),W===re.st_nullNode()&&it===re.st_nullNode()))return this.removeFromList_(lt,V),this.freeNode_(lt,V),void this.setRoot_(re.st_nullNode(),V);this.bubbleDown_(w);const Ct=this.getParent(w);Ct!==re.st_nullNode()&&(this.getLeft(Ct)===w?this.setLeft_(Ct,re.st_nullNode()):this.setRight_(Ct,re.st_nullNode())),this.removeFromList_(w,V),this.freeNode_(w,V),xt&&this.setRoot_(W===re.st_nullNode()||this.getParent(W)!==re.st_nullNode()?it:W,V)}setElement_(w,V){this.m_treapData.setField(w,3,V)}addBiggestElement_(w,V){if(this.getRoot_(V)===re.st_nullNode())return this.setRoot_(w,V),void this.addToList_(-1,w,V);const W=this.getLast_(V);this.setRight_(W,w),this.setParent_(w,W),this.bubbleUp_(w),this.getParent(w)===re.st_nullNode()&&this.setRoot_(w,V),this.addToList_(-1,w,V)}}class qe{constructor(w){this.m_lists=new fe(6),this.m_listOfLists=qe.st_nullNode(),void 0===w?(this.m_listNodes=new fe(3),this.m_bStoreListIndexWithNode=!1):(this.m_listNodes=new fe(w?4:3),this.m_bStoreListIndexWithNode=w)}freeNode_(w){this.m_listNodes.deleteElement(w)}newNode_(){return this.m_listNodes.newElement()}freeList_(w){(0,c.g)(0)}newList_(){return this.m_lists.newElement()}setPrev_(w,V){this.m_listNodes.setField(w,1,V)}setNext_(w,V){this.m_listNodes.setField(w,2,V)}setData_(w,V){(0,c.g)(0)}setList_(w,V){return this.m_listNodes.setField(w,3,V)}setListSize_(w,V){this.m_lists.setField(w,4,V)}setNextList_(w,V){(0,c.g)(0)}setPrevList_(w,V){this.m_lists.setField(w,2,V)}createList(w){const V=this.newList_();return this.m_lists.setField(V,3,this.m_listOfLists),this.m_lists.setField(V,4,0),this.m_lists.setField(V,5,w),this.m_listOfLists!==qe.st_nullNode()&&this.setPrevList_(this.m_listOfLists,V),this.m_listOfLists=V,V}deleteList(w){this.clear(w);const V=this.m_lists.getField(w,2),W=this.m_lists.getField(w,3);return V!==qe.st_nullNode()?this.setNextList_(V,W):this.m_listOfLists=W,W!==qe.st_nullNode()&&this.setPrevList_(W,V),this.freeList_(w),W}reserveLists(w){(0,c.g)(0)}getListData(w){return this.m_lists.getField(w,5)}getList(w){return(0,c.g)(0),0}setListData(w,V){this.m_lists.setField(w,5,V)}addElement(w,V){return this.insertElement(w,-1,V)}insertElement(w,V,W){const it=this.newNode_();let lt=-1;if(V!==qe.st_nullNode()&&(lt=this.getPrev(V),this.setPrev_(V,it)),this.setNext_(it,V),lt!==qe.st_nullNode()&&this.setNext_(lt,it),V===this.m_lists.getField(w,0)&&this.m_lists.setField(w,0,it),V===qe.st_nullNode()){const xt=this.m_lists.getField(w,1);this.setPrev_(it,xt),-1!==xt&&this.setNext_(xt,it),this.m_lists.setField(w,1,it)}return this.setData(it,W),this.setListSize_(w,this.getListSize(w)+1),this.m_bStoreListIndexWithNode&&this.setList_(it,w),it}deleteElement(w,V){const W=this.getPrev(V),it=this.getNext(V);return W!==qe.st_nullNode()?this.setNext_(W,it):this.m_lists.setField(w,0,it),it!==qe.st_nullNode()?this.setPrev_(it,W):this.m_lists.setField(w,1,W),this.freeNode_(V),this.setListSize_(w,this.getListSize(w)-1),it}reserveNodes(w){this.m_listNodes.setCapacity(w)}getData(w){return this.m_listNodes.getField(w,0)}getElement(w){return this.getData(w)}setData(w,V){this.m_listNodes.setField(w,0,V)}getNext(w){return this.m_listNodes.getField(w,2)}getPrev(w){return this.m_listNodes.getField(w,1)}getFirst(w){return this.m_lists.getField(w,0)}getLast(w){return this.m_lists.getField(w,1)}static st_nullNode(){return-1}clear(w){if(void 0!==w){let V=this.getLast(w);for(;V!==qe.st_nullNode();){const W=V;V=this.getPrev(W),this.freeNode_(W)}return this.m_lists.setField(w,0,-1),this.m_lists.setField(w,1,-1),void this.setListSize_(w,0)}for(let V=this.getFirstList();-1!==V;)V=this.deleteList(V)}isEmpty(w){return(0,c.g)(0),!1}getNodeCount(){return this.m_listNodes.size()}getListCount(){return this.m_lists.size()}getListSize(w){return this.m_lists.getField(w,4)}getFirstList(){return this.m_listOfLists}getNextList(w){return this.m_lists.getField(w,3)}}class Ps extends ks{constructor(w){super(),this.m_intervalTree=w}compare(w,V,W){const it=w.getElement(W),lt=this.m_intervalTree.getValue_(V),xt=this.m_intervalTree.getValue_(it);return lt<xt?-1:lt===xt?ds.isLeft_(V)&&ds.isRight_(it)?-1:ds.isLeft_(it)&&ds.isRight_(V)?1:0:1}}class ds{constructor(w){this.m_bEnvelopesRef=!1,this.m_intervals=[],this.m_envelopesRef=null,this.m_intervalNodes=new fe(3),this.m_intervalHandles=[],this.m_endIndicesUnique=[],this.m_cCount=-1,this.m_root=-1,this.m_bSortIntervals=!1,this.m_bConstructing=!1,this.m_bConstructionEnded=!1,this.m_bOfflineDynamic=w,this.m_tertiaryNodes=new fe(this.m_bOfflineDynamic?5:4),this.m_secondaryTreaps=new re,this.m_secondaryTreaps.setComparator(new Ps(this)),this.m_secondaryLists=new qe}addEnvelopesRef(w){this.reset_(!0,!0),this.m_bEnvelopesRef=!0,this.m_envelopesRef=w,this.m_bConstructing=!1,this.m_bConstructionEnded=!0,this.m_bOfflineDynamic||(this.insertIntervalsStatic_(),this.m_cCount=this.m_envelopesRef.length)}startConstruction(){this.reset_(!0,!1)}addInterval(w){this.m_bConstructing||(0,c.m)(""),this.m_intervals.push(w.clone())}addIntervalCoords(w,V){(0,c.g)(0)}endConstruction(){this.m_bConstructing||(0,c.m)(""),this.m_bConstructing=!1,this.m_bConstructionEnded=!0,this.m_bOfflineDynamic||(this.insertIntervalsStatic_(),this.m_cCount=this.m_intervals.length)}insert(w){if(this.m_bOfflineDynamic&&this.m_bConstructionEnded||(0,c.m)(""),-1===this.m_root){const lt=this.m_bEnvelopesRef?this.m_envelopesRef.length:this.m_intervals.length;if(this.m_bSortIntervals){const xt=new Re(0);this.querySortedEndPointIndices_(xt),this.m_endIndicesUnique.length=0,this.querySortedDuplicatesRemoved_(xt),this.m_intervalHandles.length=lt,this.m_intervalHandles.fill(-1),this.m_bSortIntervals=!1}else this.m_intervalHandles.fill(-1,0,lt);this.m_root=this.createRoot_()}const V=this.insertIntervalEnd_(w<<1,this.m_root),W=this.getSecondaryFromInterval_(V),it=this.m_secondaryTreaps.addElement(1+(w<<1),W);this.setRightEnd_(V,it),this.m_intervalHandles[w]=V,this.m_cCount++}remove(w){this.m_bOfflineDynamic&&this.m_bConstructionEnded||(0,c.m)("");const V=this.m_intervalHandles[w];let W;-1===V&&(0,c.t)("the interval does not exist in the interval tree"),this.m_intervalHandles[w]=-1,this.m_cCount--;let it=this.getSecondaryFromInterval_(V),lt=-1;lt=this.m_secondaryTreaps.getTreapData(it),this.m_secondaryTreaps.deleteNode(this.getLeftEnd_(V),it),this.m_secondaryTreaps.deleteNode(this.getRightEnd_(V),it),W=this.m_secondaryTreaps.size(it),0===W&&(this.m_secondaryTreaps.deleteTreap(it),this.setSecondaryToTertiary_(lt,-1)),this.m_intervalNodes.deleteElement(V);let xt=this.getPptr_(lt),Ct=this.getLptr_(lt),It=this.getRptr_(lt);for(;!(W>0||lt===this.m_root||-1!==Ct&&-1!==It);)lt===this.getLptr_(xt)?-1!==Ct?(this.setLptr_(xt,Ct),this.setPptr_(Ct,xt),this.setLptr_(lt,-1),this.setPptr_(lt,-1)):-1!==It?(this.setLptr_(xt,It),this.setPptr_(It,xt),this.setRptr_(lt,-1),this.setPptr_(lt,-1)):(this.setLptr_(xt,-1),this.setPptr_(lt,-1)):-1!==Ct?(this.setRptr_(xt,Ct),this.setPptr_(Ct,xt),this.setLptr_(lt,-1),this.setPptr_(lt,-1)):-1!==It?(this.setRptr_(xt,It),this.setPptr_(It,xt),this.setRptr_(lt,-1),this.setPptr_(lt,-1)):(this.setRptr_(xt,-1),this.setPptr_(lt,-1)),this.m_tertiaryNodes.deleteElement(lt),lt=xt,it=this.getSecondaryFromTertiary_(lt),W=-1!==it?this.m_secondaryTreaps.size(it):0,Ct=this.getLptr_(lt),It=this.getRptr_(lt),xt=this.getPptr_(lt)}size(){return this.m_cCount}getIteratorQuery(w,V){return w instanceof R.E?new fs(this,w,V):((0,c.g)(0),{})}getIterator(){return new fs(this)}querySortedEndPointIndices_(w){const V=this.m_bEnvelopesRef?this.m_envelopesRef.length:this.m_intervals.length;for(let W=0;W<2*V;W++)w.add(W);this.sortEndIndices_(w,0,2*V)}querySortedDuplicatesRemoved_(w){let V=Number.NaN;for(let W=0;W<w.size();W++){const it=w.read(W),lt=this.getValue_(it);lt!==V&&(this.m_endIndicesUnique.push(it),V=lt)}}insertIntervalsStatic_(){const w=this.m_bEnvelopesRef?this.m_envelopesRef.length:this.m_intervals.length,V=new Re(0);this.querySortedEndPointIndices_(V),this.m_endIndicesUnique.length=0,this.querySortedDuplicatesRemoved_(V),this.m_intervalNodes.setCapacity(w),this.m_secondaryLists.reserveNodes(2*w);const W=(0,R.d)(w,-1);this.m_root=this.createRoot_();for(let it=0;it<V.size();it++){const lt=V.read(it);let xt=W[lt>>1];if(-1!==xt){const Ct=this.getSecondaryFromInterval_(xt);this.setRightEnd_(xt,this.m_secondaryLists.addElement(Ct,lt))}else xt=this.insertIntervalEnd_(lt,this.m_root),W[lt>>1]=xt}}createRoot_(){const w=this.calculateDiscriminantIndex1_(0,this.m_endIndicesUnique.length-1);return this.createTertiaryNode_(w)}insertIntervalEnd_(w,V){let W=-1,it=V,lt=-1,xt=-1,Ct=0,It=this.m_endIndicesUnique.length-1,Lt=0;const te=w>>1;let le=Number.NaN,he=Number.NaN,Ye=!0;const Ys=this.getMin_(te),Je=this.getMax_(te);let ns=-1;for(;Ye;){Lt=Ct+(It-Ct>>1),ns=this.calculateDiscriminantIndex1_(Ct,It);const _s=this.getDiscriminantFromIndex1_(ns);if(Je<_s){if(-1!==it)if(ns===this.getDiscriminantIndex1_(it))W=it,le=_s,it=this.getLptr_(it),he=-1!==it?this.getDiscriminant_(it):Number.NaN;else if(he>_s){const ls=this.createTertiaryNode_(ns);_s<le?this.setLptr_(W,ls):this.setRptr_(W,ls),this.setRptr_(ls,it),this.m_bOfflineDynamic&&(this.setPptr_(ls,W),this.setPptr_(it,ls)),W=ls,le=_s,it=-1,he=Number.NaN}It=Lt;continue}if(Ys>_s){if(-1!==it)if(ns===this.getDiscriminantIndex1_(it))W=it,le=_s,it=this.getRptr_(it),he=-1!==it?this.getDiscriminant_(it):Number.NaN;else if(he<_s){const ls=this.createTertiaryNode_(ns);_s<le?this.setLptr_(W,ls):this.setRptr_(W,ls),this.setLptr_(ls,it),this.m_bOfflineDynamic&&(this.setPptr_(ls,W),this.setPptr_(it,ls)),W=ls,le=_s,it=-1,he=Number.NaN}Ct=Lt+1;continue}let as=-1;as=-1===it||ns!==this.getDiscriminantIndex1_(it)?this.createTertiaryNode_(ns):it,lt=this.getSecondaryFromTertiary_(as),-1===lt&&(lt=this.createSecondary_(as),this.setSecondaryToTertiary_(as,lt));const Ne=this.addEndIndex_(lt,w);xt=this.createIntervalNode_(),this.setSecondaryToInterval_(xt,lt),this.setLeftEnd_(xt,Ne),-1!==it&&ns===this.getDiscriminantIndex1_(it)||(_s<le?this.setLptr_(W,as):this.setRptr_(W,as),this.m_bOfflineDynamic&&this.setPptr_(as,W),-1!==it&&(he<_s?this.setLptr_(as,it):this.setRptr_(as,it),this.m_bOfflineDynamic&&this.setPptr_(it,as))),Ye=!1;break}return xt}createTertiaryNode_(w){const V=this.m_tertiaryNodes.newElement();return this.setDiscriminantIndex1_(V,w),V}createSecondary_(w){return this.m_bOfflineDynamic?this.m_secondaryTreaps.createTreap(w):this.m_secondaryLists.createList(w)}createIntervalNode_(){return this.m_intervalNodes.newElement()}reset(){this.m_bOfflineDynamic&&this.m_bConstructionEnded||(0,c.m)(""),this.reset_(!1,this.m_bEnvelopesRef)}reset_(w,V){w?(this.m_bEnvelopesRef=!1,this.m_envelopesRef=null,this.m_bSortIntervals=!0,this.m_bConstructing=!0,this.m_bConstructionEnded=!1,this.m_endIndicesUnique.length=0,V?(this.m_intervals.length=0,this.m_bEnvelopesRef=!0):this.m_intervals.length=0):this.m_bSortIntervals=!1,this.m_bOfflineDynamic?this.m_secondaryTreaps.clear():this.m_secondaryLists.clear(),this.m_intervalNodes.deleteAll(!1),this.m_tertiaryNodes.deleteAll(!1),this.m_root=-1,this.m_cCount=0}getDiscriminant_(w){const V=this.getDiscriminantIndex1_(w);return this.getDiscriminantFromIndex1_(V)}getDiscriminantFromIndex1_(w){if(-1===w)return Number.NaN;if(w>0){const it=w-2,xt=this.m_endIndicesUnique[it+1];return.5*(this.getValue_(this.m_endIndicesUnique[it])+this.getValue_(xt))}return this.getValue_(this.m_endIndicesUnique[-w-2])}calculateDiscriminantIndex1_(w,V){let W;return W=w<V?w+(V-w>>1)+2:-(w+2),W}setDiscriminantIndex1_(w,V){this.m_tertiaryNodes.setField(w,0,V)}setSecondaryToTertiary_(w,V){this.m_tertiaryNodes.setField(w,1,V)}setLptr_(w,V){this.m_tertiaryNodes.setField(w,2,V)}setRptr_(w,V){this.m_tertiaryNodes.setField(w,3,V)}setPptr_(w,V){this.m_tertiaryNodes.setField(w,4,V)}setSecondaryToInterval_(w,V){this.m_intervalNodes.setField(w,0,V)}addEndIndex_(w,V){let W=-1;return W=this.m_bOfflineDynamic?this.m_secondaryTreaps.addElement(V,w):this.m_secondaryLists.addElement(w,V),W}setLeftEnd_(w,V){this.m_intervalNodes.setField(w,1,V)}setRightEnd_(w,V){this.m_intervalNodes.setField(w,2,V)}getFirst_(w){return this.m_bOfflineDynamic?this.m_secondaryTreaps.getFirst(w):this.m_secondaryLists.getFirst(w)}getLast_(w){return this.m_bOfflineDynamic?this.m_secondaryTreaps.getLast(w):this.m_secondaryLists.getLast(w)}static isLeft_(w){return!(1&w)}static isRight_(w){return!(1&~w)}getDiscriminantIndex1_(w){return this.m_tertiaryNodes.getField(w,0)}getSecondaryFromTertiary_(w){return this.m_tertiaryNodes.getField(w,1)}getLptr_(w){return this.m_tertiaryNodes.getField(w,2)}getRptr_(w){return this.m_tertiaryNodes.getField(w,3)}getPptr_(w){return this.m_tertiaryNodes.getField(w,4)}getSecondaryFromInterval_(w){return this.m_intervalNodes.getField(w,0)}getLeftEnd_(w){return this.m_intervalNodes.getField(w,1)}getRightEnd_(w){return this.m_intervalNodes.getField(w,2)}getMin_(w){return this.m_bEnvelopesRef?this.m_envelopesRef[w].xmin:this.m_intervals[w].vmin}getMax_(w){return this.m_bEnvelopesRef?this.m_envelopesRef[w].xmax:this.m_intervals[w].vmax}sortEndIndices_(w,V,W){const it=this,lt={userSort(xt,Ct,It){it.sortEndIndicesHelper_(It,xt,Ct)},getValue:xt=>it.getValue_(xt)};(new Qe).sort(w,V,W,lt)}sortEndIndicesHelper_(w,V,W){w.sort(V,W,(it,lt)=>{const xt=this.getValue_(it),Ct=this.getValue_(lt);return xt<Ct||xt===Ct&&ds.isLeft_(it)&&ds.isRight_(lt)?-1:1})}getValue_(w){if(!this.m_bEnvelopesRef){const W=this.m_intervals[w>>1];return ds.isLeft_(w)?W.vmin:W.vmax}const V=this.m_envelopesRef[w>>1];return ds.isLeft_(w)?V.xmin:V.xmax}}class fs{constructor(w,V,W){this.m_query=R.E.constructEmpty(),this.m_tertiaryHandle=-1,this.m_nextTertiaryHandle=-1,this.m_forkedHandle=-1,this.m_currentEndHandle=-1,this.m_nextEndHandle=-1,this.m_tertiaryStack=[],this.m_functionIndex=0,this.m_intervalTree=w,this.m_functionStack=new Array(2),this.m_functionStack[0]=this.nullFunc_,this.m_functionStack[1]=this.nullFunc_,void 0!==V&&this.resetIterator(V,W)}nullFunc_(){return(0,c.c)("should not be called"),!1}resetIterator(w,V){if("number"==typeof w){const W=new R.E;W.setCoords(w,w),this.resetIterator(W,V)}else void 0===V&&(V=0),this.m_query.vmin=w.vmin-V,this.m_query.vmax=w.vmax+V,this.m_tertiaryStack.length=0,this.m_functionIndex=0,this.m_functionStack[0]=this.initialize_}next(){if(this.m_intervalTree.m_bConstructionEnded||(0,c.m)(""),this.m_functionIndex<0)return-1;for(;this.m_fi=this.m_functionStack[this.m_functionIndex],this.m_fi(););return-1!==this.m_currentEndHandle?this.getCurrentEndIndex_()>>1:-1}initialize_(){return this.m_tertiaryHandle=-1,this.m_nextTertiaryHandle=-1,this.m_forkedHandle=-1,this.m_currentEndHandle=-1,this.m_intervalTree.m_tertiaryNodes.size()>0?(this.m_functionStack[0]=this.pIn_,this.m_nextTertiaryHandle=this.m_intervalTree.m_root,!0):(this.m_functionIndex=-1,!1)}pIn_(){if(this.m_tertiaryHandle=this.m_nextTertiaryHandle,-1===this.m_tertiaryHandle)return this.m_functionIndex=-1,this.m_currentEndHandle=-1,!1;const w=this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);if(this.m_query.vmax<w){const W=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),-1!==W&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(W),this.m_functionStack[++this.m_functionIndex]=this.left_),!0}if(w<this.m_query.vmin){const W=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_tertiaryHandle),-1!==W&&(this.m_nextEndHandle=this.m_intervalTree.getLast_(W),this.m_functionStack[++this.m_functionIndex]=this.right_),!0}this.m_functionStack[this.m_functionIndex]=this.pL_,this.m_forkedHandle=this.m_tertiaryHandle;const V=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),-1!==V&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(V),this.m_functionStack[++this.m_functionIndex]=this.all_),!0}pL_(){if(this.m_tertiaryHandle=this.m_nextTertiaryHandle,-1===this.m_tertiaryHandle)return this.m_functionStack[this.m_functionIndex]=this.pR_,this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_forkedHandle),!0;if(this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle)<this.m_query.vmin){const W=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_tertiaryHandle),-1!==W&&(this.m_nextEndHandle=this.m_intervalTree.getLast_(W),this.m_functionStack[++this.m_functionIndex]=this.right_),!0}const w=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),-1!==w&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(w),this.m_functionStack[++this.m_functionIndex]=this.all_);const V=this.m_intervalTree.getRptr_(this.m_tertiaryHandle);return-1!==V&&this.m_tertiaryStack.push(V),!0}pR_(){if(this.m_tertiaryHandle=this.m_nextTertiaryHandle,-1===this.m_tertiaryHandle)return this.m_functionStack[this.m_functionIndex]=this.pT_,!0;const w=this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);if(this.m_query.vmax<w){const it=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),-1!==it&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(it),this.m_functionStack[++this.m_functionIndex]=this.left_),!0}const V=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_tertiaryHandle),-1!==V&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(V),this.m_functionStack[++this.m_functionIndex]=this.all_);const W=this.m_intervalTree.getLptr_(this.m_tertiaryHandle);return-1!==W&&this.m_tertiaryStack.push(W),!0}pT_(){if(0===this.m_tertiaryStack.length)return this.m_functionIndex=-1,this.m_currentEndHandle=-1,!1;this.m_tertiaryHandle=this.m_tertiaryStack.at(-1),this.m_tertiaryStack.pop();const w=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return-1!==w&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(w),this.m_functionStack[++this.m_functionIndex]=this.all_),-1!==this.m_intervalTree.getLptr_(this.m_tertiaryHandle)&&this.m_tertiaryStack.push(this.m_intervalTree.getLptr_(this.m_tertiaryHandle)),-1!==this.m_intervalTree.getRptr_(this.m_tertiaryHandle)&&this.m_tertiaryStack.push(this.m_intervalTree.getRptr_(this.m_tertiaryHandle)),!0}left_(){return this.m_currentEndHandle=this.m_nextEndHandle,-1!==this.m_currentEndHandle&&ds.isLeft_(this.getCurrentEndIndex_())&&this.m_intervalTree.getValue_(this.getCurrentEndIndex_())<=this.m_query.vmax?(this.m_nextEndHandle=this.getNext_(),!1):(this.m_functionIndex--,!0)}right_(){return this.m_currentEndHandle=this.m_nextEndHandle,-1!==this.m_currentEndHandle&&ds.isRight_(this.getCurrentEndIndex_())&&this.m_intervalTree.getValue_(this.getCurrentEndIndex_())>=this.m_query.vmin?(this.m_nextEndHandle=this.getPrev_(),!1):(this.m_functionIndex--,!0)}all_(){return this.m_currentEndHandle=this.m_nextEndHandle,-1!==this.m_currentEndHandle&&ds.isLeft_(this.getCurrentEndIndex_())?(this.m_nextEndHandle=this.getNext_(),!1):(this.m_functionIndex--,!0)}getNext_(){return this.m_intervalTree.m_bOfflineDynamic?this.m_intervalTree.m_secondaryTreaps.getNext(this.m_currentEndHandle):this.m_intervalTree.m_secondaryLists.getNext(this.m_currentEndHandle)}getPrev_(){return this.m_intervalTree.m_bOfflineDynamic?this.m_intervalTree.m_secondaryTreaps.getPrev(this.m_currentEndHandle):this.m_intervalTree.m_secondaryLists.getPrev(this.m_currentEndHandle)}getCurrentEndIndex_(){return this.m_intervalTree.m_bOfflineDynamic?this.m_intervalTree.m_secondaryTreaps.getElement(this.m_currentEndHandle):this.m_intervalTree.m_secondaryLists.getData(this.m_currentEndHandle)}}class qs{constructor(){this.m_tolerance=0,this.m_sweepIndexRed=-1,this.m_sweepIndexBlue=-1,this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_intervalTreeRed=null,this.m_intervalTreeBlue=null,this.m_iteratorRed=null,this.m_iteratorBlue=null,this.m_envelopesRed=[],this.m_envelopesBlue=[],this.m_elementsRed=[],this.m_elementsBlue=[],this.m_sortedEndIndicesRed=new Re(0),this.m_sortedEndIndicesBlue=new Re(0),this.m_queuedListRed=-1,this.m_queuedListBlue=-1,this.m_queuedEnvelopes=new qe,this.m_queuedIndicesRed=[],this.m_queuedIndicesBlue=[],this.m_bAddRed=!1,this.m_bAddBlue=!1,this.m_bAddRedRed=!1,this.m_bDone=!0,this.m_function=this.nullFunc_,this.reset_()}startConstruction(){this.reset_(),this.m_bAddRedRed=!0,this.m_elementsRed.length=0,this.m_envelopesRed.length=0}addEnvelope(w,V){this.m_bAddRedRed||(0,c.m)(""),this.m_elementsRed.push(w),this.m_envelopesRed.push(new F.J(V))}endConstruction(){this.m_bAddRedRed||(0,c.m)(""),this.m_bAddRedRed=!1,this.m_envelopesRed.length>0&&(this.m_function=this.initialize_,this.m_bDone=!1)}startRedConstruction(){this.reset_(),this.m_bAddRed=!0,this.m_elementsRed.length=0,this.m_envelopesRed.length=0}addRedEnvelope(w,V){this.m_bAddRed||(0,c.m)(""),this.m_elementsRed.push(w),this.m_envelopesRed.push(V.clone())}endRedConstruction(){this.m_bAddRed||(0,c.m)(""),this.m_bAddRed=!1,this.m_envelopesRed.length>0&&this.m_envelopesBlue.length>0&&(this.m_function===this.nullFunc_||this.m_function===this.initializeBlue_?this.m_function=this.initializeRedBlue_:this.m_function!==this.initializeRedBlue_&&(this.m_function=this.initializeRed_),this.m_bDone=!1)}startBlueConstruction(){this.reset_(),this.m_bAddBlue=!0,this.m_elementsBlue.length=0,this.m_envelopesBlue.length=0}addBlueEnvelope(w,V){this.m_bAddBlue||(0,c.m)(""),this.m_elementsBlue.push(w),this.m_envelopesBlue.push(V.clone())}endBlueConstruction(){this.m_bAddBlue||(0,c.m)(""),this.m_bAddBlue=!1,this.m_envelopesRed.length>0&&this.m_envelopesBlue.length>0&&(this.m_function===this.nullFunc_||this.m_function===this.initializeRed_?this.m_function=this.initializeRedBlue_:this.m_function!==this.initializeRedBlue_&&(this.m_function=this.initializeBlue_),this.m_bDone=!1)}next(){if(this.m_bDone)return!1;for(;this.m_function(););return!this.m_bDone}getHandleA(){return this.m_envelopeHandleA}getHandleB(){return this.m_envelopeHandleB}setTolerance(w){this.m_tolerance=w}getElement(w){return this.m_elementsRed[w]}getRedEnvelope(w){return this.m_envelopesRed[w]}getBlueEnvelope(w){return this.m_envelopesBlue[w]}getRedElement(w){return this.m_elementsRed[w]}getBlueElement(w){return this.m_elementsBlue[w]}isTop_(w){return!(1&~w)}isBottom_(w){return!(1&w)}reset_(){this.m_bAddRed=!1,this.m_bAddBlue=!1,this.m_bAddRedRed=!1,this.m_sweepIndexRed=-1,this.m_sweepIndexBlue=-1,this.m_queuedListRed=-1,this.m_queuedListBlue=-1,this.m_bDone=!0}initialize_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepBruteForce_,!0;this.m_intervalTreeRed||(this.m_intervalTreeRed=new ds(!0)),this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed),null===this.m_iteratorRed&&(this.m_iteratorRed=this.m_intervalTreeRed.getIterator()),this.m_sortedEndIndicesRed.resize(0);for(let w=0;w<2*this.m_envelopesRed.length;w++)this.m_sortedEndIndicesRed.add(w);return this.sortYEndIndices_(this.m_sortedEndIndicesRed,0,2*this.m_envelopesRed.length,!0),this.m_sweepIndexRed=2*this.m_envelopesRed.length,this.m_function=this.sweep_,!0}initializeRed_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10||this.m_envelopesBlue.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepRedBlueBruteForce_,!0;this.m_intervalTreeRed||(this.m_intervalTreeRed=new ds(!0)),this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed),null===this.m_iteratorRed&&(this.m_iteratorRed=this.m_intervalTreeRed.getIterator()),this.m_sortedEndIndicesRed.resize(0);for(let w=0;w<2*this.m_envelopesRed.length;w++)this.m_sortedEndIndicesRed.add(w);return this.sortYEndIndices_(this.m_sortedEndIndicesRed,0,this.m_sortedEndIndicesRed.size(),!0),this.m_sweepIndexRed=this.m_sortedEndIndicesRed.size(),-1!==this.m_queuedListRed&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListRed),this.m_queuedIndicesRed.length=0,this.m_queuedListRed=-1),this.m_function=this.sweepRedBlue_,this.resetBlue_()}initializeBlue_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10||this.m_envelopesBlue.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepRedBlueBruteForce_,!0;this.m_intervalTreeBlue||(this.m_intervalTreeBlue=new ds(!0)),this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue),null==this.m_iteratorBlue&&(this.m_iteratorBlue=this.m_intervalTreeBlue.getIterator()),this.m_sortedEndIndicesBlue.resize(0);for(let w=0;w<2*this.m_envelopesBlue.length;w++)this.m_sortedEndIndicesBlue.add(w);return this.sortYEndIndices_(this.m_sortedEndIndicesBlue,0,this.m_sortedEndIndicesBlue.size(),!1),this.m_sweepIndexBlue=this.m_sortedEndIndicesBlue.size(),-1!==this.m_queuedListBlue&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue),this.m_queuedIndicesBlue.length=0,this.m_queuedListBlue=-1),this.m_function=this.sweepRedBlue_,this.resetRed_()}initializeRedBlue_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10||this.m_envelopesBlue.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepRedBlueBruteForce_,!0;this.m_intervalTreeRed||(this.m_intervalTreeRed=new ds(!0)),this.m_intervalTreeBlue||(this.m_intervalTreeBlue=new ds(!0)),this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed),this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue),null===this.m_iteratorRed&&(this.m_iteratorRed=this.m_intervalTreeRed.getIterator()),null===this.m_iteratorBlue&&(this.m_iteratorBlue=this.m_intervalTreeBlue.getIterator()),this.m_sortedEndIndicesRed.resize(0),this.m_sortedEndIndicesBlue.resize(0);for(let w=0;w<2*this.m_envelopesRed.length;w++)this.m_sortedEndIndicesRed.add(w);for(let w=0;w<2*this.m_envelopesBlue.length;w++)this.m_sortedEndIndicesBlue.add(w);return this.sortYEndIndices_(this.m_sortedEndIndicesRed,0,this.m_sortedEndIndicesRed.size(),!0),this.sortYEndIndices_(this.m_sortedEndIndicesBlue,0,this.m_sortedEndIndicesBlue.size(),!1),this.m_sweepIndexRed=this.m_sortedEndIndicesRed.size(),this.m_sweepIndexBlue=this.m_sortedEndIndicesBlue.size(),-1!==this.m_queuedListRed&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListRed),this.m_queuedIndicesRed.length=0,this.m_queuedListRed=-1),-1!==this.m_queuedListBlue&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue),this.m_queuedIndicesBlue.length=0,this.m_queuedListBlue=-1),this.m_function=this.sweepRedBlue_,!0}sweep_(){const w=this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed),V=w>>1;if(this.isBottom_(w))return this.m_intervalTreeRed.remove(V),0!==this.m_sweepIndexRed||(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1);const W=R.E.construct(this.m_envelopesRed[V].xmin,this.m_envelopesRed[V].xmax);return this.m_iteratorRed.resetIterator(W,this.m_tolerance),this.m_envelopeHandleA=V,this.m_function=this.iterate_,!0}sweepBruteForce_(){return-1==--this.m_sweepIndexRed?(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1):(this.m_envelopeHandleA=this.m_sweepIndexRed,this.m_sweepIndexBlue=this.m_sweepIndexRed,this.m_function=this.iterateBruteForce_,!0)}sweepRedBlueBruteForce_(){return-1==--this.m_sweepIndexRed?(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1):(this.m_envelopeHandleA=this.m_sweepIndexRed,this.m_sweepIndexBlue=this.m_envelopesBlue.length,this.m_function=this.iterateRedBlueBruteForce_,!0)}sweepRedBlue_(){const w=this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed-1),V=this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue-1),W=this.getAdjustedValue_(w,!0),it=this.getAdjustedValue_(V,!1);return W>it?this.sweepRed_():W<it?this.sweepBlue_():this.isTop_(w)?this.sweepRed_():this.isTop_(V)?this.sweepBlue_():this.sweepRed_()}sweepRed_(){const w=this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed),V=w>>1;if(this.isBottom_(w))return-1!==this.m_queuedListRed&&-1!==this.m_queuedIndicesRed[V]?(this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed,this.m_queuedIndicesRed[V]),this.m_queuedIndicesRed[V]=-1):this.m_intervalTreeRed.remove(V),0!==this.m_sweepIndexRed||(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1);if(-1!==this.m_queuedListBlue&&this.m_queuedEnvelopes.getListSize(this.m_queuedListBlue)>0){let W=this.m_queuedEnvelopes.getFirst(this.m_queuedListBlue);for(;-1!==W;){const it=this.m_queuedEnvelopes.getData(W);this.m_intervalTreeBlue.insert(it),this.m_queuedIndicesBlue[it]=-1;const lt=this.m_queuedEnvelopes.getNext(W);this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue,W),W=lt}}if(this.m_intervalTreeBlue.size()>0){const W=R.E.construct(this.m_envelopesRed[V].xmin,this.m_envelopesRed[V].xmax);this.m_iteratorBlue.resetIterator(W,this.m_tolerance),this.m_envelopeHandleA=V,this.m_function=this.iterateBlue_}else-1===this.m_queuedListRed&&((0,R.w)(this.m_queuedIndicesRed,this.m_envelopesRed.length,-1),this.m_queuedListRed=this.m_queuedEnvelopes.createList(1)),this.m_queuedIndicesRed[V]=this.m_queuedEnvelopes.addElement(this.m_queuedListRed,V),this.m_function=this.sweepRedBlue_;return!0}sweepBlue_(){const w=this.m_sortedEndIndicesBlue.read(--this.m_sweepIndexBlue),V=w>>1;if(this.isBottom_(w))return-1!==this.m_queuedListBlue&&-1!==this.m_queuedIndicesBlue[V]?(this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue,this.m_queuedIndicesBlue[V]),this.m_queuedIndicesBlue[V]=-1):this.m_intervalTreeBlue.remove(V),0!==this.m_sweepIndexBlue||(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1);if(-1!==this.m_queuedListRed&&this.m_queuedEnvelopes.getListSize(this.m_queuedListRed)>0){let W=this.m_queuedEnvelopes.getFirst(this.m_queuedListRed);for(;-1!==W;){const it=this.m_queuedEnvelopes.getData(W);this.m_intervalTreeRed.insert(it),this.m_queuedIndicesRed[it]=-1;const lt=this.m_queuedEnvelopes.getNext(W);this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed,W),W=lt}}if(this.m_intervalTreeRed.size()>0){const W=R.E.construct(this.m_envelopesBlue[V].xmin,this.m_envelopesBlue[V].xmax);this.m_iteratorRed.resetIterator(W,this.m_tolerance),this.m_envelopeHandleB=V,this.m_function=this.iterateRed_}else-1===this.m_queuedListBlue&&((0,R.w)(this.m_queuedIndicesBlue,this.m_envelopesBlue.length,-1),this.m_queuedListBlue=this.m_queuedEnvelopes.createList(0)),this.m_queuedIndicesBlue[V]=this.m_queuedEnvelopes.addElement(this.m_queuedListBlue,V),this.m_function=this.sweepRedBlue_;return!0}iterate_(){if(this.m_envelopeHandleB=this.m_iteratorRed.next(),-1!==this.m_envelopeHandleB)return!1;const w=this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed)>>1;return this.m_intervalTreeRed.insert(w),this.m_function=this.sweep_,!0}iterateRed_(){if(this.m_envelopeHandleA=this.m_iteratorRed.next(),-1!==this.m_envelopeHandleA)return!1;this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1;const w=this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue)>>1;return this.m_intervalTreeBlue.insert(w),this.m_function=this.sweepRedBlue_,!0}iterateBlue_(){if(this.m_envelopeHandleB=this.m_iteratorBlue.next(),-1!==this.m_envelopeHandleB)return!1;const w=this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed)>>1;return this.m_intervalTreeRed.insert(w),this.m_function=this.sweepRedBlue_,!0}iterateBruteForce_(){if(-1==--this.m_sweepIndexBlue)return this.m_function=this.sweepBruteForce_,!0;const w=this.m_envelopesRed[this.m_sweepIndexRed].clone(),V=this.m_envelopesRed[this.m_sweepIndexBlue];return w.inflateCoords(this.m_tolerance,this.m_tolerance),!w.isIntersecting(V)||(this.m_envelopeHandleB=this.m_sweepIndexBlue,!1)}iterateRedBlueBruteForce_(){if(-1==--this.m_sweepIndexBlue)return this.m_function=this.sweepRedBlueBruteForce_,!0;const w=this.m_envelopesRed[this.m_sweepIndexRed].clone(),V=this.m_envelopesBlue[this.m_sweepIndexBlue];return w.inflateCoords(this.m_tolerance,this.m_tolerance),!w.isIntersecting(V)||(this.m_envelopeHandleB=this.m_sweepIndexBlue,!1)}resetRed_(){return this.m_sweepIndexRed=this.m_sortedEndIndicesRed.size(),this.m_intervalTreeRed.size()>0&&this.m_intervalTreeRed.reset(),-1!==this.m_queuedListRed&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListRed),this.m_queuedIndicesRed.length=0,this.m_queuedListRed=-1),this.m_bDone=!1,!0}resetBlue_(){return this.m_sweepIndexBlue=this.m_sortedEndIndicesBlue.size(),this.m_intervalTreeBlue.size()>0&&this.m_intervalTreeBlue.reset(),-1!==this.m_queuedListBlue&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue),this.m_queuedIndicesBlue.length=0,this.m_queuedListBlue=-1),this.m_bDone=!1,!0}nullFunc_(){return(0,c.c)("should not be called"),!1}sortYEndIndices_(w,V,W,it){const lt=this,xt={userSort(Ct,It,Lt){lt.sortYEndIndicesHelper_(Lt,Ct,It,it)},getValue:Ct=>lt.getAdjustedValue_(Ct,it)};(new Qe).sort(w,V,W,xt)}sortYEndIndicesHelper_(w,V,W,it){w.sort(V,W,(lt,xt)=>{const Ct=this.getAdjustedValue_(lt,it),It=this.getAdjustedValue_(xt,it);return Ct<It||Ct===It&&this.isBottom_(lt)&&this.isTop_(xt)?-1:1})}getAdjustedValue_(w,V){const W=.5*this.m_tolerance;if(V){const lt=this.m_envelopesRed[w>>1];return this.isBottom_(w)?lt.ymin-W:lt.ymax+W}const it=this.m_envelopesBlue[w>>1];return this.isBottom_(w)?it.ymin-W:it.ymax+W}}var bi=ue;class li{constructor(w,V){this.tolerance=void 0!==w?w:Number.NaN,this.resolution=void 0!==V?V:Number.NaN}add(w){return new li(this.tolerance+w,this.resolution)}scale(w){return new li(this.tolerance*w,this.resolution*w)}total(){return this.tolerance+this.resolution}}function ir(Gt,w,V,W,it){const lt=W*W,xt=Gt.sub(w),Ct=V.sub(w),It=xt.sqrLength(),Lt=Ct.sqrLength();if(It<=lt||Lt<=lt)return!0;const te=(0,R.s)(xt.crossProduct(Ct));return(te<=lt*It||te<=lt*Lt)&&xt.dotProduct(Ct)>=0}function Ls(Gt,w,V){return W=>0===V?(W+Gt)*w:1*(W-Gt*w)/w}function To(Gt,w){const V=new F.J;return Gt.queryLooseEnvelope(V),V.mergeEnvelope2D(w),V}function Us(Gt,w){const V=F.J.constructEmpty();Gt.queryLooseEnvelope(V);const W=F.J.constructEmpty();return w.queryLooseEnvelope(W),V.mergeEnvelope2D(W),V}function nr(Gt,w){return(Number.isFinite(Gt)||Number.isNaN(Gt))&&(Number.isFinite(w)||Number.isNaN(w))}function Is(Gt,w){return Number.isFinite(Gt)&&Number.isFinite(w)}function Ii(Gt,w,V){const W=F.J.constructEmpty();return W.setFromPoints(Gt,w),Oi(0,null,W.calculateToleranceFromEnvelope(),V,!1)}function rr(Gt,w,V){return Oi(0,Gt,w.calculateToleranceFromEnvelope(),V,!1)}function Br(Gt,w,V){return Oi(1,Gt,w.calculateToleranceFromEnvelope(),V,!1)}function or(Gt,w,V){return Br(Gt,w.queryInterval(1,0),V)}function Hr(Gt,w,V){const W=F.J.constructEmpty();return w.queryEnvelope(W),rr(Gt,W,V)}function Qs(Gt,w,V=!1){return Oi(0,Gt,w.calculateToleranceFromEnvelope(),V,!0).total()}function Oe(Gt,w,V){const W=F.J.constructEmpty();return w.queryEnvelope(W),Qs(Gt,W,V)}function Oi(Gt,w,V,W,it){const lt=new li(0,0);if(null!==w&&(lt.tolerance=w.getTolerance(Gt),(!it||W)&&null!==w)){const xt=w.getResolution(Gt);lt.resolution=xt,W&&(lt.resolution*=2)}return W&&(V*=4,lt.tolerance*=1.01,lt.resolution*=1.01),lt.total()<V?new li(V,0):lt}function Gn(Gt){return Math.sqrt(2)*(2*Gt.tolerance+Gt.resolution)}function zr(Gt){return Math.sqrt(2)*(Gt.tolerance+Gt.resolution)}function ar(Gt){return Gt>=3}function dn(Gt,w){return Gt.getImpl().getIsSimple(w,[0])>=3}function Qi(Gt,w){Gt.getImpl().setIsSimple(3,w)}function rn(Gt,w,V,W){return(0,R.s)(w.x-Gt.x)+(0,R.s)(w.y-Gt.y)<=V*V&&(0,R.I)(Gt.z,w.z,W)}function Ur(Gt){return Gt>=4}function hr(Gt,w){return Gt===c.G.enumPolygon?ar(w):w>=1}function mr(Gt,w,V){const W=F.J.constructEmpty(),it=F.J.constructEmpty();Gt.queryLooseEnvelope(W),w.queryLooseEnvelope(it),W.inflateCoords(V,V),it.inflateCoords(V,V);const lt=F.J.constructEmpty();lt.setCoords({env2D:W}),lt.intersect(it);const xt=Gt.querySegmentIterator(),Ct=w.querySegmentIterator(),It=F.J.constructEmpty(),Lt=F.J.constructEmpty(),te=new qs;te.setTolerance(V);let le=!1;for(te.startRedConstruction();xt.nextPath();)for(;xt.hasNextSegment();)xt.nextSegment().queryLooseEnvelope(It),It.isIntersecting(lt)&&(le=!0,te.addRedEnvelope(xt.getStartPointIndex(),It));if(te.endRedConstruction(),!le)return null;let he=!1;for(te.startBlueConstruction();Ct.nextPath();)for(;Ct.hasNextSegment();)Ct.nextSegment().queryLooseEnvelope(Lt),Lt.isIntersecting(lt)&&(he=!0,te.addBlueEnvelope(Ct.getStartPointIndex(),Lt));return te.endBlueConstruction(),he?te:null}function No(Gt,w,V,W,it){Gt.getGeometryType(),w.getGeometryType();const lt=F.J.constructEmpty(),xt=F.J.constructEmpty();Gt.queryLooseEnvelope(lt),w.queryLooseEnvelope(xt),lt.inflateCoords(V,V),xt.inflateCoords(V,V);const Ct=F.J.constructEmpty();Ct.setCoords({env2D:lt}),Ct.intersect(xt);const It=new qs;It.setTolerance(V);let Lt=!1;It.startRedConstruction();for(let le=0,he=Gt.getPathCount();le<he;le++)Gt.queryLoosePathEnvelope(le,lt),lt.isIntersecting(Ct)&&(Lt=!0,It.addRedEnvelope(le,lt));if(It.endRedConstruction(),!Lt)return null;let te=!1;It.startBlueConstruction();for(let le=0,he=w.getPathCount();le<he;le++)w.queryLoosePathEnvelope(le,xt),xt.isIntersecting(Ct)&&(te=!0,It.addBlueEnvelope(le,xt));return It.endBlueConstruction(),te?It:null}function Fn(Gt,w,V){const W=F.J.constructEmpty(),it=F.J.constructEmpty();Gt.queryLooseEnvelope(W),w.queryEnvelope(it),W.inflateCoords(V,V),it.inflateCoords(V,V);const lt=F.J.constructEmpty();lt.setCoords({env2D:W}),lt.intersect(it);const xt=Gt.querySegmentIterator(),Ct=new qs;Ct.setTolerance(V);let It=!1;for(Ct.startRedConstruction();xt.nextPath();)for(;xt.hasNextSegment();)xt.nextSegment().queryLooseEnvelope(W),W.isIntersecting(lt)&&(It=!0,Ct.addRedEnvelope(xt.getStartPointIndex(),W));if(Ct.endRedConstruction(),!It)return null;let Lt=!1;Ct.startBlueConstruction();for(let te=0,le=w.getPointCount();te<le;te++){const he=w.getXY(te);lt.contains(he)&&(Lt=!0,Ct.addBlueEnvelope(te,F.J.construct(he.x,he.y,he.x,he.y)))}return Ct.endBlueConstruction(),Lt?Ct:null}function pn(Gt,w,V){const W=F.J.constructEmpty(),it=F.J.constructEmpty();Gt.queryEnvelope(W),w.queryEnvelope(it),W.inflateCoords(V,V),it.inflateCoords(V,V);const lt=F.J.constructEmpty();lt.setCoords({env2D:W}),lt.intersect(it);const xt=new qs;xt.setTolerance(V);let Ct=!1;xt.startRedConstruction();const It=new R.P;for(let le=0,he=Gt.getPointCount();le<he;le++)Gt.queryXY(le,It),lt.contains(It)&&(Ct=!0,xt.addRedEnvelope(le,F.J.construct(It.x,It.y,It.x,It.y)));if(xt.endRedConstruction(),!Ct)return null;let Lt=!1;xt.startBlueConstruction();const te=new R.P;for(let le=0,he=w.getPointCount();le<he;le++)w.queryXY(le,te),lt.contains(te)&&(Lt=!0,xt.addBlueEnvelope(le,F.J.construct(te.x,te.y,te.x,te.y)));return xt.endBlueConstruction(),Lt?xt:null}function Or(Gt){const w=new F.J;return Gt.queryLooseEnvelope(w),w.inflateCoords(1,1),function Os(Gt,w,V){const W=new F.J;if(Gt.queryLooseEnvelope(W),W.isEmpty())return null;Gt.getGeometryType();const it=new ye(W,8);let lt=-1;const xt=new F.J;let Ct=!1;do{for(let It=0,Lt=Gt.getPathCount();It<Lt;It++)if(Gt.queryLoosePathEnvelope(It,xt),xt.isIntersecting(w)){if(lt=it.insertEx(It,xt,lt),-1===lt){Ct&&(0,c.c)("build_quad_tree_for_paths"),W.assign(Gt.calculateEnvelope2D(!1)),Ct=!0,it.reset(W,8);break}Ct=!1}}while(Ct);return it}(Gt,w)}function Ao(Gt,w){if(!w){const It=new F.J;Gt.queryLooseEnvelope(It);const Lt=new ye(It,8);let te=-1;const le=new F.J,he=Gt.querySegmentIterator();let Ye=!1;for(;he.nextPath();)for(;he.hasNextSegment();){const Ys=he.nextSegment(),Je=he.getStartPointIndex();if(Ys.queryLooseEnvelope(le),te=Lt.insertEx(Je,le,te),-1===te){Ye&&(0,c.c)(""),It.assign(Gt.calculateEnvelope2D(!1)),Ye=!0,Lt.reset(It,8),he.resetToFirstPath();break}}return Lt}const V=new F.J;Gt.queryLooseEnvelope(V);const W=new ye(V,8);let it=-1;const lt=new F.J,xt=Gt.querySegmentIterator();let Ct=!1;for(;xt.nextPath();)for(;xt.hasNextSegment();){const It=xt.nextSegment(),Lt=xt.getStartPointIndex();if(It.queryLooseEnvelope(lt),lt.isIntersecting(w)&&(it=W.insertEx(Lt,lt,it),-1===it)){Ct&&(0,c.c)(""),V.assign(Gt.calculateEnvelope2D(!1)),Ct=!0,W.reset(V,8),xt.resetToFirstPath();break}}return W}function lr(Gt,w){if(w){const V=new ye(w,8),W=new R.P,it=new F.J;let lt=!1;for(let xt=0;xt<Gt.getPointCount();xt++)W.setCoordsPoint2D(Gt.getXY(xt)),w.contains(W)&&(it.setCoords({pt:W}),-1!==V.insert(xt,it)||(lt&&(0,c.c)(""),lt=!0,V.reset(Gt.calculateEnvelope2D(),8),xt=-1));return V}return(0,c.b)("no-extent version not yet impl"),null}function Vs(Gt,w,V,W,it){let lt=!1;const xt=it.vmin,Ct=it.vmax;for(let It=V;It<w;It+=W){const Lt=Gt.read(It);Lt<xt?(lt=!0,Gt.write(It,xt)):Lt>Ct&&(lt=!0,Gt.write(It,Ct))}return lt}function wi(Gt,w,V,W){if(!Gt.hasAttribute(V))return!1;const it=Gt.getGeometryType();if(it===c.G.enumGeometryCollection){const lt=Gt,xt=lt.getGeometryCount();let Ct=0;for(let It=0;It<xt;++It)Ct|=wi(lt.getGeometry(It),w,V,W)?1:0;return!!Ct}if((0,c.i)(it)){const lt=Gt,xt=bi.getPersistence(V),Ct=bi.getComponentCount(V),It=lt.getPointCount();if(1===xt){const Lt=Vs(lt.getAttributeStreamRef(V),It*Ct,W,Ct,w);return Lt&&lt.notifyModified(),Lt}if(2===xt){const Lt=Vs(lt.getAttributeStreamRef(V),It*Ct,W,Ct,w);return Lt&&lt.notifyModified(),Lt}(0,c.c)("snap_coordinate not implemented")}if(it===c.G.enumEnvelope){const lt=Gt,xt=lt.queryInterval(V,W);let Ct=!1;return xt.vmin<w.vmin&&(Ct=!0,xt.vmin=w.vmin),xt.vmax>w.vmax&&(Ct=!0,xt.vmax=w.vmax),Ct&&lt.setIntervalEnvelope(V,W,xt),Ct}if(it===c.G.enumPoint){const lt=Gt;let xt=lt.getAttributeAsDbl(V,W),Ct=!1;return xt<w.vmin&&(Ct=!0,xt=w.vmin),xt>w.vmax&&(Ct=!0,xt=w.vmax),Ct&&lt.setAttributeBasic(V,W,xt),Ct}if((0,c.f)(it)){const lt=Gt;let xt=lt.getStartAttributeAsDbl(V,W),Ct=!1;return xt<w.vmin&&(Ct=!0,xt=w.vmin),xt>w.vmax&&(Ct=!0,xt=w.vmax),Ct&&lt.setStartAttribute(V,W,xt),xt=lt.getEndAttributeAsDbl(V,W),xt<w.vmin&&(Ct=!0,xt=w.vmin),xt>w.vmax&&(Ct=!0,xt=w.vmax),Ct&&lt.setEndAttribute(V,W,xt),Ct}(0,c.c)("snap_coordinate not implemented")}var ii=ue;class Ns{constructor(w){if(this.m_description=null,this.x=Number.NaN,this.y=Number.NaN,this.m_attribs=null,w){if(!w.copy)return w.move?(this.m_description=w.move.m_description,w.move.m_description=null,this.m_attribs=w.move.m_attribs,w.move.m_attribs=null,this.x=w.move.x,void(this.y=w.move.y)):w.vd?(this.m_description=w.vd,void(w.attribBuffer?(this.m_attribs=w.attribBuffer,w.initDefaultValues&&this.setDefaultAttributeValues()):this.ensureAttributes())):w.pt?(this.m_description=Ut(),void this.setXY(w.pt)):void("x"in w&&("z"in w?(this.m_description=jt(),this.ensureAttributes(),this.setXYZ(new me(w.x,w.y,w.z))):(this.m_description=Ut(),this.setXYCoords(w.x,w.y))));w.copy.copyTo(this)}else this.m_description=Ut()}assignCopy(w){return this.m_attribs=null,w.copyTo(this),this}assignMove(w){return this.m_attribs=null,w.copyTo(this),w.setEmpty(),this}getXY(){return new R.P(this.x,this.y)}queryXY(w){w.x=this.x,w.y=this.y}setXY(w){this.x=w.x,this.y=w.y}setXYCoords(w,V){this.x=w,this.y=V}getXYZ(){const w=new me;return w.x=this.x,w.y=this.y,w.z=this.getZ(),w}setXYZ(w){this.addAttribute(1),this.x=w.x,this.y=w.y,this.m_attribs[0]=w.z}getX(){return this.x}setX(w){this.x=w}getY(){return this.y}setY(w){this.y=w}getZ(){return this.m_description.hasZ()?this.m_attribs[0]:ii.getDefaultValue(1)}setZ(w){this.addAttribute(1),this.m_attribs[0]=w}getM(){return this.getAttributeAsDbl(2,0)}setM(w){this.addAttribute(2),this.m_description.hasZ()?this.m_attribs[1]=w:this.m_attribs[0]=w}getID(){return this.getAttributeAsInt(3,0)}setID(w){this.setAttributeBasic(3,0,w)}isEqualXY(w,V){return void 0===V&&(V=0),Math.abs(w.x-this.x)<=V&&Math.abs(w.y-this.y)<=V}isEqualXYCoords(w,V,W){return void 0===W&&(W=0),Math.abs(w-this.x)<=W&&Math.abs(V-this.y)<=W}getAttributeAsDbl(w,V){if(0===w){if(0===V)return this.x;if(1===V)return this.y;(0,c.n)("")}const W=ii.getComponentCount(w);(V<0||V>=W)&&(0,c.n)("");const it=this.m_description.getAttributeIndex(w);return it>=0?this.m_attribs[this.m_description.getPointAttributeOffset(it)-2+V]:ii.getDefaultValue(w)}getAttributeAsInt(w,V){return Math.trunc(this.getAttributeAsDbl(w,V))}setAttributeBasic(w,V,W){if(0===w)return void(0===V?this.x=W:1===V?this.y=W:(0,c.n)(""));const it=ii.getComponentCount(w);(V<0||V>=it)&&(0,c.n)("");let lt=this.m_description.getAttributeIndex(w);lt<0&&(this.addAttribute(w),lt=this.m_description.getAttributeIndex(w)),this.m_attribs[this.m_description.getPointAttributeOffset(lt)-2+V]=W}copyAttributesFrom(w,V){if(this===w)return;const W=w.getDescription();for(let it=V&&W.hasZ()?2:1,lt=W.getAttributeCount();it<lt;++it){const xt=W.getSemantics(it),Ct=ii.getComponentCount(xt);for(let It=0;It<Ct;++It){const Lt=w.getAttributeAsDbl(xt,It);this.setAttributeBasic(xt,It,Lt)}}}getAttributeArray(){return this.m_attribs}getDescription(){return this.m_description}assignVertexDescription(w){this.m_description!==w&&this.assignVertexDescriptionImpl(w)}mergeVertexDescription(w){this.m_description!==w&&(this.m_description.hasAttributesFrom(w)||this.mergeVertexDescriptionImpl(w))}hasAttribute(w){return this.m_description.hasAttribute(w)}addAttribute(w){if(this.m_description.hasAttribute(w))return;const V=se(this.m_description,w);this.assignVertexDescription(V)}dropAttribute(w){if(!this.m_description.hasAttribute(w))return;const V=Jt(this.m_description,w);this.assignVertexDescription(V)}dropAllAttributes(){const w=Ut();w!==this.m_description&&this.assignVertexDescription(w)}getGeometryType(){return c.G.enumPoint}getDimension(){return 0}queryEnvelope(w){if(w instanceof Mn)return w.setEmpty(),w.assignVertexDescription(this.m_description),void w.merge(this);if(w instanceof Vt){if(this.isEmpty())return void w.setEmpty();const V=this.getXYZ();return w.xmin=V.x,w.ymin=V.y,w.zmin=V.z,w.xmax=V.x,w.ymax=V.y,void(w.zmax=V.z)}this.isEmpty()?w.setEmpty():(w.xmin=this.x,w.ymin=this.y,w.xmax=this.x,w.ymax=this.y)}queryLooseEnvelope(w){this.queryEnvelope(w)}queryInterval(w,V){const W=new R.E;if(this.isEmpty())return W.setEmpty(),W;const it=this.getAttributeAsDbl(w,V);return W.vmin=it,W.vmax=it,W}applyTransformation(w){if(!this.isEmpty()){if(1===w.m_TransformationType){const V=this.getXY();return w.transformInPlace(V),void this.setXY(V)}(0,c.b)("3d not impl")}}transformAttribute(w,V,W,it,lt){if(this.isEmpty())return;this.addAttribute(w);const xt=this.getAttributeAsDbl(w,V),Ct=Ls(W,it,lt);this.setAttributeBasic(w,V,Ct(xt))}createInstance(){return new Ns({vd:this.m_description})}copyTo(w){if(this===w)return;w.getGeometryType()!==c.G.enumPoint&&(0,c.t)();const V=w;V.x=this.x,V.y=this.y,this.m_attribs?(V.assignVertexDescription(this.m_description),V.m_attribs=this.m_attribs.slice()):(V.releaseAttributes(),V.assignVertexDescription(this.m_description))}isEmpty(){return Number.isNaN(this.x)||Number.isNaN(this.y)}setEmpty(){this.m_description||(this.m_description=Ut(),this.releaseAttributes()),this.x=Number.NaN,this.y=Number.NaN,this.m_attribs&&(0,R.a)(this.m_attribs,this.m_description.getDefaultPointAttributes(),0,2,this.m_description.getTotalComponentCount()-2)}calculateArea2D(){return 0}calculateLength2D(){return 0}calculateLength3D(w){return 0}equals(w,V){if(w===this)return!0;if(w.getGeometryType()!==c.G.enumPoint)return!1;const W=w;if(this.m_description!==W.m_description||this.isEmpty()!==W.isEmpty())return!1;if(this.isEmpty())return!0;if(void 0===V&&(V=0),Math.abs(this.x-W.x)>V||Math.abs(this.y-W.y)>V)return!1;for(let it=0,lt=this.m_description.getTotalComponentCount()-2;it<lt;it++)if(!(0,R.I)(this.m_attribs[it],W.m_attribs[it],V))return!1;return!0}getBoundary(){return null}clone(){const w=new Ns({vd:this.m_description});return this.copyTo(w),w}swap(w){if(this===w)return;w.getGeometryType()!==c.G.enumPoint&&(0,c.t)("wrong geometry type");const V=w;V.m_description=(0,R.b)(this.m_description,this.m_description=V.m_description),V.x=(0,R.b)(this.x,this.x=V.x),V.y=(0,R.b)(this.y,this.y=V.y),V.m_attribs=(0,R.b)(this.m_attribs,this.m_attribs=V.m_attribs)}replaceNaNs(w,V){if(this.addAttribute(w),this.isEmpty())return;const W=ii.getComponentCount(w);for(let it=0;it<W;it++){const lt=this.getAttributeAsDbl(w,it);Number.isNaN(lt)&&this.setAttributeBasic(w,it,V)}}lerp(w,V,W){if(w.getDescription()!==V.getDescription()&&(0,c.t)("Point.lerp"),this.assignVertexDescription(w.getDescription()),w.isEmpty()||V.isEmpty())return this.setEmpty(),this;this.ensureAttributes();const it=ee();w.queryValues(it,it.length);const lt=ee();V.queryValues(lt,lt.length);const xt=ee();let Ct=it,It=lt;const Lt=xt;let te=0;for(let le=0,he=this.m_description.getAttributeCount();le<he;le++){const Ye=this.m_description.getSemantics(le),Ys=ii.getInterpolation(Ye),Je=ii.getComponentCount(Ye),ns=ii.getDefaultValue(Ye);(0,R.B)(Ys,Ct,It,Lt,te,Je,W,ns),Ct=Ct.slice(Je),It=It.slice(Je),te+=Je}return this.setValues(xt,te),this}setDefaultAttributeValues(){const w=this.m_description.getTotalComponentCount()-2;w>0&&(this.m_attribs?(0,R.a)(this.m_attribs,this.m_description.getDefaultPointAttributes(),0,2,w):this.m_attribs=this.m_description.getDefaultPointAttributes().slice(2))}static sqrDistance2D(w,V){return R.P.sqrDistanceCoords(w.x,w.y,V.x,V.y)}getImpl(){return this}mergeVertexDescriptionImpl(w){const V=Yt(this.getDescription(),w);this.assignVertexDescription(V)}releaseAttributes(){this.m_attribs=null}assignVertexDescriptionImpl(w){this.m_description||(this.m_description=Ut());const V=Ee();de(w,this.m_description,V);let W=null;w.getTotalComponentCount()-2>0&&(W=w.getDefaultPointAttributes().slice(2));for(let it=1,lt=w.getAttributeCount();it<lt;it++){const xt=V[it];if(-1!==xt){const Ct=this.m_description.getPointAttributeOffset(xt)-2,It=w.getPointAttributeOffset(it)-2,Lt=ii.getComponentCount(w.getSemantics(it));for(let te=0;te<Lt;te++)W[It+te]=this.m_attribs[Ct+te]}}this.m_attribs=W,this.m_description=w}ensureAttributes(){this.m_description.getTotalComponentCount()-2>0&&null===this.m_attribs&&(this.m_attribs=this.m_description.getDefaultPointAttributes().slice(2))}queryValues(w,V){const W=this.m_description.getTotalComponentCount();(0,c.g)(W<=V),w[0]=this.x,w[1]=this.y,(0,R.a)(w,this.m_attribs,2,0,W-2)}copyCommonAttributesTo(w){w.x=this.x,w.y=this.y;const V=w.getDescription();if(V===this.m_description)this.m_attribs&&(0,R.a)(w.m_attribs,this.m_attribs,0,0,this.m_description.getTotalComponentCount()-2);else{let W=0;for(let it=1,lt=V.getAttributeCount();it<lt;it++){const xt=V.getSemantics(it);let Ct=ii.getComponentCount(xt);if(this.m_description.hasAttribute(xt)){let It=this.m_description.getPointAttributeOffset(this.m_description.getAttributeIndex(xt))-2;for(;0!==Ct;)w.m_attribs[W++]=this.m_attribs[It++],Ct--}else{const It=ii.getDefaultValue(xt);for(;0!==Ct;)w.m_attribs[W++]=It,Ct--}}}}setValues(w,V){const W=this.m_description.getTotalComponentCount();(0,c.g)(W<=V),this.x=w[0],this.y=w[1],(0,R.a)(this.m_attribs,w,0,2,W-2)}dbgDefaultAttribs(){}}Ns.type=c.G.enumPoint;var Ks=ue;function Di(Gt,w){return w*(Gt.getTotalComponentCount()-2)}class Ti{constructor(w){if(this.m_attributes=null,w)if(void 0!==w.xmin)this.m_envelope2D=new F.J(w.xmin,w.ymin,w.xmax,w.ymax);else if(void 0!==w.env2D)this.m_envelope2D=new F.J(w.env2D);else if(w.move)this.m_envelope2D=new F.J(w.move.m_envelope2D),this.m_attributes=w.move.m_attributes,w.move.m_attributes=null;else{if(!w.moveEnv)throw new Error("unrecognized EnvelopeData constructor options");{const V=w.moveEnv.accessEnvelopeData();this.m_envelope2D=new F.J(V.m_envelope2D),this.m_attributes=V.m_attributes,V.m_attributes=null}}else this.m_envelope2D=F.J.constructEmpty()}ensureAttributes(w){const V=w.getTotalComponentCount()-2;!this.m_attributes&&V&&(this.m_attributes=(0,R.d)(2*V,Number.NaN),this.m_attributes.fill(Number.NaN))}copyTo(w,V){const W=V,it=w.getTotalComponentCount()-2;W.m_description!==w&&(W.releaseAttributes_(),W.m_description=w,it&&(W.m_data.m_attributes=(0,R.d)(2*it,Number.NaN))),it&&((0,c.g)(this.m_attributes&&W.m_data.m_attributes),(0,R.a)(W.m_data.m_attributes,this.m_attributes,0,0,2*it)),W.m_data.m_envelope2D=new F.J(this.m_envelope2D)}copyToIfNotNull(w,V){V.m_envelope2D=new F.J(this.m_envelope2D),V.releaseAttributes(),w.getTotalComponentCount()-2&&this.m_attributes&&(V.m_attributes=this.m_attributes.slice())}releaseAttributes(){this.m_attributes=null}isEmpty(){return this.m_envelope2D.isEmpty()}transformAttribute(w,V,W,it,lt){(0,c.g)(0)}queryInterval(w,V,W,it){if(this.isEmpty())return void it.setEmpty();if(0===V)return void(0===W?this.m_envelope2D.queryIntervalX(it):1===W?this.m_envelope2D.queryIntervalY(it):(0,c.n)(""));const lt=Ks.getComponentCount(V);(W<0||W>=lt)&&(0,c.n)("");const xt=w.getAttributeIndex(V);if(xt>=0)return it.vmin=this.m_attributes[Di(w,0)+w.getPointAttributeOffset(xt)-2+W],void(it.vmax=this.m_attributes[Di(w,1)+w.getPointAttributeOffset(xt)-2+W]);{const Ct=Ks.getDefaultValue(V);return void it.setCoords(Ct,Ct)}}queryEnvelope3D(w,V){const W=new R.E;this.queryInterval(w,1,0,W),V.setCoords(this.m_envelope2D.xmin,this.m_envelope2D.ymin,W.vmin,this.m_envelope2D.xmax,this.m_envelope2D.ymax,W.vmax)}setEmpty(w){this.m_envelope2D.setEmpty();const V=w.getTotalComponentCount()-2;V&&(this.m_attributes?this.dbgAssertSize(V):this.m_attributes=(0,R.d)(2*V,Number.NaN),this.m_attributes.fill(Number.NaN))}dbgAssertSize(w){}}let Mn=class Rm{constructor(w){if(this.m_EnvelopeType=4,this.m_description=Ut(),void 0===w)this.m_data=new Ti;else if(void 0!==w.vd)this.m_description=w.vd,this.m_data=new Ti,this.ensureAttributes_();else if(w?.env2D)this.m_data=new Ti({env2D:w.env2D});else if(void 0!==w.xmin)this.m_data=new Ti({xmin:w.xmin,ymin:w.ymin,xmax:w.xmax,ymax:w.ymax});else if(w.copy)this.m_data=new Ti,w.copy.copyTo(this);else if(w.move)this.m_description=w.move.m_description,w.move.m_description=null,this.m_data=new Ti({move:w.move.m_data});else{if(!w.centerPoint)throw new Error("unrecognized Envelope constructor options");this.m_description=w.centerPoint.getDescription(),this.m_data=new Ti,this.ensureAttributes_(),this.setFromPoint(w.centerPoint,w.width,w.height)}}accessEnvelopeData(){return this.m_description=null,this.m_data}assignMove(w){return this===w||(this.m_description=w.m_description,w.m_description=null,this.m_data=new Ti({move:w.m_data})),this}assignCopy(w){return this===w||w.copyTo(this),this}transformAttribute(w,V,W,it,lt){(0,c.g)(0)}setAttributeBasic(w,V,W){if(this.addAttribute(w),this.m_data.isEmpty())return;const it=this.queryInterval(w,V);it.vmin=W,it.vmax=W,this.setIntervalEnvelope(w,V,it)}mergeVertexDescriptionImpl(w){const V=Yt(this.getDescription(),w);this.assignVertexDescription(V)}asEnvelope2D(){return new F.J(this.m_data.m_envelope2D)}assignVertexDescription(w){this.m_description!==w&&this.assignVertexDescriptionImpl(w)}getGeometryType(){return c.G.enumEnvelope}getDimension(){return 2}getXMin(){return this.m_data.m_envelope2D.xmin}getYMin(){return this.m_data.m_envelope2D.ymin}getXMax(){return this.m_data.m_envelope2D.xmax}getYMax(){return this.m_data.m_envelope2D.ymax}width(){return this.m_data.isEmpty()?Number.NaN:this.m_data.m_envelope2D.width()}height(){return this.m_data.isEmpty()?Number.NaN:this.m_data.m_envelope2D.height()}getCenterXY(){return this.m_data.isEmpty()?new R.P:this.m_data.m_envelope2D.getCenter()}getCenter(w){if(w.assignVertexDescription(this.m_description),this.m_data.isEmpty())return void w.setEmpty();const V=this.m_description.getAttributeCount();for(let W=1;W<V;W++){const it=this.m_description.getSemantics(W),lt=Ks.getComponentCount(it);for(let xt=0;xt<lt;xt++){const Ct=.5*(this.getAttributeAsDblImpl(0,it,xt)+this.getAttributeAsDblImpl(1,it,xt));w.setAttributeBasic(it,xt,Ct)}}w.setXY(this.m_data.m_envelope2D.getCenter())}setCoords(w,V,W,it){this.m_data.m_envelope2D.setCoords({xmin:w,ymin:V,xmax:W,ymax:it})}setEnvelope(w){if(w instanceof F.J)this.m_data.m_envelope2D=new F.J(w),this.m_data.m_envelope2D.normalize();else{this.addAttribute(1),this.m_data.m_envelope2D=w.getEnvelope2D(),this.m_data.m_envelope2D.normalize();const V=R.E.constructEmpty();V.setCoords(w.zmin,w.zmax),this.setInterval(1,0,V.vmin,V.vmax)}}merge(w){if(w instanceof F.J)return w.isValid()||(0,c.t)(""),void this.m_data.m_envelope2D.mergeEnvelope2D(w);if(w instanceof Rm){if(w.m_data.isEmpty())return;const V=w.getDescription();this.mergeVertexDescription(V),this.m_data.m_envelope2D.mergeEnvelope2D(w.m_data.m_envelope2D);for(let W=1,it=V.getAttributeCount();W<it;W++){const lt=V.getSemantics(W),xt=Ks.getComponentCount(lt);for(let Ct=0;Ct<xt;Ct++){const It=w.queryInterval(lt,Ct),Lt=this.queryInterval(lt,Ct);Lt.merge(It),this.setIntervalEnvelope(lt,Ct,Lt)}}}else if(w instanceof Ns){const V=w;if(V.isEmpty())return;const W=V.getDescription();if(this.mergeVertexDescription(W),this.m_data.isEmpty())return void this.setFromPoint(V);this.m_data.m_envelope2D.merge(V.getXY());for(let it=1,lt=W.getAttributeCount();it<lt;it++){const xt=W.getSemantics(it),Ct=Ks.getComponentCount(xt);for(let It=0;It<Ct;It++){const Lt=V.getAttributeAsDbl(xt,It),te=this.queryInterval(xt,It);te.mergeCoordinate(Lt),this.setIntervalEnvelope(xt,It,te)}}}else(0,c.b)("unrecognized type for envelope.merge")}intersect(w){if(!this.m_data.m_envelope2D.intersect(w.m_data.m_envelope2D))return this.setEmpty(),!1;const V=w.getDescription();this.mergeVertexDescription(V);for(let W=1,it=this.m_description.getAttributeCount();W<it;W++){const lt=this.m_description.getSemantics(W),xt=Ks.getComponentCount(lt);for(let Ct=0;Ct<xt;Ct++){const It=w.queryInterval(lt,Ct),Lt=this.queryInterval(lt,Ct);Lt.intersect(It),this.setIntervalEnvelope(lt,Ct,Lt)}}return!0}intersectCommonAttributes(w){if(!this.m_data.m_envelope2D.intersect(w.m_data.m_envelope2D))return this.setEmpty(),!1;const V=w.getDescription();for(let W=1,it=this.m_description.getAttributeCount();W<it;W++){const lt=this.m_description.getSemantics(W);if(!V.hasAttribute(lt))continue;const xt=Ks.getComponentCount(lt);for(let Ct=0;Ct<xt;Ct++){const It=w.queryInterval(lt,Ct),Lt=this.queryInterval(lt,Ct);Lt.intersect(It),this.setIntervalEnvelope(lt,Ct,Lt)}}return!0}move(w,V){this.m_data.m_envelope2D.move(w,V)}centerAt(w,V){this.m_data.m_envelope2D.centerAtCoords(w,V)}centerAtPoint(w){this.m_data.m_envelope2D.centerAt(w)}reaspect(w,V){this.m_data.m_envelope2D.reaspect(w,V)}inflateCoords(w,V){this.m_data.m_envelope2D.inflateCoords(w,V)}containsCoords(w,V){return this.m_data.m_envelope2D.containsCoords(w,V)}contains(w){return this.m_data.m_envelope2D.contains(w)}containsPoint(w){return!w.isEmpty()&&this.m_data.m_envelope2D.contains(w.getXY())}containsEnvelope(w){return this.m_data.m_envelope2D.containsEnvelope(w.m_data.m_envelope2D)}setIntervalEnvelope(w,V,W){if(this.addAttribute(w),this.m_data.isEmpty())return;const it=new R.E(W);if(it.normalize(),0===w){if(it.isEmpty())return void this.setEmpty();0===V?(this.m_data.m_envelope2D.xmin=it.vmin,this.m_data.m_envelope2D.xmax=it.vmax):1===V?(this.m_data.m_envelope2D.ymin=it.vmin,this.m_data.m_envelope2D.ymax=it.vmax):(0,c.n)("")}else this.setAttributeAsDblImpl(0,w,V,it.vmin),this.setAttributeAsDblImpl(1,w,V,it.vmax)}setInterval(w,V,W,it){this.setIntervalEnvelope(w,V,new R.E(W,it))}queryInterval(w,V){const W=new R.E;return this.m_data.queryInterval(this.m_description,w,V,W),W}queryEnvelope(w){2!==w.m_EnvelopeType?3!==w.m_EnvelopeType?4!==w.m_EnvelopeType?(0,c.b)("unrecognized type for queryEnveloper"):this.copyTo(w):this.m_data.queryEnvelope3D(this.m_description,w):w.setCoords({env2D:this.m_data.m_envelope2D})}applyTransformation(w){1!==w.m_TransformationType?(0,c.g)(0):w.transformEnvInPlace(this.m_data.m_envelope2D)}createInstance(){return new Rm({vd:this.m_description})}copyTo(w){w!==this&&this.m_data.copyTo(this.m_description,w)}isEmpty(){return this.m_data.isEmpty()}setEmpty(){this.m_description||(this.m_description=Ut()),this.m_data.setEmpty(this.m_description)}calculateArea2D(){return this.m_data.m_envelope2D.getArea()}calculateLength2D(){return this.m_data.m_envelope2D.getLength()}calculateLength3D(w){return(0,c.g)(0),0}equals(w,V){if(w===this)return!0;const W=w;if(this.m_description!==W.m_description||this.m_data.isEmpty()!==W.m_data.isEmpty())return!1;if(this.m_data.isEmpty())return!0;if(void 0===V&&(V=0),Math.abs(this.m_data.m_envelope2D.xmin-W.m_data.m_envelope2D.xmin)>V||Math.abs(this.m_data.m_envelope2D.ymin-W.m_data.m_envelope2D.ymin)>V||Math.abs(this.m_data.m_envelope2D.xmax-W.m_data.m_envelope2D.xmax)>V||Math.abs(this.m_data.m_envelope2D.ymax-W.m_data.m_envelope2D.ymax)>V)return!1;for(let it=0,lt=2*(this.m_description.getTotalComponentCount()-2);it<lt;it++)if(!(0,R.I)(this.m_data.m_attributes[it],W.m_data.m_attributes[it],V))return!1;return!0}getBoundary(){return(0,c.b)("getBoundary not available in this context. Use the boundary operator with an envelope parameter"),null}clone(){return new Rm({copy:this})}swap(w){if(this===w)return;w.getGeometryType()!==c.G.enumEnvelope&&(0,c.t)("wrong geometry type");const V=w;V.m_description=(0,R.b)(this.m_description,this.m_description=V.m_description),V.m_data.m_envelope2D=(0,R.b)(this.m_data.m_envelope2D,this.m_data.m_envelope2D=V.m_data.m_envelope2D),V.m_data.m_attributes=(0,R.b)(this.m_data.m_attributes,this.m_data.m_attributes=V.m_data.m_attributes)}queryCoordinates(w){this.m_data.isEmpty()&&(0,c.t)(""),this.m_data.m_envelope2D.queryCorners(w)}queryCornerByVal(w,V){(w<0||w>3)&&(0,c.n)(""),V.assignVertexDescription(this.m_description);const W=this.getDescription().getAttributeCount();for(let it=1;it<W;it++){const lt=this.m_description.getSemantics(it),xt=Ks.getComponentCount(lt);for(let Ct=0;Ct<xt;Ct++)V.setAttributeBasic(lt,Ct,this.getAttributeAsDblImpl(w%2,lt,Ct))}V.setXY(this.m_data.m_envelope2D.queryCorner(w))}queryCorner(w,V){V.assign(this.m_data.m_envelope2D.queryCorner(w))}getDescription(){return this.m_description}mergeVertexDescription(w){this.m_description!==w&&(this.m_description&&this.m_description.hasAttributesFrom(w)||this.mergeVertexDescriptionImpl(w))}hasAttribute(w){return this.m_description.hasAttribute(w)}addAttribute(w){if(this.m_description.hasAttribute(w))return;const V=se(this.m_description,w);this.assignVertexDescription(V)}dropAttribute(w){if(!this.m_description.hasAttribute(w))return;const V=Jt(this.m_description,w);this.assignVertexDescription(V)}dropAllAttributes(){const w=Ut();w!==this.m_description&&this.assignVertexDescription(w)}queryLooseEnvelope(w){this.queryEnvelope(w)}replaceNaNs(w,V){if(this.addAttribute(w),this.m_data.isEmpty())return;const W=Ks.getComponentCount(w);for(let it=0;it<W;it++){const lt=this.queryInterval(w,it);lt.isEmpty()&&(lt.vmin=V,lt.vmax=V,this.setIntervalEnvelope(w,it,lt))}}getImpl(){return this}setFromPoint(w,V,W){this.m_data.m_envelope2D.setCoords({center:w.getXY(),width:V??0,height:W??0});const it=w.getDescription();for(let lt=1,xt=it.getAttributeCount();lt<xt;lt++){const Ct=it.getSemantics(lt),It=Ks.getComponentCount(Ct);for(let Lt=0;Lt<It;Lt++){const te=w.getAttributeAsDbl(Ct,Lt);this.setInterval(Ct,Lt,te,te)}}}assignVertexDescriptionImpl(w){const V=Ee();de(w,this.m_description,V);let W=null;const it=w.getTotalComponentCount()-2,lt=this.m_description?this.m_description.getTotalComponentCount()-2:0;it>0&&(W=(0,R.d)(2*it,Number.NaN));for(let xt=1;xt<w.getAttributeCount();xt++){const Ct=V[xt];if(-1!==Ct){const It=w.getPointAttributeOffset(xt)-2,Lt=Ks.getComponentCount(w.getSemantics(xt)),te=this.m_description.getPointAttributeOffset(Ct)-2;(0,R.a)(W,this.m_data.m_attributes,It,te,Lt),(0,R.a)(W,this.m_data.m_attributes,it+It,lt+te,Lt)}}this.releaseAttributes_(),this.m_data.m_attributes=W,this.m_description=w}getAttributeAsDblImpl(w,V,W){if(this.m_data.isEmpty()&&(0,c.u)(""),0===V)return w?W?this.m_data.m_envelope2D.ymax:this.m_data.m_envelope2D.xmax:W?this.m_data.m_envelope2D.ymin:this.m_data.m_envelope2D.xmin;W>=Ks.getComponentCount(V)&&(0,c.n)("");const it=this.m_description.getAttributeIndex(V);return it>=0?this.m_data.m_attributes[Di(this.m_description,w)+this.m_description.getPointAttributeOffset(it)-2+W]:ue.getDefaultValue(V)}setAttributeAsDblImpl(w,V,W,it){0===V&&(w?1===W?this.m_data.m_envelope2D.ymax=it:0===W?this.m_data.m_envelope2D.xmax=it:(0,c.n)(""):1===W?this.m_data.m_envelope2D.ymin=it:0===W?this.m_data.m_envelope2D.xmin=it:(0,c.n)(""));const lt=Ks.getComponentCount(V);(W<0||W>=lt)&&(0,c.n)(""),this.addAttribute(V);const xt=this.m_description.getAttributeIndex(V);this.m_data.m_attributes[Di(this.m_description,w)+this.m_description.getPointAttributeOffset(xt)-2+W]=it}releaseAttributes_(){this.m_data.releaseAttributes()}ensureAttributes_(){this.m_data.ensureAttributes(this.m_description)}};Mn.type=c.G.enumEnvelope,Object.freeze(Object.defineProperty({__proto__:null,Envelope:Mn,EnvelopeData:Ti},Symbol.toStringTag,{value:"Module"}))},87571:(Do,Ui,ze)=>{ze.d(Ui,{J:()=>c});var R=ze(62257),F=ze(33165);class c{static construct(Y,vt,Wt,Rt){return new c(Y,vt,Wt,Rt)}constructor(Y,vt,Wt,Rt){this.m_EnvelopeType=2,void 0===Y?(this.xmin=Number.NaN,this.ymin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN):"number"==typeof Y?(this.xmin=Y,this.ymin=vt,this.xmax=Wt,this.ymax=Rt):(this.xmin=Y.xmin,this.ymin=Y.ymin,this.xmax=Y.xmax,this.ymax=Y.ymax),this.normalize()}static constructEmpty(){return new c(Number.NaN,Number.NaN,Number.NaN,Number.NaN)}clone(){return new c(this)}assign(Y){return this.xmin=Y.xmin,this.xmax=Y.xmax,this.ymin=Y.ymin,this.ymax=Y.ymax,this}width(){return this.xmax-this.xmin}height(){return this.ymax-this.ymin}maxDimension(){return Math.max(this.width(),this.height())}minDimension(){return Math.min(this.width(),this.height())}sqrDiagonal(){const Y=this.width(),vt=this.height();return Y*Y+vt*vt}diagonal(){return Math.sqrt(this.sqrDiagonal())}getCenterX(){return.5*(this.xmin+this.xmax)}getCenterY(){return.5*(this.ymin+this.ymax)}getCenter(){return F.P.construct(this.getCenterX(),this.getCenterY())}queryCenter(Y){Y.x=.5*(this.xmin+this.xmax),Y.y=.5*(this.ymin+this.ymax)}setEmpty(){this.xmin=Number.NaN,this.ymin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN}setInfinite(){this.xmin=Number.NEGATIVE_INFINITY,this.xmax=Number.POSITIVE_INFINITY,this.ymin=Number.NEGATIVE_INFINITY,this.ymax=Number.POSITIVE_INFINITY}isDegenerate(Y){return!this.isEmpty()&&(this.width()<=Y||this.height()<=Y)}isZero(){return!(this.isEmpty()||this.width()&&this.height())}isEmpty(){return Number.isNaN(this.xmin)||Number.isNaN(this.ymin)||Number.isNaN(this.xmax)||Number.isNaN(this.ymax)}mergeNeCoords(Y,vt){this.xmin>Y?this.xmin=Y:this.xmax<Y&&(this.xmax=Y),this.ymin>vt?this.ymin=vt:this.ymax<vt&&(this.ymax=vt)}mergeNe(Y){this.mergeNeCoords(Y.x,Y.y)}mergeCoords(Y,vt){this.isEmpty()?(this.xmin=Y,this.ymin=vt,this.xmax=Y,this.ymax=vt):(this.xmin>Y?this.xmin=Y:this.xmax<Y&&(this.xmax=Y),this.ymin>vt?this.ymin=vt:this.ymax<vt&&(this.ymax=vt))}merge(Y){this.mergeCoords(Y.x,Y.y)}mergeEnvelope2D(Y){Y.isEmpty()||(this.mergeCoords(Y.xmin,Y.ymin),this.mergeNeCoords(Y.xmax,Y.ymax))}mergePoints(Y,vt){for(let Wt=0;Wt<vt;){if(!this.isEmpty()){for(let Rt=Wt;Rt<vt;Rt++)this.mergeNe(Y[Rt]);break}this.setCoords(Y[Wt]),Wt++}}mergePointsInterleaved(Y,vt,Wt){for(let Rt=2*vt,Se=Rt+2*Wt;Rt<Se;Rt+=2)this.mergeCoords(Y.read(Rt),Y.read(Rt+1))}inflateCoords(Y,vt){this.isEmpty()||(this.xmin-=Y,this.xmax+=Y,this.ymin-=vt,this.ymax+=vt,(this.xmin>this.xmax||this.ymin>this.ymax)&&this.setEmpty())}getInflatedCoords(Y,vt){const Wt=this.clone();return Wt.inflateCoords(Y,vt),Wt}inflate(Y){this.inflateCoords(Y,Y)}getInflated(Y){const vt=this.clone();return vt.inflateCoords(Y,Y),vt}zoom(Y,vt){this.isEmpty()||this.setCoords({center:this.getCenter(),width:Y*this.width(),height:vt*this.height()})}scale(Y){Y<0&&this.setEmpty(),this.xmin*=Y,this.xmax*=Y,this.ymin*=Y,this.ymax*=Y}equals(Y,vt){return!(!this.isEmpty()||!Y.isEmpty())||(vt?Math.abs(this.xmin-Y.xmin)<=vt&&Math.abs(this.ymin-Y.ymin)<=vt&&Math.abs(this.xmax-Y.xmax)<=vt&&Math.abs(this.ymax-Y.ymax)<=vt:this.xmin===Y.xmin&&this.ymin===Y.ymin&&this.xmax===Y.xmax&&this.ymax===Y.ymax)}setCoords(Y){void 0!==Y.xmin?(this.xmin=Y.xmin,this.xmax=Y.xmax,this.ymin=Y.ymin,this.ymax=Y.ymax):void 0!==Y.x?(this.xmin=Y.x,this.xmax=Y.x,this.ymin=Y.y,this.ymax=Y.y):void 0!==Y.pt1?(this.xmin=Y.pt1.x,this.ymin=Y.pt1.y,this.xmax=Y.pt2.x,this.ymax=Y.pt2.y,this.normalize()):void 0!==Y.env2D?(this.xmin=Y.env2D.xmin,this.xmax=Y.env2D.xmax,this.ymin=Y.env2D.ymin,this.ymax=Y.env2D.ymax,this.normalize()):void 0!==Y.pt?(this.xmin=Y.pt.x,this.xmax=Y.pt.x,this.ymin=Y.pt.y,this.ymax=Y.pt.y):void 0!==Y.center?(this.xmin=Y.center.x-.5*Y.width,this.xmax=this.xmin+Y.width,this.ymin=Y.center.y-.5*Y.height,this.ymax=this.ymin+Y.height,this.normalize()):(0,R.b)("unrecognized input type for setCoords"),this.normalize()}queryIntervalX(Y){this.isEmpty()?Y.setEmpty():Y.setCoords(this.xmin,this.xmax)}queryIntervalY(Y){this.isEmpty()?Y.setEmpty():Y.setCoords(this.ymin,this.ymax)}setFromPoints(Y,vt){if(0===vt)return void this.setEmpty();if(Array.isArray(Y)){const Rt=Y;this.setCoords(Rt[0]);for(let Se=1;Se<vt;){if(!this.isEmpty()){for(let ee=Se;ee<vt;ee++)this.mergeNe(Rt[ee]);return}this.setCoords(Rt[Se]),Se++}return}const Wt=Y;this.setCoords({x:Wt[0],y:Wt[1]});for(let Rt=1,Se=2*vt;Rt<Se;Rt+=2){if(!this.isEmpty()){for(let ee=Rt,ue=2*vt;ee<ue;ee+=2)this.mergeNeCoords(Wt[ee],Wt[ee+1]);return}this.setCoords({x:Wt[Rt],y:Wt[Rt+1]}),Rt+=2}}normalize(){let Y=!1;this.xmin<=this.xmax||([this.xmin,this.xmax]=[this.xmax,this.xmin],Y=!0),this.ymin<=this.ymax||([this.ymin,this.ymax]=[this.ymax,this.ymin],Y=!0),!Y||this.xmin<=this.xmax&&this.ymin<=this.ymax||this.setEmpty()}isValid(){return this.isEmpty()||this.xmin<=this.xmax&&this.ymin<=this.ymax}getLowerLeft(){return new F.P(this.xmin,this.ymin)}getLowerRight(){return new F.P(this.xmax,this.ymin)}getUpperLeft(){return new F.P(this.xmin,this.ymax)}getUpperRight(){return new F.P(this.xmax,this.ymax)}move(Y,vt){this.isEmpty()||(this.xmin+=Y,this.ymin+=vt,this.xmax+=Y,this.ymax+=vt)}centerAtCoords(Y,vt){this.move(Y-this.getCenterX(),vt-this.getCenterY())}centerAt(Y){this.centerAtCoords(Y.x,Y.y)}containsCoords(Y,vt){return Y>=this.xmin&&Y<=this.xmax&&vt>=this.ymin&&vt<=this.ymax}contains(Y){return this.containsCoords(Y.x,Y.y)}containsEnvelope(Y){return Y.xmin>=this.xmin&&Y.xmax<=this.xmax&&Y.ymin>=this.ymin&&Y.ymax<=this.ymax}containsExclusiveCoords(Y,vt){return Y>this.xmin&&Y<this.xmax&&vt>this.ymin&&vt<this.ymax}containsExclusive(Y){return this.containsExclusiveCoords(Y.x,Y.y)}containsExclusiveEnvelope(Y){return Y.xmin>this.xmin&&Y.xmax<this.xmax&&Y.ymin>this.ymin&&Y.ymax<this.ymax}isIntersecting(Y){return(this.xmin<=Y.xmin?this.xmax>=Y.xmin:Y.xmax>=this.xmin)&&(this.ymin<=Y.ymin?this.ymax>=Y.ymin:Y.ymax>=this.ymin)}isIntersectingNe(Y){return(this.xmin<=Y.xmin?this.xmax>=Y.xmin:Y.xmax>=this.xmin)&&(this.ymin<=Y.ymin?this.ymax>=Y.ymin:Y.ymax>=this.ymin)}intersect(Y){if(this.isEmpty())return!1;if(Y.isEmpty())return this.setEmpty(),!1;Y.xmin>this.xmin&&(this.xmin=Y.xmin),Y.xmax<this.xmax&&(this.xmax=Y.xmax),Y.ymin>this.ymin&&(this.ymin=Y.ymin),Y.ymax<this.ymax&&(this.ymax=Y.ymax);const vt=this.xmin<=this.xmax&&this.ymin<=this.ymax;return vt||this.setEmpty(),vt}queryCorner(Y){switch(3&Y){case 0:return new F.P(this.xmin,this.ymin);case 1:return new F.P(this.xmin,this.ymax);case 2:return new F.P(this.xmax,this.ymax);default:return new F.P(this.xmax,this.ymin)}}queryCorners(Y){Y[0].setCoords(this.xmin,this.ymin),Y[1].setCoords(this.xmin,this.ymax),Y[2].setCoords(this.xmax,this.ymax),Y[3].setCoords(this.xmax,this.ymin)}queryCornersReversed(Y){Y[0].setCoords(this.xmin,this.ymin),Y[1].setCoords(this.xmax,this.ymin),Y[2].setCoords(this.xmax,this.ymax),Y[3].setCoords(this.xmin,this.ymax)}reaspect(Y,vt){if(this.isEmpty())return;const Wt=Y/vt,Rt=.5*this.width(),Se=.5*this.height()*Wt;if(Rt<=Se){const ee=this.getCenterX();this.xmin=ee-Se,this.xmax=ee+Se}else{const ee=Rt/Wt,ue=this.getCenterY();this.ymin=ue-ee,this.ymax=ue+ee}this.normalize()}getArea(){return this.isEmpty()?0:this.width()*this.height()}getLength(){return this.isEmpty()?0:2*(this.width()+this.height())}clipCode(Y){return(Y.x<this.xmin?1:0)|(Y.x>this.xmax?1:0)<<1|(Y.y<this.ymin?1:0)<<2|(Y.y>this.ymax?1:0)<<3}clipLine(Y,vt){let Wt=this.clipCode(Y),Rt=this.clipCode(vt);if(Wt&Rt)return 0;if(!(Wt|Rt))return 4;const Se=(Wt?1:0)|(Rt?2:0);do{const ee=vt.x-Y.x,ue=vt.y-Y.y;if(Math.abs(ee)>Math.abs(ue)?Wt&c.XMASK?(Wt&c.XLESSXMIN?(Y.y+=ue*(this.xmin-Y.x)/ee,Y.x=this.xmin):(Y.y+=ue*(this.xmax-Y.x)/ee,Y.x=this.xmax),Wt=this.clipCode(Y)):Rt&c.XMASK?(Rt&c.XLESSXMIN?(vt.y+=ue*(this.xmin-vt.x)/ee,vt.x=this.xmin):(vt.y+=ue*(this.xmax-vt.x)/ee,vt.x=this.xmax),Rt=this.clipCode(vt)):Wt?(Wt&c.YLESSYMIN?(Y.x+=ee*(this.ymin-Y.y)/ue,Y.y=this.ymin):(Y.x+=ee*(this.ymax-Y.y)/ue,Y.y=this.ymax),Wt=this.clipCode(Y)):(Rt&c.YLESSYMIN?(vt.x+=ee*(this.ymin-vt.y)/ue,vt.y=this.ymin):(vt.x+=ee*(this.ymax-vt.y)/ue,vt.y=this.ymax),Rt=this.clipCode(vt)):Wt&c.YMASK?(Wt&c.YLESSYMIN?(Y.x+=ee*(this.ymin-Y.y)/ue,Y.y=this.ymin):(Y.x+=ee*(this.ymax-Y.y)/ue,Y.y=this.ymax),Wt=this.clipCode(Y)):Rt&c.YMASK?(Rt&c.YLESSYMIN?(vt.x+=ee*(this.ymin-vt.y)/ue,vt.y=this.ymin):(vt.x+=ee*(this.ymax-vt.y)/ue,vt.y=this.ymax),Rt=this.clipCode(vt)):Wt?(Wt&c.XLESSXMIN?(Y.y+=ue*(this.xmin-Y.x)/ee,Y.x=this.xmin):(Y.y+=ue*(this.xmax-Y.x)/ee,Y.x=this.xmax),Wt=this.clipCode(Y)):(Rt&c.XLESSXMIN?(vt.y+=ue*(this.xmin-vt.x)/ee,vt.x=this.xmin):(vt.y+=ue*(this.xmax-vt.x)/ee,vt.x=this.xmax),Rt=this.clipCode(vt)),Wt&Rt)return 0}while(Wt|Rt);return Se}distanceFromEnvelope(Y){return Math.sqrt(this.sqrDistanceEnvelope(Y,null,null))}distance(Y){return Math.sqrt(this.sqrDistance(Y))}sqrDistanceEnvelope(Y,vt,Wt){if(!vt&&!Wt){if(this.isEmpty()||Y.isEmpty())return Number.NaN;let Ee,As=0,Ve=0;return Ee=this.xmin-Y.xmax,Ee>As&&(As=Ee),Ee=this.ymin-Y.ymax,Ee>Ve&&(Ve=Ee),Ee=Y.xmin-this.xmax,Ee>As&&(As=Ee),Ee=Y.ymin-this.ymax,Ee>Ve&&(Ve=Ee),As*As+Ve*Ve}if(this.isEmpty()||Y.isEmpty())return vt&&vt.setNAN(),Wt&&Wt.setNAN(),Number.NaN;let Rt,Se=0,ee=0;const ue=Math.max(this.xmin,Y.xmin),hs=Math.max(this.ymin,Y.ymin);return vt&&vt.setCoords(ue,hs),Wt&&Wt.setCoords(ue,hs),Rt=this.xmin-Y.xmax,Rt>Se&&(Se=Rt,vt&&(vt.x=this.xmin),Wt&&(Wt.x=Y.xmax)),Rt=this.ymin-Y.ymax,Rt>ee&&(ee=Rt,vt&&(vt.y=this.ymin),Wt&&(Wt.y=Y.ymax)),Rt=Y.xmin-this.xmax,Rt>Se&&(Se=Rt,vt&&(vt.x=this.xmax),Wt&&(Wt.x=Y.xmin)),Rt=Y.ymin-this.ymax,Rt>ee&&(ee=Rt,vt&&(vt.y=this.ymax),Wt&&(Wt.y=Y.ymin)),Se*Se+ee*ee}sqrDistance(Y,vt){if(void 0===vt){if(this.isEmpty()||Y.isNAN())return Number.NaN;let ee,ue=0,hs=0;return ee=this.xmin-Y.x,ee>ue&&(ue=ee),ee=this.ymin-Y.y,ee>hs&&(hs=ee),ee=Y.x-this.xmax,ee>ue&&(ue=ee),ee=Y.y-this.ymax,ee>hs&&(hs=ee),ue*ue+hs*hs}if(this.isEmpty()||Y.isNAN())return vt.setNAN(),Number.NaN;vt.assign(Y);let Wt,Rt=0,Se=0;return Wt=this.xmin-Y.x,Wt>Rt&&(Rt=Wt,vt.x=this.xmin),Wt=this.ymin-Y.y,Wt>Se&&(Se=Wt,vt.y=this.ymin),Wt=Y.x-this.xmax,Wt>Rt&&(Rt=Wt,vt.x=this.xmax),Wt=Y.y-this.ymax,Wt>Se&&(Se=Wt,vt.y=this.ymax),Rt*Rt+Se*Se}sqrMaxMinDistanceEnvelope(Y){if(this.isEmpty()||Y.isEmpty())return Number.NaN;let vt=Number.MAX_VALUE;{const Wt=F.P.sqrDistanceCoords(this.xmin,this.ymin,Y.xmax,Y.ymin),Rt=F.P.sqrDistanceCoords(this.xmin,this.ymin,Y.xmax,Y.ymax),Se=F.P.sqrDistanceCoords(this.xmin,this.ymax,Y.xmax,Y.ymin),ee=F.P.sqrDistanceCoords(this.xmin,this.ymax,Y.xmax,Y.ymax),ue=Math.max(Wt,Rt),hs=Math.max(Se,ee),Ee=Math.max(ue,hs);vt=Math.min(Ee,vt)}{const Wt=F.P.sqrDistanceCoords(this.xmin,this.ymin,Y.xmin,Y.ymax),Rt=F.P.sqrDistanceCoords(this.xmin,this.ymin,Y.xmax,Y.ymax),Se=F.P.sqrDistanceCoords(this.xmax,this.ymin,Y.xmin,Y.ymax),ee=F.P.sqrDistanceCoords(this.xmax,this.ymin,Y.xmax,Y.ymax),ue=Math.max(Wt,Rt),hs=Math.max(Se,ee),Ee=Math.max(ue,hs);vt=Math.min(Ee,vt)}{const Wt=F.P.sqrDistanceCoords(this.xmax,this.ymin,Y.xmin,Y.ymin),Rt=F.P.sqrDistanceCoords(this.xmax,this.ymin,Y.xmin,Y.ymax),Se=F.P.sqrDistanceCoords(this.xmax,this.ymax,Y.xmin,Y.ymin),ee=F.P.sqrDistanceCoords(this.xmax,this.ymax,Y.xmin,Y.ymax),ue=Math.max(Wt,Rt),hs=Math.max(Se,ee),Ee=Math.max(ue,hs);vt=Math.min(Ee,vt)}{const Wt=F.P.sqrDistanceCoords(this.xmin,this.ymax,Y.xmin,Y.ymin),Rt=F.P.sqrDistanceCoords(this.xmin,this.ymax,Y.xmax,Y.ymin),Se=F.P.sqrDistanceCoords(this.xmax,this.ymax,Y.xmin,Y.ymin),ee=F.P.sqrDistanceCoords(this.xmax,this.ymax,Y.xmax,Y.ymin),ue=Math.max(Wt,Rt),hs=Math.max(Se,ee),Ee=Math.max(ue,hs);vt=Math.min(Ee,vt)}return vt}sqrMaxDistanceEnvelope(Y){if(this.isEmpty()||Y.isEmpty())return Number.NaN;let vt=0;const Wt=(0,F.m)(F.P,4);this.queryCorners(Wt);const Rt=(0,F.m)(F.P,4);Y.queryCorners(Rt);for(let Se=0;Se<4;Se++)for(let ee=0;ee<4;ee++){const ue=F.P.sqrDistance(Wt[Se],Rt[ee]);ue>vt&&(vt=ue)}return vt}sqrMaxMinDistance(Y){const vt=F.P.sqrDistance(Y,this.getLowerLeft()),Wt=F.P.sqrDistance(Y,this.getUpperLeft()),Rt=F.P.sqrDistance(Y,this.getLowerRight()),Se=F.P.sqrDistance(Y,this.getUpperRight());let ee,ue=Math.max(vt,Wt);return ee=Math.max(vt,Rt),ue>ee&&(ue=ee),ee=Math.max(Wt,Se),ue>ee&&(ue=ee),ee=Math.max(Rt,Se),ue>ee&&(ue=ee),ue}sqrMinDistance(Y){return this.contains(Y)?0:this.sqrDistance(Y)}sqrMaxDistance(Y){let vt=F.P.sqrDistance(Y,this.getLowerLeft());return vt=Math.max(F.P.sqrDistance(Y,this.getUpperLeft()),vt),vt=Math.max(F.P.sqrDistance(Y,this.getUpperRight()),vt),vt=Math.max(F.P.sqrDistance(Y,this.getLowerRight()),vt),vt}snapToBoundary(Y){if(Y.isNAN())return!1;if(this.isEmpty())return Y.setNAN(),!0;let vt=!0;if(Y.x<this.xmin?Y.x=this.xmin:Y.x>this.xmax?Y.x=this.xmax:vt=!1,Y.y<this.ymin?Y.y=this.ymin:Y.y>this.ymax?Y.y=this.ymax:vt=!1,vt)return!0;if(Y.x===this.xmin||Y.x===this.xmax||Y.y===this.ymin||Y.y===this.ymax)return!1;const Wt=this.xmax-Y.x,Rt=Y.x-this.xmin,Se=this.ymax-Y.y,ee=Y.y-this.ymin;return Math.max(Wt,Rt)>Math.max(Se,ee)?Y.y=ee<Se?this.ymin:this.ymax:Y.x=Rt<Wt?this.xmin:this.xmax,!0}snapClip(Y){const vt=(0,F.c)(Y.x,this.xmin,this.xmax),Wt=(0,F.c)(Y.y,this.ymin,this.ymax);return F.P.construct(vt,Wt)}boundaryDistance(Y){if(this.isEmpty()||Y.isNAN())return Number.NaN;if(Y.x===this.xmin)return Y.y-this.ymin;const vt=this.ymax-this.ymin,Wt=this.xmax-this.xmin;if(Y.y===this.ymax)return vt+Y.x-this.xmin;if(Y.x===this.xmax)return vt+Wt+this.ymax-Y.y;if(Y.y===this.ymin)return 2*vt+Wt+this.xmax-Y.x;const Rt=new F.P;return Rt.setCoordsPoint2D(Y),this.snapToBoundary(Rt),this.boundaryDistance(Rt)}envelopeSide(Y){if(this.isEmpty())return-1;let vt=this.boundaryDistance(Y);const Wt=this.ymax-this.ymin,Rt=this.xmax-this.xmin;return vt<Wt?0:(vt-=Wt)<Rt?1:vt-Rt<Wt?2:3}querySide(Y,vt){switch(Y){case 0:vt.constructFromCoords(this.xmin,this.ymin,this.xmin,this.ymax);break;case 1:vt.constructFromCoords(this.xmin,this.ymax,this.xmax,this.ymax);break;case 2:vt.constructFromCoords(this.xmax,this.ymax,this.xmax,this.ymin);break;case 3:vt.constructFromCoords(this.xmax,this.ymin,this.xmin,this.ymin);break;default:(0,R.t)("query_side")}return vt}isPointOnBoundary(Y,vt){return Math.abs(Y.x-this.xmin)<=vt||Math.abs(Y.x-this.xmax)<=vt||Math.abs(Y.y-this.ymin)<=vt||Math.abs(Y.y-this.ymax)<=vt}calculateToleranceFromEnvelope(){return this.isEmpty()?(0,F.g)():(Math.abs(this.xmin)+Math.abs(this.xmax)+Math.abs(this.ymin)+Math.abs(this.ymax)+1)*(0,F.g)()}toString(){return`[${this.xmin}, ${this.ymin}, ${this.xmax}, ${this.ymax}]`}}c.XLESSXMIN=1,c.YLESSYMIN=4,c.XMASK=3,c.YMASK=12},83875:(Do,Ui,ze)=>{ze.d(Ui,{O:()=>hs,a:()=>Se,c:()=>Wt});var R=ze(1469),F=ze(62257),c=ze(7085),dt=ze(87571),Y=ze(95944),vt=ze(33165);function Wt(Ve,Yt,se,Jt,Ut){return Rt(Ve,Yt,null,se,Jt,Ut)}function Rt(Ve,Yt,se,Jt,Ut,jt){const de=Ve.getGeometryType();if(de===F.G.enumPoint){const $t=Ve.getXY();return Yt.contains($t)?Ve:Ve.createInstance()}if(de===F.G.enumEnvelope){const $t=dt.J.constructEmpty();if(Ve.queryEnvelope($t),$t.intersect(Yt)){const _e=Ve.clone();return _e.setEnvelope($t),_e}return Ve.createInstance()}if(Ve.isEmpty())return Ve;if(Yt.isEmpty())return Ve.createInstance();const me=Yt.clone();{const $t=new dt.J;if(Ve.queryLooseEnvelope($t),me.containsEnvelope($t))return Ve;if(!me.isIntersecting($t))return Ve.createInstance();0===Ut&&($t.intersect(me),$t.inflate(Math.max(.1*$t.maxDimension(),1)),$t.intersect(me),me.assign($t))}let Vt=Jt;if((null!==se||Number.isNaN(Vt))&&(Vt=(0,c.a)(se,me,!1).total()),de===F.G.enumGeometryCollection){const $t=Ve,_e=Ve.createInstance();for(let Te=0,Pe=$t.getGeometryCount();Te<Pe;Te++){const ve=$t.getGeometry(Te);if(ve.isEmpty())continue;const Ie=Wt(ve,me,Vt,Ut,jt);Ie.isEmpty()||_e.addGeometry(Ie===ve?Ie.clone():Ie)}return _e}(0,F.i)(de)||(0,F.t)("Clip: geometry not supported");const xe=Ve.getImpl().getAccelerators();if(null!==xe){const $t=xe.getRasterizedGeometry();(0,F.g)(null===$t)}switch(de){case F.G.enumMultiPoint:{const $t=Ve;let _e;const Te=$t.getPointCount(),Pe=$t.getImpl().getAttributeStreamRef(0);let ve=0;for(let Ie=0;Ie<Te;Ie++){const je=Pe.readPoint2D(2*Ie);me.contains(je)||(0===ve&&(_e=$t.createInstance()),ve<Ie&&_e.addPoints($t,ve,Ie),ve=Ie+1)}return ve>0&&_e.addPoints($t,ve,Te),0===ve?$t:((0,F.g)(null!==_e),_e)}case F.G.enumPolygon:case F.G.enumPolyline:return function ee(Ve,Yt,se,Jt,Ut){return new ue(Yt,Ut).clipMultiPath2(Ve,se,Jt)}(Ve,me,Vt,Ut,jt);default:(0,F.c)("")}}function Se(Ve,Yt,se,Jt,Ut,jt){const de=new ue(Yt,jt),me=new dt.J;return Ve.queryLooseEnvelope(me),Yt.containsEnvelope(me)?Ve:Yt.isIntersecting(me)?de.clipPolesOut(Ve,Ut):Ve.createInstance()}class ue{constructor(Yt,se){this.m_shape=new Y.E,this.m_geometry=Y.n,this.m_verticesOnExtentIndex=-1,this.m_verticesOnExtent=[],this.m_progressCounter=0,this.m_extent=new dt.J(Yt),this.m_progressTracker=se}progress_(){}clipMultiPath2(Yt,se,Jt){return Yt.getGeometryType()===F.G.enumPolygon?this.clipPolygonOrProjectedPolyline2(Yt,Jt):this.clipPolyline(Yt,se)}clipPolygonOrProjectedPolyline2(Yt,se){const Jt=Yt.getGeometryType()===F.G.enumPolyline;if(0===this.m_extent.width()||0===this.m_extent.height())return Yt.createInstance();const Ut=dt.J.constructEmpty();Yt.queryLooseEnvelope(Ut),this.m_geometry=Jt?this.m_shape.addGeometry(Yt):this.m_shape.addGeometry(Yt,this.m_extent);const jt=dt.J.constructEmpty(),de=dt.J.constructEmpty(),me=new vt.P,Vt=new vt.P,xe=(0,vt.d)(9,Number.NaN),$t=(0,vt.d)(9,Number.NaN),_e=(0,vt.m)(vt.P,9);let Te=null;const Pe=new Y.L,ve=[];let Ie=!1;for(let Le=0;!Ie&&Le<4;Le++){let Be=!1;const Re=!!(1&Le);let we=0;switch(Le){case 0:we=this.m_extent.xmin,Be=Ut.xmin<=we&&Ut.xmax>=we;break;case 1:we=this.m_extent.ymin,Be=Ut.ymin<=we&&Ut.ymax>=we;break;case 2:we=this.m_extent.xmax,Be=Ut.xmin<=we&&Ut.xmax>=we;break;case 3:we=this.m_extent.ymax,Be=Ut.ymin<=we&&Ut.ymax>=we}if(Be){Ie=!0;for(let ms=this.m_shape.getFirstPath(this.m_geometry);ms!==Y.n;){let Ss=!0,Ze=-1,Qe=-1;const fe=this.m_shape.getFirstVertex(ms);let os=fe;do{this.progress_(),Te=this.m_shape.getSegment(os);let ye=Te;if(null===ye){const re=this.m_shape.getNextVertex(os);if(re===Y.n){(0,F.g)(Jt),0===Ze&&ve.push(os);break}this.m_shape.queryXY(os,me),Pe.setStartXY(me),this.m_shape.queryXY(re,Vt),Pe.setEndXY(Vt),ye=Pe}ye.queryLooseEnvelope(jt);let gs=ue.checkSegmentIntersection(jt,Le,we);ye.isCurve()&&0===gs&&ye.isCurve()&&(Pe.setStartXY(ye.getStartXY()),Pe.setEndXY(ye.getEndXY()),this.m_shape.replaceCurveWithLine(os),ye=Pe,Pe.queryEnvelope(jt),gs=ue.checkSegmentIntersection(jt,Le,we));let Ts=0,ks=Y.n;if(-1===gs){const re=ye.intersectionWithAxis2D(Re,we,xe,$t);if(re>0){let ds=null;if(ye.isCurve()){ds=_e,(0,F.g)(re<=9);for(let fs=0;fs<re;fs++)Re?_e[fs].setCoords(xe[fs],we):_e[fs].setCoords(we,xe[fs]);Ts=this.m_shape.splitSegmentAxisAware(os,$t,re,ds,Re?1:0)}else Ts=this.m_shape.splitSegmentAxisAware(os,$t,re,null,-1)}else Ts=0;Ts+=1;let qe=os,Ps=this.m_shape.getNextVertex(qe);ye=null;for(let ds=0;ds<Ts;ds++){this.m_shape.queryXY(qe,me),this.m_shape.queryXY(Ps,Vt),Te=this.m_shape.getSegment(qe);let fs=Te;null===fs&&(Pe.setStartXY(me),Pe.setEndXY(Vt),fs=Pe),fs.queryEnvelope(de);let qs=ue.checkSegmentIntersection(de,Le,we);fs.isCurve()&&0===qs&&(this.m_shape.replaceCurveWithLine(qe),Pe.setStartXY(me),Pe.setEndXY(Vt),fs=Pe,fs.queryEnvelope(de),qs=ue.checkSegmentIntersection(de,Le,we)),-1===qs&&(Re?Math.abs(me.y-we)<Math.abs(Vt.y-we)?(me.y=we,this.m_shape.setXY(qe,me)):(Vt.y=we,this.m_shape.setXY(Ps,Vt)):Math.abs(me.x-we)<Math.abs(Vt.x-we)?(me.x=we,this.m_shape.setXY(qe,me)):(Vt.x=we,this.m_shape.setXY(Ps,Vt)),Te=this.m_shape.getSegment(qe),fs=Te,null===fs&&(Pe.setStartXY(me),Pe.setEndXY(Vt),fs=Pe),fs.queryEnvelope(de),qs=ue.checkSegmentIntersection(de,Le,we),-1===qs&&(qs=ue.checkSegmentIntersectionLoose(de,Le,we)));const bi=Ze;Ze=qs,-1===Qe&&(Qe=Ze),0===bi&&1===Ze||1===bi&&0===Ze||0===bi&&0===Ze&&ve.push(qe),1===Ze&&(Ie=!1,Ss=!1),qe=Ps,ks=qe,Ps=this.m_shape.getNextVertex(Ps)}}if(0===Ts){const re=Ze;Ze=gs,-1===Qe&&(Qe=Ze),0===re&&Ze>=1||re>=1&&0===Ze||0===re&&0===Ze&&ve.push(os),1===Ze&&(Ie=!1,Ss=!1),ks=this.m_shape.getNextVertex(os)}if(os=ks,ve.length>=256){for(let re=1,qe=ve.length-1;re<qe;re++){const Ps=ve[re];Jt?this.m_shape.snapVertexForPoleClipping(Ps,we):this.m_shape.removeVertex(Ps,!1)}ve[1]=ve.at(-1),ve.length=2}}while(os!==fe);if(!Ss){0!==Qe||!Jt&&0!==Ze&&2!==Ze||ve.push(fe);for(let ye=0,gs=ve.length;ye<gs;ye++){const Ts=ve[ye];Jt?this.m_shape.snapVertexForPoleClipping(Ts,we):this.m_shape.removeVertex(Ts,!1)}}ve.length=0,ms=Ss||0===this.m_shape.getPathSize(ms)?this.m_shape.removePath(ms):this.m_shape.getNextPath(ms)}}}if(Ie)return Yt.createInstance();Te=null,Jt?this.removeSpikesAlongPoles():this.resolveBoundaryOverlaps(),se>0&&this.densifyAlongClipExtent(se);const je=this.m_shape.getGeometry(this.m_geometry);return je.getGeometryType()===F.G.enumPolygon&&je.setFillRule(Yt.getFillRule()),je}clipPolyline(Yt,se){const Jt=dt.J.constructEmpty(),Ut=dt.J.constructEmpty(),jt=(0,vt.d)(9,Number.NaN),de=(0,vt.d)(9,Number.NaN),me=new Y.S;let Vt=Yt;const xe=dt.J.constructEmpty();Yt.queryLooseEnvelope(xe);for(let $t=0;$t<4;$t++){let _e=!1;const Te=!!(1&$t);let Pe=0;switch($t){case 0:Pe=this.m_extent.xmin,_e=xe.xmin<=Pe&&xe.xmax>=Pe;break;case 1:Pe=this.m_extent.ymin,_e=xe.ymin<=Pe&&xe.ymax>=Pe;break;case 2:Pe=this.m_extent.xmax,_e=xe.xmin<=Pe&&xe.xmax>=Pe;break;case 3:Pe=this.m_extent.ymax,_e=xe.ymin<=Pe&&xe.ymax>=Pe}if(!_e)continue;const ve=Vt;Vt=Yt.createInstance();const Ie=ve.getImpl().querySegmentIterator();Ie.resetToFirstPath();const je=new vt.P,Le=new vt.P;for(;Ie.nextPath();){let Be=-1,Re=!0;for(;Ie.hasNextSegment();){this.progress_();const we=Ie.nextSegment(),ms=we.isDegenerate(0);we.queryLooseEnvelope(Jt);const Ss=ue.checkSegmentIntersection(Jt,$t,Pe);if(-1===Ss){const Ze=we.intersectionWithAxis2D(Te,Pe,jt,de);let Qe=0;je.assign(we.getStartXY());for(let fe=0;fe<=Ze;fe++){const os=fe<Ze?de[fe]:1;if(Qe===os)continue;we.queryCut(Qe,os,me,!1);const ye=me.get();let gs=!1;if(ye.getStartXY().equals(je)||(ye.setStartXY(je),gs=!0),fe<Ze&&(Te?(Le.x=jt[fe],Le.y=Pe):(Le.x=Pe,Le.y=jt[fe]),ye.getEndXY().equals(Le)||(ye.setEndXY(Le),gs=!0)),gs&&ye.normalizeAfterEndpointChange(),!ms&&ye.isDegenerate(0))continue;ye.queryEnvelope(Ut);let Ts=ue.checkSegmentIntersection(Ut,$t,Pe);if(-1===Ts){const ks=ye.getStartXY(),re=ye.getEndXY();gs=!1,Te?Math.abs(ks.y-Pe)<Math.abs(re.y-Pe)?(ks.y=Pe,ye.setStartXY(ks),ks.equals(ye.getStartXY())||(ye.setStartXY(ks),gs=!0)):(re.y=Pe,re.equals(ye.getEndXY())||(ye.setEndXY(re),gs=!0)):Math.abs(ks.x-Pe)<Math.abs(re.x-Pe)?(ks.x=Pe,ks.equals(ye.getStartXY())||(ye.setStartXY(ks),gs=!0)):(re.x=Pe,re.equals(ye.getEndXY())||(ye.setEndXY(re),gs=!0)),gs&&ye.normalizeAfterEndpointChange(),ye.queryEnvelope(Ut),Ts=ue.checkSegmentIntersection(Ut,$t,Pe),-1===Ts&&(Ts=ue.checkSegmentIntersectionLoose(Ut,$t,Pe))}je.assign(ye.getEndXY()),Qe=os,Be=Ts,Be>=1?(Vt.addSegment(ye,Re),Re=!1):Re=!0}}else Be=Ss,Be>=1?(Vt.addSegment(we,Re),Re=!1):Re=!0}}}return Vt}static checkSegmentIntersection(Yt,se,Jt){switch(se){case 0:return Yt.xmin<Jt&&Yt.xmax<=Jt?0:Yt.xmin>=Jt?Yt.xmax===Jt?2:1:-1;case 1:return Yt.ymin<Jt&&Yt.ymax<=Jt?0:Yt.ymin>=Jt?Yt.ymax===Jt?2:1:-1;case 2:return Yt.xmin>=Jt&&Yt.xmax>Jt?0:Yt.xmax<=Jt?Yt.xmin===Jt?2:1:-1;case 3:return Yt.ymin>=Jt&&Yt.ymax>Jt?0:Yt.ymax<=Jt?Yt.ymin===Jt?2:1:-1}return(0,F.c)(""),0}static checkSegmentIntersectionLoose(Yt,se,Jt){switch(se){case 0:{const Ut=Math.abs(Yt.xmin-Jt),jt=Math.abs(Yt.xmax-Jt);return Yt.xmin<Jt?Ut>jt?0:1:((0,F.c)(""),1)}case 1:{const Ut=Math.abs(Yt.ymin-Jt),jt=Math.abs(Yt.ymax-Jt);return Yt.ymin<Jt?Ut>jt?0:1:((0,F.c)(""),1)}case 2:{const Ut=Math.abs(Yt.xmin-Jt),jt=Math.abs(Yt.xmax-Jt);return Yt.xmax>Jt?Ut<jt?0:1:((0,F.c)(""),1)}case 3:{const Ut=Math.abs(Yt.ymin-Jt),jt=Math.abs(Yt.ymax-Jt);return Yt.ymax>Jt?Ut<jt?0:1:((0,F.c)(""),1)}}return(0,F.c)(""),0}resolveBoundaryOverlaps(){this.m_verticesOnExtentIndex=-1,this.splitSegments(!1,this.m_extent.xmin),this.splitSegments(!1,this.m_extent.xmax),this.splitSegments(!0,this.m_extent.ymin),this.splitSegments(!0,this.m_extent.ymax),this.m_verticesOnExtent.length=0,this.m_verticesOnExtentIndex=this.m_shape.createUserIndex();const Yt=new vt.P;for(let se=this.m_shape.getFirstPath(this.m_geometry);se!==Y.n;se=this.m_shape.getNextPath(se)){let Jt=this.m_shape.getFirstVertex(se);for(let Ut=0,jt=this.m_shape.getPathSize(se);Ut<jt;Ut++,Jt=this.m_shape.getNextVertex(Jt))this.progress_(),this.m_shape.queryXY(Jt,Yt),this.m_extent.xmin!==Yt.x&&this.m_extent.xmax!==Yt.x&&this.m_extent.ymin!==Yt.y&&this.m_extent.ymax!==Yt.y||(this.m_shape.setUserIndex(Jt,this.m_verticesOnExtentIndex,this.m_verticesOnExtent.length),this.m_verticesOnExtent.push(Jt))}this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmin),this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmax),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymin),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymax),this.fixPaths()}densifyAlongClipExtent(Yt){const se=new vt.P(0,0),Jt=new vt.P(0,0),Ut=(0,vt.d)(2048,Number.NaN);for(let jt=this.m_shape.getFirstPath(this.m_geometry);jt!==Y.n;jt=this.m_shape.getNextPath(jt)){const de=this.m_shape.getFirstVertex(jt);let me=de;do{const Vt=this.m_shape.getNextVertex(me);this.m_shape.queryXY(me,se);let xe=-1;if(se.x===this.m_extent.xmin?(this.m_shape.queryXY(Vt,Jt),Jt.x===this.m_extent.xmin&&(xe=1)):se.x===this.m_extent.xmax&&(this.m_shape.queryXY(Vt,Jt),Jt.x===this.m_extent.xmax&&(xe=1)),se.y===this.m_extent.ymin?(this.m_shape.queryXY(Vt,Jt),Jt.y===this.m_extent.ymin&&(xe=0)):se.y===this.m_extent.ymax&&(this.m_shape.queryXY(Vt,Jt),Jt.y===this.m_extent.ymax&&(xe=0)),-1===xe){me=Vt;continue}if(this.isCurve(me)){me=Vt;continue}const $t=se.clone(),_e=new vt.P(0,0);if(xe){const ve=se.y-this.m_extent.ymin;_e.y=(0,vt.e)(Jt.y-se.y),$t.y=Yt*(0,vt.f)(Math.floor(Math.abs(ve)/Yt),ve)+this.m_extent.ymin,_e.y<0&&($t.y+=Yt)}else{const ve=se.x-this.m_extent.xmin;_e.x=(0,vt.e)(Jt.x-se.x),$t.x=Yt*(0,vt.f)(Math.floor(Math.abs(ve)/Yt),ve)+this.m_extent.xmin,_e.x<0&&($t.x+=Yt)}const Te=xe?Jt.y-se.y:Jt.x-se.x,Pe=Math.abs(Te);if(Pe/Yt>65536&&(0,F.c)(""),Pe>0){const ve=Math.trunc(Pe/Yt)+2;Ut.length<ve&&(Ut.length=ve);let Ie=0;for(let je=0;;je++){const Le=$t.add(_e.mul(je*Yt)),Be=(xe?Le.y-se.y:Le.x-se.x)/Te;if(Be>=1)break;Be<=0||((0,F.g)(Ie<=Ut.length),Ut[Ie]=Be,Ie++)}0!==Ie&&this.m_shape.splitSegment(me,Ut,Ie)}me=Vt}while(me!==de)}}splitSegments(Yt,se){let Jt=-1;const Ut=new vt.P,jt=[];for(let ve=this.m_shape.getFirstPath(this.m_geometry);ve!==Y.n;ve=this.m_shape.getNextPath(ve)){let Ie=this.m_shape.getFirstVertex(ve),je=Y.n;for(let Le=0,Be=this.m_shape.getPathSize(ve);Le<Be;Le++,Ie=je)if(this.progress_(),je=this.m_shape.getNextVertex(Ie),this.m_shape.queryXY(Ie,Ut),(Yt?Ut.y===se:Ut.x===se)&&(this.m_shape.queryXY(je,Ut),Yt?Ut.y===se:Ut.x===se)){if(this.isCurve(Ie))continue;-1===Jt&&(Jt=this.m_shape.createUserIndex()),1!==this.m_shape.getUserIndex(Ie,Jt)&&(jt.push(Ie),this.m_shape.setUserIndex(Ie,Jt,1)),1!==this.m_shape.getUserIndex(je,Jt)&&(jt.push(je),this.m_shape.setUserIndex(je,Jt,1))}}if(-1!==Jt&&this.m_shape.removeUserIndex(Jt),jt.length<3)return;jt.sort((ve,Ie)=>this.compareVertices(ve,Ie));const de=new vt.P,me=new vt.P,Vt=new vt.P;me.setNAN();let xe=-1,$t=[],_e=[];const Te=this.m_shape.createUserIndex(),Pe=this.m_shape.createUserIndex();for(let ve=0,Ie=jt.length;ve<Ie;ve++)if(this.m_shape.queryXY(jt[ve],Ut),!Ut.isEqualPoint2D(me)){if(-1===xe){xe=ve,me.setCoordsPoint2D(Ut);continue}for(let Be=xe;Be<ve;Be++){const Re=jt[Be],we=this.m_shape.getNextVertex(Re),ms=this.m_shape.getPrevVertex(Re);let Ss=!1;this.m_shape.queryXY(we,de),me.compare(de)<0&&(Yt?de.y===se:de.x===se)&&(this.isCurve(Re)||($t.push(Re),Ss=!0,this.m_shape.setUserIndex(Re,Pe,1))),this.m_shape.queryXY(ms,de),me.compare(de)<0&&(Yt?de.y===se:de.x===se)&&(this.isCurve(ms)||(Ss||$t.push(Re),this.m_shape.setUserIndex(Re,Te,1)))}for(let Be=0,Re=$t.length;Be<Re;Be++){const we=$t[Be],ms=this.m_shape.getUserIndex(we,Te),Ss=this.m_shape.getUserIndex(we,Pe);if(1===ms){const Ze=this.m_shape.getPrevVertex(we);this.m_shape.queryXY(Ze,Vt);let Qe=0;if(!Vt.isEqualPoint2D(Ut)){const fe=vt.P.distance(me,Vt);Qe=vt.P.distance(Vt,Ut)/fe,0===Qe?Qe=Number.EPSILON:1===Qe&&(Qe=1-Number.EPSILON),this.m_shape.splitSegment(Ze,[Qe],1);const os=this.m_shape.getPrevVertex(we);this.m_shape.setXY(os,Ut),_e.push(os),this.m_shape.setUserIndex(os,Te,1),this.m_shape.setUserIndex(os,Pe,-1)}}if(1===Ss){const Ze=this.m_shape.getNextVertex(we);this.m_shape.queryXY(Ze,Vt);let Qe=0;if(!Vt.isEqualPoint2D(Ut)){const fe=vt.P.distance(me,Vt);Qe=vt.P.distance(me,Ut)/fe,0===Qe?Qe=Number.EPSILON:1===Qe&&(Qe=1-Number.EPSILON),this.m_shape.splitSegment(we,[Qe],1);const os=this.m_shape.getNextVertex(we);this.m_shape.setXY(os,Ut),_e.push(os),this.m_shape.setUserIndex(os,Te,-1),this.m_shape.setUserIndex(os,Pe,1)}}}const Le=$t;$t=_e,_e=Le,_e.length=0,xe=ve,me.setCoordsPoint2D(Ut)}this.m_shape.removeUserIndex(Te),this.m_shape.removeUserIndex(Pe)}resolveOverlaps(Yt,se){const Jt=new vt.P,Ut=[];let jt=-1;for(let xe=0,$t=this.m_verticesOnExtent.length;xe<$t;xe++){this.progress_();const _e=this.m_verticesOnExtent[xe];if(_e===Y.n)continue;const Te=this.m_shape.getNextVertex(_e);if(this.m_shape.queryXY(_e,Jt),(Yt?Jt.y===se:Jt.x===se)&&(this.m_shape.queryXY(Te,Jt),Yt?Jt.y===se:Jt.x===se)){if(this.isCurve(_e))continue;-1===jt&&(jt=this.m_shape.createUserIndex()),-2!==this.m_shape.getUserIndex(_e,jt)&&(Ut.push(_e),this.m_shape.setUserIndex(_e,jt,-2)),-2!==this.m_shape.getUserIndex(Te,jt)&&(Ut.push(Te),this.m_shape.setUserIndex(Te,jt,-2))}}if(0===Ut.length)return void(-1!==jt&&this.m_shape.removeUserIndex(jt));(0,F.g)(-1!==jt),Ut.sort((xe,$t)=>this.compareVertices(xe,$t));for(let xe=0,$t=Ut.length;xe<$t;xe++)this.m_shape.setUserIndex(Ut[xe],jt,xe);const de=new vt.P,me=new vt.P;me.setNAN();let Vt=-1;for(let xe=0,$t=Ut.length;xe<$t;xe++){this.progress_();const _e=Ut[xe];if(_e!==Y.n&&(this.m_shape.queryXY(_e,Jt),!Jt.isEqualPoint2D(me))){if(-1!==Vt)for(;;){let Te=!1;const Pe=xe;for(let ve=Vt;ve<Pe;ve++){const Ie=Ut[ve];if(Ie===Y.n)continue;let je=Y.n;const Le=this.m_shape.getNextVertex(Ie);this.m_shape.queryXY(Le,de),me.compare(de)<0&&(Yt?de.y===se:de.x===se)&&(this.isCurve(Ie)||(je=Le));let Be=Y.n;const Re=this.m_shape.getPrevVertex(Ie);if(this.m_shape.queryXY(Re,de),me.compare(de)<0&&(Yt?de.y===se:de.x===se)&&(this.isCurve(Re)||(Be=Re)),je===Y.n||Be===Y.n){if(je!==Y.n||Be!==Y.n){for(let we=ve+1;we<xe;we++){const ms=Ut[we];if(ms===Y.n)continue;const Ss=this.m_shape.getNextVertex(ms);let Ze=Y.n;this.m_shape.queryXY(Ss,de),me.compare(de)<0&&(Yt?de.y===se:de.x===se)&&(this.isCurve(ms)||(Ze=Ss));const Qe=this.m_shape.getPrevVertex(ms);let fe=Y.n;if(this.m_shape.queryXY(Qe,de),me.compare(de)<0&&(Yt?de.y===se:de.x===se)&&(this.isCurve(Qe)||(fe=Qe)),Ze!==Y.n&&fe!==Y.n){this.beforeRemoveVertex(ms,Ut,jt),this.m_shape.removeVertex(ms,!1),this.beforeRemoveVertex(Ze,Ut,jt),this.m_shape.removeVertex(Ze,!1),Te=!0;break}if(je!==Y.n&&fe!==Y.n){this.removeOverlap(Ut,Ie,je,ms,fe,jt),Te=!0;break}if(Be!==Y.n&&Ze!==Y.n){this.removeOverlap(Ut,ms,Ze,Ie,Be,jt),Te=!0;break}}if(Te)break}}else this.beforeRemoveVertex(Ie,Ut,jt),this.m_shape.removeVertex(Ie,!1),this.beforeRemoveVertex(je,Ut,jt),this.m_shape.removeVertex(je,!1),Te=!0}if(!Te)break}Vt=xe,me.setCoordsPoint2D(Jt)}}this.m_shape.removeUserIndex(jt)}beforeRemoveVertex(Yt,se,Jt){let Ut=this.m_shape.getUserIndex(Yt,Jt);(0,F.g)(Ut>=0),se[Ut]=Y.n,Ut=this.m_shape.getUserIndex(Yt,this.m_verticesOnExtentIndex),(0,F.g)(Ut>=0),this.m_verticesOnExtent[Ut]=Y.n;const jt=this.m_shape.getPathFromVertex(Yt);jt!==Y.n&&this.m_shape.getFirstVertex(jt)===Yt&&(this.m_shape.setFirstVertex(jt,Y.n),this.m_shape.setLastVertex(jt,Y.n))}removeOverlap(Yt,se,Jt,Ut,jt,de){this.m_shape.setNextVertex(se,Ut),this.m_shape.setPrevVertex(Ut,se),this.m_shape.setPrevVertex(Jt,jt),this.m_shape.setNextVertex(jt,Jt),this.beforeRemoveVertex(Ut,Yt,de),this.m_shape.removeVertexInternal(Ut,!1),this.beforeRemoveVertex(jt,Yt,de),this.m_shape.removeVertexInternal(jt,!0)}removeSpikesAlongPoles(){this.removeSpikesOnPole(this.m_extent.ymin),this.removeSpikesOnPole(this.m_extent.ymax)}removeSpikesOnPole(Yt){for(let se=this.m_shape.getFirstPath(this.m_geometry);se!==Y.n;se=this.m_shape.getNextPath(se)){const Jt=this.m_shape.getPathSize(se);if(Jt<3)continue;let Ut=this.m_shape.getFirstVertex(se);const jt=new vt.P;this.m_shape.queryXY(Ut,jt);let de=jt.y===Yt&&!this.isCurve(Ut);Ut=this.m_shape.getNextVertex(Ut);const me=new vt.P;this.m_shape.queryXY(Ut,me);let Vt=me.y===Yt&&!this.isCurve(Ut);Ut=this.m_shape.getNextVertex(Ut);const xe=new vt.P;for(let $t=0,_e=Jt-2;$t<_e;$t++,Ut=this.m_shape.getNextVertex(Ut)){this.progress_(),this.m_shape.queryXY(Ut,xe);const Te=xe.y===Yt;Vt&&de&&Te&&(me.x-jt.x)*(xe.x-me.x)<=0?(this.m_shape.removeVertex(this.m_shape.getPrevVertex(Ut),!1),me.setCoordsPoint2D(xe),Vt=Te&&!this.isCurve(Ut)):(jt.setCoordsPoint2D(me),de=Vt,me.setCoordsPoint2D(xe),Vt=Te&&!this.isCurve(Ut))}}}fixPaths(){for(let jt=0,de=this.m_verticesOnExtent.length;jt<de;jt++){const me=this.m_verticesOnExtent[jt];me!==Y.n&&this.m_shape.setPathToVertex(me,Y.n)}const Yt=this.m_shape.hasCurves();let se=0,Jt=0;for(let jt=this.m_shape.getFirstPath(this.m_geometry);jt!==Y.n;){const de=this.m_shape.getFirstVertex(jt);if(de===Y.n||jt!==this.m_shape.getPathFromVertex(de)){const xe=jt;jt=this.m_shape.getNextPath(jt),this.m_shape.setFirstVertex(xe,Y.n),this.m_shape.removePathOnly(xe);continue}let me=de,Vt=0;do{this.m_shape.setPathToVertex(me,jt),Vt++,me=this.m_shape.getNextVertex(me)}while(me!==de);this.m_shape.setRingAreaValid(jt,!1),this.m_shape.setLastVertex(jt,this.m_shape.getPrevVertex(de)),this.m_shape.setPathSize(jt,Vt),Jt+=Vt,se++,jt=this.m_shape.getNextPath(jt)}for(let jt=0,de=this.m_verticesOnExtent.length;jt<de;jt++){let me=this.m_verticesOnExtent[jt];if(me===Y.n)continue;let Vt=this.m_shape.getPathFromVertex(me);if(Vt!==Y.n)continue;Vt=this.m_shape.insertPath(this.m_geometry,Y.n);let xe=!1,$t=0;const _e=me;do{this.m_shape.setPathToVertex(me,Vt),$t++,Yt&&$t<=2&&(xe||=this.isCurve(me)),me=this.m_shape.getNextVertex(me)}while(me!==_e);if(xe?0===$t:$t<=2){let Te=this.m_shape.getUserIndex(_e,this.m_verticesOnExtentIndex);(0,F.g)(Te>=0),this.m_verticesOnExtent[Te]=Y.n;const Pe=this.m_shape.removeVertex(_e,!1);2===$t&&(Te=this.m_shape.getUserIndex(Pe,this.m_verticesOnExtentIndex),Te>=0&&(this.m_verticesOnExtent[Te]=Y.n),this.m_shape.removeVertex(Pe,!1));const ve=Vt;Vt=this.m_shape.getNextPath(Vt),this.m_shape.setFirstVertex(ve,Y.n),this.m_shape.removePathOnly(ve)}else this.m_shape.setClosedPath(Vt,!0),this.m_shape.setPathSize(Vt,$t),this.m_shape.setFirstVertex(Vt,_e),this.m_shape.setLastVertex(Vt,this.m_shape.getPrevVertex(_e)),this.m_shape.setRingAreaValid(Vt,!1),Jt+=$t,se++}this.m_shape.setGeometryPathCount(this.m_geometry,se),this.m_shape.setGeometryVertexCount(this.m_geometry,Jt);let Ut=0;for(let jt=this.m_shape.getFirstGeometry();jt!==Y.n;jt=this.m_shape.getNextGeometry(jt))Ut+=this.m_shape.getPointCount(jt);this.m_shape.setTotalPointCount(Ut)}dbgCheckPathFirst(){}isCurve(Yt){return null!==this.m_shape.getSegment(Yt)}compareVertices(Yt,se){const Jt=new vt.P;this.m_shape.queryXY(Yt,Jt);const Ut=new vt.P;return this.m_shape.queryXY(se,Ut),Jt.compare(Ut)}clipPolesOut(Yt,se){return this.clipPolygonOrProjectedPolyline2(Yt,se)}}class hs{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(Yt,se,Jt){return!1}canAccelerateGeometry(Yt){return!1}executeMany(Yt,se,Jt,Ut){return new Ee(Yt,se,Jt,Ut)}execute(Yt,se,Jt,Ut){return function As(Ve,Yt,se,Jt){return Rt(Ve,Yt,se,Number.NaN,0,Jt)}(Yt,se,Jt,Ut)}}class Ee extends R.G{constructor(Yt,se,Jt,Ut){super(),this.m_progressTracker=Ut,this.m_index=-1,Yt||(0,F.t)(""),this.m_envelope=se,this.m_inputGeometryCursor=Yt,this.m_spatialRefImpl=Jt,this.m_tolerance=(0,c.a)(Jt,se,!1).total()}next(){let Yt;return(Yt=this.m_inputGeometryCursor.next())?((0,F.d)(Yt),this.m_index=this.m_inputGeometryCursor.getGeometryID(),Wt(Yt,this.m_envelope,this.m_tolerance,0,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}},9279:(Do,Ui,ze)=>{ze.d(Ui,{O:()=>vt});var R=ze(1469),F=ze(62257),c=ze(95944),dt=c.D;class Y extends R.G{constructor(Rt,Se,ee,ue,hs,Ee){super(),this.m_densificator=new dt(Se,ee,ue,Ee,!1,hs),this.m_index=-1,this.m_inputGeoms=Rt}tock(){return!0}getRank(){return 1}next(){let Rt=null;for(;Rt=this.m_inputGeoms.next();)return(0,F.d)(Rt),this.m_index=this.m_inputGeoms.getGeometryID(),this.densify(Rt);return null}getGeometryID(){return this.m_index}densify(Rt){return this.m_densificator.densify(Rt)}}class vt{getOperatorType(){return 10202}accelerateGeometry(Rt,Se,ee){return!1}canAccelerateGeometry(Rt){return!1}supportsCurves(){return!0}executeMany(Rt,Se,ee,ue,hs,Ee=12e3){return new Y(Rt,Se,ee,ue,Ee,hs)}execute(Rt,Se,ee,ue,hs,Ee=12e3){return(0,c.d)(Rt,Se,ee,ue,hs,Ee)}}},3037:(Do,Ui,ze)=>{ze.r(Ui),ze.d(Ui,{$:()=>r,A:()=>se,B:()=>xa,C:()=>ci,D:()=>wn,E:()=>js,F:()=>Si,G:()=>Lr,H:()=>Pa,I:()=>Cn,J:()=>$h,K:()=>Yl,L:()=>vs,M:()=>Kh,N:()=>yi,O:()=>gm,P:()=>es,Q:()=>$t,R:()=>f,S:()=>Q,T:()=>ai,U:()=>Vt,V:()=>Dn,W:()=>gn,X:()=>Qo,Y:()=>Ie,Z:()=>Hs,_:()=>Xr,a:()=>Mt,a0:()=>ds,a1:()=>Re,a2:()=>Ss,a3:()=>n,a4:()=>pe,a5:()=>ma,a6:()=>Ps,a7:()=>Be,a8:()=>su,a9:()=>cs,aA:()=>Ru,aB:()=>Xu,aC:()=>cm,aD:()=>Eu,aE:()=>_i,aF:()=>ue,aG:()=>Yc,aH:()=>Xc,aI:()=>Rc,aJ:()=>kc,aK:()=>Lc,aa:()=>nu,ab:()=>iu,ac:()=>gt,ad:()=>pi,ae:()=>qn,af:()=>yo,ag:()=>bn,ah:()=>zn,ai:()=>Bh,aj:()=>zh,ak:()=>Uh,al:()=>Cl,am:()=>Bi,an:()=>ui,ao:()=>Yu,ap:()=>yl,aq:()=>qi,ar:()=>xi,as:()=>Il,at:()=>Qs,au:()=>Oe,av:()=>bi,aw:()=>Lu,ax:()=>ws,ay:()=>is,az:()=>ks,b:()=>yu,c:()=>Dm,d:()=>Po,e:()=>Eo,f:()=>mi,g:()=>Vi,h:()=>Co,i:()=>ti,j:()=>qu,k:()=>oi,l:()=>ri,m:()=>ln,n:()=>Yh,o:()=>Ne,p:()=>kr,q:()=>_l,r:()=>Ki,s:()=>Ai,t:()=>Xa,u:()=>ca,v:()=>Ji,w:()=>Fs,x:()=>ga,y:()=>Un,z:()=>Vu});var R=ze(87571),F=ze(62257),c=ze(95944),dt=ze(7085),Y=ze(33165),vt=ze(8189),Wt=ze(23558),Rt=ze(83875),Se=ze(9279),ee=ze(1469);class ue{constructor(t){if(this.m_geom=this.m_sr=null,t){if(t.move)return this.m_geom=t.move.m_geom,t.move.m_geom=null,this.m_sr=t.move.m_sr,void(t.move.m_sr=null);if(t.copy)return this.m_geom=t.copy.m_geom?t.copy.m_geom.clone():null,void(this.m_sr=t.copy.m_sr);t.geom&&(this.m_geom=t.geom),t.sr&&(this.m_sr=t.sr)}}getGeometry(){return this.m_geom}getSpatialReference(){return this.m_sr}setGeometry(t){this.m_geom=t}setSpatialReference(t){this.m_sr=t}equals(t,m){const u=t;return!(!this.m_sr&&u.m_sr||this.m_sr&&!u.m_sr||!this.m_geom&&u.m_geom||this.m_geom&&!u.m_geom||this.m_sr&&u.m_sr&&!this.m_sr.equals(u.m_sr)||this.m_geom&&u.m_geom&&!this.m_geom.equals(u.m_geom,m))}clone(){let t=null;return this.m_geom&&(t=this.m_geom.clone()),new ue({geom:t,sr:this.m_sr})}hasGeom(){return!!this.m_geom}}class hs{constructor(t){this.m_factor=1,this.m_wkid=0,this.m_peUnit=null,t&&(this.m_peUnit=t,this.m_factor=t.getUnitFactor(),this.m_wkid=t.getCode(),this.m_wkid<0&&(this.m_wkid=0))}getName(){return this.m_peUnit.getName()}getID(){return this.m_wkid}getConversionFactor(t){return this.getUnitType()!==t.getUnitType()&&(0,F.t)("unit type mismatch"),this.getUnitToBaseFactor()/t.getUnitToBaseFactor()}getUnitToBaseFactor(){return this.m_factor}getHashCode(){return(0,Y.aq)((0,Y.ar)(this.getUnitType()),(0,Y.ar)(this.getUnitToBaseFactor()))}equals(t){return!!t&&this.getUnitType()===t.getUnitType()&&this.getUnitToBaseFactor()===t.getUnitToBaseFactor()&&this.getID()===t.getID()&&this.getName()===t.getName()}static isValidWkid(t){return!1}}class Ee{assign(t){this.m_reason=t.m_reason,this.m_vertexIndex1=t.m_vertexIndex1,this.m_vertexIndex2=t.m_vertexIndex2}constructor(t,m,u){void 0!==t?(this.m_reason=t,this.m_vertexIndex1=m,this.m_vertexIndex2=u):(this.m_reason=0,this.m_vertexIndex1=-1,this.m_vertexIndex2=-2)}clear(){this.m_reason=0,this.m_vertexIndex1=-1,this.m_vertexIndex2=-1}}const As={330:104878,500:104879,1300:104899,1450:104986,2230:104988,3800:104978,5e3:104919,6200:104906,8200:104909,9500:104927,9600:104977,1e4:[104911,104936],11e3:104941,11080:104872,11100:104907,12e3:104920,12400:104995,13e3:104948,14e3:[104923,104989],15e3:[104913,104954],15100:104976,16e3:[104926,104931],18e3:[104922,104982],21e3:104947,21500:104877,27e3:[104950,104957],29e3:104964,3e4:104921,31e3:104949,33e3:104946,4e4:[104914,104967],40600:104897,41900:104937,42e3:104951,43100:104993,49300:104924,50100:104939,54e3:104955,58200:104981,59500:104930,74e3:104961,77e3:104956,79e3:104962,83500:104910,85e3:104917,88800:104934,89200:104985,96e3:104997,104e3:104963,106500:104898,11e4:104938,133e3:104932,135e3:104983,17e4:104965,198200:104987,198630:104935,208e3:104966,235800:104952,249400:104929,252100:104980,255e3:104973,47e4:104972,529800:104942,531e3:104996,56e4:104928,561400:104979,578900:104945,584700:104959,593e3:104970,606e3:104999,718e3:104933,745700:104984,761400:104953,763500:104994,764e3:104940,788900:104958,1188300:104998,1195e3:104969,1352600:104968,1560800:104874,1562090:104915,1737400:104903,1821460:104918,1821490:104876,2409300:104912,2410300:104873,2439400:104974,2439700:104900,2575e3:104943,2631200:104875,2632345:104916,3393400:104904,3396190:[104905,104971],6051e3:104901,6051800:104902,637e4:104128,6370997:[4052,37008],6371e3:4035,6371007:4047,6371228:[4053,10346],6376045:[8042,8043],6376523:[4027,4901,4902],6376896:37007,6378135:[4122,4322,4324,4720,4985,4987],6378136:[4740,4923,7678,7680,9474,9475,104017,104018],6378137:[3823,3824,3888,3889,4017,4019,4023,4031,4040,4046,4055,4074,4075,4080,4081,4121,4126,4130,4133,4140,4141,4148,4151,4152,4163,4166,4167,4170,4171,4172,4173,4176,4180,4189,4190,4258,4269,4283,4318,4319,4326,4463,4466,4469,4470,4480,4482,4483,4490,4557,4558,4612,4617,4619,4624,4627,4659,4661,4667,4669,4670,4674,4686,4687,4693,4694,4702,4737,4742,4747,4749,4750,4755,4756,4757,4758,4759,4761,4762,4763,4764,4765,4883,4885,4887,4889,4893,4895,4898,4907,4909,4921,4925,4927,4929,4931,4933,4935,4937,4939,4941,4943,4945,4947,4949,4951,4953,4955,4957,4959,4961,4963,4965,4967,4971,4975,4977,4979,4981,4983,4989,4997,4999,5012,5013,5245,5246,5251,5252,5263,5264,5323,5324,5340,5342,5353,5354,5359,5360,5364,5365,5370,5371,5372,5373,5380,5381,5392,5393,5488,5489,5545,5546,5592,5593,5885,5886,6134,6135,6310,6311,6318,6319,6321,6322,6324,6325,6364,6365,6667,6668,6705,6706,6782,6783,6980,6982,6983,6987,6989,6990,7034,7035,7036,7037,7038,7039,7040,7041,7042,7072,7073,7084,7085,7086,7087,7133,7135,7136,7138,7139,7372,7373,7657,7659,7661,7663,7665,7685,7686,7797,7798,7816,7843,7844,7880,7881,7885,7886,7900,7901,7902,7903,7904,7905,7906,7907,7908,7909,7910,7911,7912,7915,7917,7919,7921,7923,7925,7927,7929,7931,8085,8086,8231,8232,8235,8237,8239,8240,8244,8246,8248,8249,8251,8252,8254,8255,8399,8403,8426,8427,8449,8542,8544,8545,8684,8685,8698,8699,8817,8818,8860,8888,8899,8900,8901,8902,8906,8907,8916,8918,8920,8922,8924,8926,8928,8930,8932,8934,8936,8938,8940,8942,8944,8946,8948,8949,8972,8973,8974,8975,8976,8977,8978,8979,8980,8981,8982,8983,8984,8985,8986,8987,8988,8989,8990,8991,8992,8993,8994,8995,8996,8997,8998,8999,9e3,9002,9003,9005,9006,9008,9009,9011,9012,9013,9014,9016,9017,9018,9019,9053,9054,9055,9056,9057,9059,9060,9061,9062,9063,9064,9065,9066,9067,9068,9069,9071,9072,9074,9075,9139,9140,9147,9148,9152,9153,9183,9184,9293,9294,9299,9308,9309,9332,9333,9364,9372,9379,9380,9384,9453,9469,9470,9546,9547,9695,9696,9701,9702,9739,9754,9755,9758,9763,9776,9777,9778,9779,9781,9782,9783,9784,9866,9871,9939,9964,9969,9974,9989,9990,10175,10177,10178,10185,10191,10196,10204,10209,10214,10219,10224,10229,10237,10272,10277,10283,10284,10298,10299,10300,10304,10305,10307,10309,10310,10311,10312,10327,10328,10413,10414,10468,10474,10475,10570,10571,10605,10606,10623,10628,20033,20040,20041,20045,20046,104009,104010,104011,104012,104013,104014,104015,104016,104019,104020,104021,104022,104024,104027,104028,104050,104100,104107,104108,104110,104111,104114,104115,104116,104117,104118,104119,104120,104121,104122,104123,104124,104129,104133,104134,104137,104141,104142,104143,104144,104145,104179,104180,104181,104182,104183,104184,104185,104186,104199,104223,104257,104258,104259,104260,104286,104287,104602,104613,104644,104645,104646,104647,104653,104804,104896,104991],6378140:4610,6378145:[4025,4276,4760,4891,37001],6378150:37003,6378155:[37004,37207],6378160:[3821,4003,4021,4036,4202,4203,4237,4238,4291,4618,4708,5527,37231,104023,104136],6378166:37002,6378200:[4020,4229,4286,4303,4706],6378245:[4024,4147,4164,4178,4179,4191,4200,4205,4214,4284,4317,4555,4676,4677,4678,4991,4993,5560,5561,37257,104135],6378270:[4732,37005,37229],6378273:[4054,10345],6378300:[4029,4168,4174],6378388:[4022,4123,4153,4154,4158,4159,4160,4161,4165,4181,4182,4183,4184,4185,4192,4194,4195,4196,4199,4204,4207,4208,4215,4218,4221,4224,4225,4230,4231,4233,4235,4236,4247,4248,4249,4254,4255,4259,4264,4265,4271,4272,4274,4285,4287,4288,4292,4297,4309,4311,4313,4316,4472,4475,4611,4614,4615,4616,4621,4622,4623,4625,4626,4628,4629,4630,4631,4632,4633,4636,4637,4639,4641,4642,4643,4644,4645,4646,4658,4660,4662,4663,4664,4665,4668,4672,4673,4684,4688,4689,4690,4691,4692,4698,4704,4705,4707,4709,4710,4711,4712,4714,4715,4716,4718,4719,4721,4722,4724,4725,4727,4728,4729,4730,4733,4734,4735,4739,4741,4753,4754,4802,4803,4806,4809,4810,4823,4824,4900,5524,6883,8428,8430,8431,9248,9251,9253,9403,9893,10158,10249,10252,37201,37204,37205,37212,37213,37214,37215,37216,37217,37218,37219,37221,37222,37224,37226,37227,37230,37232,37233,37234,37235,37237,37238,37241,37242,37245,37246,37247,37249,37250,37251,37253,37259,104104,104106,104125,104126,104127,104130,104138,104248],6378523:104786,24764e3:104960,25559e3:104944,60268e3:104925,71492e3:104908,6957e5:104975,6377397.155:[3819,3906,4004,4120,4124,4125,4149,4150,4156,4162,4211,4219,4257,4262,4280,4289,4294,4295,4301,4306,4308,4312,4314,4613,4666,4745,4746,4801,4804,4805,4808,4813,4814,4815,4818,4820,4904,5132,5228,5229,5681,5830,8351,9267,10268,37255,104101,104102,104105,104131,104648,104696,104697,104990,104992],6377563.396:[4001,4188,4277,4278,4279],6377340.189:[4002,4299,4300],6377492.018:[4005,4273,4817],6377483.865280418:[4006,4293],6378293.645208759:[4007,4157,4302,4738,5464],6378206.4:[4008,4127,4128,4129,4135,4136,4137,4138,4139,4169,4216,4242,4253,4267,4608,4609,4638,4675,4683,4695,4717,4723,4726,4995,5451,5467,37220,37239,37243,37252,37260,104e3,104109,104112,104113,104132],6378450.047:[4009,4268],6378300.789:[4010,4281],6378249.2:[4011,4014,4155,4193,4206,4213,4223,4226,4227,4228,4252,4261,4266,4275,4282,4296,4304,4310,4315,4671,4807,4811,4816,4821,37223,37225,104139,104140,104261,104304],6378249.145:[4012,4013,4132,4134,4142,4143,4175,4197,4198,4201,4209,4210,4212,4220,4222,4232,4234,4246,4250,4251,4256,4260,4263,4270,4305,4307,4600,4601,4602,4603,4604,4605,4606,4607,4620,4679,4680,4696,4697,4699,4700,4701,4703,4713,4731,4736,4743,4744,4812,4819,6881,6882,6892,6894,8694,37206,37208,37211,37228,37240,37254,104025,104026,104103,104305],6377276.345:[4015,4131,4144,4239,4240,4244,4682,5233,6207,37202,104256,104664,104693],6377298.556:[4016,4298],6377304.063:[4018,4245],6378298.3:[4028,4903],6378136.2:4032,6378136.3:4033,6378249.144808011:[4034,4241],20922931.8:[4042,4243],6377301.243:[4044,4145,37203],6377299.151:[4045,4146],6377019.27:[4657,10256,10260,10265],6378306.3696:[4748,4752],6377295.664:[4751,37006],6378136.5:[7682,7683],6371008.7714:104047,6378418.941:[104700,104726,104760],6378586.581:[104701,104743],6378505.809:104702,6378544.823:104703,6378490.569:104704,6378470.757:[104705,104776],6378403.701:[104706,104750],6378434.181:[104707,104724,104739,104764],6378454.907:104708,6378400.653:104709,6378567.378:104710,6378546.957:[104711,104717,104780],6378476.853:[104712,104736],6378411.321:[104713,104728],6378647.541:[104714,104715],6378514.953:[104716,104782],6378421.989:[104718,104770],6378481.425:[104719,104753,104774,104781],6378518.001:[104720,104725],6378521.049:[104721,104723,104731,104745,104748],6378464.661:104722,6378436.619:104727,6378574.389:[104729,104730],6378472.281:[104732,104756],6378498.189:[104733,104746],6378449.421:[104734,104766],6378525.621:[104735,104754],6378466.185:104737,6378496.665:104738,6378643.579:104740,6378559.758:104741,6378414.369:[104742,104763,104772],6378441.801:104744,6378502.761:[104747,104759,104773,104775],6378617.061:104749,6378624.681:[104751,104765],6378468.623:104752,6378445.763:[104755,104758,104761],6378670.401:104757,6378438.753:104762,6378543.909:104767,6378605.783:104768,6378540.861:104769,6378443.325:[104771,104784],6378548.481:104777,6378463.746:104778,6378426.561:104779,6378453.688:104783,6378530.193:104785,6378376.271:[104800,104828],6378471.92:104801,6378472.931:104802,6378411.351:104803,6378380.991:104805,6378414.96:104806,6378345.09:[104807,104819,104844,104870],6378412.542:104808,6378470.401:104809,6378376.331:104810,6378379.031:104811,6378407.621:104812,6378376.811:[104813,104827],6378313.92:104814,6378414.93:104815,6378413.021:104816,6378380.381:104817,6378530.851:104818,6378591.521:104820,6378378.881:104821,6378408.481:[104822,104832],6378375.601:[104823,104838],6378408.041:104824,6378655.071:104825,6378409.151:104826,6378315.7:[104829,104840,104845,104851],6378285.86:[104830,104835,104859],6378379.301:104831,6378560.121:104833,6378531.821:104834,6378500.6:104836,6378376.041:104837,6378406.601:104839,6378438.991:104841,6378345.42:104842,6378593.86:104843,6378381.271:[104846,104847],6378413.671:104848,6378344.377:104849,6378563.891:104850,6378408.091:104852,6378377.671:104853,6378472.751:104854,6378412.511:104855,6378407.281:104856,6378534.451:104857,6378406.051:104858,6378532.921:104860,6378380.091:104861,6378408.941:104862,6378624.171:104863,6378377.411:104864,6378474.591:104865,6378407.141:104866,6378376.871:104867,6378375.251:104868,6378405.971:104869,6378437.651:104871};class Yt extends hs{constructor(t){if("number"==typeof t)return super(),this.m_factor=t,void(this.m_wkid=0);super(t)}getUnitType(){return 1}convertFromRadians(t){return t/this.getUnitToBaseFactor()}convertToRadians(t){return t*this.getUnitToBaseFactor()}}function se(P){return new Tn}class jt{constructor(t,m,u){void 0===t?(this.x=new Y.F,this.y=new Y.F,this.z=new Y.F):t instanceof dt.h?(this.x=new Y.F(t.x),this.y=new Y.F(t.y),this.z=new Y.F(t.z)):t instanceof Y.F?(this.x=t.clone(),this.y=m.clone(),this.z=u.clone()):(0,F.t)("EPoint3D constructor")}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y)).addE(this.z.mulE(t.z))}crossProduct(t){return new jt(this.y.mulE(t.z).subE(this.z.mulE(t.y)),this.z.mulE(t.x).subE(this.x.mulE(t.z)),this.x.mulE(t.y).subE(this.y.mulE(t.x)))}crossProductVector(t){const m=this.y.mulE(t.z).subE(t.y.mulE(this.z)),u=t.x.mulE(this.z).subE(this.x.mulE(t.z)),g=this.x.mulE(t.y).subE(t.x.mulE(this.y));return new jt(m,u,g)}sqrLength(){return this.x.mulE(this.x).addE(this.y.mulE(this.y)).addE(this.z.mulE(this.z))}length(){return this.sqrLength().sqrt()}static distance(t,m){return t.sub(m).length()}negate(){return new jt(this.x.negate(),this.y.negate(),this.z.negate())}add(t){return new jt(this.x.addE(t.x),this.y.addE(t.y),this.z.addE(t.z))}sub(t){return new jt(this.x.subE(t.x),this.y.subE(t.y),this.z.subE(t.z))}subThis(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this.z.subThisE(t.z),this}addThis(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this.z.addThisE(t.z),this}mul(t){return new jt(this.x.mulE(t),this.y.mulE(t),this.z.mulE(t))}div(t){return new jt(this.x.divE(t),this.y.divE(t),this.z.divE(t))}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)&&this.z.eq(t.z)}isZero(){return this.x.isZero()&&this.y.isZero()&&this.z.isZero()}value(){return dt.h.construct(this.x.value(),this.y.value(),this.z.value())}}class de{constructor(t){if(this.m_origin=new dt.h,this.m_normal=new dt.h,this.m_axisX=new dt.h,this.m_axisY=new dt.h,!t)return this.m_origin=new dt.h,this.m_normal=new dt.h(0,0,1),this.m_axisX=new dt.h(1,0,0),void(this.m_axisY=new dt.h(0,1,0));t.pt0&&t.pt1&&t.pt2?this.setFromPoints(t.pt0,t.pt1,t.pt2):(0,F.g)(0,`unimplemented constructor options ${JSON.stringify(t)}`)}assign(t){return(0,F.g)(0),this}set(t,m,u,g){(0,F.g)(0)}setFromPoints(t,m,u){let g=m.sub(t);const d=u.sub(t);this.m_normal=g.crossProductVector(d);let y=!0;if(this.m_normal.isZero()){if(y=!1,g.isZero()&&(g=d),g.isZero())return this.m_normal.setCoords(0,0,1),this.m_axisX.setCoords(1,0,0),this.m_axisY.setCoords(0,1,0),this.m_origin=t,!1;this.m_axisX=g.getUnitVector(),this.m_normal=this.m_axisX.createAPerpendicular()}else this.m_normal.normalizeThis(),this.m_axisX=g.getUnitVector();return this.m_axisY=this.m_normal.crossProductVector(this.m_axisX),this.m_origin=t,y}getCoord(t,m){return(0,F.g)(0),{}}getCoord2D(t){return(0,F.g)(0),{}}getCoordX(t,m){return(0,F.g)(0),0}getCoordY(t,m){return(0,F.g)(0),0}getCoordZ(t,m){return(0,F.g)(0),0}setPreferredAxisX(t){(0,F.g)(0)}getOrigin(){return(0,F.g)(0),{}}getNormal(){return(0,F.g)(0),{}}getAxisX(){return this.m_axisX.clone()}getAxisY(){return this.m_axisY.clone()}setAxisX(t,m=!1){(0,F.g)(0)}setAxisY(t,m=!1){(0,F.g)(0)}recalculateAxisY(){(0,F.g)(0)}setOrigin(t){(0,F.g)(0)}setNormal(t,m){(0,F.g)(0)}intersect(t,m){return(0,F.g)(0),!1}intersectLine(t){return(0,F.g)(0),0}intersectLineEx(t,m){return(0,F.g)(0),0}closestCoordinate(t){const m=t.sub(this.m_origin),u=new Y.P;return u.x=m.dotProduct(this.m_axisX),u.y=m.dotProduct(this.m_axisY),u}projectVector(t){return(0,F.g)(0),{}}signedDistance(t){return(0,F.g)(0),0}distance(t){return(0,F.g)(0),0}}function me(P,t){return!1}function Vt(P,t,m,u,g=100,d=me){let y,C,S,b,A,T,M,X,k;(0,F.g)(u>0);let H,U,Z,st=0,mt=0;const ht=(0,Y.an)();t>m&&(m=(0,Y.b)(t,t=m));const ut=P(t),ct=P(m);ut<ct?(y=C=S=t,b=A=T=ut):(y=C=S=m,b=A=T=ct);let Et=0;for(;Et<g&&(Z=.5*(m-t),k=t+Z,H=u*(Math.abs(y)+.25),U=2*H,!(d(y,b)||Math.abs(y-k)<=U-Z));++Et){if(Math.abs(mt)>H){const Tt=(y-C)*(b-T);let Pt=(y-S)*(b-A),At=(y-S)*Pt-(y-C)*Tt;Pt=2*(Pt-Tt),Pt>0&&(At=-At),Pt=Math.abs(Pt);const Ht=mt;mt=st,Math.abs(At)>=Math.abs(Pt*Ht*.5)||At<=Pt*(t-y)||At>=Pt*(m-y)?(mt=y>=k?t-y:m-y,st=(0,Y.an)()*mt):(st=At/Pt,X=y+st,(X-t<U||m-X<U)&&(st=k-y<0?-Math.abs(H):Math.abs(H)))}else mt=y>=k?t-y:m-y,st=mt*ht;X=y+st,M=P(X),M<b?(X>=y?t=y:m=y,S=C,C=y,y=X,T=A,A=b,b=M):(X<y?t=X:m=X,M<=A||C===y?(S=C,C=X,T=A,A=M):(M<=T||S===y||S===C)&&(S=X,T=M))}return(0,Y.n)(y,b)}function xe(P,t,m){return P>m?P-=Math.ceil((P-m)/Y.k)*Y.k:P<t&&(P+=Math.ceil((t-P)/Y.k)*Y.k),P}function $t(P,t,m){return function _e(P,t,m,u){const g=m.x,d=m.y;return Pe(P,t,Math.cos(g),Math.sin(g),Math.cos(d),Math.sin(d),u)}(P,t,m,0)}function Pe(P,t,m,u,g,d,y){const C=P/Math.sqrt(1-t*d*d),S=C+y;return dt.h.construct(S*g*m,S*g*u,(C*(1-t)+y)*d)}function ve(P,t,m){const u=new Y.F,g=new Y.F,d=new Y.F,y=new Y.F;u.setCos(m.x),g.setSin(m.x),d.setCos(m.y),y.setSin(m.y);const C=y.negate().mulE(y.mul(t)).add(1).sqrt(),S=new Y.F(P).divE(C),b=S.mulE(d).mulE(u),A=S.mulE(d).mulE(g),T=S.mul(1-t).mulE(y);return new jt(b,A,T)}function Ie(P,t,m){const u=m.x,g=m.y,d=m.z,y=Math.atan2(g,u),C=Math.sqrt(u*u+g*g),S=Math.atan2(d,(1-t)*C);return Y.P.construct(y,S)}function je(P,t,m){const u=1-t,g=P/Math.sqrt((0,Y.s)(m.x)+(0,Y.s)(m.y)+(0,Y.s)(m.z)/u);return m.mul(g)}function Le(P,t,m,u,g){const d=$t(P,t,m),y=$t(P,t,u);return Ie(0,t,dt.h.lerp(d,y,g))}function Be(P,t,m){const u=new dt.h;return u.setCrossProductVector(t,m),Math.abs(Math.atan2(u.length(),t.dotProduct(m)))*P}function Re(P,t,m,u,g){const d=m.getUnitVector(),y=u.getUnitVector(),C=t.getUnitVector(),S=new dt.h;if(S.setCrossProductVector(d,y),!S.isZero()){S.normalizeThis();const T=C.sub(S.mul(S.dotProduct(C)));if(!T.isZero()){T.normalizeThis();const M=d.add(y).mul(.5);if(M.dotProduct(T)>M.dotProduct(d)){const X=Math.abs(S.dotProduct(C)),k=Math.asin(X);return g.assign(T.getUnitVector().mul(P)),k*P}}}const b=Be(1,d,C),A=Be(1,y,C);return b<=A?(g.assign(m),b*P):(g.assign(u),A*P)}function Ss(P,t,m,u,g,d=0,y){if(2===d||3===d)return function Ze(P,t,m,u,g,d=!1,y){const C=je(P,t,m);if(d){const A=new de({pt0:new dt.h(0,0,0),pt1:u,pt2:g}),T=A.closestCoordinate(m),M=A.closestCoordinate(u),X=A.closestCoordinate(g),k=Y.P.getClosestCoordinate(M,X,T),H=je(P,t,dt.h.lerp(u,g,k)),U=dt.h.distance(H,C);return y&&y.assign(H),(0,Y.n)(k,U)}const S=A=>{const T=je(P,t,dt.h.lerp(u,g,A));return dt.h.distance(T,C)},b=dt.h.distance(u,g);if(b>0){const A=qs(P,b),{first:T,second:M}=Vt(S,0,1,A);return y&&y.assign(je(P,t,dt.h.lerp(u,g,T))),(0,Y.n)(T,M)}{const A=dt.h.distance(m,u);return y&&y.assign(m),(0,Y.n)(.5,A)}}(P,t,m,u,g,3===d,y);const C=Ie(0,t,m),S=A=>{const T=Ie(0,t,dt.h.lerp(u,g,A));return function ms(P,t,m,u,g){switch((0,F.g)(m.isFinite()&&u.isFinite()),g){case 0:return function we(P,t,m,u){const g={stack:[],error:void 0,hasError:!1};try{const d=(0,vt.b)(g,new js,!1);return Si.geodeticDistance(P,t,m.x,m.y,u.x,u.y,d,null,null,pe.PE_LINETYPE_GEODESIC),d.val}catch(d){g.error=d,g.hasError=!0}finally{(0,vt.c)(g)}}(P,t,m,u);case 1:return function Qe(P,t,m,u){const g={stack:[],error:void 0,hasError:!1};try{const d=(0,vt.b)(g,new js,!1);return Si.greatEllipticDistance(P,t,m.x,m.y,m.x,m.y,d,null,null),d.val}catch(d){g.error=d,g.hasError=!0}finally{(0,vt.c)(g)}}(P,t,m);case 2:case 3:{const d=$t(P,t,m),y=$t(P,t,u);return dt.h.distance(d,y)}default:(0,F.b)("")}}(P,t,C,T,d)},b=dt.h.distance(u,g);if(b>0){const A=qs(P,b),{first:T,second:M}=Vt(S,0,1,A);return y&&y.assign(je(P,t,dt.h.lerp(u,g,T))),(0,Y.n)(T,M)}{const A=S(0);return y&&y.assign(u),(0,Y.n)(.5,A)}}function os(P,t,m,u,g,d){if(d[0]=Number.NaN,d[1]=Number.NaN,Math.abs(m.x-u.x)>Math.PI||Math.abs(m.y)>Y.l||Math.abs(u.y)>Y.l||(Math.abs(m.y)===Y.l||Math.abs(u.y)===Y.l)&&m.x!==u.x||Math.abs(g)>=Y.l||m.y>0&&u.y>0&&m.y>g&&u.y>g||m.y<0&&u.y<0&&m.y<g&&u.y<g)return 0;const y=c.W.constructPoint2D(m),C=c.W.constructPoint2D(u),S=ve(1,t,y),b=ve(1,t,C),A=S.crossProductVector(b);if(A.z.isZero())return Y.E.construct(m.y,u.y).containsCoordinate(g)?(d[0]=m.x,1):0;const T=A.x.divE(A.z.negate()),M=A.y.divE(A.z.negate()),X=T.mulE(T).addE(M.mulE(M)).sqrt();if(X.isZero()||T.isZero()&&M.isZero())return 0===g?(d[0]=m.x,d[1]=u.x,2):0;const k=(1-t)*Math.tan(g)/X.value();if(Math.abs(k)>1)return 0;const H=Math.acos(k),U=Math.atan2(M.value(),T.value()),Z=U-H;let st=U+H;const mt=Math.min(m.x,u.x),ht=Math.max(m.x,u.x);xe(Z,mt,ht),0!==g?xe(st,mt,ht):st=Z;let ut=0;return mt<=Z&&Z<=ht&&(d[ut]=Z,ut++),st!==Z&&mt<=st&&st<=ht&&(d[ut]=st,ut++),ut}function ye(P,t){t[0]>.5*Math.PI?(P[0]+=Math.PI,t[0]=Math.PI-t[0]):t[0]<.5*-Math.PI&&(P[0]-=Math.PI,t[0]=-Math.PI-t[0]),(0,F.g)(t[0]>=.5*-Math.PI&&t[0]<=.5*Math.PI)}function ks(P,t,m,u,g){u=(0,Y.c)(u,-Y.l,Y.l),g=(0,Y.c)(g,-Y.l,Y.l);const d=Y.l-.03;let y;return y=u>d&&g>d||u<-d&&g<-d?function re(P,t,m){let u=1;if(t<0&&(u=-1,t=-t,m=-m),0!==P){const g=P*P,d=g*P,y=[1,(1+11*P)/12,(1+118*P+241*g)/360,(1+1089*P+10419*g+8651*d)/20160,(1+9836*P+318246*g+1027436*d+d*P*458881)/1814400],C=b=>{let A=0;const T=(0,Y.s)(b)/(P-1);for(let M=y.length-1;M>=0;--M)A=y[M]+A*T;return A*=-(0,Y.s)(b/(1-P)),A},S=C(Y.l-t);return(C(Y.l-m)-S)*u}{const d=Y.l-m,y=-4*(0,Y.s)(Math.sin((Y.l-t)/2));return(-4*(0,Y.s)(Math.sin(d/2))-y)*u}}(P,u,g):qe(P,g)-qe(P,u),.5*(m-t)*y*function Ts(P){return 1-P}(P)}function qe(P,t){if(0===t)return 0;const m=Math.sin(t);let u=m,g=m;if(0!==P){u/=1-P*m*m;const d=Math.sqrt(P);g=m*(0,Y.y)(d*m)}return u+g}function Ps(P,t){return P/Math.sqrt(1-t)}function ds(P,t){return(1-t)*P}function qs(P,t){if(0!==t){const m=P*(0,Y.aF)()/t;return Math.min(m,1e-10)}return 0}class bi{constructor(t){this.m_currentShift=63n,this.m_currentElt=0n,this.m_iCurrentElt=-1,this.m_parent=t,this.m_aiSetElts=t.m_bits.flatMap((m,u)=>u)}next(){if(this.m_currentShift++,64n===this.m_currentShift){if(this.m_iCurrentElt++,this.m_iCurrentElt===this.m_aiSetElts.length)return bi.npos();this.m_currentShift=0n,this.m_currentElt=this.m_parent.m_bits[this.m_aiSetElts[this.m_iCurrentElt]]}for(;this.m_currentShift<63n&&!(this.m_currentElt&1n<<this.m_currentShift);)this.m_currentShift++;return this.m_currentElt&1n<<this.m_currentShift?64*this.m_aiSetElts[this.m_iCurrentElt]+Number(this.m_currentShift):this.next()}static npos(){return Number.MAX_SAFE_INTEGER}}function li(P){return 1n<<(0x3fn&BigInt(P))}function ir(P){return P>>6}class Ls{constructor(t){this.m_bits=[],void 0!==t&&t.copy&&(this.m_bits=t.copy.m_bits.slice())}assignMove(){return this}assignCopy(){return this}hasBit(t){const m=li(t),u=ir(t);return void 0!==this.m_bits[u]&&!!(this.m_bits[u]&m)}setBit(t){const m=li(t),u=ir(t);void 0===this.m_bits[u]&&(this.m_bits[u]=0n),this.m_bits[u]|=m}clearBit(t){}flipBit(t){const m=li(t),u=ir(t);return void 0===this.m_bits[u]&&(this.m_bits[u]=0n),this.m_bits[u]^=m,0n!==(this.m_bits[u]&m)}clear(){this.m_bits.length=0}isZero(){let t=0;return this.m_bits.forEach(m=>{t|=m?2:1}),!(2&t)}equals(t){if(this===t)return!0;if(this.m_bits.length!==t.m_bits.length)return!1;let m=0;return this.m_bits.forEach((u,g)=>{m|=u===t.m_bits[g]?2:1}),!(1&m||(t.m_bits.forEach((u,g)=>{m|=u===this.m_bits[g]?2:1}),1&m))}notEquals(t){return!this.equals(t)}assignOr(t){return t.m_bits.forEach((m,u)=>{void 0===this.m_bits[u]?this.m_bits[u]=m:this.m_bits[u]|=m}),this}assignSubtract(t){return t.m_bits.forEach((m,u)=>{void 0!==this.m_bits[u]&&(this.m_bits[u]&=~m)}),this}assignAnd(t){return t.m_bits.forEach((m,u)=>{void 0!==this.m_bits[u]&&(this.m_bits[u]&=m)}),this}assignXor(t){return t.m_bits.forEach((m,u)=>{void 0===this.m_bits[u]?this.m_bits[u]=m:this.m_bits[u]^=m}),this}getHashCode(){return this.m_bits.reduce((t,m)=>(0,Y.aD)(t,m),(0,Y.ar)(0))}getUnorderedBitIterator(){return new bi(this)}}class To{constructor(t,m){this.m_map=new Map,this.m_hf=t,this.m_ef=m}add(t){const m=this.m_hf(t);if(!this.m_map.has(m))return this.m_map.set(m,t),this;const u=this.m_map.get(m);return u instanceof Array?u.find(g=>this.m_ef(g,t))||u.push(t):this.m_ef(u,t)||this.m_map.set(m,[u,t]),this}clear(){this.m_map.clear()}delete(t){return!1}has(t){const m=this.m_hf(t);if(!this.m_map.has(m))return!1;const u=this.m_map.get(m);return u instanceof Array?void 0!==u.find(g=>this.m_ef(g,t)):this.m_ef(u,t)}get(t){const m=this.m_hf(t),u=this.m_map.get(m);if(void 0!==u)return u instanceof Array?u.find(g=>this.m_ef(g,t)):u}get size(){let t=0;for(const m of this.m_map.values())t+=m instanceof Array?m.length:1;return t}forEach(t,m){}[Symbol.iterator](){return(new Set)[Symbol.iterator]()}entries(){return(new Set).entries()}keys(){return(new Set).keys()}values(){return(new Set).values()}get[Symbol.toStringTag](){return"ValueSet"}}class Us extends dt.a6{constructor(t){super(),this.m_bufferLeft=new c.S,this.m_bufferRight=new c.S,this.m_intervalLeft=Y.E.constructEmpty(),this.m_intervalRight=Y.E.constructEmpty(),this.m_yScanline=Number.NaN,this.m_helper=t}compare(t,m,u){const g=m,d=t.getElement(u);this.m_helper.querySegmentXY(g,this.m_bufferLeft),this.m_helper.querySegmentXY(d,this.m_bufferRight);const y=this.m_bufferLeft.get(),C=this.m_bufferRight.get();if(this.m_intervalLeft.setCoords(y.getStartX(),y.getEndX()),this.m_intervalRight.setCoords(C.getStartX(),C.getEndX()),this.m_intervalLeft.vmax<this.m_intervalRight.vmin)return-1;if(this.m_intervalLeft.vmin>this.m_intervalRight.vmax)return 1;const S=y.getStartY()===y.getEndY(),b=C.getStartY()===C.getEndY();if(S||b){if(S&&b)return 0;if(y.getStartY()===C.getStartY()&&y.getStartX()===C.getStartX())return S?1:-1;if(y.getEndY()===C.getEndY()&&y.getEndX()===C.getEndX())return S?-1:1}let A=y.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalLeft.vmin),T=C.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalRight.vmin);if(A===T){const M=y.getEndY(),X=C.getEndY(),k=Math.min(M,X);let H=.5*(k+this.m_yScanline);H===this.m_yScanline&&(H=k),A=y.intersectionOfYMonotonicWithAxisX(H,this.m_intervalLeft.vmin),T=C.intersectionOfYMonotonicWithAxisX(H,this.m_intervalRight.vmin)}return A<T?-1:A>T?1:0}setY(t){this.m_yScanline=t}}class nr{constructor(t){this.m_segmentBuffer=new c.S,this.m_point=Y.P.getNAN(),this.m_parent=t}setPointXY(t){this.m_point.assign(t)}compare(t,m){const u=t.getElement(m);this.m_parent.querySegmentXY(u,this.m_segmentBuffer);const g=this.m_segmentBuffer.get(),d=new Y.E;if(d.setCoords(g.getStartX(),g.getEndX()),this.m_point.x<d.vmin)return-1;if(this.m_point.x>d.vmax)return 1;const y=g.intersectionOfYMonotonicWithAxisX(this.m_point.y,this.m_point.x);return this.m_point.x<y?-1:this.m_point.x>y?1:0}}var Is,Ii,P;function rr(P,t){return{parentage:P,rank:t}}function Br(P,t){const m=P.length;if(m!==t.length)return!1;const u=P[0].parentage;if(u!==t[0].parentage)return!1;if(-1===u)return!0;for(let g=1;g<m;++g)if(P[g].parentage!==t[g].parentage)return!1;return!0}function or(P,t,m){m.length=0;let u=!1;{let g=P.getHalfEdgeVertexIterator(t);for(;g!==c.n;){const d=P.getVertexFromVertexIterator(g),y=P.getShape().getSegmentRank(d),C=P.getShape().getSegmentParentage(d);u||=C>=0,m.push(rr(C,y)),g=P.incrementVertexIterator(g)}}{let g=P.getHalfEdgeVertexIterator(P.getHalfEdgeTwin(t));for(;g!==c.n;){const d=P.getVertexFromVertexIterator(g),y=P.getShape().getSegmentRank(d),C=P.getShape().getSegmentParentage(d);u||=C>=0,m.push(rr(C,y)),g=P.incrementVertexIterator(g)}}u&&m.sort((g,d)=>g.rank>d.rank?-1:g.rank<d.rank?1:g.parentage<d.parentage?-1:g.parentage>d.parentage?1:0),-1===m[0].parentage&&(m.length=1)}(P=Is||(Is={}))[P.enumInputModeBuildGraph=0]="enumInputModeBuildGraph",P[P.enumInputModeSimplifyAlternate=1]="enumInputModeSimplifyAlternate",P[P.enumInputModeSimplifyWinding=2]="enumInputModeSimplifyWinding",function(P){P[P.enumSegmentParentageBreakNode=1]="enumSegmentParentageBreakNode",P[P.enumPathBreakNode=2]="enumPathBreakNode"}(Ii||(Ii={}));class Qs{constructor(){this.m_shape=null,this.m_clusterData=new dt.S(8),this.m_clusterVertices=new dt.S(2),this.m_firstCluster=c.n,this.m_lastCluster=c.n,this.m_halfEdgeData=new dt.S(8),this.m_chainData=new dt.S(8),this.m_chainAreas=null,this.m_chainPerimeters=null,this.m_universeChain=-1,this.m_simplifiedGeometry=-1,this.m_edgeIndices=[],this.m_clusterIndices=[],this.m_chainIndices=[],this.m_bBuildGeometryParentageSets=!1,this.m_chainBitSetIndex=-1,this.m_edgeBitSetIndex=-1,this.m_edgeBitSetIndexLeft=-1,this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_uniqueBitSets=null,this.m_chainBitSets=[],this.m_edgeBitSets=[],this.m_checkDirtyPlanesweepTolerance=Number.NaN,this.m_geometryIDIndex=-1,this.m_clusterIndex=-1,this.m_halfEdgeIndex=-1,this.m_tmpHalfEdgeParentageIndex=-1,this.m_tmpHalfEdgeParentageIndexLeft=-1,this.m_tmpHalfEdgeWindingNumberIndex=-1,this.m_tmpHalfEdgeOddEvenNumberIndex=-1,this.m_segmentParentageIndex=-1,this.m_segmentIndexHe=-1,this.m_clusterBreakNodeIndex=-1,this.m_universeGeomID=-1,this.m_pointCount=0,this.m_progressCounter=0,this.m_bBuildChains=!0,this.m_bDirtyCheckFailed=!1}setCheckDirtyPlanesweepTolerance(t){this.m_checkDirtyPlanesweepTolerance=t}dirtyCheckFailed(){return this.m_bDirtyCheckFailed}getShape(){return this.m_shape}setEditShape(t,m,u=!0,g=!1){g?this.setEditShapeImpl3D_(t,Is.enumInputModeBuildGraph,null,m,!1):this.setEditShapeImpl_(t,Is.enumInputModeBuildGraph,null,m,u)}setAndSimplifyEditShapeAlternate(t,m,u=null,g=!1){const d=[];d.push(m),this.m_simplifiedGeometry=m,g?this.setEditShapeImpl3D_(t,Is.enumInputModeSimplifyAlternate,d,u,!1):this.setEditShapeImpl_(t,Is.enumInputModeSimplifyAlternate,d,u,t.getGeometryType(m)===F.G.enumPolygon)}setAndSimplifyEditShapeWinding(t,m,u=null){const g=[];g.push(m),this.m_simplifiedGeometry=m,this.setEditShapeImpl_(t,Is.enumInputModeSimplifyWinding,g,u,!0)}removeShape(){null!==this.m_shape&&(-1!==this.m_geometryIDIndex&&(this.m_shape.removeGeometryUserIndex(this.m_geometryIDIndex),this.m_geometryIDIndex=-1),-1!==this.m_clusterIndex&&(this.m_shape.removeUserIndex(this.m_clusterIndex),this.m_clusterIndex=-1),-1!==this.m_halfEdgeIndex&&(this.m_shape.removeUserIndex(this.m_halfEdgeIndex),this.m_halfEdgeIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),-1!==this.m_tmpHalfEdgeWindingNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),-1!==this.m_tmpHalfEdgeOddEvenNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1),-1!==this.m_segmentParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),-1!==this.m_segmentIndexHe&&(this.deleteUserIndexForHalfEdges(this.m_segmentIndexHe),this.m_segmentIndexHe=-1),-1!==this.m_clusterBreakNodeIndex&&(this.deleteUserIndexForClusters(this.m_clusterBreakNodeIndex),this.m_clusterBreakNodeIndex=-1),this.deleteEdgeBitSets_(),this.deleteChainBitSets_(),this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_shape=null,this.m_clusterData.deleteAll(!0),this.m_clusterVertices.deleteAll(!0),this.m_firstCluster=c.n,this.m_lastCluster=c.n,this.m_halfEdgeData.deleteAll(!0),this.m_edgeIndices.length=0,this.m_clusterIndices.length=0,this.m_chainIndices.length=0,this.m_chainData.deleteAll(!0),this.m_universeChain=c.n,this.m_chainAreas=null)}getClusterHalfEdge(t){return this.m_clusterData.getField(t,2)}queryXY(t,m){const u=this.getClusterVertexIndex_(t);m.assign(this.m_shape.getXYWithIndex(u))}queryXYZ(t,m){(0,F.g)(0)}getClusterParentage(t){return this.m_clusterData.getField(t,1)}getFirstCluster(){return this.m_firstCluster}getPrevCluster(t){return this.m_clusterData.getField(t,3)}getNextCluster(t){return this.m_clusterData.getField(t,4)}getClusterChain(t){return this.m_clusterData.getField(t,6)}getClusterVertexIterator(t){return this.m_clusterData.getField(t,7)}incrementVertexIterator(t){return this.m_clusterVertices.getField(t,1)}getVertexFromVertexIterator(t){return this.m_clusterVertices.getField(t,0)}getClusterUserIndex(t,m){const u=this.getClusterIndex_(t),g=this.m_clusterIndices[m];return g.size()<=u?-1:g.read(u)}setClusterUserIndex(t,m,u){const g=this.getClusterIndex_(t),d=this.m_clusterIndices[m];d.size()<=g&&d.resize(this.m_clusterData.size(),-1),d.write(g,u)}hasClusterUserIndexFlags(t,m,u){if(-1===m)return!1;const g=this.getClusterUserIndex(t,m);return-1!==g&&!!(u&g)}setClusterUserIndexFlags(t,m,u){const g=this.getClusterIndex_(t),d=this.m_clusterIndices[m];d.size()<=g&&d.resize(this.m_clusterData.size(),-1);let y=d.read(g);-1===y&&(y=0),d.write(g,u|y)}clearClusterUserIndexFlags(t,m,u){const g=this.getClusterIndex_(t),d=this.m_clusterIndices[m];d.size()<=g&&d.resize(this.m_clusterData.size(),-1);let y=d.read(g);-1===y&&(y=0),d.write(g,~u&y)}createUserIndexForClusters(t=-1){const m=new dt.A(this.m_clusterData.capacity(),t);for(let u=0,g=this.m_clusterIndices.length;u<g;u++)if(null===this.m_clusterIndices[u])return this.m_clusterIndices[u]=m,u;return this.m_clusterIndices.push(m),this.m_clusterIndices.length-1}deleteUserIndexForClusters(t){this.m_clusterIndices[t]=null}getHalfEdgeOrigin(t){return this.m_halfEdgeData.getField(t,1)}getHalfEdgeTo(t){return this.getHalfEdgeOrigin(this.getHalfEdgeTwin(t))}getHalfEdgeTwin(t){return this.m_halfEdgeData.getField(t,4)}getHalfEdgePrev(t){return this.m_halfEdgeData.getField(t,5)}getHalfEdgeNext(t){return this.m_halfEdgeData.getField(t,6)}getHalfEdgeChain(t){return this.m_halfEdgeData.getField(t,2)}getHalfEdgeFaceParentage(t){return this.getChainParentage(this.getHalfEdgeChain(t))}getHalfEdgeVertexIterator(t){return this.m_halfEdgeData.getField(t,7)}getHalfEdgeFromXY(t,m){this.queryXY(this.getHalfEdgeOrigin(t),m)}getHalfEdgeToXY(t,m){this.queryXY(this.getHalfEdgeTo(t),m)}isHalfEdgeCurve(t){return-1!==this.m_segmentIndexHe&&-1!==this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)}getHalfEdgeFromXYZ(t,m){(0,F.g)(0)}getHalfEdgeToXYZ(t,m){(0,F.g)(0)}getHalfEdgeParentage(t){return this.m_halfEdgeData.getField(t,3)&Qs.c_EdgeParentageMask}getHalfEdgeUserIndex(t,m){const u=this.getHalfEdgeIndex_(t),g=this.m_edgeIndices[m];return g.size()<=u?-1:g.read(u)}setHalfEdgeUserIndex(t,m,u){const g=this.getHalfEdgeIndex_(t),d=this.m_edgeIndices[m];d.size()<=g&&d.resize(this.m_halfEdgeData.size(),-1),d.write(g,u)}createUserIndexForHalfEdges(t){void 0===t&&(t=-1);const m=new dt.A(this.m_halfEdgeData.capacity(),t);for(let g=0,d=this.m_edgeIndices.length;g<d;g++)if(null===this.m_edgeIndices[g])return this.m_edgeIndices[g]=m,g;this.m_edgeIndices.push(m);const u=this.m_edgeIndices.length-1;return(0,F.g)(u>=0&&u<=Number.MAX_SAFE_INTEGER),u}deleteUserIndexForHalfEdges(t){this.m_edgeIndices[t]=null}deleteEdgesBreakFaces_(t){for(let m=0,u=t.length;m<u;m++){const g=t[m],d=this.getHalfEdgeChain(g),y=this.getHalfEdgeTwin(g),C=this.getHalfEdgeChain(y);this.setChainHalfEdge_(d,c.n),this.setChainHalfEdge_(C,c.n),this.updateVertexToHalfEdgeConnection_(g,!0),this.deleteEdgeImpl_(g)}}doesHalfEdgeBelongToAPolygonInterior(t,m){return(0,F.g)(0),!1}doesHalfEdgeBelongToAPolygonExterior(t,m){return(0,F.g)(0),!1}doesHalfEdgeBelongToAPolygonBoundary(t,m){return(0,F.g)(0),!1}doesHalfEdgeBelongToAPolylineInterior(t,m){return(0,F.g)(0),!1}doesHalfEdgeBelongToAPolylineExterior(t,m){return(0,F.g)(0),!1}doesClusterBelongToAPolygonInterior(t,m){return(0,F.g)(0),!1}doesClusterBelongToAPolygonExterior(t,m){return(0,F.g)(0),!1}doesClusterBelongToAPolygonBoundary(t,m){return(0,F.g)(0),!1}getFirstChain(){return this.m_universeChain}getChainHalfEdge(t){return this.m_chainData.getField(t,1)}getChainParentage(t){return this.m_chainData.getField(t,2)}getChainParent(t){return this.m_chainData.getField(t,3)}getChainFirstIsland(t){return this.m_chainData.getField(t,4)}getChainNextInParent(t){return this.m_chainData.getField(t,5)}getChainNext(t){return this.m_chainData.getField(t,7)}getChainArea(t){const m=this.getChainIndex_(t);let u=this.m_chainAreas.read(m);return Number.isNaN(u)&&(this.updateChainAreaAndPerimeter_(t),u=this.m_chainAreas.read(m)),u}getChainPerimeter(t){return(0,F.g)(0),0}getChainUserIndex(t,m){const u=this.getChainIndex_(t),g=this.m_chainIndices[m];return g.size()<=u?-1:g.read(u)}setChainUserIndex(t,m,u){const g=this.getChainIndex_(t),d=this.m_chainIndices[m];d.size()<=g&&d.resize(this.m_chainData.size(),-1),d.write(g,u)}createUserIndexForChains(){const t=new dt.A(this.m_chainData.capacity(),-1);for(let m=0,u=this.m_chainIndices.length;m<u;m++)if(null===this.m_chainIndices[m])return this.m_chainIndices[m]=t,m;return this.m_chainIndices.push(t),this.m_chainIndices.length-1}deleteUserIndexForChains(t){this.m_chainIndices[t]=null}extractPolygonFromChainAndIslands(t,m,u,g){const d=m===c.n?t.createGeometry(F.G.enumPolygon):m,y=new c.S;this.extractPolygonPathFromChain_(t,d,u,g,y);for(let C=this.getChainFirstIsland(u);C!==c.n;C=this.getChainNextInParent(C))this.extractPolygonPathFromChain_(t,d,C,g,y);return d}getGeometryID(t){const m=this.m_shape.getGeometryUserIndex(t,this.m_geometryIDIndex);return(0,F.g)(m>=0),1<<Math.min(m,31)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_clusterIndex)}getHalfEdgeFromVertex(t){return this.m_shape.getUserIndex(t,this.m_halfEdgeIndex)}buildGeometryParentageSets(){this.m_bBuildGeometryParentageSets=!0}getChainBitSet(t){if((0,F.g)(this.m_bBuildGeometryParentageSets),-1===this.m_chainBitSetIndex)return this.getEmptySet();const m=this.getChainUserIndex(t,this.m_chainBitSetIndex);(0,F.g)(m>=0);let u=this.m_chainBitSets.at(m);return u||(u=this.getEmptySet()),u}getChainBoundaryBitSet(t){(0,F.g)(this.m_bBuildGeometryParentageSets);const m=new Ls,u=g=>{const d=this.getChainHalfEdge(g);let y=d;do{const C=this.getEdgeBitSet_(y);null!==C&&m.assignOr(C);const S=this.getEdgeBitSet_(this.getHalfEdgeTwin(y));null!==S&&m.assignOr(S),y=this.getHalfEdgeNext(y)}while(y!==d)};u(t);for(let g=this.getChainFirstIsland(t);g!==c.n;g=this.getChainNextInParent(g))u(t);return m}getChainPolygons(t){return(0,F.g)(0),[]}getGeometriesFromBits(t){if(!this.m_bBuildGeometryParentageSets||null===t)return[];if(null===this.m_geometryMapID){this.m_geometryMapID=new Map;for(let g=this.m_shape.getFirstGeometry();g!==c.n;g=this.m_shape.getNextGeometry(g))this.m_geometryMapID.set(this.m_shape.getGeometryUserIndex(g,this.m_geometryIDIndex),g)}const m=[],u=t.getUnorderedBitIterator();for(let g=u.next();g!==bi.npos();g=u.next())(0,F.g)(this.m_geometryMapID.has(g)),m.push(this.m_geometryMapID.get(g));return m}getVertexDominant(t,m){if(m===c.n)return t;const u=this.getClusterFromVertex(t);return this.getVertexDominantFromCluster(u,m)}getVertexDominantFromCluster(t,m){if(m!==c.n){let u=c.n;for(let g=this.getClusterVertexIterator(t);g!==c.n;g=this.incrementVertexIterator(g)){const d=this.getVertexFromVertexIterator(g);u===c.n&&(u=d);const y=this.m_shape.getPathFromVertex(d);if(this.m_shape.getGeometryFromPath(y)===m){u=d;break}}return u}{const u=this.getClusterVertexIterator(t);return u!==c.n?this.getVertexFromVertexIterator(u):c.n}}isBreakNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Ii.enumSegmentParentageBreakNode)}setBreakNode(t,m){(0,F.g)(-1!==this.m_clusterBreakNodeIndex),m?this.setClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Ii.enumSegmentParentageBreakNode):this.clearClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Ii.enumSegmentParentageBreakNode)}isStrongPathNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Ii.enumPathBreakNode)}setStrongPathNode(t,m){if(-1===this.m_clusterBreakNodeIndex){if(!m)return;this.m_clusterBreakNodeIndex=this.createUserIndexForClusters()}m?this.setClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Ii.enumPathBreakNode):this.clearClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Ii.enumPathBreakNode)}getSegmentParentage(t){if(-1===this.m_segmentParentageIndex)return-1;const m=this.getHalfEdgeUserIndex(t,this.m_segmentParentageIndex);return m>=0?m:-1}isCrossroadAhead(t){const m=this.getHalfEdgeNext(t);if(this.isStrongPathNode(this.getHalfEdgeOrigin(m)))return!0;const u=this.getHalfEdgeTwin(m),g=this.getHalfEdgeNext(u);return t!==this.getHalfEdgeTwin(g)}isCrossroadBehind(t){return(0,F.g)(0),!1}getHalfEdgeConnector(t,m){const u=this.getClusterHalfEdge(t);if(u===c.n)return c.n;let g=u,d=c.n,y=c.n;do{if(this.getHalfEdgeTo(g)===m)return g;if(d===c.n){if(d=this.getClusterHalfEdge(m),d===c.n)return c.n;y=d}if(this.getHalfEdgeTo(y)===t)return g=this.getHalfEdgeTwin(y),g;g=this.getHalfEdgeNext(this.getHalfEdgeTwin(g)),y=this.getHalfEdgeNext(this.getHalfEdgeTwin(y))}while(g!==u&&y!==d);return c.n}querySegmentXY(t,m){if(-1!==this.m_segmentIndexHe){let d=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(-1!==d){if(-2!==d){const y=this.m_shape.getSegmentFromIndex(d);m.copyFrom(y,!0)}else{d=this.getHalfEdgeUserIndex(this.getHalfEdgeTwin(t),this.m_segmentIndexHe);const y=this.m_shape.getSegmentFromIndex(d);m.copyFrom(y,!0),m.get().reverse()}return}}m.createLine();const u=m.get(),g=Y.P.getNAN();this.getHalfEdgeFromXY(t,g),u.setStartXY(g),this.getHalfEdgeToXY(t,g),u.setEndXY(g)}isCurveEdge(t){return-1!==this.m_segmentIndexHe&&-1!==this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)}compareEdgeAnglesCurveHelper_(t,m,u){const g=new c.S,d=new c.S;this.querySegmentXY(t,g),this.querySegmentXY(m,d);const y=g.get(),C=d.get();if(y.equals(C))return 0;const S=new Y.P;this.getHalfEdgeFromXY(t,S);const b=new Y.P;this.getHalfEdgeToXY(t,b);const A=new Y.P;this.getHalfEdgeToXY(m,A),(0,F.g)(!b.isEqualPoint2D(A));const T=y.getTangent(0),M=C.getTangent(0);return Y.P.compareVectors(T,M)}compareEdgeAnglesHelper_(t,m,u){if(t===m)return 0;if(this.isHalfEdgeCurve(t)||this.isHalfEdgeCurve(m))return this.compareEdgeAnglesCurveHelper_(t,m,u);const g=Y.P.getNAN();this.getHalfEdgeToXY(t,g);const d=Y.P.getNAN();if(this.getHalfEdgeToXY(m,d),g.isEqualPoint2D(d))return 0;const y=Y.P.getNAN();this.getHalfEdgeFromXY(t,y);const C=Y.P.getNAN();C.setSub(g,y);const S=Y.P.getNAN();return S.setSub(d,y),!u||S.y>=0&&C.y>0?Y.P.compareVectors(C,S):0}compareEdgeAngles_(t,m){return this.compareEdgeAnglesHelper_(t,m,!1)}compareEdgeAnglesForPair_(t,m){return this.compareEdgeAnglesHelper_(t,m,!0)}compareEdgeAngles3D_(t,m){return(0,F.g)(0),0}compareEdgeAnglesForPair3D_(t,m){return(0,F.g)(0),0}dbgDumpChains_(){}dbgDumpChainToPolygon_(t,m){}deleteEdgeInternal_(t){const m=this.getHalfEdgeChain(t),u=this.getHalfEdgeTwin(t),g=this.getHalfEdgeChain(u);(0,F.g)(g===m),(0,F.g)(t===this.getHalfEdgeNext(u)||u===this.getHalfEdgeNext(t));let d=this.getHalfEdgeNext(t);d===u&&(d=this.getHalfEdgeNext(d),d===t&&(d=c.n));const y=this.getChainIndex_(m),C=this.m_chainAreas.read(y);Number.isNaN(C)||(this.setChainArea_(m,Number.NaN),this.setChainPerimeter_(m,Number.NaN));const S=this.getChainHalfEdge(m);S!==t&&S!==u||this.setChainHalfEdge_(m,d),this.updateVertexToHalfEdgeConnection_(t,!0),this.deleteEdgeImpl_(t)}getFirstUnvisitedHalfEdgeOnCluster_(t,m,u){let g=m!==c.n?m:this.getClusterHalfEdge(t);if(g===c.n)return c.n;const d=g;for(;;){if(1!==this.getHalfEdgeUserIndex(g,u))return g;const y=this.getHalfEdgeNext(this.getHalfEdgeTwin(g));if(y===d)return c.n;g=y}}removeSpikes_(){let t=!1;const m=this.createUserIndexForHalfEdges();for(let u=this.getFirstCluster();u!==c.n;u=this.getNextCluster(u)){let g=c.n;for(;;){let d=this.getFirstUnvisitedHalfEdgeOnCluster_(u,g,m);if(d===c.n)break;g=this.getHalfEdgeNext(this.getHalfEdgeTwin(d));let y=d;for(;;){const C=this.getHalfEdgeNext(y),S=this.getHalfEdgePrev(y),b=this.getHalfEdgeTwin(y);if(S===b){if(this.deleteEdgeInternal_(y),t=!0,g!==y&&g!==b||(g=c.n),y===d||S===d){if(d=C,y===d||S===d)break;y=C;continue}}else this.setHalfEdgeUserIndex(y,m,1);if(y=C,y===d)break}}}return this.deleteUserIndexForHalfEdges(m),t}progress_(t,m=!1){}newCluster_(){const t=this.m_clusterData.newElement();return this.m_clusterData.setField(t,1,0),t}newHalfEdgePair_(){const t=this.m_halfEdgeData.newElement();this.m_halfEdgeData.setField(t,2,0),this.m_halfEdgeData.setField(t,3,0);const m=this.m_halfEdgeData.newElement();return this.m_halfEdgeData.setField(m,2,0),this.m_halfEdgeData.setField(m,3,0),this.setHalfEdgeTwin_(t,m),this.setHalfEdgeTwin_(m,t),t}newChain_(){const t=this.m_chainData.newElement();return this.m_chainData.setField(t,2,0),t}deleteChain_(t){return(0,F.g)(0),0}getClusterIndex_(t){return this.m_clusterData.elementToIndex(t)}setClusterVertexIterator_(t,m){this.m_clusterData.setField(t,7,m)}setClusterHalfEdge_(t,m){this.m_clusterData.setField(t,2,m)}setClusterParentage_(t,m){this.m_clusterData.setField(t,1,m)}setPrevCluster_(t,m){this.m_clusterData.setField(t,3,m)}setNextCluster_(t,m){this.m_clusterData.setField(t,4,m)}setClusterVertexIndex_(t,m){this.m_clusterData.setField(t,5,m)}getClusterVertexIndex_(t){return this.m_clusterData.getField(t,5)}setClusterChain_(t,m){this.m_clusterData.setField(t,6,m)}addClusterToExteriorChain_(t,m){this.setClusterChain_(m,t)}getHalfEdgeIndex_(t){return this.m_halfEdgeData.elementToIndex(t)}setHalfEdgeOrigin_(t,m){this.m_halfEdgeData.setField(t,1,m)}setHalfEdgeTwin_(t,m){this.m_halfEdgeData.setField(t,4,m)}setHalfEdgePrev_(t,m){this.m_halfEdgeData.setField(t,5,m)}setHalfEdgeNext_(t,m){this.m_halfEdgeData.setField(t,6,m)}setHalfEdgeChain_(t,m){this.m_halfEdgeData.setField(t,2,m)}setHalfEdgeParentage_(t,m){this.m_halfEdgeData.setField(t,3,m)}getHalfEdgeParentageMask_(t){return this.m_halfEdgeData.getField(t,3)}setHalfEdgeVertexIterator_(t,m){this.m_halfEdgeData.setField(t,7,m)}updateVertexToHalfEdgeConnectionHelper_(t,m){const u=m?c.n:t;for(let g=this.getHalfEdgeVertexIterator(t);g!==c.n;g=this.incrementVertexIterator(g)){const d=this.getVertexFromVertexIterator(g);this.m_shape.setUserIndex(d,this.m_halfEdgeIndex,u)}}updateVertexToHalfEdgeConnection_(t,m){t!==c.n&&(this.updateVertexToHalfEdgeConnectionHelper_(t,m),this.updateVertexToHalfEdgeConnectionHelper_(this.getHalfEdgeTwin(t),m))}getChainIndex_(t){return this.m_chainData.elementToIndex(t)}setChainHalfEdge_(t,m){this.m_chainData.setField(t,1,m)}setChainParentage_(t,m){this.m_chainData.setField(t,2,m)}setChainParent_(t,m){this.m_chainData.setField(t,3,m);const u=this.getChainFirstIsland(m);this.setChainNextInParent_(t,u),this.setChainFirstIsland_(m,t)}setChainFirstIsland_(t,m){this.m_chainData.setField(t,4,m)}setChainNextInParent_(t,m){this.m_chainData.setField(t,5,m)}setChainPrev_(t,m){this.m_chainData.setField(t,6,m)}setChainNext_(t,m){this.m_chainData.setField(t,7,m)}setChainArea_(t,m){const u=this.getChainIndex_(t);this.m_chainAreas.write(u,m)}setChainPerimeter_(t,m){const u=this.getChainIndex_(t);this.m_chainPerimeters.write(u,m)}updateChainAreaAndPerimeter_(t){const m=this.m_shape.hasCurves(),u=new Y.K(0),g=new Y.K(0),d=this.getChainHalfEdge(t),y=Y.P.getNAN(),C=Y.P.getNAN(),S=Y.P.getNAN();this.getHalfEdgeFromXY(d,y),C.setCoordsPoint2D(y);let b=d;do{this.getHalfEdgeToXY(b,S),m&&this.isCurveEdge(b)||g.pe(Y.P.distance(C,S)),this.getHalfEdgeChain(this.getHalfEdgeTwin(b))!==t&&u.pe((S.x-y.x-(C.x-y.x))*(S.y-y.y+(C.y-y.y))*.5),C.setCoordsPoint2D(S),b=this.getHalfEdgeNext(b)}while(b!==d);if(m){const T=new c.S;b=d;do{this.getHalfEdgeToXY(b,S);const M=this.isCurveEdge(b);if(M&&(this.querySegmentXY(b,T),g.pe(T.get().calculateLength2D())),this.getHalfEdgeChain(this.getHalfEdgeTwin(b))!==t&&M){const X=T.get().calculateArea2DHelper();u.pe(X)}b=this.getHalfEdgeNext(b)}while(b!==d)}const A=this.getChainIndex_(t);this.m_chainAreas.write(A,u.getResult()),this.m_chainPerimeters.write(A,g.getResult())}getChainTopmostEdge_(t){return(0,F.g)(0),0}planeSweepParentage_(t,m){const u=new Us(this),g=new dt.T;g.setCapacity(Math.trunc(this.m_pointCount/2)),g.setComparator(u);const d=[],y=this.createUserIndexForHalfEdges();let C=null;const S=Y.P.getNAN();for(let b=this.getFirstCluster();b!==c.n;b=this.getNextCluster(b)){this.progress_(m);const A=this.getClusterHalfEdge(b);if(A!==c.n){if(d.length=0,!this.tryOptimizedInsertion_(g,y,d,b,A)){this.queryXY(b,S),u.setY(S.y);let T=A;do{const M=this.getHalfEdgeUserIndex(T,y);-1!==M&&(g.deleteNode(M),this.setHalfEdgeUserIndex(T,y,dt.S.impossibleIndex2())),T=this.getHalfEdgeNext(this.getHalfEdgeTwin(T))}while(A!==T);T=A;do{if(-1===this.getHalfEdgeUserIndex(T,y)){const M=g.addElement(T);d.push(M)}T=this.getHalfEdgeNext(this.getHalfEdgeTwin(T))}while(A!==T)}for(let T=d.length-1;T>=0;T--){const M=d[T],X=g.getElement(M),k=this.getHalfEdgeTwin(X);this.setHalfEdgeUserIndex(k,y,M),this.planeSweepParentagePropagateParentage_(g,M,t)}}else if(this.getClusterChain(b)===c.n){null===C&&(C=new nr(this)),this.queryXY(b,S),C.setPointXY(S);const T=g.searchLowerBound(C);let M=this.m_universeChain;if(-1!==T){let X=g.getElement(T);this.getHalfEdgeChain(X)===this.getHalfEdgeChain(this.getHalfEdgeTwin(X))&&(X=this.getLeftSkipPolylines_(g,T)),X!==c.n&&(M=this.getHalfEdgeChain(X))}this.addClusterToExteriorChain_(M,b)}}this.deleteUserIndexForHalfEdges(y)}planeSweepParentagePropagateParentage_(t,m,u){const g=t.getElement(m),d=this.getHalfEdgeChain(g);if(this.getChainParent(d)!==c.n)return;const y=this.getLeftSkipPolylines_(t,m),C=this.getHalfEdgeTwin(g),S=this.getHalfEdgeChain(C);let b=this.getChainParent(d),A=this.getChainParent(S);if(y===c.n)b===c.n&&(S===d?(this.setChainParent_(S,this.m_universeChain),A=this.m_universeChain,b=A):(A===c.n&&(this.setChainParent_(S,this.m_universeChain),A=this.m_universeChain),this.setChainParent_(d,S),b=S));else{const T=this.getHalfEdgeChain(y);if(A===c.n){if(this.getChainArea(T)<=0){const M=this.getChainParent(T);this.setChainParent_(S,M),A=M}else this.setChainParent_(S,T),A=T;S===d&&(b=A)}}b===c.n&&(this.trySetChainParentFromTwin_(d,S),b=this.getChainParent(d)),(0,F.g)(b!==c.n),u===Is.enumInputModeBuildGraph?this.propagateParentageBuildGraph_(t,m,g,y):u===Is.enumInputModeSimplifyWinding?this.propagateParentageWinding_(t,m,g,y,C,d,S):u===Is.enumInputModeSimplifyAlternate&&this.propagateParentageAlternate_(t,m,g,y,C,d,S)}propagateParentageBuildGraph_(t,m,u,g){let d,y=m;g===c.n?(y=t.getNext(y),d=this.getHalfEdgeChain(u)):d=this.getHalfEdgeChain(g);let C=null,S=this.getChainParentage(d);for(this.m_bBuildGeometryParentageSets&&(C=this.getChainBitSet(d));-1!==y;y=t.getNext(y)){const b=t.getElement(y),A=this.getHalfEdgeTwin(b);d=this.getHalfEdgeChain(b);const T=this.getHalfEdgeChain(A);if(this.m_bBuildGeometryParentageSets){let U=this.getChainBitSet(T);U=new Ls({copy:U}),U.assignOr(C),this.setChainBitSet_(T,U);let Z=this.getChainBitSet(d);const st=this.getLeftEdgeBitSet_(b),mt=new Ls({copy:C});if(mt.assignSubtract(st),mt.isZero())break;Z=new Ls({copy:Z}),Z.assignOr(mt),this.setChainBitSet_(d,Z),C=Z}const M=this.getChainParentage(T),X=M|S;X!==M&&this.setChainParentage_(T,X);let k=this.getChainParentage(d);const H=S&~this.getHalfEdgeUserIndex(b,this.m_tmpHalfEdgeParentageIndexLeft);if(H&&(k|=H,this.setChainParentage_(d,k)),0===H)break;S=k}}propagateParentageWinding_(t,m,u,g,d,y,C){if(y===C)return;let S=this.getHalfEdgeUserIndex(u,this.m_tmpHalfEdgeWindingNumberIndex);S+=this.getHalfEdgeUserIndex(d,this.m_tmpHalfEdgeWindingNumberIndex);let b=0;const A=[],T=[];T.push(0);for(let M=t.getFirst();M!==m;M=t.getNext(M)){const X=t.getElement(M),k=this.getHalfEdgeTwin(X),H=this.getHalfEdgeChain(X),U=this.getHalfEdgeChain(k);if(H!==U){let Z=this.getHalfEdgeUserIndex(X,this.m_tmpHalfEdgeWindingNumberIndex);Z+=this.getHalfEdgeUserIndex(k,this.m_tmpHalfEdgeWindingNumberIndex),b+=Z;let st=!1;0!==A.length&&A.at(-1)===U&&(T.pop(),A.pop(),st=!0),(0,F.g)(this.getChainParent(U)!==c.n),st&&this.getChainParent(U)===H||(T.push(b),A.push(H))}}if(b+=S,0!==A.length&&A.at(-1)===C&&(T.pop(),A.pop()),0!==b){if(0===T.at(-1)){const X=this.getGeometryID(this.m_simplifiedGeometry);this.setChainParentage_(y,X)}}else if(0!==T.at(-1)){const X=this.getGeometryID(this.m_simplifiedGeometry);this.setChainParentage_(y,X)}}propagateParentageAlternate_(t,m,u,g,d,y,C){const b=this.getGeometryID(this.m_simplifiedGeometry);if(g===c.n)this.setChainParentage_(C,this.m_universeGeomID),1&this.getHalfEdgeUserIndex(u,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(y,b):this.setChainParentage_(y,this.m_universeGeomID);else{const A=this.getChainParentage(C);if(0===A){const T=this.getHalfEdgeChain(g),M=this.getChainParentage(T);this.setChainParentage_(C,M),1&this.getHalfEdgeUserIndex(u,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(y,M===b?this.m_universeGeomID:b):this.setChainParentage_(y,M)}else 1&this.getHalfEdgeUserIndex(u,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(y,A===b?this.m_universeGeomID:b):this.setChainParentage_(y,A)}}tryOptimizedInsertion_(t,m,u,g,d){let y=d,C=-1,S=c.n,b=0;do{if(2===b)return!1;const A=this.getHalfEdgeUserIndex(y,m);if(-1!==A){if(-1!==C)return!1;C=A}else{if(S!==c.n)return!1;S=y}b++,y=this.getHalfEdgeNext(this.getHalfEdgeTwin(y))}while(d!==y);return S!==c.n&&-1!==C&&(this.setHalfEdgeUserIndex(t.getElement(C),m,dt.S.impossibleIndex2()),t.setElement(C,S),u.push(C),!0)}trySetChainParentFromTwin_(t,m){const u=this.getChainArea(t);if(0===u)return!1;const g=this.getChainArea(m);if(u>0&&g<0||u<0&&g>0)return this.setChainParent_(t,m),!0;{const d=this.getChainParent(m);if(d!==c.n)return this.setChainParent_(t,d),!0}return!1}createHalfEdges_(t,m){this.m_halfEdgeIndex=this.m_shape.createUserIndex();for(let u=0,g=m.size();u<g;u++){const d=m.read(u),y=this.m_shape.getUserIndex(d,this.m_clusterIndex),C=this.m_shape.getPathFromVertex(d),S=this.m_shape.getGeometryFromPath(C),b=this.m_shape.getGeometryType(S);if((0,F.h)(b)){const A=this.m_shape.getNextVertex(d);if(A===c.n)continue;const T=this.m_shape.getUserIndex(A,this.m_clusterIndex);if(y===T)continue;const M=this.newHalfEdgePair_(),X=this.getHalfEdgeTwin(M),k=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(k,0,d),this.m_clusterVertices.setField(k,1,-1),this.setHalfEdgeVertexIterator_(M,k),this.m_shape.setUserIndex(d,this.m_halfEdgeIndex,M),this.setHalfEdgeOrigin_(M,y);const H=this.getClusterHalfEdge(y);if(H===c.n)this.setClusterHalfEdge_(y,M),this.setHalfEdgePrev_(M,X),this.setHalfEdgeNext_(X,M);else{const mt=this.getHalfEdgePrev(H);this.setHalfEdgePrev_(H,X),this.setHalfEdgeNext_(X,H),this.setHalfEdgeNext_(mt,M),this.setHalfEdgePrev_(M,mt)}this.setHalfEdgeOrigin_(X,T);const U=this.getClusterHalfEdge(T);if(U===c.n)this.setClusterHalfEdge_(T,X),this.setHalfEdgeNext_(M,X),this.setHalfEdgePrev_(X,M);else{const mt=this.getHalfEdgePrev(U);this.setHalfEdgePrev_(U,M),this.setHalfEdgeNext_(M,U),this.setHalfEdgeNext_(mt,X),this.setHalfEdgePrev_(X,mt)}const Z=this.getGeometryID(S);if(t===Is.enumInputModeBuildGraph){const mt=b===F.G.enumPolygon?Z:0;if(this.setHalfEdgeUserIndex(X,this.m_tmpHalfEdgeParentageIndex,0),this.setHalfEdgeUserIndex(M,this.m_tmpHalfEdgeParentageIndex,mt),this.setHalfEdgeUserIndex(X,this.m_tmpHalfEdgeParentageIndexLeft,mt),this.setHalfEdgeUserIndex(M,this.m_tmpHalfEdgeParentageIndexLeft,0),this.m_bBuildGeometryParentageSets){const ht=new Ls,ut=this.m_shape.getGeometryUserIndex(S,this.m_geometryIDIndex);ht.setBit(ut),this.setEdgeBitSet_(M,ht),this.setEdgeBitSet_(X,null),this.setLeftEdgeBitSet_(X,ht),this.setLeftEdgeBitSet_(M,null)}}else if(t===Is.enumInputModeSimplifyWinding){const mt=this.m_shape.getXY(d),ht=this.m_shape.getXY(A);let ut=0,ct=0;mt.compare(ht)<0?ut=1:ct=-1,this.setHalfEdgeUserIndex(M,this.m_tmpHalfEdgeWindingNumberIndex,ut),this.setHalfEdgeUserIndex(X,this.m_tmpHalfEdgeWindingNumberIndex,ct)}else t===Is.enumInputModeSimplifyAlternate&&(this.setHalfEdgeUserIndex(M,this.m_tmpHalfEdgeOddEvenNumberIndex,1),this.setHalfEdgeUserIndex(X,this.m_tmpHalfEdgeOddEvenNumberIndex,1));const st=b===F.G.enumPolygon?Qs.c_EdgeBitMask:0;this.setHalfEdgeParentage_(M,Z|st),this.setHalfEdgeParentage_(X,Z|st)}}if(this.m_shape.hasCurves()){this.m_segmentIndexHe=this.createUserIndexForHalfEdges();for(let u=0,g=m.size();u<g;u++){const d=m.read(u);if(this.m_shape.getSegment(d)){const y=this.m_shape.getUserIndex(d,this.m_halfEdgeIndex);y!==c.n&&(this.setHalfEdgeUserIndex(y,this.m_segmentIndexHe,this.m_shape.getVertexIndex(d)),this.setHalfEdgeUserIndex(this.getHalfEdgeTwin(y),this.m_segmentIndexHe,-2))}}}}mergeVertexListsOfEdges_(t,m){{const d=this.getHalfEdgeVertexIterator(m);if(d!==c.n){const y=this.getHalfEdgeVertexIterator(t);this.m_clusterVertices.setField(d,1,y),this.setHalfEdgeVertexIterator_(t,d),this.setHalfEdgeVertexIterator_(m,c.n)}}const u=this.getHalfEdgeTwin(t),g=this.getHalfEdgeTwin(m);{const d=this.getHalfEdgeVertexIterator(g);if(d!==c.n){const y=this.getHalfEdgeVertexIterator(u);this.m_clusterVertices.setField(d,1,y),this.setHalfEdgeVertexIterator_(u,d),this.setHalfEdgeVertexIterator_(g,c.n)}}if(-1!==this.m_segmentIndexHe){let d=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(-1!==d){if(-2===d){const y=this.getHalfEdgeUserIndex(m,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(t,this.m_segmentIndexHe,y)}if(d=this.getHalfEdgeUserIndex(u,this.m_segmentIndexHe),-2===d){const y=this.getHalfEdgeUserIndex(g,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(u,this.m_segmentIndexHe,y)}}}}sortHalfEdgesByAngle_(t){const m=[];for(let u=this.getFirstCluster();u!==c.n;u=this.getNextCluster(u)){m.length=0;const g=this.getClusterHalfEdge(u);if(g!==c.n){let d=g;do{m.push(d),d=this.getHalfEdgeNext(this.getHalfEdgeTwin(d))}while(d!==g);if(m.length>1){let y=!0;m.length>2?(m.sort((M,X)=>this.compareEdgeAngles_(M,X)),m.push(m[0])):this.compareEdgeAnglesForPair_(m[0],m[1])>0?m[1]=(0,Y.b)(m[0],m[0]=m[1]):y=!1;let C=m[0],S=C,b=this.getHalfEdgeTo(S),A=this.getHalfEdgeTwin(S),T=c.n;for(let M=1,X=m.length;M<X;M++){const k=m[M],H=this.getHalfEdgeTwin(k),U=this.getHalfEdgeOrigin(H);if(U!==b||k===S)this.updateVertexToHalfEdgeConnection_(T,!1),T=c.n,S=k,b=U,A=H;else{if(t===Is.enumInputModeBuildGraph){const Z=this.getHalfEdgeParentageMask_(S)|this.getHalfEdgeParentageMask_(k);if(this.setHalfEdgeParentage_(S,Z),this.setHalfEdgeParentage_(A,Z),this.setHalfEdgeUserIndex(S,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(S,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(k,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(A,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(A,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(H,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(S,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(S,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(k,this.m_tmpHalfEdgeParentageIndexLeft)),this.setHalfEdgeUserIndex(A,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(A,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(H,this.m_tmpHalfEdgeParentageIndexLeft)),this.m_bBuildGeometryParentageSets){let st,mt,ht;st=this.getEdgeBitSet_(S),mt=this.getEdgeBitSet_(k),ht=new Ls({copy:st}),ht.assignOr(mt),this.setEdgeBitSet_(S,ht),st=this.getEdgeBitSet_(A),mt=this.getEdgeBitSet_(H),ht=new Ls({copy:st}),ht.assignOr(mt),this.setEdgeBitSet_(A,ht),st=this.getLeftEdgeBitSet_(S),mt=this.getLeftEdgeBitSet_(k),ht=new Ls({copy:st}),ht.assignOr(mt),this.setLeftEdgeBitSet_(S,ht),st=this.getLeftEdgeBitSet_(A),mt=this.getLeftEdgeBitSet_(H),ht=new Ls({copy:st}),ht.assignOr(mt),this.setLeftEdgeBitSet_(A,ht)}}else if(-1!==this.m_tmpHalfEdgeWindingNumberIndex){const Z=this.getHalfEdgeUserIndex(S,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(k,this.m_tmpHalfEdgeWindingNumberIndex),st=this.getHalfEdgeUserIndex(A,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(H,this.m_tmpHalfEdgeWindingNumberIndex);this.setHalfEdgeUserIndex(S,this.m_tmpHalfEdgeWindingNumberIndex,Z),this.setHalfEdgeUserIndex(A,this.m_tmpHalfEdgeWindingNumberIndex,st)}else if(-1!==this.m_tmpHalfEdgeOddEvenNumberIndex){const Z=this.getHalfEdgeUserIndex(S,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(k,this.m_tmpHalfEdgeOddEvenNumberIndex),st=this.getHalfEdgeUserIndex(A,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(H,this.m_tmpHalfEdgeOddEvenNumberIndex);this.setHalfEdgeUserIndex(S,this.m_tmpHalfEdgeOddEvenNumberIndex,Z),this.setHalfEdgeUserIndex(A,this.m_tmpHalfEdgeOddEvenNumberIndex,st)}this.mergeVertexListsOfEdges_(S,k),this.deleteEdgeImpl_(k),T=S,m[M]=c.n,k===C&&(m[0]=c.n,C=c.n)}}if(this.updateVertexToHalfEdgeConnection_(T,!1),T=c.n,!y){C=c.n;for(let M=0,X=m.length;M<X;M++){const k=m[M];if(k!==c.n){C=k;break}}g!==C&&this.setClusterHalfEdge_(u,C);continue}C=c.n;for(let M=0,X=m.length;M<X;M++){const k=m[M];if(k===c.n)continue;if(C===c.n){C=k,S=C,b=this.getHalfEdgeTo(S),A=this.getHalfEdgeTwin(S);continue}if(k===S)continue;const H=this.getHalfEdgeTwin(k),U=this.getHalfEdgeOrigin(H);this.setHalfEdgeNext_(A,k),this.setHalfEdgePrev_(k,A),S=k,b=U,A=H}this.setClusterHalfEdge_(u,C)}}}}sortHalfEdgesByAngle3D_(t){(0,F.g)(0)}buildChains_(t){this.m_universeChain=this.newChain_(),this.setChainHalfEdge_(this.m_universeChain,c.n);let m=this.m_universeChain;const u=this.createUserIndexForHalfEdges();for(let g=this.getFirstCluster();g!==c.n;g=this.getNextCluster(g)){const d=this.getClusterHalfEdge(g);if(d!==c.n){let y=d;do{if(1!==this.getHalfEdgeUserIndex(y,u)){const C=this.newChain_();this.setChainHalfEdge_(C,y),this.setChainPrev_(C,m),this.setChainNext_(m,C);let S=null;this.m_bBuildGeometryParentageSets&&(S=new Ls),m=C;let b=0,A=y;do{-1!==this.m_tmpHalfEdgeParentageIndex&&(b|=this.getHalfEdgeUserIndex(A,this.m_tmpHalfEdgeParentageIndex)),this.m_bBuildGeometryParentageSets&&S.assignOr(this.getEdgeBitSet_(A)),this.setHalfEdgeChain_(A,C),this.setHalfEdgeUserIndex(A,u,1),A=this.getHalfEdgeNext(A)}while(A!==y);this.m_bBuildGeometryParentageSets&&this.setChainBitSet_(C,S),this.setChainParentage_(C,b)}y=this.getHalfEdgeNext(this.getHalfEdgeTwin(y))}while(y!==d)}}this.m_chainAreas=new dt.y(this.m_chainData.size(),Number.NaN),this.m_chainPerimeters=new dt.y(this.m_chainData.size(),Number.NaN),this.setChainArea_(this.m_universeChain,Number.POSITIVE_INFINITY),this.setChainPerimeter_(this.m_universeChain,Number.POSITIVE_INFINITY),this.deleteUserIndexForHalfEdges(u)}simplify_(t){(0,F.g)(0)}simplifyAlternate_(){(0,F.g)(0)}simplifyWinding_(){(0,F.g)(0)}setEditShapeImpl_(t,m,u,g,d){this.removeShape(),this.m_bBuildChains=d,this.m_shape=t,this.m_geometryIDIndex=this.m_shape.createGeometryUserIndex();let y=this.m_shape.getTotalPointCount();if(u){y=0;for(let X=0,k=u.length;X<k;X++)y+=this.m_shape.getPointCount(u[X])}const C=new dt.A(0);let S=0,b=0;{let X=null!=u?u[0]:this.m_shape.getFirstGeometry(),k=1;for(;X!==c.n;){this.m_shape.setGeometryUserIndex(X,this.m_geometryIDIndex,b++);for(let H=this.m_shape.getFirstPath(X);H!==c.n;H=this.m_shape.getNextPath(H)){let U=this.m_shape.getFirstVertex(H);for(let Z=0,st=this.m_shape.getPathSize(H);Z<st;Z++)C.add(U),U=this.m_shape.getNextVertex(U)}(0,F.e)(this.m_shape.getGeometryType(X))||(S+=this.m_shape.getPathCount(X)),null!=u?(X=k<u.length?u[k]:c.n,k++):X=this.m_shape.getNextGeometry(X)}}this.m_universeGeomID=1<<Math.min(b,31),this.m_pointCount=C.size(),this.m_shape.sortVerticesSimpleByY(C,0,this.m_pointCount),this.m_clusterVertices.setCapacity(this.m_pointCount),this.progress_(g,!0),this.m_clusterData.setCapacity(this.m_pointCount+10),this.m_halfEdgeData.setCapacity(2*this.m_pointCount+32),this.m_chainData.setCapacity(Math.max(32,S)),this.m_clusterIndex=this.m_shape.createUserIndex();const A=Y.P.getNAN();let T=0;const M=Y.P.getNAN();for(let X=0;X<=this.m_pointCount;X++){if(X<this.m_pointCount){const k=C.read(X);this.m_shape.queryXY(k,M)}else M.setNAN();if(!A.isEqualPoint2D(M)){if(T<X){const k=this.newCluster_();let H=c.n,U=-1;for(let Z=T;Z<X;Z++){U=C.read(Z),this.m_shape.setUserIndex(U,this.m_clusterIndex,k);const st=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(st,0,U),this.m_clusterVertices.setField(st,1,H),H=st;const mt=this.m_shape.getPathFromVertex(U),ht=this.m_shape.getGeometryFromPath(mt),ut=this.getGeometryID(ht);this.setClusterParentage_(k,this.getClusterParentage(k)|ut)}this.setClusterVertexIterator_(k,H),this.setClusterVertexIndex_(k,this.m_shape.getVertexIndex(U)),this.m_lastCluster!==c.n&&this.setNextCluster_(this.m_lastCluster,k),this.setPrevCluster_(k,this.m_lastCluster),this.m_lastCluster=k,this.m_firstCluster===c.n&&(this.m_firstCluster=k)}T=X,A.setCoordsPoint2D(M)}}if(this.m_shape.hasSegmentParentage()){-1===this.m_clusterBreakNodeIndex&&(this.m_clusterBreakNodeIndex=this.createUserIndexForClusters());for(let X=0;X<this.m_pointCount;X++){const k=C.read(X);if(this.m_shape.getSegmentParentageBreakVertex(k)){const H=this.getClusterFromVertex(k);this.setBreakNode(H,!0)}}}this.progress_(g,!0);{let X=null!=u?u[0]:this.m_shape.getFirstGeometry(),k=1;for(;X!==c.n;){for(let H=this.m_shape.getFirstPath(X);H!==c.n;H=this.m_shape.getNextPath(H)){if(this.m_shape.isStrongPathStart(H)){const U=this.m_shape.getFirstVertex(H),Z=this.getClusterFromVertex(U);this.setStrongPathNode(Z,!0)}if(this.m_shape.isStrongPathEnd(H)){const U=this.m_shape.isClosedPath(H)?this.m_shape.getFirstVertex(H):this.m_shape.getLastVertex(H),Z=this.getClusterFromVertex(U);this.setStrongPathNode(Z,!0)}}null!=u?(X=k<u.length?u[k]:c.n,k++):X=this.m_shape.getNextGeometry(X)}}if(m===Is.enumInputModeBuildGraph&&(this.m_tmpHalfEdgeParentageIndex=this.createUserIndexForHalfEdges(),this.m_tmpHalfEdgeParentageIndexLeft=this.createUserIndexForHalfEdges()),m===Is.enumInputModeSimplifyWinding&&(this.m_tmpHalfEdgeWindingNumberIndex=this.createUserIndexForHalfEdges()),m===Is.enumInputModeSimplifyAlternate&&(this.m_tmpHalfEdgeOddEvenNumberIndex=this.createUserIndexForHalfEdges()),this.createHalfEdges_(m,C),this.dbgNavigate_(),this.sortHalfEdgesByAngle_(m),!Number.isNaN(this.m_checkDirtyPlanesweepTolerance)&&!this.checkStructureAfterDirtySweep_())return this.m_bDirtyCheckFailed=!0,void this.cleanSetEditShapeImpl_();this.buildChains_(m),-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),this.m_bBuildChains&&this.planeSweepParentage_(m,g),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),this.dbgChkChainParents_(),this.dbgDumpChains_(),this.mergeSegmentParentage_(),this.dbgNavigate_(),this.dbgDumpChains_(),this.cleanSetEditShapeImpl_()}setEditShapeImpl3D_(t,m,u,g,d){(0,F.g)(0)}cleanSetEditShapeImpl_(){-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),-1!==this.m_tmpHalfEdgeWindingNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),-1!==this.m_tmpHalfEdgeOddEvenNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1)}cleanSetEditShapeImpl3D_(){(0,F.g)(0)}dbgNavigate_(){}dbgChkChainParents_(){}deleteEdgeImpl_(t){const m=this.getHalfEdgeNext(t),u=this.getHalfEdgePrev(t),g=this.getHalfEdgeTwin(t),d=this.getHalfEdgeNext(g),y=this.getHalfEdgePrev(g);m!==g&&(this.setHalfEdgeNext_(y,m),this.setHalfEdgePrev_(m,y)),u!==g&&(this.setHalfEdgeNext_(u,d),this.setHalfEdgePrev_(d,u));const C=this.getHalfEdgeOrigin(t);this.getClusterHalfEdge(C)===t&&this.setClusterHalfEdge_(C,d!==t?d:c.n);const S=this.getHalfEdgeOrigin(g);this.getClusterHalfEdge(S)===g&&this.setClusterHalfEdge_(S,m!==g?m:c.n),this.m_halfEdgeData.deleteElement(t),this.m_halfEdgeData.deleteElement(g)}getLeftSkipPolylines_(t,m){let u=m;for(;;){if(u=t.getPrev(u),-1===u)return c.n;{const g=t.getElement(u);if(this.getHalfEdgeChain(g)!==this.getHalfEdgeChain(this.getHalfEdgeTwin(g)))return g}}}checkStructureAfterDirtySweep_(){const t=(0,Y.s)(this.m_checkDirtyPlanesweepTolerance),m=new Y.P,u=new Y.P,g=new Y.P,d=new Y.P,y=new Y.P;for(let C=this.getFirstCluster();C!==c.n;C=this.getNextCluster(C)){const S=this.getClusterHalfEdge(C);if(S!==c.n){let b=S;this.getHalfEdgeFromXY(b,m),this.getHalfEdgeToXY(b,u),g.setSub(u,m);let A=g.sqrLength();do{const T=b;if(b=this.getHalfEdgeNext(this.getHalfEdgeTwin(b)),b!==T){this.getHalfEdgeToXY(b,d),y.setSub(d,m);const M=y.sqrLength(),X=y.crossProduct(g),k=X*X/(M*A);if(Math.min(M,A)*k<=t&&y.dotProduct(g)>=0)return!1;g.assign(y),A=M,u.assign(d)}}while(b!==S)}}return!0}extractPolygonPathFromChain_(t,m,u,g,d){const y=this.m_shape.hasSegmentParentage(),C=this.getChainHalfEdge(u);let S=C,b=c.n;const A=new dt.P;do{const T=this.getHalfEdgeTwin(S);if(this.getHalfEdgeChain(T)!==u){let M=c.n;const X=this.getHalfEdgeOrigin(S);if(g===c.n){const H=this.getClusterVertexIterator(X);M=this.getVertexFromVertexIterator(H)}else for(let H=this.getClusterVertexIterator(X);H!==c.n;H=this.incrementVertexIterator(H)){const U=this.getVertexFromVertexIterator(H);M===c.n&&(M=U);const Z=this.m_shape.getPathFromVertex(U);if(this.m_shape.getGeometryFromPath(Z)===g){M=U;break}}let k;if(b===c.n&&(b=t.insertPath(m,c.n),t.setClosedPath(b,!0)),this.m_shape===t?k=t.addVertex(b,M):(this.m_shape.queryPoint(M,A),k=t.addPoint(b,A)),this.isHalfEdgeCurve(S)&&(this.querySegmentXY(S,d),t.setSegmentToIndex(t.getVertexIndex(k),d.get().clone())),y){const H=this.getSegmentParentage(S);t.setSegmentParentageAndBreak(k,H,this.isBreakNode(X))}}S=this.getHalfEdgeNext(S)}while(S!==C)}mergeSegmentParentage_(){if(!this.m_shape.hasSegmentParentage())return;(0,F.g)(-1!==this.m_clusterBreakNodeIndex),(0,F.g)(-1===this.m_segmentParentageIndex);for(let g=this.getFirstCluster();g!==c.n;g=this.getNextCluster(g)){let d=0;const y=this.getClusterHalfEdge(g);if(y!==c.n){let C=y;do{d++,C=this.getHalfEdgeNext(this.getHalfEdgeTwin(C))}while(C!==y&&d<3)}2!==d&&this.setBreakNode(g,!0)}let t=[],m=[];this.m_segmentParentageIndex=this.createUserIndexForHalfEdges();const u=this.createUserIndexForHalfEdges();for(let g=this.getFirstCluster();g!==c.n;g=this.getNextCluster(g)){const d=this.getClusterHalfEdge(g);if(d!==c.n){let y=!1,C=d;do{let S=C;for(;-1===this.getHalfEdgeUserIndex(S,u);){const b=this.getHalfEdgeNext(S),A=this.getHalfEdgeTwin(S);or(this,S,m);const T=m.at(-1).parentage;if(!y){const X=this.getHalfEdgeOrigin(S);if(!this.isBreakNode(X)){const k=this.getHalfEdgePrev(S);S!==k&&(or(this,k,t),y=!0)}}if(y&&!Br(m,t)){const X=this.getHalfEdgeOrigin(S);this.setBreakNode(X,!0)}t=(0,Y.b)(m,m=t),y=!0;const M=this.getHalfEdgeOrigin(b);this.isBreakNode(M)&&(y=!1),this.setHalfEdgeUserIndex(S,this.m_segmentParentageIndex,T),this.setHalfEdgeUserIndex(A,this.m_segmentParentageIndex,T),this.setHalfEdgeUserIndex(S,u,1),this.setHalfEdgeUserIndex(A,u,1),S=b}C=this.getHalfEdgeNext(this.getHalfEdgeTwin(C))}while(C!==d)}}this.deleteUserIndexForHalfEdges(u)}registerNewBitSet(t){return null===this.m_uniqueBitSets&&(this.m_uniqueBitSets=function Hr(){return new To(P=>P.getHashCode(),(P,t)=>P.equals(t))}(),this.m_uniqueBitSets.add(this.getEmptySet())),null===t?this.getEmptySet():this.m_uniqueBitSets.has(t)?this.m_uniqueBitSets.get(t):(this.m_uniqueBitSets.add(t),t)}getLeftEdgeBitSet_(t){const m=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft);return(0,F.g)(m>=0),(0,F.g)(this.m_edgeBitSets.at(m)),this.m_edgeBitSets.at(m)}getEdgeBitSet_(t){const m=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndex);return(0,F.g)(m>=0),this.m_edgeBitSets.at(m)}setEdgeBitSet_(t,m){(0,F.g)(this.m_bBuildGeometryParentageSets),m=this.registerNewBitSet(m),-1===this.m_edgeBitSetIndex&&(this.m_edgeBitSetIndex=this.createUserIndexForHalfEdges());const u=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndex);-1!==u?this.m_edgeBitSets[u]=m:(this.setHalfEdgeUserIndex(t,this.m_edgeBitSetIndex,this.m_edgeBitSets.length),this.m_edgeBitSets.push(m))}setLeftEdgeBitSet_(t,m){(0,F.g)(this.m_bBuildGeometryParentageSets),m=this.registerNewBitSet(m),-1===this.m_edgeBitSetIndexLeft&&(this.m_edgeBitSetIndexLeft=this.createUserIndexForHalfEdges());const u=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft);-1!==u?this.m_edgeBitSets[u]=m:(this.setHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft,this.m_edgeBitSets.length),this.m_edgeBitSets.push(m))}setChainBitSet_(t,m){(0,F.g)(this.m_bBuildGeometryParentageSets),m=this.registerNewBitSet(m),-1===this.m_chainBitSetIndex&&(this.m_chainBitSetIndex=this.createUserIndexForChains());const u=this.getChainUserIndex(t,this.m_chainBitSetIndex);-1!==u?this.m_chainBitSets[u]=m:(this.setChainUserIndex(t,this.m_chainBitSetIndex,this.m_chainBitSets.length),this.m_chainBitSets.push(m))}getEmptySet(){return this.m_emptyBitSet||(this.m_emptyBitSet=new Ls),this.m_emptyBitSet}deleteEdgeBitSets_(){-1!==this.m_edgeBitSetIndex&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndex),this.m_edgeBitSetIndex=-1),-1!==this.m_edgeBitSetIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndexLeft),this.m_edgeBitSetIndexLeft=-1),this.m_edgeBitSets.length=0,this.m_uniqueBitSets=null}deleteChainBitSets_(){-1!==this.m_chainBitSetIndex&&(this.deleteUserIndexForChains(this.m_chainBitSetIndex),this.m_chainBitSetIndex=-1,this.m_chainBitSets.length=0)}dbgPrintEdge_(t){}dbgVerifyEdgeSegment(t){}}Qs.c_EdgeParentageMask=~(1<<31),Qs.c_EdgeBitMask=1<<31;class Oe{freeNode_(t){this.m_listNodes.deleteElement(t)}newNode_(){return this.m_listNodes.newElement()}freeList_(t){this.m_lists.deleteElement(t)}newList_(){return this.m_lists.newElement()}Init_(t){(0,F.g)(0)}constructor(t){this.m_listNodes=new dt.S(2),this.m_listOfLists=Oe.st_nullNode(),this.m_bAllowNavigationBetweenLists=!0,void 0===t&&(t=!0),this.m_bAllowNavigationBetweenLists=t,this.m_lists=new dt.S(this.m_bAllowNavigationBetweenLists?4:2)}createList(){const t=this.newList_();return this.m_bAllowNavigationBetweenLists&&(this.m_lists.setField(t,3,this.m_listOfLists),this.m_listOfLists!==Oe.st_nullNode()&&this.m_lists.setField(this.m_listOfLists,2,t),this.m_listOfLists=t),t}deleteList(t){let m=this.getFirst(t);for(;m!==Oe.st_nullNode();){const u=m;m=this.getNext(m),this.freeNode_(u)}if(this.m_bAllowNavigationBetweenLists){const u=this.m_lists.getField(t,2),g=this.m_lists.getField(t,3);u!==Oe.st_nullNode()?this.m_lists.setField(u,3,g):this.m_listOfLists=g,g!==Oe.st_nullNode()&&this.m_lists.setField(g,2,u)}this.freeList_(t)}reserveLists(t){this.m_lists.setCapacity(t)}addElement(t,m){this.m_lists.getField(t,0);const u=this.m_lists.getField(t,1),g=this.newNode_();return u!==Oe.st_nullNode()?(this.m_listNodes.setField(u,1,g),this.m_lists.setField(t,1,g)):(this.m_lists.setField(t,0,g),this.m_lists.setField(t,1,g)),this.m_listNodes.setField(g,0,m),g}reserveNodes(t){this.m_listNodes.setCapacity(t)}deleteElementDirect(t,m,u){m!==Oe.st_nullNode()?(this.m_listNodes.setField(m,1,this.m_listNodes.getField(u,1)),this.m_lists.getField(t,1)===u&&this.m_lists.setField(t,1,m)):(this.m_lists.setField(t,0,this.m_listNodes.getField(u,1)),this.m_lists.getField(t,1)===u&&this.m_lists.setField(t,1,Oe.st_nullNode())),this.freeNode_(u)}deleteElementSearch(t,m){let u=-1,g=this.getFirst(t);for(;g!==m;)u=g,g=this.getNext(g);this.deleteElementDirect(t,u,m)}concatenateLists(t,m){const u=this.m_lists.getField(t,1),g=this.m_lists.getField(m,0);if(g!==Oe.st_nullNode()&&(u!==Oe.st_nullNode()?(this.m_listNodes.setField(u,1,g),this.m_lists.setField(t,1,this.m_lists.getField(m,1))):(this.m_lists.setField(t,0,g),this.m_lists.setField(t,1,this.m_lists.getField(m,1)))),this.m_bAllowNavigationBetweenLists){const d=this.m_lists.getField(m,2),y=this.m_lists.getField(m,3);d!==Oe.st_nullNode()?this.m_lists.setField(d,3,y):this.m_listOfLists=y,y!==Oe.st_nullNode()&&this.m_lists.setField(y,2,d)}return this.freeList_(m),t}getElement(t){return this.m_listNodes.getField(t,0)}getData(t){return this.getElement(t)}setElement(t,m){(0,F.g)(0)}getNext(t){return this.m_listNodes.getField(t,1)}getFirst(t){return this.m_lists.getField(t,0)}getFirstElement(t){const m=this.getFirst(t);return this.getElement(m)}static st_nullNode(){return-1}clear(){this.m_listNodes.deleteAll(!0),this.m_lists.deleteAll(!0),this.m_listOfLists=Oe.st_nullNode()}isEmpty(t){return(0,F.g)(0),!1}getNodeCount(){return this.m_listNodes.size()}getListCount(){return this.m_lists.size()}getFirstList(){return this.m_listOfLists}getNextList(t){return this.m_lists.getField(t,3)}}function Oi(P=-1){return{m_value:P,m_line:new c.L,m_segment:null,m_segmentInfo:new c.a8(-1),m_env:new Y.E(0,0),m_dxdy:55555555,m_bHorizontal:!1,m_bCurve:!1}}class zr extends dt.a6{constructor(t,m,u){super(!0),this.m_bIntersectionDetected=!1,this.m_nonSimpleResult=new Ee,this.m_tempSimpleEdge1=Oi(),this.m_tempSimpleEdge2=Oi(),this.m_prev1=c.n,this.m_prev2=c.n,this.m_vertex1=c.n,this.m_vertex2=c.n,this.m_currentNode=-1,this.m_prevX1=Number.NaN,this.m_prevX2=Number.NaN,this.m_prevY=Number.NaN,this.m_prevX=0,this.m_sweepY=Number.NaN,this.m_sweepX=0,this.m_ptSweep=new Y.P,this.m_simpleEdgesCache=[],this.m_simpleEdgesRecycle=[],this.m_cOutstandingConstructedEdges=0,this.m_shape=t,this.m_bShapeHasSegments=this.m_shape.hasCurves(),this.m_tolerance=m,this.m_tolerance10=10*m,this.m_bIsSimple=u;const g=Math.trunc(Math.min(3*t.getTotalPointCount()/2,67)),d=Math.min(7,g);this.m_simpleEdgesCache.length=d}tryGetCachedEdge_(t){const m=this.m_simpleEdgesCache[(t&(0,Y.j)())%this.m_simpleEdgesCache.length];return m&&m.m_value===t?m:null}tryDeleteCachedEdge_(t){const m=(t&(0,Y.j)())%this.m_simpleEdgesCache.length,u=this.m_simpleEdgesCache[m];u&&u.m_value===t&&(this.m_simpleEdgesRecycle.push(u),this.m_simpleEdgesCache[m]=null)}tryCreateCachedEdge_(t){const m=(t&(0,Y.j)())%this.m_simpleEdgesCache.length;let u=this.m_simpleEdgesCache[m];return u?null:(0===this.m_simpleEdgesRecycle.length?(u=Oi(),this.m_cOutstandingConstructedEdges++):u=this.m_simpleEdgesRecycle.pop(),u.m_value=t,this.m_simpleEdgesCache[m]=u,u)}initSimpleEdge_(t,m){this.m_bShapeHasSegments&&this.initSimpleEdgeHelper_(t,m)||t.m_bCurve||(this.m_shape.queryLineConnector(m,t.m_line,!0),t.m_segment=t.m_line,t.m_env.setCoordsNoNAN(t.m_line.getStartX(),t.m_line.getEndX()),t.m_env.vmax+=this.m_tolerance,t.m_line.orientBottomUp(),t.m_bHorizontal=t.m_line.getEndY()===t.m_line.getStartY(),t.m_bHorizontal||(t.m_dxdy=(t.m_line.getEndX()-t.m_line.getStartX())/(t.m_line.getEndY()-t.m_line.getStartY())))}initSimpleEdgeHelper_(t,m){if(t.m_segment=this.m_shape.getSegment(m),t.m_segmentInfo=this.m_shape.getOriginalSegmentInfo(m),t.m_bCurve=null!==t.m_segment,t.m_bCurve){const u=t.m_segment.clone();return u.orientBottomUp(),t.m_segment=u,t.m_env=t.m_segment.queryInterval(0,0),t.m_env.vmax+=this.m_tolerance,!0}return!1}compareTwoSegments_(t,m){const u=t.getStartXY(),g=t.getEndXY(),d=m.getStartXY(),y=m.getEndXY();if(this.m_ptSweep.setCoords(this.m_sweepX,this.m_sweepY),u.isEqualPoint2D(d)&&this.m_sweepY===u.y){this.m_ptSweep.assign(g.compare(y)<0?g:y);const T=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),M=m.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x);if(Math.abs(T-M)>this.m_tolerance)return T<M?-1:1}const C=u.compare(d)<0?d:u,S=g.compare(y)<0?g:y;let b=0,A=0;for(let T=1;T<5;T++){(0,Y.Z)(C,S,T/5,this.m_ptSweep);const M=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),X=m.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),k=Math.abs(M-X);k>b&&(b=k,A=M<X?-1:1)}return 0===A?this.errorCracking():A}compareNonHorizontal_(t,m){if(t.m_line.getStartY()===m.m_line.getStartY()&&t.m_line.getStartX()===m.m_line.getStartX())return t.m_line.getEndY()===m.m_line.getEndY()&&t.m_line.getEndX()===m.m_line.getEndX()?this.m_bIsSimple?this.errorCoincident():0:this.compareNonHorizontalUpperEnd_(t,m);if(t.m_line.getEndY()===m.m_line.getEndY()&&t.m_line.getEndX()===m.m_line.getEndX())return this.compareNonHorizontalLowerEnd_(t,m);const u=this.compareNonHorizontalLowerEnd_(t,m),g=this.compareNonHorizontalUpperEnd_(t,m);return u<0&&g<0?-1:u>0&&g>0?1:this.errorCracking()}compareHorizontal1Case1_(t,m){if(t.getEndX()>m.getEndX()){if(m.getEndX()>m.getStartX()&&m.getEndY()-m.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(m.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else if((m.getEndY()-m.getStartY())/(m.getEndX()-m.getStartX())*(t.getEndX()-t.getStartX())<this.m_tolerance10&&m.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking();return 1}compareHorizontal1Case2_(t,m){if(t.getStartX()<m.getStartX()){if(m.getEndX()>m.getStartX()&&m.getEndY()-m.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(m.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else if((m.getEndY()-m.getStartY())/(m.getEndX()-m.getStartX())*(t.getStartX()-t.getEndX())<this.m_tolerance10&&m.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking();return-1}compareHorizontal1Case3_(t,m){const u=Y.P.getNAN();u.setSub(m.getEndXY(),m.getStartXY()),u.rightPerpendicularThis(),u.normalize();const g=Y.P.getNAN();g.setSub(t.getStartXY(),m.getStartXY());const d=Y.P.getNAN();d.setSub(t.getEndXY(),m.getStartXY());const y=g.dotProduct(u),C=d.dotProduct(u),S=Math.abs(y),b=Math.abs(C);if(S<b){if(S<this.m_tolerance10&&m.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking()}else if(b<this.m_tolerance10&&m.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking();return y<0&&C<0?-1:y>0&&C>0?1:this.errorCracking()}compareHorizontal1_(t,m){return t.getStartY()===m.getStartY()&&t.getStartX()===m.getStartX()?this.compareHorizontal1Case1_(t,m):t.getEndY()===m.getEndY()&&t.getEndX()===m.getEndX()?this.compareHorizontal1Case2_(t,m):this.compareHorizontal1Case3_(t,m)}compareHorizontal2_(t,m){return t.getEndY()===m.getEndY()&&t.getEndX()===m.getEndX()&&t.getStartY()===m.getStartY()&&t.getStartX()===m.getStartX()?this.m_bIsSimple?this.errorCoincident():0:this.errorCracking()}compareNonHorizontalLowerEnd_(t,m){let u=1;if(t.m_line.getStartY()<m.m_line.getStartY()){u=-1;const b=t;t=m,m=b}const g=t.m_line,d=m.m_line,y=g.getStartX()-d.getStartX(),C=m.m_dxdy*(g.getStartY()-d.getStartY()),S=this.m_tolerance10;return y<C-S?-u:y>C+S?u:d.isIntersectingPoint(g.getStartXY(),this.m_tolerance,!0)?this.errorCracking():y<C?-u:u}compareNonHorizontalUpperEnd_(t,m){let u=1;if(m.m_line.getEndY()<t.m_line.getEndY()){u=-1;const b=t;t=m,m=b}const g=t.m_line,d=m.m_line,y=g.getEndX()-d.getStartX(),C=m.m_dxdy*(g.getEndY()-d.getStartY()),S=this.m_tolerance10;return y<C-S?-u:y>C+S?u:d.isIntersectingPoint(g.getEndXY(),this.m_tolerance,!0)?this.errorCracking():y<C?-u:u}errorCoincident(){return this.m_bIntersectionDetected=!0,this.m_nonSimpleResult=new Ee(7,this.m_vertex1,this.m_vertex2),-1}errorCracking(){return this.m_bIntersectionDetected=!0,this.m_bIsSimple?this.m_nonSimpleResult=new Ee(6,this.m_vertex1,this.m_vertex2):(this.m_prev1=c.n,this.m_prev2=c.n,this.m_vertex1=c.n,this.m_vertex2=c.n),-1}compareSegments_(t,m,u,g){if(u.m_env.vmax<g.m_env.vmin)return-1;if(g.m_env.vmax<u.m_env.vmin)return 1;if(!u.m_bCurve&&!g.m_bCurve){let b=u.m_bHorizontal?1:0;return b|=g.m_bHorizontal?2:0,0===b?this.compareNonHorizontal_(u,g):1===b?this.compareHorizontal1_(u.m_line,g.m_line):2===b?-1*this.compareHorizontal1_(g.m_line,u.m_line):this.compareHorizontal2_(u.m_line,g.m_line)}if(this.m_bIntersectionDetected)return-1;const d=this.m_prevY===this.m_sweepY&&this.m_prevX===this.m_sweepX;let y,C;if(d&&t===this.m_prev1?y=this.m_prevX1:(y=Number.NaN,this.m_prev1=c.n),d&&m===this.m_prev2?C=this.m_prevX2:(C=Number.NaN,this.m_prev2=c.n),this.m_prevY=this.m_sweepY,this.m_prevX=this.m_sweepX,Number.isNaN(y)){this.m_prev1=t;const b=u.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);y=b,this.m_prevX1=b}if(Number.isNaN(C)){this.m_prev2=m;const b=g.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);C=b,this.m_prevX2=b}const S=(0,c.a2)(!0,!0,u.m_segment,g.m_segment,this.m_tolerance,!0);return 0!==S?2===S?this.m_bIsSimple?this.errorCoincident():u.m_segmentInfo.equals(g.m_segmentInfo)?0:this.errorCracking():this.errorCracking():Math.abs(y-C)<=this.m_tolerance?this.compareTwoSegments_(u.m_segment,g.m_segment):y<C?-1:y>C?1:0}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1}intersectionDetected(){return this.m_bIntersectionDetected}getLastComparedNode(){return this.m_currentNode}getResult(){return this.m_nonSimpleResult}setSweepY(t,m){this.m_sweepY=t,this.m_sweepX=m,this.m_prev1=c.n,this.m_prev2=c.n,this.m_vertex1=c.n,this.m_vertex2=c.n}compare(t,m,u){if(this.m_bIntersectionDetected)return-1;const g=t.getElement(u),d=m;return this.m_currentNode=u,this.compareSegments(d,d,g,g)}compareSegments(t,m,u,g){let d=this.tryGetCachedEdge_(t);null===d?this.m_vertex1===m?d=this.m_tempSimpleEdge1:(this.m_vertex1=m,d=this.tryCreateCachedEdge_(t),null===d&&(d=this.m_tempSimpleEdge1,this.m_tempSimpleEdge1.m_value=t),this.initSimpleEdge_(d,m)):this.m_vertex1=m;let y=this.tryGetCachedEdge_(u);return null===y?this.m_vertex2===g?y=this.m_tempSimpleEdge2:(this.m_vertex2=g,y=this.tryCreateCachedEdge_(u),null===y&&(y=this.m_tempSimpleEdge2,this.m_tempSimpleEdge2.m_value=u),this.initSimpleEdge_(y,g)):this.m_vertex2=g,this.compareSegments_(m,g,d,y)}onDelete(t){this.tryDeleteCachedEdge_(t)}onSet(t){this.tryDeleteCachedEdge_(t)}onEndSearch(t){this.tryDeleteCachedEdge_(t)}onAddUniqueElementFailed(t){this.tryDeleteCachedEdge_(t)}}class ar{constructor(t,m){this.m_bIntersectionDetected=!1,this.m_pointOfInterest=Y.P.getNAN(),this.m_line1=new c.L,this.m_seg1=null,this.m_env=Y.E.constructEmpty(),this.m_vertex1=-1,this.m_currentNode=-1,this.m_minDist=Number.MAX_VALUE,this.m_shape=t,this.m_tolerance=m}getCurrentNode(){return this.m_currentNode}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1,this.m_minDist=Number.MAX_VALUE}intersectionDetected(){return this.m_bIntersectionDetected}setPoint(t){this.m_pointOfInterest.assign(t)}compare(t,m){const u=t.getElement(m);return this.compareVertex(t,m,u)}compareVertex(t,m,u){let g,d=this.m_shape.getSegment(u),y=!0;if(null==d)this.m_shape.queryLineConnector(u,this.m_line1,!0),this.m_env.setCoordsNoNAN(this.m_line1.getStartX(),this.m_line1.getEndX()),d=this.m_line1,g=this.m_line1.getStartY()===this.m_line1.getEndY();else{const S=R.J.constructEmpty();d.queryLooseEnvelope(S),S.queryIntervalX(this.m_env),g=0===S.height(),y=!1}if(this.m_pointOfInterest.x+this.m_tolerance<this.m_env.vmin)return-1;if(this.m_pointOfInterest.x-this.m_tolerance>this.m_env.vmax)return 1;if(g)return this.m_currentNode=m,this.m_bIntersectionDetected=!0,0;let C=0;if(y){(0,c.a4)(this.m_line1);const S=this.m_line1.getStartXY(),b=new Y.P;b.setSub(this.m_line1.getEndXY(),S),b.rightPerpendicularThis();const A=new Y.P;A.setSub(this.m_pointOfInterest,S),C=b.dotProduct(A),C/=b.length()}else C=d.intersectionOfYMonotonicWithAxisX(this.m_pointOfInterest.y,this.m_pointOfInterest.x)-this.m_pointOfInterest.x;return C<10*-this.m_tolerance?-1:C>10*this.m_tolerance?1:(d.isIntersectingPoint(this.m_pointOfInterest,this.m_tolerance)&&(Math.abs(C)<this.m_minDist&&(this.m_currentNode=m,this.m_minDist=C),this.m_bIntersectionDetected=!0),C<0?-1:C>0?1:0)}}class dn{constructor(t,m){this.m_lists=new Oe(!1),this.m_hash=m,this.m_hashBuckets=new Int32Array(t),this.m_hashBuckets.fill(dn.st_nullNode()),this.m_bitFilter=new Int32Array(10*t+31>>5)}reserveElements(t){this.m_lists.reserveLists(Math.min(this.m_hashBuckets.length,t)),this.m_lists.reserveNodes(t)}addElement(t,m){void 0===m&&(m=this.m_hash.getHash(t));const u=m%(this.m_bitFilter.length<<5);this.m_bitFilter[u>>5]|=1<<(31&u);const g=m%this.m_hashBuckets.length;let d=this.m_hashBuckets[g];return d===Oe.st_nullNode()&&(d=this.m_lists.createList(),this.m_hashBuckets[g]=d),this.m_lists.addElement(d,t)}deleteElement(t,m){void 0===m&&(m=this.m_hash.getHash(t));const u=m%this.m_hashBuckets.length,g=this.m_hashBuckets[u];g===Oe.st_nullNode()&&(0,F.t)("");let d=this.m_lists.getFirst(g),y=Oe.st_nullNode();for(;d!==Oe.st_nullNode();){const C=this.m_lists.getData(d),S=this.m_lists.getNext(d);C===t?(this.m_lists.deleteElementDirect(g,y,d),this.m_lists.getFirst(g)===Oe.st_nullNode()&&(this.m_lists.deleteList(g),this.m_hashBuckets[u]=Oe.st_nullNode())):y=d,d=S}}getFirstInBucket(t){const m=t%(this.m_bitFilter.length<<5);if(!(this.m_bitFilter[m>>5]&1<<(31&m)))return Oe.st_nullNode();const g=this.m_hashBuckets[t%this.m_hashBuckets.length];return g===Oe.st_nullNode()?Oe.st_nullNode():this.m_lists.getFirst(g)}getNextInBucket(t){return this.m_lists.getNext(t)}findNode(t){const m=this.m_hash.getHash(t);let u=this.getFirstInBucket(m);for(;u!==Oe.st_nullNode();){const g=this.m_lists.getData(u);if(this.m_hash.equal(g,t))return u;u=this.m_lists.getNext(u)}return Oe.st_nullNode()}deleteNode(t){const m=this.getElement(t),u=this.m_hash.getHash(m)%this.m_hashBuckets.length,g=this.m_hashBuckets[u];g===Oe.st_nullNode()&&(0,F.t)(""),this.m_lists.deleteElementSearch(g,t),this.m_lists.getFirst(g)===Oe.st_nullNode()&&(this.m_lists.deleteList(g),this.m_hashBuckets[u]=Oe.st_nullNode())}getElement(t){return this.m_lists.getData(t)}static st_nullNode(){return Oe.st_nullNode()}clear(){(0,F.g)(0)}size(){return this.m_lists.getNodeCount()}dbgPrintBucketHistogram(){}}function Qi(P,t,m,u,g){const d=new Or(g);return d.m_shape=P,d.m_sqrTolerance=t*t,d.m_cellSize=2*t,d.m_invCellSize=1/d.m_cellSize,d.m_geometry=m,d.m_bTrackChanges=u,d.m_bHasSegmentParentage=P.hasSegmentParentage(),d.clusterNonReciprocal()}function rn(P,t,m,u,g){const d=P-m,y=t-u;return d*d+y*y<=g}function hr(P,t,m,u,g,d){const y=function Ur(){return{pt:new Y.P,weight:0,rank:0,bMerged:!1}}(),C=m+g;let S=!1,b=P.x;P.x!==t.x&&(u===d&&(b=(P.x*m+t.x*g)/C),S=!0);let A=P.y;return P.y!==t.y&&(u===d&&(A=(P.y*m+t.y*g)/C),S=!0),u!==d?u>d?(y.rank=u,y.weight=m,y.pt=P):(y.rank=d,y.weight=g,y.pt=t):(y.pt.setCoords(b,A),y.weight=C,y.rank=u),y.bMerged=S,y}function Fn(P,t){const m=(0,Y.aH)(P);return(0,Y.aG)(m,t)}class pn{constructor(t,m,u,g,d){this.m_workPt=new Y.P,this.m_shape=t,this.m_sqrTolerance=u,this.m_invCellSize=g,this.m_origin=m.clone(),this.m_hashValues=d}getHash(t){return this.m_shape.getUserIndex(t,this.m_hashValues)}calculateHashFromVertex(t){return this.m_shape.queryXY(t,this.m_workPt),Fn(Math.trunc((this.m_workPt.x-this.m_origin.x)*this.m_invCellSize+.5),Math.trunc((this.m_workPt.y-this.m_origin.y)*this.m_invCellSize+.5))}equal(t,m){return(0,F.g)(0),!1}}class Or{constructor(t){this.m_origin=Y.P.getNAN(),this.m_sqrTolerance=0,this.m_cellSize=0,this.m_invCellSize=0,this.m_geometry=c.n,this.m_bucketArray=(0,Y.d)(4,Number.NaN),this.m_bucketHash=(0,Y.d)(4,Number.NaN),this.m_dbgCandidateCheckCount=0,this.m_nsr=new Ee,this.m_hashValues=-1,this.m_newClusters=-1,this.m_bTrackChanges=!1,this.m_bHasSegmentParentage=!1,this.m_shape=null,this.m_clusters=new Oe,this.m_hashFunction=null,this.m_hashTable=null,this.m_progressCounter=0,this.m_progressTracker=t}progress_(){}collectClusterCandidates(t,m){const u=Y.P.getNAN();this.m_shape.queryXY(t,u);const d=(u.y-this.m_origin.y)*this.m_invCellSize,y=Math.trunc((u.x-this.m_origin.x)*this.m_invCellSize),C=Math.trunc(d);let S=0;for(let b=0;b<=1;b+=1)for(let A=0;A<=1;A+=1){const T=Fn(y+b,C+A),M=this.m_hashTable.getFirstInBucket(T);M!==dn.st_nullNode()&&(this.m_bucketArray[S]=M,this.m_bucketHash[S]=T,S++)}for(let b=S-1;b>=1;b--){const A=this.m_bucketArray[b];for(let T=b-1;T>=0;T--)if(A===this.m_bucketArray[T]){this.m_bucketHash[T]=-1,S--,b!==S&&(this.m_bucketHash[b]=this.m_bucketHash[S],this.m_bucketArray[b]=this.m_bucketArray[S]);break}}for(let b=0;b<S;b++)this.collectNearestNeighbourCandidates(t,this.m_bucketHash[b],u,this.m_bucketArray[b],m)}collectNearestNeighbourCandidates(t,m,u,g,d){const y=Y.P.getNAN();for(let C=g;C!==dn.st_nullNode();C=this.m_hashTable.getNextInBucket(C)){const S=this.m_hashTable.getElement(C);t===S||-1!==m&&this.m_shape.getUserIndex(S,this.m_hashValues)!==m||(this.m_shape.queryXY(S,y),rn(u.x,u.y,y.x,y.y,this.m_sqrTolerance)&&d.push(C))}}mergeClusters(t,m,u){let g=this.m_shape.getUserIndex(t,this.m_newClusters);const d=this.m_shape.getUserIndex(m,this.m_newClusters);-1===g&&(g=this.m_clusters.createList(),this.m_clusters.addElement(g,t),this.m_shape.setUserIndex(t,this.m_newClusters,g)),-1===d?this.m_clusters.addElement(g,m):this.m_clusters.concatenateLists(g,d),this.m_shape.setUserIndex(m,this.m_newClusters,dt.S.impossibleIndex2());const y=this.mergeVertices(t,m);if(u){const C=this.m_hashFunction.calculateHashFromVertex(t);this.m_shape.setUserIndex(t,this.m_hashValues,C)}return y}mergeVertices(t,m){const u=Y.P.getNAN();this.m_shape.queryXY(t,u);const g=Y.P.getNAN();this.m_shape.queryXY(m,g);const d=this.m_shape.getRank(t),y=this.m_shape.getRank(m),C=this.m_shape.getWeight(t),S=this.m_shape.getWeight(m);let b,A,T,M,X=!1;if(d===y?(b=d,A=C+S,T=u.x,u.x!==g.x&&(T=(u.x*C+g.x*S)/A,X=!0),M=u.y,u.y!==g.y&&(M=(u.y*C+g.y*S)/A,X=!0)):(d>y?(T=u.x,M=u.y,A=C,b=d):(T=g.x,M=g.y,A=S,b=y),X=!u.equals(g)),X&&(this.m_shape.setXYMonotonic(t,T,M),this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(t,!0),this.m_bHasSegmentParentage)){const k=this.m_shape.getSegmentParentageBreakVertex(t)||this.m_shape.getSegmentParentageBreakVertex(m);this.m_shape.setSegmentParentageBreakVertex(t,k),this.m_shape.setSegmentParentageBreakVertex(m,k)}return this.m_shape.setWeight(t,A),this.m_shape.setRank(t,b),X}needsClustering(){const t={stack:[],error:void 0,hasError:!1};try{(0,vt.b)(t,(0,Y.h)(()=>{this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters)}),!1);const m=this.m_shape.getSelectedCount(),u=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin.assign(u.getLowerLeft());const g=Math.max(u.height(),u.width())/((0,Y.i)()-1);this.m_cellSize<g&&(this.m_cellSize=g,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(this.m_shape.getSelectedCount()/3+1),this.m_clusters.reserveNodes(this.m_shape.getSelectedCount()/3+1),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new pn(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new dn(4*m/3,this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let d=!1;for(let y=0;y<2;y++){const C=[],S=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let b=S.next();b!==c.n;b=S.next()){if(this.progress_(),y>0&&this.m_shape.getUserIndex(b,this.m_newClusters)===dt.S.impossibleIndex2())continue;let A;if(0===y?(A=this.m_hashFunction.calculateHashFromVertex(b),this.m_shape.setUserIndex(b,this.m_hashValues,A)):A=this.m_shape.getUserIndex(b,this.m_hashValues),this.collectClusterCandidates(b,C),0!==C.length){for(let T=0,M=C.length;T<M;T++){this.progress_();const X=C[T],k=this.m_hashTable.getElement(X);if(this.m_hashTable.deleteNode(X),!this.m_shape.isEqualXY(b,k))return this.m_nsr=new Ee(5,this.m_shape.getVertexIndex(b),this.m_shape.getVertexIndex(k)),d=!0,d;this.mergeClusters(b,k,!1)}C.length=0}0===y&&this.m_hashTable.addElement(b,A)}}return d}catch(m){t.error=m,t.hasError=!0}finally{(0,vt.c)(t)}}clusterNonReciprocal(){const t=this.m_shape.getSelectedCount(),m=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin=m.getLowerLeft();const u=Math.max(m.height(),m.width())/((0,Y.i)()-1);this.m_cellSize<u&&(this.m_cellSize=u,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_clusters.reserveNodes(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new pn(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new dn(Math.trunc(4*t/3),this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let g=!1;{const d=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let y=d.next();y!==c.n;y=d.next()){this.progress_();const C=this.m_hashFunction.calculateHashFromVertex(y);this.m_shape.setUserIndex(y,this.m_hashValues,C),this.m_hashTable.addElement(y,C)}}{const d=[],y=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let C=y.next();C!==c.n;C=y.next()){if(this.m_shape.getUserIndex(C,this.m_newClusters)===dt.S.impossibleIndex2())continue;let S=this.m_shape.getUserIndex(C,this.m_hashValues);this.m_hashTable.deleteElement(C,S);let b=!1;for(;this.collectClusterCandidates(C,d),0!==d.length;){let A=0;for(let T=0,M=d.length;T<M;T++){this.progress_();const X=d[T],k=this.m_hashTable.getElement(X);this.m_hashTable.deleteNode(X),A|=this.mergeClusters(C,k,T+1===M)?1:0}if(b||=0!==A,g||=0!==A,d.length=0,!A)break}b&&(S=this.m_shape.getUserIndex(C,this.m_hashValues)),this.m_hashTable.addElement(C,S)}d.length=0}return g&&this.applyClusterPositions_(),this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters),g}applyClusterPositions_(){const t=Y.P.getNAN();for(let m=this.m_clusters.getFirstList();m!==Oe.st_nullNode();m=this.m_clusters.getNextList(m)){let u=this.m_clusters.getFirst(m);const g=this.m_clusters.getElement(u);this.m_shape.queryXY(g,t);const d=this.m_shape.getRank(g),y=this.m_shape.getWeight(g);for(u=this.m_clusters.getNext(u);u!==Oe.st_nullNode();u=this.m_clusters.getNext(u)){const C=this.m_clusters.getElement(u);if(this.m_bTrackChanges?this.m_shape.isEqualXYPoint2D(C,t)||(this.m_shape.setXYMonotonicPoint2D(C,t),this.m_shape.setGeometryModifiedWithVertex(C,!0)):this.m_shape.setXYMonotonicPoint2D(C,t),this.m_bHasSegmentParentage){const S=this.m_shape.getSegmentParentageBreakVertex(g)||this.m_shape.getSegmentParentageBreakVertex(C);this.m_shape.setSegmentParentageBreakVertex(g,S),this.m_shape.setSegmentParentageBreakVertex(C,S)}this.m_shape.setWeight(C,y),this.m_shape.setRank(C,d)}}}}class Os{constructor(){this.m_inputParts=[],this.m_resultParts1=[],this.m_resultParts2=[],this.m_resultSegments=[],this.m_freeSegments=[],this.m_inputSegments=[],this.m_param1=[],this.m_param2=[],this.m_tolerance=0,this.m_toleranceZ=0,this.m_point=new dt.P,this.m_pointWeight=1,this.m_maxDensifyLimit=0,this.m_pointRank=0,this.m_changed1=!1,this.m_changed2=!1,this.m_adaptiveDensify=!1}clear(){this.freeAllResultSegments(),this.m_inputSegments.length=0,this.m_inputParts.length=0,this.m_resultParts1.length=0,this.m_resultParts2.length=0,this.m_param1.length=0,this.m_param2.length=0,this.m_adaptiveDensify=!1,this.m_changed1=!1,this.m_changed2=!1}newIntersectionPart_(t,m,u,g,d,y,C,S,b,A){return function lr(P,t,m,u,g,d,y,C,S,b){return{segmentIndex:P,weightStart:t,rankStart:m,weightEnd:u,rankEnd:g,weightInterior:d,rankInterior:y,segmentParentage:b,u:Ao(C,S)}}(t,m,u,g,d,y,C,S,b,A)}pushSegment(t,m,u,g,d,y,C,S,b,A){return this.m_inputParts.push(this.newIntersectionPart_(this.m_inputSegments.length,m,u,g,d,y,C,S,b,A)),this.m_inputSegments.push(t),this.m_inputParts.length-1}getResultSegmentCount(t){return this.m_adaptiveDensify?0===t?this.m_param1.length-1:this.m_param2.length-1:0===t?this.m_resultParts1.length:this.m_resultParts2.length}getResultPart_(t,m){return 0===t?this.m_resultParts1[m]:this.m_resultParts2[m]}getResultSegment(t,m){return this.m_resultSegments[this.getResultPart_(t,m).segmentIndex].get()}getSegmentChanged(t){return 0===t?this.m_changed1:this.m_changed2}getResultSegmentStartPointWeight(t,m){return this.getResultPart_(t,m).weightStart}getResultSegmentStartPointRank(t,m){return this.getResultPart_(t,m).rankStart}getResultSegmentSegmentParentage(t,m){return this.getResultPart_(t,m).segmentParentage}getResultSegmentStartPointIsBreak(t,m){return this.getResultPart_(t,m).u.bBreakStart}getResultSegmentEndPointWeight(t,m){return this.getResultPart_(t,m).weightEnd}getResultSegmentEndPointRank(t,m){return this.getResultPart_(t,m).rankEnd}getResultSegmentEndPointIsBreak(t,m){return this.getResultPart_(t,m).u.bBreakEnd}getResultSegmentInteriorRank(t,m){return this.getResultPart_(t,m).rankInterior}getResultSegmentInteriorWeight(t,m){return this.getResultPart_(t,m).weightInterior}getResultPoint(){return this.m_point}getResultPointWeight(){return this.m_pointWeight}getResultPointRank(){return this.m_pointRank}getResultPointChanged(){return this.m_changed2}intersectLines(t,m){2!==this.m_inputSegments.length&&(0,F.c)(""),this.m_changed1=!1,this.m_changed2=!1,this.m_tolerance=t;const u=(0,Y.s)(t*Os.c_smallToleranceFactor);let g=!1;const d=this.m_inputParts[0],y=this.m_inputParts[1],C=this.m_inputSegments[d.segmentIndex],S=this.m_inputSegments[y.segmentIndex];if(m||5&(0,c._)(!0,C,S,t,!0)){const b=(0,c.a0)(!0,C,S,null,this.m_param1,this.m_param2,t);0===b&&(0,F.c)("");const A=new Array(b);for(let ct=0;ct<b;++ct)A[ct]=Y.P.getNAN();const T=new Float64Array(b),M=new Int32Array(b),X=new Array(b),k=new Array(b);for(let ct=0;ct<b;++ct)X[ct]={bBigMove:!1,bIsBreak:!1},k[ct]={bBigMove:!1,bIsBreak:!1};for(let ct=0;ct<b;ct++){const Et=this.m_param1[ct],Tt=this.m_param2[ct];let Pt,At=d.rankInterior,Ht=d.weightInterior;0===Et?(At=d.rankStart,Ht=d.weightStart,Pt=d.u.bBreakStart):1===Et?(At=d.rankEnd,Ht=d.weightEnd,Pt=d.u.bBreakEnd):(this.m_changed1=!0,Pt=!1);let Bt,kt=y.rankInterior,wt=y.weightInterior;0===Tt?(kt=y.rankStart,wt=y.weightStart,Bt=y.u.bBreakStart):1===Tt?(kt=y.rankEnd,wt=y.weightEnd,Bt=y.u.bBreakEnd):(this.m_changed2=!0,Bt=!1);const Xt=At,Zt=kt;let zt=1,ge=0,qt=Y.P.getNAN();if(Xt===Zt){const ce=C.getCoord2D(Et),be=S.getCoord2D(Tt);zt=Ht+wt,ge=At,(0,Y.Z)(ce,be,wt/zt,qt);const Me=Y.P.sqrDistance(qt,ce),Es=Y.P.sqrDistance(qt,be);X[ct].bBigMove=Me>u,k[ct].bBigMove=Es>u,this.m_changed1||ce.equals(qt)||(this.m_changed1=!0),this.m_changed2||be.equals(qt)||(this.m_changed2=!0)}else if(Xt>Zt){qt=C.getCoord2D(Et);const ce=S.getCoord2D(Tt);zt=Ht,ge=At;const be=Y.P.sqrDistance(qt,ce);X[ct].bBigMove=!1,k[ct].bBigMove=be>u,this.m_changed2||ce.equals(qt)||(this.m_changed2=!0)}else{qt=S.getCoord2D(Tt),zt=wt,ge=kt;const ce=C.getCoord2D(Et),be=Y.P.sqrDistance(qt,ce);X[ct].bBigMove=be>u,k[ct].bBigMove=!1,this.m_changed1||ce.equals(qt)||(this.m_changed1=!0)}A[ct].assign(qt),T[ct]=zt,M[ct]=ge,X[ct].bIsBreak=Pt||Bt,k[ct].bIsBreak=Pt||Bt,g||=X[ct].bBigMove||k[ct].bBigMove}const H=d.rankInterior,U=d.weightInterior;let Z=0,st=-1;for(let ct=0;ct<=b;ct++){const Et=ct<b?this.m_param1[ct]:1;if(Et!==Z){const Tt=this.allocResultSegment(),Pt=this.m_resultSegments[Tt];let At,Ht,Bt,kt;C.queryCut(Z,Et,Pt,!1),Pt.get().snapControlPoints(t*t);let wt=!1,Xt=!1,Zt=!1,zt=!1,ge=!1,qt=Y.P.getNAN(),ce=Y.P.getNAN();-1!==st?(Ht=M[st],At=T[st],wt=X[st].bBigMove,qt.assign(A[st]),Zt=X[st].bIsBreak,ge=!0):(At=d.weightStart,Ht=d.rankStart,qt=Pt.get().getStartXY(),Zt=d.u.bBreakStart),ct<b?(kt=M[ct],Bt=T[ct],Xt=X[ct].bBigMove,ce.assign(A[ct]),zt=X[ct].bIsBreak,ge=!0):(Bt=d.weightEnd,kt=d.rankEnd,ce=Pt.get().getEndXY(),zt=d.u.bBreakEnd),ge&&Pt.get().setCoordsForIntersector(qt,ce,!0),this.m_resultParts1.push(this.newIntersectionPart_(Tt,At,Ht,Bt,kt,U,H,Zt,zt,d.segmentParentage));const be=this.m_resultParts1.at(-1);be.u.bBigMoveStart=wt,be.u.bBigMoveEnd=Xt,Z=Et,st=ct}else-1===st&&(st=ct)}const mt=(0,Y.d)(b,0);for(let ct=0;ct<b;ct++)mt[ct]=ct;b>2?(mt.sort((ct,Et)=>this.m_param2[ct]<this.m_param2[Et]?-1:this.m_param2[ct]>this.m_param2[Et]?1:0),(0,Y.v)(this.m_param2)):2===b&&this.m_param2[0]>this.m_param2[1]&&(this.m_param2[1]=(0,Y.b)(this.m_param2[0],this.m_param2[0]=this.m_param2[1]),mt[1]=(0,Y.b)(mt[0],mt[0]=mt[1]));const ht=y.rankInterior,ut=y.weightInterior;Z=0,st=-1;for(let ct=0;ct<=b;ct++){const Et=ct<b?this.m_param2[ct]:1;if(Et!==Z){const Tt=this.allocResultSegment(),Pt=this.m_resultSegments[Tt];let At,Ht,Bt,kt;S.queryCut(Z,Et,Pt,!1),Pt.get().snapControlPoints(t*t);let wt=Y.P.getNAN(),Xt=Y.P.getNAN(),Zt=!1,zt=!1,ge=!1,qt=!1,ce=!1;if(-1!==st){const Me=mt[st];At=T[Me],Ht=M[Me],wt.assign(A[Me]),ge=k[Me].bBigMove,Zt=k[Me].bIsBreak,ce=!0}else At=y.weightStart,Ht=y.rankStart,wt=Pt.get().getStartXY(),Zt=y.u.bBreakStart;if(ct!==b){const Me=mt[ct];Bt=T[Me],kt=M[Me],Xt.assign(A[Me]),qt=k[Me].bBigMove,zt=k[Me].bIsBreak,ce=!0}else Bt=y.weightEnd,kt=y.rankEnd,Xt=Pt.get().getEndXY(),zt=y.u.bBreakEnd;ce&&Pt.get().setCoordsForIntersector(wt,Xt,!0),this.m_resultParts2.push(this.newIntersectionPart_(Tt,At,Ht,Bt,kt,ut,ht,Zt,zt,y.segmentParentage));const be=this.m_resultParts2.at(-1);be.u.bBigMoveStart=ge,be.u.bBigMoveEnd=qt,Z=Et,st=ct}else-1===st&&(st=ct)}return g?3:2}return 0}intersectLines3D(t,m,u,g){return(0,F.g)(0),1}intersect2D(t,m){const g=this.m_inputParts[1],d=this.m_inputSegments[this.m_inputParts[0].segmentIndex].getGeometryType(),y=this.m_inputSegments[g.segmentIndex].getGeometryType();return d!==F.G.enumLine||y!==F.G.enumLine?new Ks(this).intersectCurves(t,m):this.intersectLines(t,m)}intersect2DEx(t,m,u,g,d){this.m_point.assignCopy(m),1!==this.m_inputSegments.length&&(0,F.c)(""),this.m_tolerance=t,this.m_changed1=!1,this.m_changed2=!1;const y=(0,Y.s)(t*Os.c_smallToleranceFactor);let C=!1;const S=this.m_inputParts[0],b=this.m_inputSegments[S.segmentIndex];if(d||b.isIntersectingPoint(m.getXY(),t,!0)){this.m_param1=(0,Y.d)(16,Number.NaN);const A=b.getClosestCoordinate(m.getXY(),!1);this.m_param1[0]=A;let T=S.rankInterior,M=S.weightInterior;0===A?(T=S.rankStart,M=S.weightStart):1===A?(T=S.rankEnd,M=S.weightEnd):this.m_changed1=!0;let X=T;const k=u,H=g;X===k&&b.isCurve()&&(X=k+1);let U=1,Z=0;const st=new Y.P;if(X===k){const ct=b.getCoord2D(A),Et=m.getXY();U=M+H,Z=T,(0,Y.Z)(ct,Et,H/U,st),this.m_changed1||ct.equals(st)||(this.m_changed1=!0),this.m_changed2||Et.equals(st)||(this.m_changed2=!0),C=Y.P.sqrDistance(st,ct)>y}else X>k?(st.assign(b.getCoord2D(A)),U=M,Z=T,this.m_changed2||st.equals(m.getXY())||(this.m_changed2=!0)):(st.assign(b.getCoord2D(A)),U=H,Z=k,this.m_changed1||st.equals(m.getXY())||(this.m_changed1=!0),C=Y.P.sqrDistance(st,m.getXY())>y);let mt=0,ht=-1;const ut=1;for(let ct=0;ct<=ut;ct++){const Et=ct<ut?this.m_param1[0]:1;if(Et!==mt){const Tt=this.allocResultSegment(),Pt=this.m_resultSegments[Tt];b.queryCut(mt,Et,Pt),Pt.get().snapControlPoints(t*t);let At=S.weightStart,Ht=S.weightEnd,Bt=S.rankStart,kt=S.rankEnd;const wt=S.rankInterior,Xt=S.weightInterior;let Zt=S.u.bBreakStart,zt=S.u.bBreakEnd;-1!==ht&&(At=U,Bt=Z,Zt=!0,Pt.get().setCoordsForIntersector(st,Pt.get().getEndXY(),!0)),ct!==ut&&(Ht=U,kt=Z,zt=!0,Pt.get().setCoordsForIntersector(Pt.get().getStartXY(),st,!0)),mt=Et,this.m_resultParts1.push(this.newIntersectionPart_(Tt,At,Bt,Ht,kt,Xt,wt,Zt,zt,S.segmentParentage))}ht=ct}return this.m_point.setXY(st),this.m_pointWeight=U,this.m_pointRank=Z,C?3:2}return 0}intersect3D(t,m,u,g){return(0,F.g)(0),1}intersect3DEx(t,m,u,g,d,y,C){return(0,F.g)(0),1}getTolerance(){return this.m_tolerance}freeAllResultSegments(){this.m_resultSegments.length=0,this.m_freeSegments.length=0}freeResultSegment(t){this.m_freeSegments.push(t)}allocResultSegment(){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const t=new c.S,m=this.m_resultSegments.length;return this.m_resultSegments.push(t),m}allocResultSegmentFromBuffer(t){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const m=new c.S({copy:t}),u=this.m_resultSegments.length;return this.m_resultSegments.push(m),u}allocResultSegmentFromSegment(t){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const m=new c.S({segment:t}),u=this.m_resultSegments.length;return this.m_resultSegments.push(m),u}}function Ao(P,t){return{bBigMoveStart:!1,bBigMoveEnd:!1,bBreakStart:P,bBreakEnd:t}}function Vs(){return{bBigMove:!1,bIsBreak:!1}}Os.maxWeight=.1*Number.MAX_VALUE,Os.c_smallToleranceFactor=.01,Os.c_maxGeometryTypeToRankDelta=8;let wi=class{constructor(){this.start=null,this.end=null,this.equalEdge=null,this.segmentIndex=-1,this.segmentParentage=-1,this.weight=0,this.rank=0}hasSegment(){return this.segmentIndex>=0}transferAttributes(P,t,m){if(1===t.getDescription().getAttributeCount())return;const u=P.parent.m_resultSegments[this.segmentIndex].get().getStartXY(),g=P.parent.m_resultSegments[this.segmentIndex].get().getEndXY(),d=new dt.P;t.queryStart(d),m?(d.setXY(u),P.parent.m_resultSegments[this.segmentIndex].get().setStart(d)):(d.setXY(g),P.parent.m_resultSegments[this.segmentIndex].get().setEnd(d)),t.queryEnd(d),m?(d.setXY(g),P.parent.m_resultSegments[this.segmentIndex].get().setEnd(d)):(d.setXY(u),P.parent.m_resultSegments[this.segmentIndex].get().setStart(d))}copyFromWhenOverlap(P,t,m){this.equalEdge=t,t.equalEdge=this,this.segmentIndex=P.parent.allocResultSegmentFromBuffer(P.parent.m_resultSegments[t.segmentIndex]),this.segmentParentage=t.segmentParentage,this.weight=t.weight,this.rank=t.rank,m?(this.start.copyFrom(t.start),this.end.copyFrom(t.end)):(this.start.copyFrom(t.end),this.end.copyFrom(t.start),P.parent.m_resultSegments[this.segmentIndex].get().reverse())}getEnd(){return this.end}getNextInChain(){return this.end.nextInChain}getPrevInChain(){return this.start.prevInChain}};class ii{constructor(){this.hash=0,this.pt=new Y.P,this.prevInChain=null,this.nextInChain=null,this.prevInHash=null,this.nextInHash=null,this.prevEqual=null,this.nextEqual=null,this.weight=0,this.rank=0,this.bBigMove=!1,this.bIsBreak=!1}copyFrom(t){this.pt.assign(t.pt),this.weight=t.weight,this.rank=t.rank,this.bBigMove=t.bBigMove,this.bIsBreak=t.bIsBreak}nextNode(){return this.nextInChain?this.nextInChain.end:null}prevNode(){return this.prevInChain?this.prevInChain.start:null}equalListHead(){let t=this;for(;null!==t.prevEqual;t=t.prevEqual);return t}}function Ns(P,t,m,u){return{edge1:P,edge2:t,recursion:m,bIsIntersecting:u}}class Ks{constructor(t){this.m_pairs=[],this.m_chainOrigin1=null,this.m_chainOrigin2=null,this.m_newNodes=[],this.m_hashTableOfEquals=[],this.m_hashTableOfEqualsSize=0,this.m_origin=new Y.P,this.m_cell=new Y.P,this.parent=t}addSegment(t,m,u,g,d,y,C,S,b,A,T){const M=this.newNode(this.parent.m_resultSegments[t].get().getStartXY(),u,g,b),X=this.newNode(this.parent.m_resultSegments[t].get().getEndXY(),d,y,A);this.newEdge(M,X,t,C,S,T),null===this.m_chainOrigin1?this.m_chainOrigin1=M:null===this.m_chainOrigin2?this.m_chainOrigin2=M:(0,F.g)(0)}intersectCurvesHelper(t,m,u,g,d){const y=this.getSegment(t).get(),C=this.getSegment(m).get();if(y.isDegenerate(0)||C.isDegenerate(0))return 0;const S=this.tryOverlapIntersectCurves(t,m,u,g);if(0!==S)return S;const b=(0,Y.s)(.01*u);let A=!1,T=this.processSharpCorners(y,C,u,d>4);const M=T>0;if(!M){if(!(g||5&(0,c.a2)(!0,!1,y,C,u,!0)))return 0;T=(0,c.a0)(!0,y,C,null,this.parent.m_param1,this.parent.m_param2,u)}0===T&&(0,F.c)("");const X=y.getGeometryType(),k=C.getGeometryType(),H=(0,Y.m)(Y.P,T),U=(0,Y.m)(Y.P,T),Z=(0,Y.d)(T,Number.NaN),st=(0,Y.d)(T,Number.NaN),mt=(0,Y.d)(T,Number.NaN),ht=(0,Y.d)(T,Number.NaN),ut=(0,Y.p)(Vs,T),ct=(0,Y.p)(Vs,T);let Et=!1,Tt=!1;for(let qt=0;qt<T;qt++){const ce=this.parent.m_param1[qt],be=this.parent.m_param2[qt];let Me=t.rank,Es=t.weight,ts=!0,He=!1;0===ce?(Me=t.start.rank,Es=t.start.weight,He=t.start.bIsBreak):1===ce?(Me=t.end.rank,Es=t.end.weight,He=t.end.bIsBreak):(Et=!0,ts=!1);let Ke=m.rank,rs=m.weight,Fe=!1,di=!0;0===be?(Ke=m.start.rank,rs=m.start.weight,Fe=m.start.bIsBreak):1===be?(Ke=m.end.rank,rs=m.end.weight,Fe=m.end.bIsBreak):(Tt=!0,di=!1);let Js=Me,Zs=Ke;if(Js===Zs&&(Js*=Os.c_maxGeometryTypeToRankDelta,Zs*=Os.c_maxGeometryTypeToRankDelta,Js+=Di(X,y,!1),Zs+=Di(k,C,!1)),ts&&di&&Zs===Js){const _n=y.getCoord2D(ce),Ra=C.getCoord2D(be);_n.equals(Ra)&&(Zs=Js-1)}let Cs=1,vi=0,Ds=1,Zi=0;const bs=new Y.P,si=new Y.P,Hi=y.getCoord2D(ce),zi=C.getCoord2D(be);if(M&&Y.P.distance(Hi,zi)>u)bs.setCoordsPoint2D(Hi),si.setCoordsPoint2D(zi),Cs=Es,Ds=rs,vi=Me,Zi=Ke,ut[qt].bBigMove=!1,ct[qt].bBigMove=!1,He=!0,Fe=!0;else if(Js===Zs){Ds=Cs=Es+rs,Zi=vi=Me,(0,Y.Z)(Hi,zi,rs/Cs,bs),si.setCoordsPoint2D(bs);const _n=Y.P.sqrDistance(bs,Hi),Ra=Y.P.sqrDistance(bs,zi);ut[qt].bBigMove=_n>b,ct[qt].bBigMove=Ra>b,Et||Hi.equals(bs)||(Et=!0),Tt||zi.equals(si)||(Tt=!0)}else if(Js>Zs){bs.setCoordsPoint2D(Hi),si.setCoordsPoint2D(bs),Ds=Cs=Es,Zi=vi=Me;const _n=Y.P.sqrDistance(bs,zi);ut[qt].bBigMove=!1,ct[qt].bBigMove=_n>b,Tt||zi.equals(si)||(Tt=!0)}else{si.setCoordsPoint2D(zi),bs.setCoordsPoint2D(si),Ds=Cs=rs,Zi=vi=Ke;const _n=Y.P.sqrDistance(bs,Hi);ut[qt].bBigMove=_n>b,ct[qt].bBigMove=!1,Et||Hi.equals(bs)||(Et=!0)}H[qt].assign(bs),U[qt].assign(si),Z[qt]=Cs,st[qt]=Ds,mt[qt]=vi,ht[qt]=Zi,ut[qt].bIsBreak=He||Fe,ct[qt].bIsBreak=He||Fe,A||=ut[qt].bBigMove||ct[qt].bBigMove,qt>0&&(ce!==this.parent.m_param1[qt-1]&&be!==this.parent.m_param2[qt-1]||(mt[qt]<=mt[qt-1]?(H[qt].assign(U[qt-1]),Z[qt]=st[qt-1],mt[qt]=ht[qt-1],U[qt].assign(U[qt-1]),st[qt]=st[qt-1],ht[qt]=ht[qt-1],ut[qt].bBigMove||=ut[qt-1].bBigMove,ct[qt].bBigMove||=ct[qt-1].bBigMove,ut[qt].bIsBreak||=ut[qt-1].bIsBreak,ct[qt].bIsBreak||=ct[qt-1].bIsBreak):(H[qt-1].assign(H[qt]),Z[qt-1]=Z[qt],mt[qt-1]=mt[qt],U[qt-1].assign(U[qt]),st[qt-1]=st[qt],ht[qt-1]=ht[qt],ut[qt-1].bBigMove||=ut[qt].bBigMove,ct[qt-1].bBigMove||=ct[qt].bBigMove,ut[qt-1].bIsBreak||=ut[qt].bIsBreak,ct[qt-1].bIsBreak||=ct[qt].bIsBreak)))}if(!(Et||Tt||2!==T||X===F.G.enumLine&&k===F.G.enumLine)){if(this.processDoublyConnectedEdges(t,m,d+1,u))return this.parent.m_changed1=!0,this.parent.m_changed2=!0,2;(0,F.g)(0)}this.parent.m_changed1||=Et,this.parent.m_changed2||=Tt;let Pt=t,At=t.end.weight,Ht=t.end.rank,Bt=t.end.bBigMove,kt=t.end.bIsBreak,wt=0,Xt=-1;for(let qt=0;qt<=T;qt++){const ce=qt<T?this.parent.m_param1[qt]:1;if(ce!==wt){const be=this.parent.allocResultSegment(),Me=this.parent.m_resultSegments[be];let Es,ts,He,Ke;y.queryCut(wt,ce,Me,!1),Me.get().snapControlPoints(u*u);let rs=!1,Fe=!1,di=!1,Js=!1;const Zs=new Y.P,Cs=new Y.P;-1!==Xt?(ts=mt[Xt],Es=Z[Xt],di=ut[Xt].bBigMove,rs=ut[Xt].bIsBreak,Zs.assign(H[Xt])):(Es=t.start.weight,ts=t.start.rank,di=t.start.bBigMove,rs=t.start.bIsBreak,Zs.assign(Me.get().getStartXY())),qt<T?(Ke=mt[qt],He=Z[qt],Js=ut[qt].bBigMove,Fe=ut[qt].bIsBreak,Cs.assign(H[qt])):(He=At,Ke=Ht,Js=Bt,Fe=kt,Cs.assign(Me.get().getEndXY()));let vi=Pt;ce<1&&(this.splitEdgeInPlace(Pt),vi=Pt.getNextInChain()),this.updateSegmentOnly(Pt,be),0===Pt.start.hash||Pt.start.pt.equals(Zs)||(this.m_newNodes.push(Pt.start),this.removeNodeFromHash(Pt.start),Pt.start.hash=0),0===Pt.end.hash||Pt.end.pt.equals(Cs)||(this.m_newNodes.push(Pt.end),this.removeNodeFromHash(Pt.end),Pt.end.hash=0),Pt.start.pt.assign(Zs),Pt.end.pt.assign(Cs),Pt.start.bBigMove||=di,Pt.end.bBigMove||=Js,Pt.start.bIsBreak||=rs,Pt.end.bIsBreak||=Fe,Pt.start.weight=Es,Pt.start.rank=ts,Pt.end.weight=He,Pt.end.rank=Ke,Pt=vi,wt=ce,Xt=qt}else-1===Xt&&(Xt=qt)}const Zt=Pt.getNextInChain(),zt=[];zt.length=T;for(let qt=0;qt<T;qt++)zt[qt]=qt;T>2?(zt.sort((qt,ce)=>(0,Y.X)(this.parent.m_param2[qt],this.parent.m_param2[ce])),this.parent.m_param2.sort(Y.X)):2===T&&this.parent.m_param2[0]>this.parent.m_param2[1]&&(this.parent.m_param2[1]=(0,Y.b)(this.parent.m_param2[0],this.parent.m_param2[0]=this.parent.m_param2[1]),zt[1]=(0,Y.b)(zt[0],zt[0]=zt[1])),Pt=m,At=m.end.weight,Ht=m.end.rank,Bt=m.end.bBigMove,kt=m.end.bIsBreak,wt=0,Xt=-1;for(let qt=0;qt<=T;qt++){const ce=qt<T?this.parent.m_param2[qt]:1;if(ce!==wt){const be=this.parent.allocResultSegment(),Me=this.parent.m_resultSegments[be];let Es,ts,He,Ke;C.queryCut(wt,ce,Me,!1),Me.get().snapControlPoints(u*u);const rs=new Y.P,Fe=new Y.P;let di=!1,Js=!1,Zs=!1,Cs=!1;if(-1!==Xt){const Ds=zt[Xt];Es=st[Ds],ts=ht[Ds],rs.assign(U[Ds]),Zs=ct[Ds].bBigMove,di=ct[Ds].bIsBreak}else Es=m.start.weight,ts=m.start.rank,Zs=m.start.bBigMove,di=m.start.bIsBreak,rs.assign(Me.get().getStartXY());if(qt!==T){const Ds=zt[qt];He=st[Ds],Ke=ht[Ds],Fe.assign(U[Ds]),Cs=ct[Ds].bBigMove,Js=ct[Ds].bIsBreak}else He=At,Ke=Ht,Cs=Bt,Js=kt,Fe.assign(Me.get().getEndXY());let vi=Pt;ce<1&&(this.splitEdgeInPlace(Pt),vi=Pt.getNextInChain()),this.updateSegmentOnly(Pt,be),0===Pt.start.hash||Pt.start.pt.equals(rs)||(this.m_newNodes.push(Pt.start),this.removeNodeFromHash(Pt.start),Pt.start.hash=0),0===Pt.end.hash||Pt.end.pt.equals(Fe)||(this.m_newNodes.push(Pt.end),this.removeNodeFromHash(Pt.end),Pt.end.hash=0),Pt.start.pt.assign(rs),Pt.end.pt.assign(Fe),Pt.start.bBigMove||=Zs,Pt.end.bBigMove||=Cs,Pt.start.bIsBreak||=di,Pt.end.bIsBreak||=Js,Pt.start.weight=Es,Pt.start.rank=ts,Pt.end.weight=He,Pt.end.rank=Ke,Pt=vi,wt=ce,Xt=qt}else-1===Xt&&(Xt=qt)}const ge=Pt.getNextInChain();return this.postProcessResultPartsForCurves(t,Zt,m,ge,d+1),A?3:2}intersectCurves(t,m){2!==this.parent.m_inputSegments.length&&(0,F.c)(""),this.parent.m_changed1=!1,this.parent.m_changed2=!1,this.parent.m_tolerance=t,this.m_hashTableOfEqualsSize=0,this.m_hashTableOfEquals=(0,Y.as)(16);const u=R.J.constructEmpty();for(let y=0;y<2;y++){const C=this.parent.allocResultSegmentFromSegment(this.parent.m_inputSegments[this.parent.m_inputParts[y].segmentIndex]),S=R.J.constructEmpty();this.parent.m_inputSegments[this.parent.m_inputParts[y].segmentIndex].queryLooseEnvelope(S),u.mergeEnvelope2D(S);const b=this.parent.m_inputParts[y];this.addSegment(C,0,b.weightStart,b.rankStart,b.weightEnd,b.rankEnd,b.weightInterior,b.rankInterior,b.u.bBreakStart,b.u.bBreakEnd,b.segmentParentage)}u.inflateCoords(100*t,100*t),this.m_origin.assign(u.getLowerLeft()),this.m_cell.setCoords(2*t,2*t),this.m_pairs.push(Ns(this.m_chainOrigin1.nextInChain,this.m_chainOrigin2.nextInChain,0,m));let g=0,d=!0;for(;this.m_pairs.length;){const y=this.m_pairs.at(-1);this.m_pairs.pop(),(0,F.g)(y.recursion>=0),(0,F.g)(y.recursion<=256),this.clusterNodes(t);const C=this.intersectCurvesHelper(y.edge1,y.edge2,t,y.bIsIntersecting,y.recursion);d&&(d=!1,g=C)}for(let y=0;y<2;y++){const C=0===y?this.parent.m_resultParts1:this.parent.m_resultParts2;for(let S=(0===y?this.m_chainOrigin1:this.m_chainOrigin2).nextInChain;null!=S;S=S.getNextInChain())C.push(this.parent.newIntersectionPart_(S.segmentIndex,S.start.weight,S.start.rank,S.end.weight,S.end.rank,S.weight,S.rank,S.start.bIsBreak,S.end.bIsBreak,S.segmentParentage)),C.at(-1).u.bBigMoveStart=S.start.bBigMove,C.at(-1).u.bBigMoveEnd=S.end.bBigMove}return g}tryOverlapIntersectCurves(t,m,u,g){const d=this.parent.m_resultSegments[t.segmentIndex].get(),y=this.parent.m_resultSegments[m.segmentIndex].get(),C=d.getStartXY().equals(y.getStartXY())&&d.getEndXY().equals(y.getEndXY()),S=d.getStartXY().equals(y.getEndXY())&&d.getEndXY().equals(y.getStartXY());if(!C&&!S)return 0;const b=(0,c.a5)(d,y,!0);if(0!==b&&(0,c.a6)(d,y)&&t.segmentParentage===m.segmentParentage){let k=!1;if(b>0)k=d.equals(y);else{(0,F.g)(-1===b);const H=new c.S({segment:y});H.get().reverse(),k=d.equals(H.get())}if(k)return 1}const A=u*Os.c_smallToleranceFactor;let T=!1;if(0===b){const k=[.5,.25,.75,.125,.375,.625,.875,.5625,.3125];for(let H=0,U=k.length;H<U;++H){const Z=k[H],st=new Y.P;d.queryCoord2D(Z,st);const mt=y.getClosestCoordinate(st,!1),ht=new Y.P;y.queryCoord2D(mt,ht);const ut=Y.P.distance(st,ht);if(ut>u)return 0;T||=ut>A}for(let H=0,U=k.length;H<U;++H){const Z=k[H],st=new Y.P;y.queryCoord2D(Z,st);const mt=d.getClosestCoordinate(st,!1),ht=new Y.P;d.queryCoord2D(mt,ht);const ut=Y.P.distance(st,ht);if(ut>u)return 0;T||=ut>A}}let M=t.rank,X=m.rank;return M===X&&(M*=Os.c_maxGeometryTypeToRankDelta,X*=Os.c_maxGeometryTypeToRankDelta,M+=Di(d.getGeometryType(),d,!0),X+=Di(y.getGeometryType(),y,!0)),M>X?(m.copyFromWhenOverlap(this,t,C),m.transferAttributes(this,d,C)):X>M?(t.copyFromWhenOverlap(this,m,C),t.transferAttributes(this,y,C)):t.segmentParentage<=m.segmentParentage?(t.weight=t.weight+m.weight,m.copyFromWhenOverlap(this,t,C),m.transferAttributes(this,d,C)):(m.weight=t.weight+m.weight,t.copyFromWhenOverlap(this,m,C),t.transferAttributes(this,y,C)),T?3:2}postProcessResultPartsForCurves(t,m,u,g,d){d===(0,Y.aE)()&&(0,F.c)("curve_helper");for(let y=t;y!==m;y=y.getNextInChain())this.updateSegmentToNodes(y);for(let y=u;y!==g;y=y.getNextInChain())this.updateSegmentToNodes(y);for(let y=t;y!==m;y=y.getNextInChain()){const C=y.end.pt.sub(y.start.pt);for(let S=u;S!==g;S=S.getNextInChain()){let b=0;if(y.start.pt.equals(S.start.pt)&&y.end.pt.equals(S.end.pt)?b=1:y.start.pt.equals(S.end.pt)&&y.end.pt.equals(S.start.pt)&&(b=-1),!b){let H=y.start.pt.equals(S.start.pt)?1:0;if(H||(H=y.end.pt.equals(S.end.pt)?2:0,H||(H=y.end.pt.equals(S.start.pt)?3:0,H||(H=y.start.pt.equals(S.end.pt)?4:0))),H){const U=S.end.pt.sub(S.start.pt),Z=C.dotProduct(U);let st;switch(H){case 1:case 2:st=Z>0;break;case 3:case 4:st=Z<0;break;default:(0,F.c)("post_process_result_parts_for_curves_")}st&&this.m_pairs.push(Ns(y,S,d,!1))}continue}const A=this.parent.m_resultSegments[y.segmentIndex],T=this.parent.m_resultSegments[S.segmentIndex],M=[.5,.25,.75];for(let H=0,U=M.length;H<U;++H){const Z=M[H],st=new Y.P;A.get().queryCoord2D(Z,st);const mt=T.get().getClosestCoordinate(st,!1),ht=new Y.P;if(T.get().queryCoord2D(mt,ht),Y.P.distance(st,ht)>this.parent.m_tolerance){b=0;break}}if(!b){this.m_pairs.push(Ns(y,S,d,!1));continue}for(let H=0,U=M.length;H<U;++H){const Z=M[H],st=new Y.P;T.get().queryCoord2D(Z,st);const mt=A.get().getClosestCoordinate(st,!1),ht=new Y.P;if(A.get().queryCoord2D(mt,ht),Y.P.distance(st,ht)>this.parent.m_tolerance){b=0;break}}if(!b){this.m_pairs.push(Ns(y,S,d,!1));continue}y.equalEdge=S,S.equalEdge=y;let X=y.rank,k=S.rank;X===k&&(X*=Os.c_maxGeometryTypeToRankDelta,k*=Os.c_maxGeometryTypeToRankDelta,X+=Di(A.get().getGeometryType(),A.get(),!0),k+=Di(T.get().getGeometryType(),T.get(),!0)),X>k||X===k&&y.segmentParentage<=S.segmentParentage?(A.copyTo(T,!1),S.segmentParentage=y.segmentParentage,-1===b&&T.get().reverse()):(T.copyTo(A,!1),y.segmentParentage=S.segmentParentage,-1===b&&A.get().reverse());break}}this.updateAttachedEdgesAfterNodeChange(t.start),m&&this.updateAttachedEdgesAfterNodeChange(m.start),this.updateAttachedEdgesAfterNodeChange(u.start),g&&this.updateAttachedEdgesAfterNodeChange(g.start)}processDoublyConnectedEdges(t,m,u,g){u===(0,Y.aE)()&&(0,F.c)("curve_helper");const d=this.getSegment(t).get(),y=this.getSegment(m).get(),C=d.getStartXY().equals(y.getStartXY())&&d.getEndXY().equals(y.getEndXY())?1:d.getEndXY().equals(y.getStartXY())&&d.getStartXY().equals(y.getEndXY())?-1:0;if(0!==C){const S=new c.S;d.queryCut(0,.5,S),S.get().snapControlPoints(g*g);const b=new c.S;d.queryCut(.5,1,b),b.get().snapControlPoints(g*g),this.splitEdgeInPlace(t),t.end.pt=S.get().getEndXY(),t.segmentIndex=this.parent.allocResultSegmentFromBuffer(S),t.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(b);let A=y.getClosestCoordinate(t.end.pt,!1);return Math.abs(A-.5)>.2&&(A=.5),y.queryCut(0,A,S),S.get().snapControlPoints(g*g),y.queryCut(A,1,b),b.get().snapControlPoints(g*g),this.splitEdgeInPlace(m),m.end.pt=S.get().getEndXY(),m.segmentIndex=this.parent.allocResultSegmentFromBuffer(S),m.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(b),C>0?(this.m_pairs.push(Ns(t,m,u,!1)),this.m_pairs.push(Ns(t.getNextInChain(),m.getNextInChain(),u,!1))):(this.m_pairs.push(Ns(t,m.getNextInChain(),u,!1)),this.m_pairs.push(Ns(t.getNextInChain(),m,u,!1))),!0}return!1}newNode(t,m,u,g){const d=new ii;return this.m_newNodes.push(d),d.pt=t,d.rank=u,d.weight=m,d.bIsBreak=g,d}newEdge(t,m,u,g,d,y){const C=new wi;return C.start=t,C.end=m,t.nextInChain=C,m.prevInChain=C,C.segmentIndex=u,C.segmentParentage=y,C.rank=d,C.weight=g,C}splitEdgeInPlace(t){t.segmentIndex=-1;const m=new wi,u=new ii;this.m_newNodes.push(u),u.pt.setNAN(),u.nextInChain=m,u.prevInChain=t,u.prevInHash=null,u.nextInHash=null,u.prevEqual=null,u.nextEqual=null,u.weight=t.weight,u.rank=t.rank,u.bIsBreak=!1,u.bBigMove=!1,m.start=u,m.segmentIndex=-1,m.end=t.end,m.end.prevInChain=m,m.rank=t.rank,m.weight=t.weight,m.segmentParentage=t.segmentParentage,t.end=u,t.equalEdge&&(t.equalEdge.equalEdge=null),t.equalEdge=null}updateSegmentOnly(t,m){t.segmentIndex=m}updateAttachedEdgesAfterNodeChange(t){for(let m=t.equalListHead();null!==m;m=m.nextEqual)this.updateAttachedEdgesAfterNodeChangeImpl(m)}updateAttachedEdgesAfterNodeChangeImpl(t){const m=t.prevInChain;if(m&&m.hasSegment()){const g=this.getSegment(m).get();t.pt.equals(g.getEndXY())||(g.setCoordsForIntersector(m.start.pt,m.end.pt,!1),g.ensureXYMonotone())}const u=t.nextInChain;if(u&&u.hasSegment()){const g=this.getSegment(u).get();t.pt.equals(g.getStartXY())||(g.setCoordsForIntersector(u.start.pt,u.end.pt,!1),g.ensureXYMonotone())}}updateSegmentToNodes(t){const m=this.getSegment(t).get();t.start.pt.equals(m.getStartXY())&&t.end.pt.equals(m.getEndXY())||(m.setCoordsForIntersector(t.start.pt,t.end.pt,!1),m.ensureXYMonotone()),this.updateAttachedEdgesAfterNodeChange(t.start),this.updateAttachedEdgesAfterNodeChange(t.end)}getSegment(t){return this.parent.m_resultSegments[t.segmentIndex]}clusterNodes(t){let m=!1;const u=[],g=[],d=[];for(let y=0,C=this.m_newNodes.length;y<C;y++){const S=this.m_newNodes[y];if(null===S)continue;let b=S;for(let A=y+1;A<C;A++){const T=this.m_newNodes[A];null!==T&&S.pt.equals(T.pt)&&(b.nextInHash=T,T.prevInHash=b,b=T,this.m_newNodes[A]=null)}}for(let y=0,C=this.m_newNodes.length;y<C;y++){const S=this.m_newNodes[y];if(null==S)continue;for(S.hash=this.calculateHash(S.pt);;){const X=(0,Y.as)(4),k=this.hashTableBinsToCheck(S,X);for(let U=0;U<k;U++)if(null!==X[U])for(let Z=X[U];null!==Z;){const st=Z.nextInHash;Y.P.distance(S.pt,Z.pt)<=t&&(u.push(Z),this.removeNodeFromHash(Z),Z.hash=0,d.push(Z),g.push(Z)),Z=st}let H=!1;for(const U of u)if(!S.pt.equals(U.pt)){const Z=hr(S.pt,U.pt,S.weight,S.rank,U.weight,U.rank);S.pt.assign(Z.pt),S.weight=Z.weight,S.rank=Z.rank,H=!0,m=!0}if(u.length=0,!H)break;S.hash=this.calculateHash(S.pt)}d.push(S),g.push(S);for(let X=S.nextInHash;null!==X;){X.prevInHash=null;const k=X.nextInHash;X.nextInHash=null,d.push(X),g.push(X),X=k}const b=S.hash;let A=null,T=null;for(const X of g)S!==X&&(X.hash=b,X.pt.assign(S.pt),X.rank=S.rank,X.weight=S.weight),X.prevInHash=A,A&&(A.nextInHash=X),X.prevEqual=T,X.nextEqual=null,T&&(T.nextEqual=X),T=X,A=X;const M=b%this.m_hashTableOfEquals.length;A.nextInHash=this.m_hashTableOfEquals[M],null!==this.m_hashTableOfEquals[M]&&(this.m_hashTableOfEquals[M].prevInHash=A),this.m_hashTableOfEquals[M]=g[0],this.m_hashTableOfEqualsSize+=g.length,g.length=0,this.rehashIfNeeded()}if(this.m_newNodes.length=0,m)for(const y of d)this.updateAttachedEdgesAfterNodeChange(y)}rehashIfNeeded(){if(2*this.m_hashTableOfEqualsSize>this.m_hashTableOfEquals.length){const t=this.m_hashTableOfEquals;this.m_hashTableOfEquals=(0,Y.as)(2*t.length),this.m_hashTableOfEqualsSize=0;for(const m of t){let u=m;for(;u;){const g=u.nextInHash;u.nextInHash=null,u.prevInHash=null,this.addNodeToHashImpl(u),u=g}}}}addNodeToHashImpl(t){const m=t.hash%this.m_hashTableOfEquals.length,u=this.m_hashTableOfEquals[m];t.nextInHash=u,null!==u&&(u.prevInHash=t),this.m_hashTableOfEquals[m]=t,this.m_hashTableOfEqualsSize++}removeNodeFromHash(t){const m=t.hash%this.m_hashTableOfEquals.length,u=t.prevInHash,g=t.nextInHash;u?u.nextInHash=g:this.m_hashTableOfEquals[m]=g,g&&(g.prevInHash=u),this.m_hashTableOfEqualsSize--,t.prevInHash=null,t.nextInHash=null}hashTableBinsToCheck(t,m){const u=(t.pt.x-this.m_origin.x)/this.m_cell.x,g=(t.pt.y-this.m_origin.y)/this.m_cell.y,d=(0,Y.i)()-1,y=Math.round((0,Y.c)(u,-2147483646,d)),C=Math.round((0,Y.c)(g,-2147483646,d));let S=y|C<<32;S=(0,Y.ar)(S),m[0]=this.m_hashTableOfEquals[S%this.m_hashTableOfEquals.length];let b=y+1|C<<32;b=(0,Y.ar)(b);let A=1;m[1]=this.m_hashTableOfEquals[b%this.m_hashTableOfEquals.length],m[1]!==m[0]&&(A=2);let T=y+1|C+1<<32;T=(0,Y.ar)(T),m[A]=this.m_hashTableOfEquals[T%this.m_hashTableOfEquals.length];for(let X=0;X<A;X++)if(m[A]===m[X]){A--;break}A++;let M=y|C+1<<32;M=(0,Y.ar)(M),m[A]=this.m_hashTableOfEquals[M%this.m_hashTableOfEquals.length];for(let X=0;X<A;X++)if(m[A]===m[X]){A--;break}return A++,A}calculateHash(t){const m=(t.x-this.m_origin.x)/this.m_cell.x,u=(t.y-this.m_origin.y)/this.m_cell.y,g=(0,Y.i)()-1;let d=Math.round((0,Y.c)(m,-2147483646,g))|Math.round((0,Y.c)(u,-2147483646,g))<<32;return d=(0,Y.ar)(d),0===d&&(d=1),d}processSharpCorners(t,m,u,g){if(this.parent.m_param1.length=0,this.parent.m_param2.length=0,t.getStartXY().equals(m.getStartXY())){const d=[0,0],y=[0,0],C=(0,c.a7)(t,m,0,0,u,2,d,y,g);if(C){this.parent.m_param1.push(0),this.parent.m_param2.push(0);for(let S=0;S<C;S++)this.parent.m_param1.push(d[S]),this.parent.m_param2.push(y[S]);return C+1}}if(t.getEndXY().equals(m.getEndXY())){const d=[0,0],y=[0,0],C=(0,c.a7)(t,m,1,1,u,2,d,y,g);if(C){for(let S=0;S<C;S++)this.parent.m_param1.push(d[S]),this.parent.m_param2.push(y[S]);return this.parent.m_param1.push(1),this.parent.m_param2.push(1),C+1}}if(t.getStartXY().equals(m.getEndXY())){const d=[0,0],y=[0,0],C=(0,c.a7)(t,m,0,1,u,2,d,y,g);if(C){this.parent.m_param1.push(0),this.parent.m_param2.push(1);for(let S=0;S<C;S++)this.parent.m_param1.push(d[S]),this.parent.m_param2.push(y[S]);return C+1}}if(t.getEndXY().equals(m.getStartXY())){const d=[0,0],y=[0,0],C=(0,c.a7)(t,m,1,0,u,2,d,y,g);if(C){for(let S=0;S<C;S++)this.parent.m_param1.push(d[S]),this.parent.m_param2.push(y[S]);return this.parent.m_param1.push(1),this.parent.m_param2.push(0),C+1}}return 0}}function Di(P,t,m){let u=0;switch(P){case F.G.enumLine:u=0;break;case F.G.enumBezier:u=2;break;case F.G.enumRationalBezier2:u=3;break;case F.G.enumBezier2:u=1;break;case F.G.enumEllipticArc:u=0===t.projectionBehavior()?5:4;break;default:(0,F.c)("")}return m?5-u:u}class Ti extends zr{constructor(t){super(t.m_shape,t.m_tolerance,!1),this.m_parent=t}compare(t,m,u){if(this.m_bIntersectionDetected)return-1;const g=t.getElement(u),d=this.m_parent.getEdgeOriginVertices(m),y=this.m_parent.m_edgeVertices.getFirstElement(d),C=this.m_parent.getEdgeOriginVertices(g),S=this.m_parent.m_edgeVertices.getFirstElement(C);return this.m_currentNode=u,this.compareSegments(m,y,g,S)}}class Mn extends ar{constructor(t){super(t.m_shape,t.m_tolerance),this.m_parent=t}compare(t,m){if(this.m_bIntersectionDetected)return-1;const u=t.getElement(m),g=this.m_parent.getEdgeOriginVertices(u),d=this.m_parent.m_edgeVertices.getFirstElement(g);return this.m_currentNode=m,this.compareVertex(t,m,d)}}class Go extends dt.a6{constructor(t){super(),this.pt1=Y.P.getNAN(),this.pt2=Y.P.getNAN(),this.m_shape=t}compare(t,m,u){this.m_shape.queryXY(m,this.pt1);const g=t.getElement(u);return this.m_shape.queryXY(g,this.pt2),this.pt1.compare(this.pt2)}}class Gt{constructor(t){this.m_point=Y.P.getNAN(),this.m_pt=Y.P.getNAN(),this.m_shape=t}setPoint(t){this.m_point.setCoordsPoint2D(t)}compare(t,m){const u=t.getElement(m);return this.m_shape.queryXY(u,this.m_pt),this.m_point.compare(this.m_pt)}}class w{constructor(t,m){this.m_shape=null,this.m_progressTracker=null,this.m_edges=new dt.S(8),this.m_clusters=new dt.S(5),this.m_clusterVertices=new Oe(!1),this.m_edgeVertices=new Oe(!1),this.m_helperPoint=new dt.P,this.m_eventQ=new dt.T,this.m_sweepStructure=new dt.T,this.m_bComplications=!1,this.m_sweepComparator=null,this.m_tempEdgeBuffer=[],this.m_modifiedClusters=[],this.m_edgesToInsertInSweepStructure=[],this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1,this.m_progressCounter=0,this.m_segmentIntersector=new Os,this.m_segBuf1=new c.S,this.m_segBuf2=new c.S,this.m_sweepPoint=new Y.P(0,0),this.m_tolerance=0,this.m_toleranceSqr=0,this.m_sweepPointCluster=-1,this.m_vertexClusterIndex=-1,this.m_bCracked=!1,this.m_bSweepPointClusterWasModified=!1,this.m_progressTracker=t,this.m_bTrackChanges=m}hadComplications(){return this.m_bComplications}sweep(t,m){const u=new Wt.T;u.setSwapCoordinates(),t.applyTransformation(u),this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=m,this.m_toleranceSqr=m*m;let g=this.sweepImpl_();return t.applyTransformation(u),g||(this.fillEventQueuePass2(),g=this.sweepImpl_()||g),this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_shape=null,this.m_bCracked}sweepVertical(t,m){this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=m,this.m_toleranceSqr=m*m,this.m_bComplications=!1;let u=this.sweepImpl_();if(!this.m_bComplications){const g=t.filterClosePoints(m,!0,!1,this.m_bTrackChanges,c.n);this.m_bComplications=1===g,u||=1===g}return-1!==this.m_vertexClusterIndex&&(this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_vertexClusterIndex=-1),this.m_shape=null,u}getEdgeCluster(t,m){return this.m_edges.getField(t,0+m)}setEdgeCluster_(t,m,u){this.m_edges.setField(t,0+m,u)}getEdgeOriginVertices(t){return this.m_edges.getField(t,2)}setEdgeOriginVertices_(t,m){this.m_edges.setField(t,2,m)}getNextEdgeEx(t,m){return this.m_edges.getField(t,3+m)}setNextEdgeEx_(t,m,u){this.m_edges.setField(t,3+m,u)}getEdgeSweepNode(t){return this.m_edges.getField(t,7)}setEdgeSweepNode_(t,m){this.m_edges.setField(t,7,m)}getNextEdge(t,m){const u=this.getEdgeEnd(t,m);return this.m_edges.getField(t,3+u)}setNextEdge_(t,m,u){const g=this.getEdgeEnd(t,m);this.m_edges.setField(t,3+g,u)}getPrevEdge(t,m){const u=this.getEdgeEnd(t,m);return this.m_edges.getField(t,5+u)}setPrevEdge_(t,m,u){const g=this.getEdgeEnd(t,m);this.m_edges.setField(t,5+g,u)}getClusterVertices(t){return this.m_clusters.getField(t,0)}setClusterVertices_(t,m){this.m_clusters.setField(t,0,m)}getClusterSweepEdgeList(t){return this.m_clusters.getField(t,2)}setClusterSweepEdgeList_(t,m){this.m_clusters.setField(t,2,m)}getClusterFirstEdge(t){return this.m_clusters.getField(t,1)}setClusterFirstEdge_(t,m){this.m_clusters.setField(t,1,m)}getClusterEventQNode(t){return this.m_clusters.getField(t,3)}setClusterEventQNode_(t,m){this.m_clusters.setField(t,3,m)}newCluster_(t){const m=this.m_clusters.newElement(),u=this.m_clusterVertices.createList();return this.setClusterVertices_(m,u),t!==c.n&&(this.m_clusterVertices.addElement(u,t),this.m_shape.setUserIndex(t,this.m_vertexClusterIndex,m)),m}deleteCluster_(t){this.m_clusters.deleteElement(t)}addVertexToCluster_(t,m){const u=this.getClusterVertices(t);this.m_clusterVertices.addElement(u,m),this.m_shape.setUserIndex(m,this.m_vertexClusterIndex,t)}newEdge_(t){const m=this.m_edges.newElement(),u=this.m_edgeVertices.createList();return this.setEdgeOriginVertices_(m,u),-1!==t&&this.m_edgeVertices.addElement(u,t),m}addVertexToEdge_(t,m){const u=this.getEdgeOriginVertices(t);this.m_edgeVertices.addElement(u,m)}deleteEdge_(t){this.m_edges.deleteElement(t);const m=this.m_edgesToInsertInSweepStructure.findIndex(u=>u===t);m>=0&&(0,Y.aA)(this.m_edgesToInsertInSweepStructure,m)}addEdgeToCluster(t,m){-1===this.getEdgeCluster(t,0)?this.setEdgeCluster_(t,0,m):-1===this.getEdgeCluster(t,1)?this.setEdgeCluster_(t,1,m):(0,F.c)(""),this.addEdgeToClusterImpl_(t,m)}addEdgeToClusterImpl_(t,m){const u=this.getClusterFirstEdge(m);if(-1!==u){const g=this.getNextEdge(u,m);this.setPrevEdge_(g,m,t),this.setNextEdge_(t,m,g),this.setNextEdge_(u,m,t),this.setPrevEdge_(t,m,u)}else this.setPrevEdge_(t,m,t),this.setNextEdge_(t,m,t),this.setClusterFirstEdge_(m,t)}getEdgeEnd(t,m){return this.getEdgeCluster(t,0)===m?0:1}mergeClusters_(t,m){this.dbgCheckCluster_(t),this.dbgCheckCluster_(m);const u=this.getClusterEventQNode(m);-1!==u&&(this.m_eventQ.deleteNode(u),this.setClusterEventQNode_(m,-1));let g=this.getClusterFirstEdge(t),d=this.getClusterFirstEdge(m);if(-1!==d){let S=d,b=d,A=!1;do{this.dbgCheckEdge_(S),A=!1;const T=this.getEdgeEnd(S,m),M=this.getNextEdgeEx(S,T);if(this.getEdgeCluster(S,T+1&1)===t){this.disconnectEdge_(S);const X=this.getEdgeOriginVertices(S);if(this.m_edgeVertices.deleteList(X),this.deleteEdge_(S),S===M){d=-1;break}d===S&&(d=this.getClusterFirstEdge(m),b=M,A=!0)}S=M}while(S!==b||A);if(-1!==d){do{const T=this.getEdgeEnd(S,m),M=this.getNextEdgeEx(S,T);this.setEdgeCluster_(S,T,t),S=M}while(S!==b);if(g=this.getClusterFirstEdge(t),-1!==g){const T=this.getNextEdge(g,t),M=this.getNextEdge(d,t);T===g?(this.setClusterFirstEdge_(t,d),this.addEdgeToClusterImpl_(g,t),this.setClusterFirstEdge_(t,g)):M===d&&this.addEdgeToClusterImpl_(d,t),this.setNextEdge_(d,t,T),this.setPrevEdge_(T,t,d),this.setNextEdge_(g,t,M),this.setPrevEdge_(M,t,g)}else this.setClusterFirstEdge_(t,d)}}const y=this.getClusterVertices(t),C=this.getClusterVertices(m);for(let S=this.m_clusterVertices.getFirst(C);-1!==S;S=this.m_clusterVertices.getNext(S)){const b=this.m_clusterVertices.getElement(S);this.m_shape.setUserIndex(b,this.m_vertexClusterIndex,t)}this.m_clusterVertices.concatenateLists(y,C),this.deleteCluster_(m),this.dbgCheckCluster_(t)}mergeEdges_(t,m){this.dbgCheckEdge_(t),this.dbgCheckEdge_(m);const u=this.getEdgeCluster(t,0),g=this.getEdgeCluster(t,1),d=this.getEdgeCluster(m,0),y=this.getEdgeCluster(m,1),C=this.getEdgeOriginVertices(t),S=this.getEdgeOriginVertices(m);if(this.m_edgeVertices.concatenateLists(C,S),m===this.getClusterFirstEdge(u)&&this.setClusterFirstEdge_(u,t),m===this.getClusterFirstEdge(g)&&this.setClusterFirstEdge_(g,t),this.disconnectEdge_(m),this.deleteEdge_(m),!(u===d&&g===y||g===d&&u===y)){const b=this.getClusterXY(u),A=this.getClusterXY(d);b.isEqualPoint2D(A)?(u!==d&&this.mergeClusters_(u,d),g!==y&&this.mergeClusters_(g,y)):(g!==d&&this.mergeClusters_(g,d),u!==y&&this.mergeClusters_(u,y))}this.dbgCheckEdge_(t)}disconnectEdge_(t){const m=this.getEdgeCluster(t,0),u=this.getEdgeCluster(t,1);this.disconnectEdgeFromCluster_(t,m),this.disconnectEdgeFromCluster_(t,u)}disconnectEdgeFromCluster_(t,m){const u=this.getNextEdge(t,m),g=this.getPrevEdge(t,m),d=this.getClusterFirstEdge(m);u!==t?(this.setNextEdge_(g,m,u),this.setPrevEdge_(u,m,g),d===t&&this.setClusterFirstEdge_(m,u)):this.setClusterFirstEdge_(m,-1)}applyIntersectorToEditShape_(t,m,u){let g=this.m_edgeVertices.getFirst(t);const d=this.m_edgeVertices.getElement(g),y=this.getClusterFromVertex(d),C=this.m_shape.getNextVertex(d),S=this.getClusterFromVertex(C),b=this.m_shape.getXY(d),A=this.m_shape.getXY(C);let T=!1,M=!1;const X=m.getResultSegment(u,0).getStartXY(),k=m.getResultSegment(u,m.getResultSegmentCount(u)-1).getEndXY();b.equals(X)||(T=!0),A.equals(k)||(M=!0),this.m_shape.splitSegmentWithIntersector(d,m,u,!0,!0);const H=this.m_bTrackChanges&&m.getSegmentChanged(u);for(H&&this.m_shape.setGeometryModifiedWithVertex(d,!0),g=this.m_edgeVertices.getNext(g);-1!==g;g=this.m_edgeVertices.getNext(g)){const U=this.m_edgeVertices.getElement(g),Z=this.getClusterFromVertex(U)===y;this.m_shape.splitSegmentWithIntersector(U,m,u,Z,!0),H&&this.m_shape.setGeometryModifiedWithVertex(U,!0)}if(T&&this.updateClusterXY(!0,y,X,m.getResultSegmentStartPointWeight(u,0),m.getResultSegmentStartPointRank(u,0)),M){const U=m.getResultSegmentCount(u)-1;this.updateClusterXY(!0,S,k,m.getResultSegmentEndPointWeight(u,U),m.getResultSegmentEndPointRank(u,U))}}createEdgesAndClustersFromSplitEdge_(t,m,u){this.dbgCheckNewEdgesArray_();const g=this.getEdgeOriginVertices(t),d=this.getEdgeCluster(t,0),y=this.getEdgeCluster(t,1);let C=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(C);const S=dt.S.impossibleIndex3();this.setEdgeSweepNode_(C,S),this.m_tempEdgeBuffer.push(C),this.addEdgeToCluster(C,d);const b=m.getResultSegmentCount(u);for(let A=1;A<b;A++){const T=this.newCluster_(-1);this.m_modifiedClusters.push(T),this.m_tempEdgeBuffer.push(T),this.addEdgeToCluster(C,T);const M=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(M),this.setEdgeSweepNode_(M,S),this.m_tempEdgeBuffer.push(M),this.addEdgeToCluster(M,T),C=M}this.addEdgeToCluster(C,y);for(let A=this.m_edgeVertices.getFirst(g);-1!==A;A=this.m_edgeVertices.getNext(A)){let T=this.m_edgeVertices.getElement(A);if(this.getClusterFromVertex(T)===d){let M=0;const X=this.m_tempEdgeBuffer.length;do{M>0&&this.addVertexToCluster_(this.m_tempEdgeBuffer[M-1],T);const k=this.m_tempEdgeBuffer[M];M+=2,this.addVertexToEdge_(k,T),T=this.m_shape.getNextVertex(T)}while(M<X)}else{let M=this.m_tempEdgeBuffer.length-1;do{M<this.m_tempEdgeBuffer.length-2&&this.addVertexToCluster_(this.m_tempEdgeBuffer[M+1],T);const X=this.m_tempEdgeBuffer[M];M-=2,this.addVertexToEdge_(X,T),T=this.m_shape.getNextVertex(T)}while(M>=0)}}this.m_tempEdgeBuffer.length=0,this.dbgCheckNewEdgesArray_()}getVertexFromClusterIndex(t){const m=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(m)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_vertexClusterIndex)}processSplitHelper1_(t,m,u){const g=this.getEdgeCluster(m,0),d=this.getClusterXY(g),y=this.getEdgeCluster(m,1),C=this.getClusterXY(y),S=u.getResultSegmentCount(t);let b=u.getResultSegment(t,0);const A=b.getStartXY();if(d.isEqualPoint2D(A)||(this.m_bComplications||d.compare(this.m_sweepPoint)*A.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0),this.getAffectedEdges(g,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(g)),!this.m_bComplications&&S>1){const M=d.compare(C),X=b.getEndXY();(d.compare(X)!==M||X.compare(C)!==M||X.compare(this.m_sweepPoint)<0)&&(this.m_bComplications=!0)}b=u.getResultSegment(t,S-1);const T=b.getEndXY();C.isEqualPoint2D(T)||(this.m_bComplications||C.compare(this.m_sweepPoint)*T.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0),this.getAffectedEdges(y,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(y)),this.m_tempEdgeBuffer.push(m);for(let M=0,X=this.m_tempEdgeBuffer.length;M<X;M++){const k=this.m_tempEdgeBuffer[M],H=this.getEdgeSweepNode(k);dt.S.isValidElement(H)&&(this.m_sweepStructure.deleteNode(H),this.setEdgeSweepNode_(k,-1));const U=dt.S.impossibleIndex3();k!==m&&this.getEdgeSweepNode(k)!==U&&(this.m_edgesToInsertInSweepStructure.push(k),this.setEdgeSweepNode_(k,U))}this.m_tempEdgeBuffer.length=0}checkAndFixIntersection_(t,m){const u=this.m_sweepStructure.getElement(t);return this.m_sweepComparator.compare(this.m_sweepStructure,u,m),!!this.m_sweepComparator.intersectionDetected()&&(this.m_sweepComparator.clearIntersectionDetectedFlag(),this.fixIntersection_(t,m),!0)}fixIntersection_(t,m){this.m_bCracked=!0;const u=this.m_sweepStructure.getElement(t),g=this.m_sweepStructure.getElement(m);let d=null,y=null;const C=this.getEdgeOriginVertices(u),S=this.m_edgeVertices.getFirstElement(C),b=this.getEdgeOriginVertices(g),A=this.m_edgeVertices.getFirstElement(b),T=this.m_shape.querySegment(S,this.m_segBuf1,!1,!1);(0,F.g)(T),d=this.m_segBuf1.get();const M=this.m_shape.getNextVertex(S),X=this.m_shape.getWeight(S),k=this.m_shape.getSegmentParentageBreakVertex(S),H=this.m_shape.getWeight(M),U=this.m_shape.getSegmentParentageBreakVertex(M),Z=this.m_shape.getSegmentWeight(S),st=this.m_shape.getRank(S),mt=this.m_shape.getRank(M),ht=this.m_shape.getSegmentRank(S),ut=this.m_shape.getSegmentParentage(S),ct=this.m_shape.querySegment(A,this.m_segBuf2,!1,!1);(0,F.g)(ct),y=this.m_segBuf2.get();const Et=this.m_shape.getNextVertex(A),Tt=this.m_shape.getWeight(A),Pt=this.m_shape.getSegmentParentageBreakVertex(A),At=this.m_shape.getWeight(Et),Ht=this.m_shape.getSegmentParentageBreakVertex(Et),Bt=this.m_shape.getSegmentWeight(A),kt=this.m_shape.getRank(A),wt=this.m_shape.getRank(Et),Xt=this.m_shape.getSegmentRank(A),Zt=this.m_shape.getSegmentParentage(A);this.m_segmentIntersector.pushSegment(d,X,st,H,mt,Z,ht,k,U,ut),this.m_segmentIntersector.pushSegment(y,Tt,kt,At,wt,Bt,Xt,Pt,Ht,Zt),3===this.m_segmentIntersector.intersect2D(this.m_tolerance,!0)&&(this.m_bComplications=!0),this.splitEdge_(u,g,-1,this.m_segmentIntersector),this.m_segmentIntersector.clear()}fixIntersectionPointSegment_(t,m){this.m_bCracked=!0;const u=this.m_sweepStructure.getElement(m);let g=null;const d=this.getEdgeOriginVertices(u),y=this.m_edgeVertices.getFirstElement(d),C=this.m_shape.querySegment(y,this.m_segBuf1,!1,!1);(0,F.g)(C),g=this.m_segBuf1.get();const S=this.m_shape.getNextVertex(y),b=this.m_shape.getWeight(y),A=this.m_shape.getSegmentParentageBreakVertex(y),T=this.m_shape.getWeight(S),M=this.m_shape.getSegmentParentageBreakVertex(S),X=this.m_shape.getSegmentWeight(y),k=this.m_shape.getRank(y),H=this.m_shape.getRank(S),U=this.m_shape.getSegmentRank(y),Z=this.m_shape.getSegmentParentage(y),st=this.getClusterFirstVertex(t);this.m_segmentIntersector.pushSegment(g,b,k,T,H,X,U,A,M,Z),this.m_shape.queryPoint(st,this.m_helperPoint);const mt=this.m_shape.getWeight(st),ht=this.m_shape.getRank(st);this.m_segmentIntersector.intersect2DEx(this.m_tolerance,this.m_helperPoint,ht,mt,!0),this.splitEdge_(u,-1,t,this.m_segmentIntersector),this.m_segmentIntersector.clear()}insertNewEdges_(){if(0===this.m_edgesToInsertInSweepStructure.length)return!0;this.dbgCheckNewEdgesArray_();let t=!0,m=0;const g=Math.max(2*this.m_edgesToInsertInSweepStructure.length+200,this.m_sweepStructure.size()+200);for(;this.m_edgesToInsertInSweepStructure.length;){if(this.m_edgesToInsertInSweepStructure.length>Math.max(100,this.m_shape.getTotalPointCount())||m>g){this.m_edgesToInsertInSweepStructure.length=0,this.m_bComplications=!0,t=!1;break}const d=this.m_edgesToInsertInSweepStructure.at(-1);this.m_edgesToInsertInSweepStructure.pop(),this.setEdgeSweepNode_(d,-1);const y=this.isEdgeOnSweepLine_(d);dt.S.isValidElement(y)?(this.insertNewEdgeToSweepStructure_(d,y),m++):y!==dt.S.impossibleIndex2()&&(t=!1),this.m_bContinuingSegmentChainOptimization=!1}return t}insertNewEdgeToSweepStructure_(t,m){let u;if(this.m_bContinuingSegmentChainOptimization?(u=this.m_sweepStructure.addElementAtPosition(this.m_prevNeighbour,this.m_nextNeighbour,t,!0,!0),this.m_bContinuingSegmentChainOptimization=!1):u=this.m_sweepStructure.addUniqueElement(t),-1===u){const g=this.m_sweepStructure.getDuplicateElement(),d=this.m_sweepStructure.getElement(g);return this.mergeEdges_(d,t),!1}if(this.setEdgeSweepNode_(t,u),this.m_sweepComparator.intersectionDetected()){this.m_sweepComparator.clearIntersectionDetectedFlag();const g=this.m_sweepComparator.getLastComparedNode();return this.m_prevNeighbour===g&&(this.m_prevNeighbour=-1),this.m_nextNeighbour===g&&(this.m_nextNeighbour=-1),this.fixIntersection_(g,u),!0}return!1}isEdgeOnSweepLine_(t){const m=this.getEdgeCluster(t,0),u=this.getEdgeCluster(t,1),g=this.getClusterXY(m),d=this.getClusterXY(u);if(Y.P.sqrDistance(g,d)<=this.m_toleranceSqr)return this.m_bComplications=!0,-1;const y=g.compare(this.m_sweepPoint),C=d.compare(this.m_sweepPoint);return y<=0&&C>0?u:C<=0&&y>0?m:y>0&&C>0?dt.S.impossibleIndex2():-1}fillEventQueue(){const t=new dt.A(0),m=this.m_shape.queryVertexIteratorOnSelection();for(let d=m.next();d!==c.n;d=m.next())-1!==this.m_shape.getUserIndex(d,this.m_vertexClusterIndex)&&t.add(d);this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0),this.m_eventQ.clear(),this.m_eventQ.setCapacity(t.size()),this.m_eventQ.setComparator(new Go(this.m_shape));const u=Y.P.getNAN();u.setNAN();let g=-1;for(let d=0,y=t.size();d<y;d++){const C=t.read(d);if(this.m_shape.getXY(C).isEqualPoint2D(u)){const b=this.m_shape.getUserIndex(C,this.m_vertexClusterIndex);this.mergeClusters_(g,b);continue}g=this.getClusterFromVertex(C),this.m_shape.queryXY(C,u);const S=this.m_eventQ.addBiggestElement(C);this.setClusterEventQNode_(g,S)}}fillEventQueuePass2(){const t=new dt.A(0);for(let m=this.m_eventQ.getFirst();-1!==m;m=this.m_eventQ.getNext(m)){const u=this.m_eventQ.getElement(m);t.add(u)}this.m_eventQ.clear(),this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0);for(let m=0,u=t.size();m<u;m++){const g=t.read(m),d=this.getClusterFromVertex(g),y=this.m_eventQ.addBiggestElement(g);this.setClusterEventQNode_(d,y)}}getAffectedEdges(t,m){const u=this.getClusterFirstEdge(t);if(-1===u)return;let g=u;do{const d=this.getEdgeSweepNode(g);dt.S.isValidElement(d)&&m.push(g),g=this.getNextEdge(g,t)}while(g!==u)}updateClusterXY(t,m,u,g,d){const y=this.getClusterVertices(m);for(let C=this.m_clusterVertices.getFirst(y);-1!==C;C=this.m_clusterVertices.getNext(C)){const S=this.m_clusterVertices.getElement(C);this.m_shape.setXYMonotonicPoint2D(S,u),this.m_shape.setWeight(S,g),this.m_shape.setRank(S,d),t&&this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(S,!0),this.m_shape.setSegmentParentageBreakVertex(S,!0)}}splitEdge_(t,m,u,g){this.dbgCheckEdge_(t),-1!==m&&this.dbgCheckEdge_(m),this.disconnectEdge_(t),-1!==m&&this.disconnectEdge_(m),this.processSplitHelper1_(0,t,g),-1!==m&&this.processSplitHelper1_(1,m,g),-1!==u&&g.getResultPointChanged()&&this.m_modifiedClusters.push(u);for(let C=0,S=this.m_modifiedClusters.length;C<S;C++){const b=this.m_modifiedClusters[C],A=this.getClusterEventQNode(b);-1!==A&&(this.m_eventQ.deleteNode(A),this.setClusterEventQNode_(b,-1))}const d=this.getEdgeOriginVertices(t),y=-1!==m?this.getEdgeOriginVertices(m):-1;if(this.applyIntersectorToEditShape_(d,g,0),-1!==y)this.applyIntersectorToEditShape_(y,g,1);else{const C=g.getResultPoint().getXY();this.updateClusterXY(g.getResultPointChanged(),u,C,g.getResultPointWeight(),g.getResultPointRank())}this.createEdgesAndClustersFromSplitEdge_(t,g,0),-1!==m&&this.createEdgesAndClustersFromSplitEdge_(m,g,1),this.m_edgeVertices.deleteList(d),this.deleteEdge_(t),-1!==m&&(this.m_edgeVertices.deleteList(y),this.deleteEdge_(m));for(let C=0,S=this.m_modifiedClusters.length;C<S;C++){const b=this.m_modifiedClusters[C];b===this.m_sweepPointCluster&&(this.m_bSweepPointClusterWasModified=!0);let A=this.getClusterEventQNode(b);if(-1===A){const T=this.getClusterFirstVertex(b);if(A=this.m_eventQ.addUniqueElement(T),-1===A){const M=this.m_eventQ.getDuplicateElement(),X=this.m_eventQ.getElement(M),k=this.getClusterFromVertex(X);this.mergeClusters_(k,b)}else this.setClusterEventQNode_(b,A)}}this.m_modifiedClusters.length=0}getClusterXY(t){const m=this.getClusterFirstVertex(t);return this.m_shape.getXY(m)}getClusterFirstVertex(t){const m=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(m)}dbgCheckEdge_(t){}dbgCheckCluster_(t){}dbgCheckNewEdgesArray_(){}dbgSaveSweepStructure_(t){}sweepImpl_(){this.progress_(!0),this.m_bSweepPointClusterWasModified=!1,this.m_sweepPointCluster=-1,null===this.m_sweepComparator&&(this.m_sweepStructure.disableBalancing(),this.m_sweepComparator=new Ti(this),this.m_sweepStructure.setComparator(this.m_sweepComparator));const t=[];let m=null,u=null;this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1;const g=dt.S.impossibleIndex2(),d=dt.S.impossibleIndex3();for(let y=this.m_eventQ.getFirst();-1!==y;){this.progress_(),this.dbgCheckSweepStructure_(),this.m_bContinuingSegmentChainOptimization=!1,this.m_prevNeighbour=-1,this.m_nextNeighbour=-1;const C=this.m_eventQ.getElement(y);this.m_sweepPointCluster=this.getClusterFromVertex(C),this.m_shape.queryXY(C,this.m_sweepPoint),this.m_sweepComparator.setSweepY(this.m_sweepPoint.y,this.m_sweepPoint.x);let S=!1;{const A=this.getClusterFirstEdge(this.m_sweepPointCluster);if(S=-1===A,!S){let T=A;do{const M=this.getEdgeSweepNode(T);-1===M?(this.m_edgesToInsertInSweepStructure.push(T),this.setEdgeSweepNode_(T,d)):M!==d&&t.push(M),T=this.getNextEdge(T,this.m_sweepPointCluster)}while(T!==A)}}if(!this.m_sweepStructure.isAutoBalancing()&&(this.m_sweepStructure.getMaxDepthEver()>4||this.m_edgesToInsertInSweepStructure.length>10)&&this.m_sweepStructure.enableBalancing(),t.length>0){this.m_bContinuingSegmentChainOptimization=1===t.length&&1===this.m_edgesToInsertInSweepStructure.length;for(let M=0,X=t.length;M<X;M++){const k=this.m_sweepStructure.getElement(t[M]);this.setEdgeSweepNode_(k,g)}let A=g,T=g;for(let M=0,X=t.length;M<X;M++){const k=t[M];if(A===g){const H=this.m_sweepStructure.getPrev(k);if(-1!==H){const U=this.m_sweepStructure.getElement(H);this.getEdgeSweepNode(U)!==g&&(A=H)}else A=-1}if(T===g){const H=this.m_sweepStructure.getNext(k);if(-1!==H){const U=this.m_sweepStructure.getElement(H);this.getEdgeSweepNode(U)!==g&&(T=H)}else T=-1}if(A!==g&&T!==g)break}for(let M=0,X=t.length;M<X;M++){const k=t[M],H=this.m_sweepStructure.getElement(k);this.m_sweepStructure.deleteNode(k),this.setEdgeSweepNode_(H,-1)}t.length=0,this.m_prevNeighbour=A,this.m_nextNeighbour=T,-1!==A&&-1!==T?this.m_bContinuingSegmentChainOptimization||this.checkAndFixIntersection_(A,T):-1===A&&-1===T&&(this.m_bContinuingSegmentChainOptimization=!1)}else S&&(null===m&&(m=new Mn(this)),m.setPoint(this.m_sweepPoint),this.m_sweepStructure.searchUpperBound(m),m.intersectionDetected()&&(m.clearIntersectionDetectedFlag(),this.fixIntersectionPointSegment_(this.m_sweepPointCluster,m.getCurrentNode())));const b=this.m_bContinuingSegmentChainOptimization;!this.insertNewEdges_()&&b&&-1!==this.m_prevNeighbour&&-1!==this.m_nextNeighbour&&this.checkAndFixIntersection_(this.m_prevNeighbour,this.m_nextNeighbour),this.m_bSweepPointClusterWasModified?(this.m_bSweepPointClusterWasModified=!1,null===u&&(u=new Gt(this.m_shape)),u.setPoint(this.m_sweepPoint),y=this.m_eventQ.searchUpperBound(u)):y=this.m_eventQ.getNext(y)}return this.m_bCracked}setEditShape_(t){this.m_shape=t,this.m_vertexClusterIndex=this.m_shape.createUserIndex(),this.m_edges.setCapacity(t.getSelectedCount()+32),this.m_clusters.setCapacity(t.getSelectedCount()),this.m_clusterVertices.reserveLists(t.getSelectedCount()),this.m_clusterVertices.reserveNodes(t.getSelectedCount()),this.m_edgeVertices.reserveLists(t.getSelectedCount()+32),this.m_edgeVertices.reserveNodes(t.getSelectedCount()+32);for(let m=this.m_shape.getFirstGeometry();m!==c.n;m=this.m_shape.getNextGeometry(m))if((0,F.h)(this.m_shape.getGeometryType(m)))for(let u=this.m_shape.getFirstPath(m);u!==c.n;u=this.m_shape.getNextPath(u)){const g=this.m_shape.getPathSize(u),d=this.m_shape.getFirstVertex(u);if(d===c.n)continue;let y=this.m_shape.getNextVertex(d);if(y===c.n||y===d)continue;let C=-1;t.selected(d)&&(C=this.newCluster_(d));let S=-1;-1!==C&&t.selected(y)&&(S=this.newEdge_(d),this.addEdgeToCluster(S,C));let b=S;for(let A=0,T=g-2;A<T;A++){const M=this.m_shape.getNextVertex(y);let X=-1;if(this.m_shape.selected(y)){const k=this.newCluster_(y);-1!==b&&this.addEdgeToCluster(b,k),this.m_shape.selected(M)&&(X=this.newEdge_(y),this.addEdgeToCluster(X,k))}b=X,y=M}if(this.m_shape.isClosedPath(u)){const A=this.m_shape.getNextVertex(y);if(this.m_shape.selected(y)){const T=this.newCluster_(y);if(-1!==b&&this.addEdgeToCluster(b,T),this.m_shape.selected(A)){const M=this.newEdge_(y);this.addEdgeToCluster(M,T),this.addEdgeToCluster(M,C)}}}else{let A=-1;this.m_shape.selected(y)&&(A=this.newCluster_(y),-1!==b&&this.addEdgeToCluster(b,A))}}else for(let u=this.m_shape.getFirstPath(m);u!==c.n;u=this.m_shape.getNextPath(u)){let g=this.m_shape.getFirstVertex(u);for(let d=0,y=this.m_shape.getPathSize(u);d<y;d++)this.m_shape.selected(g)&&this.newCluster_(g),g=this.m_shape.getNextVertex(g)}this.fillEventQueue()}progress_(t=!1){}dbgCheckSweepStructure_(){}}function W(P,t,m){return{vertex0:P,vertex1:t,dir:m}}class it{constructor(t){this.m_shape=null,this.m_spikes=[],this.m_points=new dt.A(0),this.m_pointsIndex=-1,this.m_dissolvedEdges=0,this.m_progressTracker=t}executeImpl_(t,m){if(this.m_shape=t,t.getPathCount(m)<2&&t.getPointCount(m)<6)return;this.m_points.resize(0);for(let T=t.getFirstPath(m);T!==c.n;T=t.getNextPath(T)){let M=t.getFirstVertex(T);for(let X=0,k=t.getPathSize(T);X<k;X++,M=t.getNextVertex(M))this.m_points.add(M)}this.m_pointsIndex=t.createUserIndex();for(let T=0,M=this.m_points.size();T<M;++T)t.setUserIndex(this.m_points.read(T),this.m_pointsIndex,T);t.sortVerticesSimpleByY(this.m_points,0,this.m_points.size());let u=this.m_points.read(0);const g=t.getXY(u);let d=1,y=0;const C=[];for(let T=1;T<this.m_points.size();T++){const M=this.m_points.read(T);if(M===c.n||-1===t.getUserIndex(M,this.m_pointsIndex))continue;const X=t.getXY(M);if(X.isEqualPoint2D(g))d++;else{if(d>1){for(let k=y;k<T;k++){const H=this.m_points.read(k);if(-1===t.getUserIndex(H,this.m_pointsIndex))continue;const U=t.getNextVertex(H),Z=t.getPrevVertex(H);if(H!==U&&!t.isEqualXYPoint2D(U,g)){const st=W(H,U,1);C.push(st)}if(H!==Z&&Z!==U&&!t.isEqualXYPoint2D(Z,g)){const st=W(H,Z,-1);C.push(st)}}C.length>0&&this.processBunch_(C,g)}u=M,g.assign(X),d=1,y=T}}if(0===this.m_dissolvedEdges)return t.removeUserIndex(this.m_pointsIndex),void(this.m_pointsIndex=-1);let S=t.getPointCount(m);for(let T=0;T<this.m_points.size();T++){const M=this.m_points.read(T);if(M===c.n)continue;if(-1!==t.getUserIndex(M,this.m_pointsIndex)){t.setUserIndex(M,this.m_pointsIndex,-1);continue}const X=t.getPathFromVertex(M);t.getFirstVertex(X)===M&&t.setFirstVertex(X,c.n),t.freeVertex(M),this.m_points.write(T,c.n),S--}const b=t.createPathUserIndex();let A=t.getPathCount(m);for(let T=0,M=this.m_points.size();T<M;++T){if(this.m_points.read(T)===c.n)continue;let X=this.m_points.read(T);if(-1!==t.getUserIndex(X,this.m_pointsIndex))continue;let k=t.getPathFromVertex(X),H=-1;if(2===t.getPathUserIndex(k,b)){k=c.n;for(let mt=t.getNextVertex(X);mt!==X;mt=t.getNextVertex(mt)){const ht=t.getPathFromVertex(mt);if(2!==t.getPathUserIndex(ht,b)){k=ht,X=mt;break}}k===c.n&&(k=t.insertPath(m,c.n),t.setClosedPath(k,!0),A++),(0,F.g)(k!==c.n)}t.setPathUserIndex(k,b,2),H=t.getFirstVertex(k);let U=0,Z=!1,st=X;do{H===st&&(Z=!0),t.setUserIndex(st,this.m_pointsIndex,1);const mt=t.getPathFromVertex(st);mt!==k&&(2!==t.getPathUserIndex(mt,b)&&(t.setPathUserIndex(mt,b,1),t.setFirstVertex(mt,c.n)),t.setPathToVertex(st,k)),U++,st=t.getNextVertex(st)}while(st!==X);Z||t.setFirstVertex(k,X),t.setPathSize(k,U)}for(let T=t.getFirstPath(m);T!==c.n;){const M=t.getNextPath(T);1!==t.getPathUserIndex(T,b)&&t.getFirstVertex(T)!==c.n||(t.removePathOnly(T),A--),T=M}t.setGeometryVertexCount(m,S),t.setGeometryPathCount(m,A),t.removePathUserIndex(b),t.removeUserIndex(this.m_pointsIndex),this.m_pointsIndex=-1,t.dbgVerifyVertexCounts(),t.filterClosePoints(0,!0,!1,!1,m)}processBunch_(t,m){t.sort((C,S)=>{const b=this.m_shape.getXY(C.vertex1).sub(m),A=this.m_shape.getXY(S.vertex1).sub(m),T=Y.P.compareVectors(b,A);return 0===T?C.dir<S.dir?-1:1:T});let u=0;const g=this.m_shape.getXY(t[0].vertex1);let d=1;const y=this.m_shape.hasCurves();for(let C=1,S=t.length;C<S;C++){const b=this.m_shape.getXY(t[C].vertex1);if(!(b.isEqualPoint2D(g)&&(d++,C+1<S))){if(2===d){const A=t[u],T=t[u+1],M=A.dir;if(M!==T.dir){let X=!0;if(y&&(X=!this.m_shape.isCurve(1===A.dir?A.vertex0:A.vertex1)&&!this.m_shape.isCurve(1===T.dir?T.vertex0:T.vertex1)),X){if(1===M){const k=A.vertex0,H=T.vertex0;this.m_shape.setNextVertex(k,H),this.m_shape.setPrevVertex(H,k),this.m_shape.getPrevVertex(k)===H&&(this.m_shape.setUserIndex(k,this.m_pointsIndex,-1),this.m_shape.setUserIndex(H,this.m_pointsIndex,-1));const U=A.vertex1,Z=T.vertex1;this.m_shape.setPrevVertex(U,Z),this.m_shape.setNextVertex(Z,U),this.m_shape.getNextVertex(U)===Z&&(this.m_shape.setUserIndex(U,this.m_pointsIndex,-1),this.m_shape.setUserIndex(Z,this.m_pointsIndex,-1))}else{const k=A.vertex0,H=T.vertex0;this.m_shape.setPrevVertex(k,H),this.m_shape.setNextVertex(H,k),this.m_shape.getNextVertex(k)===H&&(this.m_shape.setUserIndex(k,this.m_pointsIndex,-1),this.m_shape.setUserIndex(H,this.m_pointsIndex,-1));const U=A.vertex1,Z=T.vertex1;this.m_shape.setNextVertex(U,Z),this.m_shape.setPrevVertex(Z,U),this.m_shape.getPrevVertex(U)===Z&&(this.m_shape.setUserIndex(U,this.m_pointsIndex,-1),this.m_shape.setUserIndex(Z,this.m_pointsIndex,-1))}this.m_dissolvedEdges+=2}}}g.assign(b),u=C,d=1}}t.length=0}}function lt(P){for(let t=P.getFirstGeometry();t!==c.n;t=P.getNextGeometry(t))if((0,F.h)(P.getGeometryType(t)))return!0;return!1}function Ct(P,t,m,u,g){if(!lt(t))return!1;let d=new te(g);if(d.m_shape=t,d.m_tolerance=m,d.m_bAllowCoincident=P,d.m_bNeedsNonSimpleResult=null!==u,d.needsCrackingImpl_())return u&&u.assign(d.m_nonSimpleResult),!0;const y=new Wt.T;y.setSwapCoordinates(),t.applyTransformation(y),d=new te(g),d.m_shape=t,d.m_tolerance=m,d.m_bAllowCoincident=P,d.m_bNeedsNonSimpleResult=null!==u;const C=d.needsCrackingImpl_();return t.applyTransformation(y),!!C&&(u&&u.assign(d.m_nonSimpleResult),!0)}function Lt(P,t){return{t:P,index:t}}class te{crackBruteForce_(){let t=this.crackBruteForceImpl_();if(!t&&this.m_shape.hasCurves()){const m=new Wt.T;m.setSwapCoordinates(),this.m_shape.applyTransformation(m),t=this.crackBruteForceImpl_(),this.m_shape.applyTransformation(m)}return t}crackBruteForceImpl_(){let t=!1;const m=new c.S,u=new c.S,g=R.J.constructEmpty(),d=R.J.constructEmpty(),C=new dt.P,S=new Os,b=this.m_shape.getTotalPointCount(),A=b*b*2,T=this.m_shape.queryVertexIteratorOnSelection();for(let M=T.next();M!==c.n;M=T.next()){const X=this.m_shape.getGeometryType(T.currentGeometry());let k=1,H=1,U=1,Z=0,st=0,mt=0;const ht=this.m_shape.getSegmentParentage(M);let ut=!1,ct=!1,Et=null,Tt=!1;if((0,F.e)(X))k=this.m_shape.getWeight(M),Z=this.m_shape.getRank(M);else{if(Et=this.getSegment_(M,m),null===Et)continue;const Bt=this.m_shape.getVertexIndex(M);k=this.m_shape.getWeightWithIndex(Bt),Z=this.m_shape.getRankWithIndex(Bt),U=this.m_shape.getSegmentWeightWithIndex(Bt),mt=this.m_shape.getSegmentRankWithIndex(Bt),ut=this.m_shape.getSegmentParentageBreakVertex(M);{const kt=this.m_shape.getNextVertex(M);H=this.m_shape.getWeight(kt),st=this.m_shape.getRank(kt),ct=this.m_shape.getSegmentParentageBreakVertex(kt)}if(Et.queryLooseEnvelope(g),g.inflateCoords(this.m_tolerance,this.m_tolerance),Et.isDegenerate(this.m_tolerance)){if(!Et.isDegenerate(0))continue;Tt=!0,Et=null}}const Pt=new c.a1({copy:T});let At=Pt.next();At!==c.n&&(At=Pt.next());let Ht=0;for(;At!==c.n;At=Pt.next()){if(0!==Ht){Ht--;continue}if(this.m_shape.getTotalPointCount()>A)return t;this.progress_();const Bt=this.m_shape.getGeometryType(Pt.currentGeometry());let kt=null,wt=!1,Xt=0,Zt=0,zt=0,ge=0,qt=0,ce=0,be=!1,Me=!1;const Es=this.m_shape.getSegmentParentage(At);if((0,F.e)(Bt))Xt=this.m_shape.getWeight(At),ge=this.m_shape.getRank(At);else{if(kt=this.getSegment_(At,u),null===kt)continue;const Ke=this.m_shape.getVertexIndex(At);Xt=this.m_shape.getWeightWithIndex(Ke),ge=this.m_shape.getRankWithIndex(Ke),zt=this.m_shape.getSegmentWeightWithIndex(Ke),ce=this.m_shape.getSegmentRankWithIndex(Ke),be=this.m_shape.getSegmentParentageBreakVertex(At);{const rs=this.m_shape.getNextVertex(At);Zt=this.m_shape.getWeight(rs),qt=this.m_shape.getRank(rs),Me=this.m_shape.getSegmentParentageBreakVertex(rs)}if(kt.queryLooseEnvelope(d),kt.isDegenerate(this.m_tolerance)){if(!kt.isDegenerate(0))continue;wt=!0,kt=null}}let ts=0,He=0;if(null!==Et&&null!==kt)g.isIntersectingNe(d)&&0!==(0,c.a2)(!0,!0,Et,kt,this.m_tolerance,!0)&&(S.pushSegment(Et,k,Z,H,st,U,mt,ut,ct,ht),S.pushSegment(kt,Xt,ge,Zt,qt,zt,ce,be,Me,Es),S.intersect2D(this.m_tolerance,!0),t||=S.getSegmentChanged(0)||S.getSegmentChanged(1),ts=S.getResultSegmentCount(0),He=S.getResultSegmentCount(1),ts+He>0&&(this.m_shape.splitSegmentWithIntersector(M,S,0,!0,!0),this.m_shape.splitSegmentWithIntersector(At,S,1,!0,!0),this.m_bTrackChanges&&(S.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(M,!0),S.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(At,!0))),He>1&&(Ht+=He-1),S.clear());else if(null!==Et){const Ke=this.m_shape.getXY(At);if(g.contains(Ke)){if(S.pushSegment(Et,k,Z,H,st,U,mt,ut,ct,ht),this.m_shape.queryPoint(At,C),S.intersect2DEx(this.m_tolerance,C,ge,Xt,!1),t||=S.getSegmentChanged(0)||S.getResultPointChanged(),ts=S.getResultSegmentCount(0),ts>0)if(this.m_bTrackChanges&&(S.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(M,!0),S.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(At,!0)),this.m_shape.splitSegmentWithIntersector(M,S,0,!0,!0),wt){let rs=c.n;for(let Fe=this.m_shape.getNextVertex(At);Fe!==c.n&&Fe!==At&&(kt=this.getSegment_(Fe,u),rs=Fe,null!=kt&&kt.isDegenerate(0));Fe=this.m_shape.getNextVertex(Fe));for(let Fe=At;Fe!==c.n&&(this.m_shape.setPoint(Fe,S.getResultPoint(),!0),Fe!==rs);Fe=this.m_shape.getNextVertex(Fe));}else this.m_shape.setPoint(At,S.getResultPoint(),!0);S.clear()}}else{if(null===kt)continue;{const Ke=this.m_shape.getXY(M);if(d.inflateCoords(this.m_tolerance,this.m_tolerance),d.contains(Ke)){if(S.pushSegment(kt,Xt,ge,Zt,qt,zt,ce,be,Me,Es),this.m_shape.queryPoint(M,C),S.intersect2DEx(this.m_tolerance,C,Z,k,!1),t||=S.getSegmentChanged(0)||S.getResultPointChanged(),He=S.getResultSegmentCount(0),He>0)if(this.m_bTrackChanges&&(S.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(At,!0),S.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(M,!0)),this.m_shape.splitSegmentWithIntersector(At,S,0,!0,!0),Ht+=He-1,Tt){let rs=c.n;for(let Fe=this.m_shape.getNextVertex(M);Fe!==c.n&&Fe!==M&&(kt=this.getSegment_(Fe,u),rs=Fe,null!=kt&&kt.isDegenerate(0));Fe=this.m_shape.getNextVertex(Fe));for(let Fe=M;Fe!==c.n&&(this.m_shape.setPoint(Fe,S.getResultPoint(),!0),Fe!==rs);Fe=this.m_shape.getNextVertex(Fe));}else this.m_shape.setPoint(M,S.getResultPoint(),!0);S.clear()}}}if(ts+He!==0&&0!==ts){let Ke=!1;for(;Et=this.getSegment_(M,m),null!=Et&&(Et.queryEnvelope(g),Et.isDegenerate(this.m_tolerance));){if(!(ts>1)){Ke=!0;break}M=T.next(),ts--,(0,F.g)(M!==c.n)}if(Ke)break}}}return t}crackerPlaneSweep_(){return this.planesweep_()}planesweep_(){return new w(this.m_progressTracker,this.m_bTrackChanges).sweep(this.m_shape,this.m_tolerance)}needsCrackingImpl_(){let t=!1;const m=new dt.A(0);m.resize(this.m_shape.getSelectedCount());const u=this.m_shape.queryVertexIteratorOnSelection();for(let T=0,M=u.next();M!==c.n;++T,M=u.next())m.write(T,M);this.m_shape.sortVerticesSimpleByY(m,0,m.size()),m.add(c.n);const g=this.m_shape.createUserIndex(),d=this.m_shape.createUserIndex();this.m_sweepComparator=new zr(this.m_shape,this.m_tolerance,!this.m_bAllowCoincident),this.m_sweepStructure.setComparator(this.m_sweepComparator);let y=null;const C=[],S=[];let b=0;const A=new Y.P;for(let T=m.read(b++);T!==c.n;){this.m_shape.queryXY(T,A);let M=!1;do{let Z=this.m_shape.getNextVertex(T),st=this.m_shape.getPrevVertex(T);M||=Z!==c.n||st!==c.n,Z===c.n||this.m_shape.selected(Z)||(Z=c.n),st===c.n||this.m_shape.selected(st)||(st=c.n),Z!==c.n&&this.m_shape.compareVerticesSimpleY(T,Z)<0&&(S.push(T),S.push(Z)),st!==c.n&&this.m_shape.compareVerticesSimpleY(T,st)<0&&(S.push(st),S.push(st));const mt=this.m_shape.getUserIndex(T,g);-1!==mt&&(C.push(mt),this.m_shape.setUserIndex(T,g,-1));const ht=this.m_shape.getUserIndex(T,d);-1!==ht&&(C.push(ht),this.m_shape.setUserIndex(T,d,-1)),T=m.read(b++)}while(T!==c.n&&this.m_shape.isEqualXYPoint2D(T,A));if(!M&&(null===y&&(y=new ar(this.m_shape,this.m_tolerance)),y.setPoint(A),this.m_sweepStructure.searchUpperBound(y),y.intersectionDetected())){t=!0,this.m_bNeedsNonSimpleResult&&((0,F.c)("needsCrackingIMpl_"),this.m_nonSimpleResult=new Ee(6,-1,-1));break}let X=1===C.length&&2===S.length;C.length>32&&(0,Y.v)(C);let H=-1,U=-1;if(!X)for(let Z=0,st=C.length;Z<st;Z++){const mt=C[Z],ht=this.m_sweepStructure.getPrev(mt);if(-1!==ht&&-1===C.indexOf(ht))if(-1===H)H=ht;else{if(t=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new Ee(6,-1,-1)}const ut=this.m_sweepStructure.getNext(mt);if(-1!==ut&&-1===C.indexOf(ut))if(-1===U)U=ut;else{if(t=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new Ee(6,-1,-1)}if(-1!==H&&-1!==U)break}if(t&&!this.m_bNeedsNonSimpleResult)break;if(this.m_sweepComparator.setSweepY(A.y,A.x),!X){for(let Z=0,st=C.length;Z<st;Z++)this.m_sweepStructure.deleteNode(C[Z]);C.length=0}if(!X&&-1!==H&&-1!==U&&this.checkForIntersections_(H,U)){t=!0,this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult());break}for(let Z=0,st=S.length;Z<st;Z+=2){const mt=S[Z],ht=S[Z+1];let ut;if(X?(ut=this.m_sweepStructure.replaceElementAtPosition(C[0],mt,!0,!0),C.length=0,X=!1):ut=this.m_sweepStructure.addElement(mt),this.m_sweepComparator.intersectionDetected()){this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult()),t=!0;break}-1===this.m_shape.getUserIndex(ht,g)?this.m_shape.setUserIndex(ht,g,ut):this.m_shape.setUserIndex(ht,d,ut)}if(t)break;S.length=0}return this.m_shape.removeUserIndex(g),this.m_shape.removeUserIndex(d),t}checkForIntersections_(t,m){const u=this.m_sweepStructure.getElement(t);this.m_sweepComparator.compare(this.m_sweepStructure,u,m);const g=this.m_sweepComparator.intersectionDetected();return this.m_sweepComparator.clearIntersectionDetectedFlag(),g}getSegment_(t,m){return te.st_getSegment(this.m_shape,t,m)}static st_getSegment(t,m,u){return t.querySegment(m,u,!1,!1)?u.get():null}dbgPrintSweepEdge(t){}dbgPrintSweepStructure(){}dbgSaveSweepStructure(t=null){}dbgCheckSweepStructure(){}progress_(t=!1){this.m_progressCounter++}crackAWithBMultiPath_(t,m,u){const g=R.J.constructEmpty();t.queryLooseEnvelope(g);const d=R.J.constructEmpty();if(m.queryLooseEnvelope(d),d.inflateCoords(u,u),!d.isIntersecting(g))return t;const y=t.getImpl(),C=y.getAccelerators();let S=null,b=null;C&&(b=C.getQuadTree()),function le(P,t){const m=P.getPointCount();if(m<16)return!1;return 2*m+Math.log(m)/Math.log(2)*1*t<1*m*t}(t,(0,F.v)(m))&&(S=(0,dt.G)(y,d),b=S);const A=b?b.getIteratorForQT():null,T=m.querySegmentIterator(),M=t.querySegmentIterator(),X=(0,Y.d)(15,Number.NaN),k=[];for(;T.nextPath();)for(;T.hasNextSegment();){const ht=T.nextSegment();if(b){A.resetIterator(ht,u);for(let ut=A.next();-1!==ut;ut=A.next()){this.progress_();const ct=b.getElement(ut);if(M.resetToVertex(ct,-1),M.hasNextSegment()){const Et=M.nextSegment().intersect(ht,null,X,null,u);for(let Tt=0;Tt<Et;Tt++){const Pt=X[Tt];if(0===Pt||1===Pt)continue;const At=Lt(Pt,M.getStartPointIndex());k.push(At)}}}}else{const ut=R.J.constructEmpty();if(ht.queryLooseEnvelope(ut),ut.inflateCoords(u,u),!g.isIntersecting(ut))continue;for(M.resetToFirstPath();M.nextPath();)for(;M.hasNextSegment();){const ct=M.nextSegment(),Et=R.J.constructEmpty();if(ct.queryLooseEnvelope(Et),!Et.isIntersecting(ut))continue;const Tt=ct.intersect(ht,null,X,null,u);for(let Pt=0;Pt<Tt;Pt++){const At=X[Pt];if(0===At||1===At)continue;const Ht=Lt(At,M.getStartPointIndex());k.push(Ht)}}}}if(0===k.length)return t;k.sort((ht,ut)=>ht.index<ut.index?-1:ht.index>ut.index?1:ht.t<ut.t?-1:ht.t>ut.t?1:0);const H=t.createInstance();for(H.getGeometryType()===F.G.enumPolygon&&H.setFillRule(t.getFillRule()),M.resetToFirstPath();M.nextPath()&&!M.hasNextSegment(););(0,F.g)(M.hasNextSegment());let U=M.nextSegment();const Z=new c.S;let st=-1;for(let ht=0,ut=k.length;ht<ut;){const ct=k[ht].index;let Et=ht+1;for(;Et<ut&&k[Et].index===ct;)++Et;for(;M.getStartPointIndex()<ct;){this.progress_();const At=M.hasNextSegment(),Ht=M.getPathIndex();if((At||!M.isClosingSegment()||M.isCurve())&&((0,F.g)(null!==U),H.addSegment(U,st!==Ht)),st=Ht,!At){for(M.isPathClosed();M.nextPath()&&!M.hasNextSegment(););(0,F.g)(M.hasNextSegment())}U=M.nextSegment()}let Tt=0;for(let At=ht;At<Et;At++){const Ht=k[At].t;if(Ht===Tt)continue;(0,F.g)(null!==U),U.queryCut(Tt,Ht,Z),Tt=Ht;const Bt=M.getPathIndex();H.addSegment(Z.get(),st!==Bt),st=Bt}const Pt=M.hasNextSegment();if((Pt||!M.isClosingSegment()||M.isCurve())&&((0,F.g)(null!=U),U.queryCut(Tt,1,Z),H.addSegment(Z.get(),!1)),Pt)U=M.nextSegment();else{for(;M.nextPath()&&!M.hasNextSegment(););U=M.hasNextSegment()?M.nextSegment():null}ht=Et}if(null!==U){const ht=M.getPathIndex();(M.hasNextSegment()||!M.isClosingSegment()||M.isCurve())&&H.addSegment(U,st!==ht),st=ht}let mt=M.hasNextSegment();for(;;){if(!mt){for(;M.nextPath()&&(mt=M.hasNextSegment(),!mt););if(!mt)break}U=M.nextSegment();const ht=M.getPathIndex();mt=M.hasNextSegment(),(mt||!M.isClosingSegment()||M.isCurve())&&H.addSegment(U,st!==ht),st=ht}return H}constructor(t){this.m_shape=null,this.m_progressTracker=null,this.m_nonSimpleResult=new Ee,this.m_tolerance=0,this.m_sweepComparator=null,this.m_progressCounter=0,this.m_bTrackChanges=!1,this.m_bNeedsNonSimpleResult=!1,this.m_bAllowCoincident=!0,this.m_sweepStructure=new dt.T,this.m_progressTracker=t}}te.s_bForceBruteForce=!0;class he{constructor(t,m){this.m_monotoneParts=(0,Y.m)(c.S,16),this.m_xOrds=(0,Y.d)(16,Number.NaN),this.m_inputPoint=Y.P.getNAN(),this.m_miny=0,this.m_maxy=0,this.m_windnum=0,this.m_bAlternate=t,this.m_tolerance=m,this.m_toleranceSqr=m*m,this.m_bTestBorder=!!m,this.m_bBreak=!1}_DoOne(t){if(!this.m_bTestBorder&&(this.m_bAlternate&&this.m_inputPoint.equals(t.getStartXY())||this.m_inputPoint.equals(t.getEndXY())))return void(this.m_bBreak=!0);if(t.getStartY()===this.m_inputPoint.y&&t.getStartY()===t.getEndY()){if(this.m_bAlternate&&!this.m_bTestBorder){const g=Math.min(t.getStartX(),t.getEndX()),d=Math.max(t.getStartX(),t.getEndX());this.m_inputPoint.x>g&&this.m_inputPoint.x<d&&(this.m_bBreak=!0)}return}let m=!1;const u=Math.max(t.getStartX(),t.getEndX());if(this.m_inputPoint.x>u)m=!0;else if(this.m_inputPoint.x>=Math.min(t.getStartX(),t.getEndX())){const g=t.intersectionOfYMonotonicWithAxisX(this.m_inputPoint.y,u);m=!Number.isNaN(g)&&g<=this.m_inputPoint.x}if(m){if(this.m_inputPoint.y===t.getStartY()){if(this.m_inputPoint.y<t.getEndY())return}else if(this.m_inputPoint.y===t.getEndY()&&this.m_inputPoint.y<t.getStartY())return;this.m_bAlternate?this.m_windnum^=1:this.m_windnum+=t.getStartY()>t.getEndY()?1:-1}}_Result(){return!!this.m_windnum}testBorder(t){const m=t.getClosestCoordinate(this.m_inputPoint,!1),u=t.getCoord2D(m);return Y.P.sqrDistance(u,this.m_inputPoint)<=this.m_toleranceSqr}setInputPoint(t){this.m_inputPoint.setCoordsPoint2D(t),this.m_miny=t.y-this.m_tolerance,this.m_maxy=t.y+this.m_tolerance}processSegment(t){const m=t.queryInterval(0,1);if(m.vmin>this.m_maxy||m.vmax<this.m_miny)return!1;if(this.m_bTestBorder&&this.testBorder(t))return!0;if(m.vmin>this.m_inputPoint.y||m.vmax<this.m_inputPoint.y)return!1;let u=0;if(t.isCurve()&&(0===this.m_monotoneParts.length&&(this.m_monotoneParts.length=128),u=t.getMonotonicParts(this.m_monotoneParts,!0),(0,F.g)(this.m_monotoneParts.length>=u)),u>0)for(let g=0;g<u;g++){const d=this.m_monotoneParts[g].get(),y=Y.E.construct(d.getStartY(),d.getEndY());if(!(y.vmin>this.m_inputPoint.y||y.vmax<this.m_inputPoint.y)&&(this._DoOne(d),this.m_bBreak))return!0}else if(this._DoOne(t),this.m_bBreak)return!0;return!1}result(){return(0,F.g)(0),2}}function ns(P,t,m){if(P.isEmpty())return 0;const u=R.J.constructEmpty();if(P.queryLooseEnvelope(u),u.inflateCoords(m,m),!u.contains(t))return 0;const g=P.getImpl().getAccelerators();if(g){g.getRasterizedGeometry()&&(0,F.g)(0);const d=g.getQuadTree();if(d)return function Ye(P,t,m,u){const g=new R.J;P.queryLooseEnvelope(g),g.inflateCoords(u,u);const d=0===P.getFillRule(),y=new he(d,u);y.setInputPoint(m);const C=g.clone();C.xmax=m.x+u,C.ymin=m.y-u,C.ymax=m.y+u;const S=P.getImpl().querySegmentIterator(),b=t.getIterator(C,u);for(let A=b.next();-1!==A;A=b.next())if(S.resetToVertex(t.getElement(A),-1),S.hasNextSegment()){const T=S.nextSegment();if(y.processSegment(T))return-1}return y._Result()?1:0}(P,d,t,m)}return function Ys(P,t,m){const u=0===P.getFillRule(),g=new he(u,m);g.setInputPoint(t);const d=P.getImpl().querySegmentIterator();for(;d.nextPath();)for(;d.hasNextSegment();){const y=d.nextSegment();if(g.processSegment(y))return-1}return g._Result()?1:0}(P,t,m)}function _s(P,t){const m=P.getPointCount();return!(m<16)&&2*m+Math.log(m)/Math.log(2)*1*t<1*m*t}function Ne(P,t,m){const u=new La(m);return u.m_shape=P,u.m_geometry=t,u.m_sortedVertices=null,u.m_bFixSelfTangency=!1,u.fixRingOrientationForMp2sp_()}class ls{getDirection_(t){return this.m_shape.getNextVertex(this.getEnd1(t))===this.getEnd2(t)}getEnd_(t){const m=this.getEnd1(t),u=this.getEnd2(t);return this.m_shape.getNextVertex(m)===u?u:m}constructor(t){this.m_end1Nodes=[],this.m_end2Nodes=[],this.m_directions=[],this.m_shape=t,this.m_firstFree=-1}getSegment(t){return this.m_shape.getSegment(this.getStart(t))}isBottomUp(t){let m=this.getEnd1(t),u=this.getEnd2(t);this.m_shape.getPrevVertex(m)===u&&(u=(0,Y.b)(m,m=u));const g=Y.P.getNAN(),d=Y.P.getNAN();return this.m_shape.queryXY(m,g),this.m_shape.queryXY(u,d),(0,F.g)(!g.equals(d)),g.y<d.y}getStart(t){const m=this.getEnd1(t),u=this.getEnd2(t);return this.m_shape.getNextVertex(m)===u?m:u}getEnd1(t){return this.m_end1Nodes[t]}getEnd2(t){return this.m_end2Nodes[t]}freeEdge(t){this.m_end1Nodes[t]=this.m_firstFree,this.m_firstFree=t}newEdge(t){if(-1!==this.m_firstFree){const u=this.m_firstFree;return this.m_firstFree=this.m_end1Nodes[u],this.m_end1Nodes[u]=t,this.m_end2Nodes[u]=this.m_shape.getNextVertex(t),u}const m=this.m_end1Nodes.length;return this.m_end1Nodes.push(t),this.m_end2Nodes.push(this.m_shape.getNextVertex(t)),m}getShape(){return this.m_shape}getPath(t){return this.m_shape.getPathFromVertex(this.getEnd1(t))}}let Ae=class extends dt.a6{constructor(P){super(),this.m_line1=new c.L,this.m_line2=new c.L,this.m_leftElm=-1,this.m_leftx=0,this.m_seg1=null,this.m_helper=P}compare(P,t,m){const u=P.getElement(m),g=this.m_helper.m_edges;let d;this.m_leftElm===t?d=this.m_leftx:(this.m_seg1=g.getSegment(t),this.m_seg1?d=this.m_seg1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0):(g.getShape().queryLineConnector(g.getStart(t),this.m_line1,!0),this.m_seg1=this.m_line1,d=this.m_line1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)),this.m_leftx=d,this.m_leftElm=t);let y,C=g.getSegment(u);if(C?y=C.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0):(g.getShape().queryLineConnector(g.getStart(u),this.m_line2,!0),C=this.m_line2,y=this.m_line2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)),d===y){const S=g.isBottomUp(t),b=g.isBottomUp(u),A=S?this.m_seg1.getEndY():this.m_seg1.getStartY(),T=b?C.getEndY():C.getStartY(),M=Math.min(A,T);let X=.5*(M+this.m_helper.m_yScanline);X===this.m_helper.m_yScanline&&(X=M),d=this.m_seg1.intersectionOfYMonotonicWithAxisX(X,0),y=C.intersectionOfYMonotonicWithAxisX(X,0),d===y&&(0,F.D)("")}return d<y?-1:d>y?1:0}reset(){this.m_leftElm=-1}};class Xs{constructor(t){this.m_node=-1,this.m_index=0,this.m_sortedVertices=t.m_sortedVertices,this.m_sortedVerticesArray=t.m_sortedVerticesArray,this.m_sortedVertices&&(this.m_node=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()))}next(){if(this.m_sortedVertices){const t=this.m_node;if(-1===t)return c.n;const m=this.m_sortedVertices.getData(t);return this.m_node=this.m_sortedVertices.getNext(t),m}if(this.m_index<this.m_sortedVerticesArray.size()){const t=this.m_sortedVerticesArray.read(this.m_index);return this.m_index++,t}return c.n}}class La{constructor(t){this.m_edges=null,this.m_shape=null,this.m_AET=new dt.T,this.m_yScanline=0,this.m_geometry=c.n,this.m_unknownRingOrientationCount=-1,this.m_sortedVertices=null,this.m_sortedVerticesArray=null,this.m_unknownNodes=[],this.m_node1UserIndex=-1,this.m_node2UserIndex=-1,this.m_pathOrientationIndex=-1,this.m_pathParentageIndex=-1,this.m_pathParentsIndex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_progressTracker=t,this.m_AET.disableBalancing(),this.m_sweepComparator=new Ae(this),this.m_AET.setComparator(this.m_sweepComparator)}fixRingOrientation_(){const t=this.fixRingOrientationImplMain_();return-1===this.m_pathOrientationIndex||this.fixRingOrientationImplSimplify_(),t}fixRingOrientationForMp2sp_(){return this.fixRingOrientationImplMain_(),-1===this.m_pathOrientationIndex?-1:this.fixRingOrientationImplMp2sp_()}processBunchForRingOrientationTest_(t){return this.processBunchForRingOrientationTestOddEven_(t)}processBunchForRingOrientationTestOddEven_(t){let m=!1;if(this.m_edges||(this.m_edges=new ls(this.m_shape)),this.m_unknownNodes.length=0,this.processBunchForRingOrientationRemoveEdges_(t),!this.m_AET.isAutoBalancing()){let u=0;for(let g=0,d=t.length;g<d;g++)-1!==t[g]&&u++;(u>10||this.m_AET.getMaxDepthEver()>4)&&this.m_AET.enableBalancing()}for(let u=0,g=t.length;u<g;u++){const d=t[u];d!==c.n&&this.insertEdge_(d,-1)}for(let u=0;u<this.m_unknownNodes.length&&this.m_unknownRingOrientationCount>0;u++){const g=this.m_unknownNodes[u],d=this.m_AET.getElement(g),y=this.m_edges.getPath(d),C=this.m_shape.getPathUserIndex(y,this.m_pathOrientationIndex);let S=c.n;if(0===C){let b=this.m_AET.getPrev(g),A=g,T=!1;for(;b!==dt.T.st_nullNode();){const M=this.m_AET.getElement(b),X=this.m_edges.getPath(M);if(0!==this.m_shape.getPathUserIndex(X,this.m_pathOrientationIndex)){S=X;break}A=b,b=this.m_AET.getPrev(b)}if(b===dt.T.st_nullNode())T=!0,b=A;else{const M=this.m_AET.getElement(b);T=this.m_edges.isBottomUp(M),b=this.m_AET.getNext(b),T=!T}do{const M=this.m_AET.getElement(b),X=this.m_edges.getPath(M);if(0===this.m_shape.getPathUserIndex(X,this.m_pathOrientationIndex)){if(T!==this.m_edges.isBottomUp(M)){const k=this.m_shape.getFirstVertex(X);this.m_shape.reverseRingInternal(k),this.m_shape.setLastVertex(X,this.m_shape.getPrevVertex(k)),m=!0}if(this.m_shape.setPathUserIndex(X,this.m_pathOrientationIndex,T?3:2),!T){let k=this.m_shape.getPathUserIndex(S,this.m_pathOrientationIndex);2===k&&(S=this.m_shape.getPathUserIndex(S,this.m_pathParentsIndex),k=this.m_shape.getPathUserIndex(S,this.m_pathOrientationIndex)),(0,F.g)(3===k);const H=this.m_shape.getPathUserIndex(S,this.m_pathParentageIndex);this.m_shape.setPathUserIndex(S,this.m_pathParentageIndex,X),this.m_shape.setPathUserIndex(X,this.m_pathParentageIndex,H),this.m_shape.setPathUserIndex(X,this.m_pathParentsIndex,S)}if(this.m_unknownRingOrientationCount--,!this.m_unknownRingOrientationCount)return m}S=X,A=b,b=this.m_AET.getNext(b),T=!T}while(A!==g)}}return m}processBunchForRingOrientationRemoveEdges_(t){for(let m=0,u=t.length;m<u;m++){const g=t[m],d=this.m_shape.getUserIndex(g,this.m_node1UserIndex),y=this.m_shape.getUserIndex(g,this.m_node2UserIndex);if(-1!==d){const S=this.m_AET.getElement(d);this.m_edges.freeEdge(S),this.m_shape.setUserIndex(g,this.m_node1UserIndex,-1)}if(-1!==y){const S=this.m_AET.getElement(y);this.m_edges.freeEdge(S),this.m_shape.setUserIndex(g,this.m_node2UserIndex,-1)}let C=-1;-1!==d&&-1!==y?(this.m_AET.deleteNode(d),this.m_AET.deleteNode(y),t[m]=c.n):C=-1!==d?d:y,-1!==C&&(this.insertEdge_(g,C)||this.m_AET.deleteNode(C),t[m]=c.n)}}dbgVerifyRingOrientation_(){}insertEdge_(t,m){const u=Y.P.getNAN(),g=Y.P.getNAN();this.m_shape.queryXY(t,u);const d=this.m_shape.getNextVertex(t);this.m_shape.queryXY(d,g);let y=!1;if(u.y<g.y){y=!0;const S=this.m_edges.newEdge(t);let b;-1===m?b=this.m_AET.addElement(S):(b=m,this.m_AET.setElement(b,S)),-1===this.m_shape.getUserIndex(d,this.m_node1UserIndex)?this.m_shape.setUserIndex(d,this.m_node1UserIndex,b):this.m_shape.setUserIndex(d,this.m_node2UserIndex,b);const A=this.m_shape.getPathFromVertex(t);0===this.m_shape.getPathUserIndex(A,this.m_pathOrientationIndex)&&this.m_unknownNodes.push(b)}const C=this.m_shape.getPrevVertex(t);if(this.m_shape.queryXY(C,g),u.y<g.y){y=!0;const S=this.m_edges.newEdge(C);let b;-1===m?b=this.m_AET.addElement(S):(b=m,this.m_AET.setElement(b,S)),-1===this.m_shape.getUserIndex(C,this.m_node1UserIndex)?this.m_shape.setUserIndex(C,this.m_node1UserIndex,b):this.m_shape.setUserIndex(C,this.m_node2UserIndex,b);const A=this.m_shape.getPathFromVertex(t);0===this.m_shape.getPathUserIndex(A,this.m_pathOrientationIndex)&&this.m_unknownNodes.push(b)}return y}fixRingSelfTangency_(){const t=[],m=[];let u=-1,g=-1;const d=new Y.P;let y=c.n,C=c.n,S=-1;const b=new Xs(this);for(let A=b.next();A!==c.n;A=b.next()){const T=new Y.P;this.m_shape.queryXY(A,T);const M=this.m_shape.getPathFromVertex(A);d.equals(T)&&C===M?(-1===g&&(u=this.m_shape.createPathUserIndex(),this.m_shape.fillPathUserIndexForGeometry(this.m_geometry,u,-1),g=this.m_shape.createUserIndex(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,g,-1)),-1===S&&(S=m.length,this.m_shape.setUserIndex(y,g,S),m.push(1),-1===this.m_shape.getPathUserIndex(M,u)&&(this.m_shape.setPathUserIndex(M,u,y),t.push(M))),this.m_shape.setUserIndex(A,g,S),m[m.length-1]++):(S=-1,d.assign(T)),y=A,C=M}if(0===t.length)return!1;(0,F.g)(-1!==u);for(let A=0,T=t.length;A<T;A++){let X=this.m_shape.getPathUserIndex(t[A],u);const k=this.m_shape.getUserIndex(X,g),H=[],U=[];H.push(X),U.push(k);for(let Z=this.m_shape.getNextVertex(X);Z!==X;Z=this.m_shape.getNextVertex(Z)){const st=Z,mt=this.m_shape.getUserIndex(st,g);if(-1!==mt){if(0===U.length){U.push(mt),H.push(st);continue}if(U.at(-1)===mt){const ht=H.at(-1);this.m_shape.peelALoopIntoAPath(ht,st),this.m_shape.setUserIndex(Z,g,-1),m[mt]--,1===m[mt]&&(m[mt]=0,U.pop(),H.pop()),X=ht,Z=ht}else H.push(Z),U.push(mt)}}}return this.m_shape.removePathUserIndex(u),this.m_shape.removeUserIndex(g),this.m_shape.dbgVerifyVertexCounts(),!0}progress_(t=!1){}fixRingOrientationImplMain_(){const t={stack:[],error:void 0,hasError:!1};try{let m,u=!1;const g=(0,vt.b)(t,(0,Y.h)(()=>{this.m_sortedVerticesArray=null}),!1);if(null===this.m_sortedVertices){const S=this.m_shape.getPointCount(this.m_geometry);m=new dt.A(0);for(let b=this.m_shape.getFirstPath(this.m_geometry);b!==c.n;b=this.m_shape.getNextPath(b)){let A=this.m_shape.getFirstVertex(b);for(let T=0,M=this.m_shape.getPathSize(b);T<M;T++)m.add(A),A=this.m_shape.getNextVertex(A)}this.m_shape.sortVerticesSimpleByY(m,0,S),this.progress_(!0),this.m_sortedVerticesArray=m}else g.bForget=!0;if(this.m_bFixSelfTangency&&(u=this.fixRingSelfTangency_()),1===this.m_shape.getPathCount(this.m_geometry)){const S=this.m_shape.getFirstPath(this.m_geometry),b=this.m_shape.getRingArea(S);if(this.m_shape.setExterior(S,!0),b<0){const A=this.m_shape.getFirstVertex(S);return this.m_shape.reverseRingInternal(A),this.m_shape.setLastVertex(S,this.m_shape.getPrevVertex(A)),!0}return!1}this.m_shape.dbgVerifyCurves(),this.m_pathOrientationIndex=this.m_shape.createPathUserIndex(),this.m_pathParentageIndex=this.m_shape.createPathUserIndex(),this.m_pathParentsIndex=this.m_shape.createPathUserIndex();for(let S=this.m_shape.getFirstPath(this.m_geometry);S!==c.n;S=this.m_shape.getNextPath(S))this.m_shape.setPathUserIndex(S,this.m_pathOrientationIndex,0),this.m_shape.setPathUserIndex(S,this.m_pathParentageIndex,-1),this.m_shape.setPathUserIndex(S,this.m_pathParentsIndex,-1);const d=[];this.m_yScanline=Number.NaN;const y=Y.P.getNAN();this.m_unknownRingOrientationCount=this.m_shape.getPathCount(this.m_geometry),this.m_node1UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node1UserIndex,-1),this.m_node2UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node2UserIndex,-1);const C=new Xs(this);for(let S=C.next();S!==c.n&&(this.progress_(),this.m_shape.queryXY(S,y),y.y!==this.m_yScanline&&d.length&&(u=this.processBunchForRingOrientationTest_(d)||u,this.m_sweepComparator.reset(),d.length=0),d.push(S),this.m_yScanline=y.y,0!==this.m_unknownRingOrientationCount);S=C.next());return this.m_unknownRingOrientationCount>0&&(u=this.processBunchForRingOrientationTest_(d)||u,d.length=0),this.m_shape.removeUserIndex(this.m_node1UserIndex),this.m_shape.removeUserIndex(this.m_node2UserIndex),this.dbgVerifyRingOrientation_(),u}catch(m){t.error=m,t.hasError=!0}finally{(0,vt.c)(t)}}fixRingOrientationImplSimplify_(){const t=[];for(let m=this.m_shape.getFirstPath(this.m_geometry);m!==c.n;)if(this.progress_(),3===this.m_shape.getPathUserIndex(m,this.m_pathOrientationIndex)){this.m_shape.setExterior(m,!0);for(let d=this.m_shape.getPathUserIndex(m,this.m_pathParentageIndex);d!==c.n;){const y=this.m_shape.getPathUserIndex(d,this.m_pathParentageIndex);t.push(d),this.m_shape.setExterior(d,!1),this.m_shape.setPathUserIndex(d,this.m_pathParentageIndex,m),d=y}let u=m,g=t.length;for(let d=this.m_shape.getNextPath(m);g>0&&d!==c.n;d=this.m_shape.getNextPath(d),--g){if(this.m_shape.getPathUserIndex(d,this.m_pathParentageIndex)!==m){u=c.n;break}u=d}if(0!==g){u=m;for(let d=0,y=t.length;d<y;d++){const C=t[d];this.m_shape.setPathUserIndex(C,this.m_pathParentageIndex,dt.X),this.m_shape.movePath(this.m_geometry,this.m_shape.getNextPath(u),C),u=C}}t.length=0,m=this.m_shape.getNextPath(u)}else m=this.m_shape.getNextPath(m);this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex)}fixRingOrientationImplMp2sp_(){const t=this.m_shape.createPathUserIndex();let m=0;const u=[];for(let g=this.m_shape.getFirstPath(this.m_geometry);g!==c.n;)if(this.progress_(),3===this.m_shape.getPathUserIndex(g,this.m_pathOrientationIndex)){this.m_shape.setExterior(g,!0),this.m_shape.setPathUserIndex(g,t,m),m++;for(let S=this.m_shape.getPathUserIndex(g,this.m_pathParentageIndex);S!==c.n;){const b=this.m_shape.getPathUserIndex(S,this.m_pathParentageIndex);u.push(S),this.m_shape.setExterior(S,!1),this.m_shape.setPathUserIndex(S,this.m_pathParentageIndex,g),S=b}let d=g,y=u.length,C=m;for(let S=this.m_shape.getNextPath(g);y>0&&S!==c.n;S=this.m_shape.getNextPath(S),--y){if(this.m_shape.getPathUserIndex(S,this.m_pathParentageIndex)!==g){d=c.n;break}d=S,this.m_shape.setPathUserIndex(S,t,-C),C++}if(0!==y){d=g,C=m;for(let S=0,b=u.length;S<b;S++){const A=u[S];this.m_shape.setPathUserIndex(A,t,-C),C++,this.m_shape.setPathUserIndex(A,this.m_pathParentageIndex,dt.X)}d=g}m=C,u.length=0,g=this.m_shape.getNextPath(d)}else g=this.m_shape.getNextPath(g);return this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex),t}}function ui(P,t,m,u,g,d){const y=new km(d);return y.m_shape=P,y.m_geometry=t,y.m_knownSimpleResult=m,y.m_bFixSelfTangency=u,y.m_polylineDegeneracies=g,y.m_bHasSegmentParentage=P.hasSegmentParentage(),y.m_bHasSegments=P.hasCurves(),y.simplify_()}class km{constructor(t){this.m_shape=null,this.m_geometry=c.n,this.m_sortedVertices=new dt.a2,this.m_bunchEdgeEndPoints=[],this.m_bunchEdgeCenterPoints=[],this.m_bunchEdgeIndices=[],this.m_knownSimpleResult=-1,this.m_sortedVerticesListIndex=-1,this.m_polylineDegeneracies=c.n,this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_bHasSegmentParentage=!1,this.m_bHasSegments=!1,this.m_progressTracker=t}compareAngles_(t,m){if(this.m_bHasSegments)return this.compareAnglesCurves_(t,m);const u=this.m_bunchEdgeEndPoints[t],g=new Y.P;this.m_shape.queryXY(u,g);const d=new Y.P;if(this.m_shape.queryXY(this.m_bunchEdgeEndPoints[m],d),g.equals(d))return 0;const C=this.m_bunchEdgeCenterPoints[t],S=new Y.P;this.m_shape.queryXY(C,S);const b=this.m_bunchEdgeCenterPoints[m],A=new Y.P;this.m_shape.queryXY(b,A);const T=new Y.P;T.setSub(g,S);const M=new Y.P;return M.setSub(d,A),(T.isZero()||M.isZero())&&(0,F.D)(""),Y.P.compareVectors(T,M)}compareAnglesCurves_(t,m){const u=this.m_bunchEdgeEndPoints[t],g=this.m_bunchEdgeEndPoints[m],d=this.m_bunchEdgeCenterPoints[t],y=this.m_bunchEdgeCenterPoints[m],C=this.m_shape.getNextVertex(d)===u,S=this.m_shape.getNextVertex(y)===g,b=new c.S,A=new Y.P;C?(this.m_shape.querySegment(d,b,!1,!0),A.assign(b.get().getTangent(0))):(this.m_shape.querySegment(u,b,!1,!0),A.assign(b.get().getTangent(1)),A.negateThis());const T=new Y.P;return S?(this.m_shape.querySegment(y,b,!1,!0),T.assign(b.get().getTangent(0))):(this.m_shape.querySegment(g,b,!1,!0),T.assign(b.get().getTangent(1)),T.negateThis()),(A.isZero()||T.isZero())&&(0,F.D)(""),Y.P.compareVectors(A,T)}beforeRemoveVertex_(t,m){const u=this.m_shape.getUserIndex(t,this.m_userIndexSortedIndexToVertex);if(this.m_nextVertexToProcess===u&&(this.m_nextVertexToProcess=this.m_sortedVertices.getNext(this.m_nextVertexToProcess)),this.m_firstCoincidentVertex===u&&(this.m_firstCoincidentVertex=this.m_sortedVertices.getNext(this.m_firstCoincidentVertex)),this.m_sortedVertices.deleteElement(this.m_sortedVerticesListIndex,u),this.removeAngleSortInfo_(t),m){const g=this.m_shape.getPathFromVertex(t);if(g!==c.n&&this.m_shape.getFirstVertex(g)===t){const d=this.m_shape.getNextVertex(t);if(d!==t){if(this.m_shape.getPathFromVertex(d)===g)return void this.m_shape.setFirstVertex(g,d);{const y=this.m_shape.getPrevVertex(t);if(y!==t&&this.m_shape.getPathFromVertex(y)===g)return void this.m_shape.setFirstVertex(g,y)}}this.m_shape.setFirstVertex(g,c.n),this.m_shape.setLastVertex(g,c.n)}}}processBunch_(){let t=!1;const m=new Y.P(0,0);for(;;){this.m_bunchEdgeEndPoints.length=0,this.m_bunchEdgeCenterPoints.length=0,this.m_bunchEdgeIndices.length=0;let u=this.m_firstCoincidentVertex,g=0,d=!0;for(;u!==this.m_nextVertexToProcess;){const C=this.m_sortedVertices.getData(u);d&&(this.m_shape.queryXY(C,m),d=!1);const S=this.m_shape.getPrevVertex(C),b=this.m_shape.getNextVertex(C);this.m_shape.getUserIndex(S,this.m_userIndexSortedAngleIndexToVertex)!==dt.X&&(this.m_bunchEdgeEndPoints.push(S),this.m_shape.setUserIndex(S,this.m_userIndexSortedAngleIndexToVertex,dt.X),this.m_bunchEdgeCenterPoints.push(C),this.m_bunchEdgeIndices.push(g++)),this.m_shape.getUserIndex(b,this.m_userIndexSortedAngleIndexToVertex)!==dt.X&&(this.m_bunchEdgeEndPoints.push(b),this.m_shape.setUserIndex(b,this.m_userIndexSortedAngleIndexToVertex,dt.X),this.m_bunchEdgeCenterPoints.push(C),this.m_bunchEdgeIndices.push(g++)),u=this.m_sortedVertices.getNext(u)}if(this.m_bunchEdgeEndPoints.length<2){1===this.m_bunchEdgeEndPoints.length&&this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[0],this.m_userIndexSortedAngleIndexToVertex,-1);break}this.m_bunchEdgeIndices.sort((C,S)=>this.compareAngles_(C,S));for(let C=0,S=this.m_bunchEdgeIndices.length;C<S;C++)this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[this.m_bunchEdgeIndices[C]],this.m_userIndexSortedAngleIndexToVertex,C);const y=this.processCrossOvers_(m);for(let C=0,S=this.m_bunchEdgeIndices.length;C<S;C++){const b=this.m_bunchEdgeIndices[C];-1!==b&&this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[b],this.m_userIndexSortedAngleIndexToVertex,-1)}if(!y)break;t=!0}return t}processCrossOvers_(t){let m=!1,u=!0;for(;u;){u=!1;let g=0;-1===this.m_bunchEdgeIndices[g]&&(g=this.getNextEdgeIndex_(g));let d=this.getNextEdgeIndex_(g);for(let y=0,C=this.m_bunchEdgeIndices.length;y<C&&-1!==g&&-1!==d&&g!==d;y++){const A=this.m_bunchEdgeEndPoints[this.m_bunchEdgeIndices[g]],T=this.m_bunchEdgeEndPoints[this.m_bunchEdgeIndices[d]];let M=this.m_shape.getNextVertex(A),X=!1;this.m_shape.isEqualXYPoint2D(M,t)||(M=this.m_shape.getPrevVertex(A),X=!0);let k=this.m_shape.getNextVertex(T),H=!1;this.m_shape.isEqualXYPoint2D(k,t)||(k=this.m_shape.getPrevVertex(T),H=!0);const U=X?this.m_shape.getPrevVertex(M):this.m_shape.getNextVertex(M),Z=H?this.m_shape.getPrevVertex(k):this.m_shape.getNextVertex(k);let st=!1;(this.removeSpike_(M)||this.removeSpike_(k)||this.removeSpike_(A)||this.removeSpike_(T)||this.removeSpike_(U)||this.removeSpike_(Z))&&(st=!0),M!==k&&(!st&&this.m_shape.isEqualXY(A,T)&&(st=this.resolveOverlap_(X,H,M,A,k,T)),!st&&this.m_shape.isEqualXY(U,Z)&&(st=this.resolveOverlap_(!X,!H,M,U,k,Z)),!st&&this.m_shape.isEqualXY(A,Z)&&(st=this.resolveOverlap_(X,!H,M,A,k,Z)),!st&&this.m_shape.isEqualXY(U,T)&&(st=this.resolveOverlap_(!X,H,M,U,k,T))),st&&(m=!0),u||=st,g=st?this.getNextEdgeIndex_(g):d,d=this.getNextEdgeIndex_(g)}}if(!m){let g=0;-1===this.m_bunchEdgeIndices[g]&&(g=this.getNextEdgeIndex_(g));let d=this.getNextEdgeIndex_(g);for(let y=0,C=this.m_bunchEdgeIndices.length;y<C&&-1!==g&&-1!==d&&g!==d;y++){const A=this.m_bunchEdgeEndPoints[this.m_bunchEdgeIndices[g]],T=this.m_bunchEdgeEndPoints[this.m_bunchEdgeIndices[d]];let M=this.m_shape.getNextVertex(A);this.m_shape.isEqualXYPoint2D(M,t)||(M=this.m_shape.getPrevVertex(A));let X=this.m_shape.getNextVertex(T);this.m_shape.isEqualXYPoint2D(X,t)||(X=this.m_shape.getPrevVertex(T));const k=this.getDirection_(M,A),H=this.getDirection_(X,T),U=k?this.m_shape.getPrevVertex(M):this.m_shape.getNextVertex(M),Z=H?this.m_shape.getPrevVertex(X):this.m_shape.getNextVertex(X),st=this.detectAndResolveCrossOver_(k,H,A,M,U,T,X,Z);1!==st?0===st?(g=this.getNextEdgeIndex_(g),d=this.getNextEdgeIndex_(g)):(g=this.getPrevEdgeIndex_(g),d=this.getNextEdgeIndex_(g)):m=!0}}return m}simplify_(){this.m_shape.getGeometryType(this.m_geometry)===F.G.enumPolygon&&1===this.m_shape.getFillRule(this.m_geometry)&&new ai(this.m_progressTracker).planarSimplifyNoCrackingAndCluster(this.m_bFixSelfTangency,this.m_shape,this.m_geometry,0);let t=!1;this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=this.m_shape.createUserIndexUninitialized();const m=this.m_shape.getPointCount(this.m_geometry),u=new dt.A(0);this.m_shape.dbgVerifyMonotone();for(let y=this.m_shape.getFirstPath(this.m_geometry);y!==c.n;y=this.m_shape.getNextPath(y)){let C=this.m_shape.getFirstVertex(y);for(let S=0,b=this.m_shape.getPathSize(y);S<b;S++)this.m_shape.setUserIndex(C,this.m_userIndexSortedAngleIndexToVertex,-1),u.add(C),C=this.m_shape.getNextVertex(C)}this.m_shape.sortVerticesSimpleByY(u,0,m),this.progress_(!0),this.m_userIndexSortedIndexToVertex=this.m_shape.createUserIndexUninitialized(),this.m_sortedVertices.reserveNodes(m),this.m_sortedVerticesListIndex=this.m_sortedVertices.createList(0);for(let y=0;y<m;y++){const C=u.read(y),S=this.m_sortedVertices.addElement(this.m_sortedVerticesListIndex,C);this.m_shape.setUserIndex(C,this.m_userIndexSortedIndexToVertex,S)}this.m_nextVertexToProcess=-1,this.cleanupSpikes_()&&(t=!0);let g=0,d=!1;do{d=!1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=this.m_sortedVertices.getFirst(this.m_sortedVerticesListIndex);const y=new Y.P(0,0);this.m_firstCoincidentVertex!==dt.a2.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(this.m_firstCoincidentVertex),y);let C=0,S=this.m_firstCoincidentVertex;for(;S!==dt.a2.st_nullNode()&&(S=this.m_sortedVertices.getNext(S),S!==dt.a2.st_nullNode());){this.progress_();const b=this.m_sortedVertices.getData(S),A=Y.P.getNAN();if(this.m_shape.queryXY(b,A),y.equals(A))C++;else{if(C>0){this.m_nextVertexToProcess=S;const T=this.processBunch_();S=this.m_nextVertexToProcess,S!==dt.a2.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(S),A),T&&(d=!0)}y.setCoordsPoint2D(A),this.m_firstCoincidentVertex=S,C=0}}this.m_nextVertexToProcess=-1,C>0&&this.processBunch_()&&(d=!0),g++>10&&(0,F.c)(""),d&&this.fixOrphanVertices_(),this.cleanupSpikes_()&&(d=!0),t||=d}while(d);return this.m_shape.dbgVerifyMonotone(),this.m_shape.dbgVerifyCurves(),this.m_shape.removeUserIndex(this.m_userIndexSortedIndexToVertex),this.m_shape.removeUserIndex(this.m_userIndexSortedAngleIndexToVertex),t=function as(P,t,m,u,g){const d=new La(g);return d.m_shape=P,d.m_geometry=t,d.m_sortedVertices=m,d.m_bFixSelfTangency=u,d.fixRingOrientation_()}(this.m_shape,this.m_geometry,this.m_sortedVertices,this.m_bFixSelfTangency,this.m_progressTracker)||t,this.m_shape.dbgVerifyCurves(),t}getDirection_(t,m){return this.m_shape.getNextVertex(m)!==t}detectAndResolveCrossOver_(t,m,u,g,d,y,C,S){if(g===C)return this.removeAngleSortInfo_(u),this.removeAngleSortInfo_(y),-1;const b=this.m_shape.getUserIndex(u,this.m_userIndexSortedAngleIndexToVertex),A=this.m_shape.getUserIndex(d,this.m_userIndexSortedAngleIndexToVertex),T=this.m_shape.getUserIndex(y,this.m_userIndexSortedAngleIndexToVertex),M=this.m_shape.getUserIndex(S,this.m_userIndexSortedAngleIndexToVertex),X=(0,Y.d)(8,Number.NaN),k=(0,Y.d)(4,Number.NaN);X[0]=0,k[0]=b,X[1]=0,k[1]=A,X[2]=1,k[2]=T,X[3]=1,k[3]=M;for(let U=1;U<4;U++){const Z=k[U],st=X[U];let mt=U-1;for(;mt>=0&&k[mt]>Z;)k[mt+1]=k[mt],X[mt+1]=X[mt],mt--;k[mt+1]=Z,X[mt+1]=st}let H=0;if(X[0]&&(H|=1),X[1]&&(H|=2),X[2]&&(H|=4),X[3]&&(H|=8),5!==H&&10!==H)return 0;if(t!==m&&(S=(0,Y.b)(y,y=S)),t)this.m_shape.setNextVertex(S,g),this.m_shape.setPrevVertex(g,S),this.m_shape.setNextVertex(d,C),this.m_shape.setPrevVertex(C,d),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(g,!0),this.m_shape.setSegmentParentageBreakVertex(C,!0));else{if(this.m_shape.setPrevVertex(S,g),this.m_shape.setNextVertex(g,S),this.m_shape.setPrevVertex(d,C),this.m_shape.setNextVertex(C,d),this.m_bHasSegmentParentage){const U=this.m_shape.getSegmentParentage(g),Z=this.m_shape.getSegmentParentage(C);this.m_shape.setSegmentParentageAndBreak(g,Z,!0),this.m_shape.setSegmentParentageAndBreak(C,U,!0)}if(this.m_bHasSegments){const U=this.m_shape.getVertexIndex(g),Z=this.m_shape.getVertexIndex(C),st=this.m_shape.getSegmentFromIndex(U);this.m_shape.setSegmentToIndex(U,null);const mt=this.m_shape.getSegmentFromIndex(Z);this.m_shape.setSegmentToIndex(Z,null),this.m_shape.setSegmentToIndex(U,mt),this.m_shape.setSegmentToIndex(Z,st)}}return 1}resolveOverlap_(t,m,u,g,d,y){return this.resolveOverlapOddEven_(t,m,u,g,d,y)}resolveOverlapOddEven_(t,m,u,g,d,y){if(t!==m){t||(d=(0,Y.b)(u,u=d),y=(0,Y.b)(g,g=y));const C=this.m_shape.getNextVertex(d),S=this.m_shape.getNextVertex(u);if(this.m_shape.setNextVertex(u,C),this.m_shape.setPrevVertex(C,u),this.m_shape.setNextVertex(d,S),this.m_shape.setPrevVertex(S,d),this.m_bHasSegments){const b=this.m_shape.getVertexIndex(u),A=this.m_shape.getVertexIndex(d),T=this.m_shape.getSegmentFromIndex(b);this.m_shape.setSegmentToIndex(b,null);const M=this.m_shape.getSegmentFromIndex(A);this.m_shape.setSegmentToIndex(A,null),this.m_shape.setSegmentToIndex(b,M),this.m_shape.setSegmentToIndex(A,T)}if(this.m_bHasSegmentParentage){const b=this.m_shape.getSegmentParentage(u),A=this.m_shape.getSegmentParentage(d);this.m_shape.setSegmentParentageAndBreak(u,A,!0),this.m_shape.setSegmentParentageAndBreak(d,b,!0),this.m_shape.setSegmentParentageBreakVertex(g,!0),this.m_shape.setSegmentParentageBreakVertex(y,!0)}this.removeSpike_(d)}else{const C=t?u:g,S=m?d:y,b=t?g:u,A=m?y:d;let T=null;if(this.m_bHasSegments){const st=this.m_shape.getVertexIndex(A);T=this.m_shape.getSegmentFromIndex(st),this.m_shape.setSegmentToIndex(st,null);const mt=this.m_shape.getVertexIndex(S);this.m_shape.setSegmentToIndex(mt,null);const ht=this.m_shape.getVertexIndex(C);this.m_shape.setSegmentToIndex(ht,null)}let M=-1;this.m_bHasSegmentParentage&&(M=this.m_shape.getSegmentParentage(A));let X=!1;this.m_shape.setNextVertex(C,S),this.m_shape.setNextVertex(S,C),this.m_shape.setPrevVertex(b,A),this.m_shape.setPrevVertex(A,b);let k=A;for(;k!==S;){const st=this.m_shape.getPrevVertex(k),mt=this.m_shape.getNextVertex(k);if(this.m_shape.setPrevVertex(k,mt),this.m_shape.setNextVertex(k,st),X||=k===C,this.m_bHasSegments&&k!==C){const ht=this.m_shape.getVertexIndex(mt),ut=T;T=this.m_shape.getSegmentFromIndex(ht),null!==ut&&ut.reverse(),this.m_shape.setSegmentToIndex(ht,ut)}if(this.m_bHasSegmentParentage){const ht=this.m_shape.getSegmentParentage(mt);this.m_shape.setSegmentParentagePreserveBreak(mt,M),M=ht}k=mt}let H=null;if(!X){const st=this.m_shape.getPrevVertex(S),mt=this.m_shape.getNextVertex(S);if(this.m_shape.setPrevVertex(S,mt),this.m_shape.setNextVertex(S,st),this.m_bHasSegments){const ht=this.m_shape.getVertexIndex(S);H=this.m_shape.getSegmentFromIndex(ht),this.m_shape.setSegmentToIndex(ht,null)}}let U=-1,Z=-1;if(this.m_bHasSegmentParentage&&(U=this.m_shape.getSegmentParentage(X?C:S),Z=this.m_shape.getSegmentParentage(b)),this.transferVertexData_(S,C),this.beforeRemoveVertex_(S,!0),this.m_shape.removeVertexInternal(S,!0),this.removeAngleSortInfo_(C),this.transferVertexData_(A,b),this.beforeRemoveVertex_(A,!0),this.m_shape.removeVertexInternal(A,!0),this.removeAngleSortInfo_(b),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageAndBreak(C,U,!0),this.m_shape.setSegmentParentageAndBreak(b,Z,!0)),H){const st=this.m_shape.getVertexIndex(C);this.m_shape.setSegmentToIndex(st,H)}}return!0}cleanupSpikes_(){let t=!1;for(let m=this.m_shape.getFirstPath(this.m_geometry);m!==c.n;){const u=this.m_shape.getNextPath(m);let g=this.m_shape.getFirstVertex(m);for(let d=0,y=this.m_shape.getPathSize(m);d<y&&y>1;){this.progress_();const{v:C,bModified:S}=this.checkAndCleanupSpike_(m,g);if(C===c.n)break;S?(t=!0,g=C,d=0,y=this.m_shape.getPathSize(m)):(g=C,d++)}m=u}return t}checkAndCleanupSpike_(t,m){const u={v:c.n,bModified:!1};let g=this.m_shape.getPrevVertex(m),d=this.m_shape.getNextVertex(m),y=c.n,C=c.n;for(;this.m_shape.isEqualXY(g,d)&&(y=g,C=d,d!==m);)g=this.m_shape.getPrevVertex(g),d=this.m_shape.getNextVertex(d);if(y===c.n)return u.v=d,u;u.bModified=!0;for(let S=this.m_shape.getNextVertex(y);this.beforeRemoveVertex_(S,!1),S!==C;S=this.m_shape.getNextVertex(S));if(y===m)return this.m_polylineDegeneracies!==c.n?this.m_shape.movePath(this.m_polylineDegeneracies,c.n,t):this.m_shape.removePath(t),u.v=c.n,u;{const S=this.m_shape.peelALoopIntoAPath(y,C);this.m_polylineDegeneracies!==c.n?this.m_shape.movePath(this.m_polylineDegeneracies,c.n,S):this.m_shape.removePath(S)}return u.v=y,u}removeSpike_(t){let m=this.m_shape.getPrevVertex(t),u=this.m_shape.getNextVertex(t),g=c.n,d=c.n;for(;this.m_shape.isEqualXY(m,u)&&(g=m,d=u,u!==t);)m=this.m_shape.getPrevVertex(m),u=this.m_shape.getNextVertex(u);if(g===c.n)return!1;if(this.m_shape.peelALoop(g,d),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(g,!0),this.m_shape.setSegmentParentageBreakVertex(d,!0)),this.removeAngleSortInfo_(g),this.m_polylineDegeneracies===c.n)for(let y=this.m_shape.getNextVertex(d);;){const C=this.m_shape.getNextVertex(y);if(this.removeAngleSortInfo_(y),this.beforeRemoveVertex_(y,!0),this.m_shape.setSegmentToIndex(this.m_shape.getVertexIndex(y),null),this.m_shape.removeVertexInternal(y,!1),y===d)break;y=C}else{for(let C=d;;){const S=this.m_shape.getNextVertex(C);if(this.removeAngleSortInfo_(C),this.beforeRemoveVertex_(C,!1),C=S,C===d)break}this.m_shape.insertClosedPath(this.m_polylineDegeneracies,c.n,d,d,[!1])}return!0}fixOrphanVertices_(){let t=0;for(let g=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());-1!==g;g=this.m_sortedVertices.getNext(g)){const d=this.m_sortedVertices.getData(g);this.m_shape.setPathToVertex(d,c.n)}let m=0;for(let g=this.m_shape.getFirstPath(this.m_geometry);g!==c.n;){const d=this.m_shape.getFirstVertex(g);if(d===c.n||this.m_shape.getPathFromVertex(d)!==c.n){const C=g;g=this.m_shape.getNextPath(g),this.m_shape.removePathOnly(C);continue}this.m_shape.setPathToVertex(d,g);let y=1;for(let C=this.m_shape.getNextVertex(d);C!==d;C=this.m_shape.getNextVertex(C))this.m_shape.setPathToVertex(C,g),y++;this.m_shape.setRingAreaValid(g,!1),this.m_shape.setPathSize(g,y),this.m_shape.setLastVertex(g,this.m_shape.getPrevVertex(d)),m+=y,t++,g=this.m_shape.getNextPath(g)}for(let g=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());-1!==g;g=this.m_sortedVertices.getNext(g)){const d=this.m_sortedVertices.getData(g);if(this.m_shape.getPathFromVertex(d)!==c.n)continue;const C=this.m_shape.insertClosedPath(this.m_geometry,c.n,d,d,[!1]);m+=this.m_shape.getPathSize(C),t++}this.m_shape.setGeometryPathCount(this.m_geometry,t),this.m_shape.setGeometryVertexCount(this.m_geometry,m);let u=0;for(let g=this.m_shape.getFirstGeometry();g!==c.n;g=this.m_shape.getNextGeometry(g))u+=this.m_shape.getPointCount(g);this.m_shape.setTotalPointCount(u)}getNextEdgeIndex_(t){if(-1===t)return-1;for(let m=0,u=this.m_bunchEdgeIndices.length-1;m<u;m++)if(-1!==this.m_bunchEdgeIndices[t=(t+1)%this.m_bunchEdgeIndices.length])return t;return-1}getPrevEdgeIndex_(t){if(-1===t)return-1;for(let m=0,u=this.m_bunchEdgeIndices.length-1;m<u;m++)if(-1!==this.m_bunchEdgeIndices[t=(this.m_bunchEdgeIndices.length+t-1)%this.m_bunchEdgeIndices.length])return t;return-1}transferVertexData_(t,m){const u=this.m_shape.getUserIndex(m,this.m_userIndexSortedIndexToVertex),g=this.m_shape.getUserIndex(m,this.m_userIndexSortedAngleIndexToVertex);this.m_shape.transferAllDataToTheVertex(t,m),this.m_shape.setUserIndex(m,this.m_userIndexSortedIndexToVertex,u),this.m_shape.setUserIndex(m,this.m_userIndexSortedAngleIndexToVertex,g)}removeAngleSortInfo_(t){const m=this.m_shape.getUserIndex(t,this.m_userIndexSortedAngleIndexToVertex);-1!==m&&(this.m_bunchEdgeIndices[m]=-1,this.m_shape.setUserIndex(t,this.m_userIndexSortedAngleIndexToVertex,-1))}progress_(t=!1){}}function pi(P,t,m,u,g,d=!0){switch(qn(u)){case 0:break;case 1:(0,F.t)("relation string length has to be 9 characters");break;default:(0,F.t)("relation string")}if(d){const M=function cr(P,t,m){return function Oa(P){return"T*F**FFF*"===P}(P)?3:function Wa(P){return"FF*FF****"===P}(P)?4:function ja(P,t,m){return!(0===t&&0===m||(2===t&&2===m?"F***T****"!==P:2!==t&&1!==t||0!==m||"F**T*****"!==P))}(P,t,m)?8:function Ja(P,t,m){return t>m?"T*****T**"===P:1===t&&1===m&&"0********"===P}(P,t,m)?16:function Qa(P){return"T**FF*FF*"===P}(P)?64:function Za(P){return"T*****FF*"===P}(P)?1:function Wi(P,t,m){return t===m&&(1!==t?"T*T***T**"===P:"1*T***T**"===P)}(P,t,m)?32:0}(u,P.getDimension(),t.getDimension());if(0!==M)return Ki(P,t,m,M,g)}let y=0;if("number"==typeof m)y=m;else{const M=R.J.constructEmpty();P.queryEnvelope(M);const X=R.J.constructEmpty();t.queryEnvelope(X);const k=R.J.constructEmpty();k.setCoords({env2D:M}),k.mergeEnvelope2D(X),y=(0,dt.c)(m,k,!1)}const C=$a(P,y),S=$a(t,y);if(C.isEmpty()||S.isEmpty())return function Ua(P,t,m){const u=(0,Y.d)(9,-1);if(P.isEmpty()&&t.isEmpty())return Bs(u,m);let g,d=!1;P.isEmpty()?(g=t,d=!0):g=P,u[0]=-1,u[1]=-1,u[3]=-1,u[4]=-1,u[6]=-1,u[7]=-1,u[8]=2;const y=g.getGeometryType();if((0,F.h)(y))if(y===F.G.enumPolygon)if(0!==g.calculateArea2D())u[2]=2,u[5]=1;else{u[5]=-1;const C=R.J.constructEmpty();g.queryEnvelope(C),u[2]=C.height()||C.width()?1:0}else{const C=0!==g.calculateLength2D();u[2]=C?1:0,u[5]=(0,c.J)(g)?0:-1}else u[2]=0,u[5]=-1;return d&&Ka(u),Bs(u,m)}(C,S,u);const b=C.getGeometryType(),A=S.getGeometryType();let T=!1;switch(b){case F.G.enumPolygon:switch(A){case F.G.enumPolygon:T=function ur(P,t,m,u,g){const d=new Gi;d.resetMatrix_(),d.setPredicates_(u),d.setAreaAreaPredicates_();const y=R.J.constructEmpty(),C=R.J.constructEmpty();P.queryEnvelope(y),t.queryEnvelope(C);let S=!1;if(Fi(y,C,m)&&(d.areaAreaDisjointPredicates_(P,t),S=!0),S||Xe(P,t),!S){const b=new c.E,A=b.addGeometry(P),T=b.addGeometry(t);d.setEditShapeCrackAndCluster_(b,new dt.C(m,0),g),d.computeMatrixTopoGraphHalfEdges_(A,T),d.m_topoGraph.removeShape()}return Bs(d.m_matrix,d.m_scl)}(C,S,y,u,g);break;case F.G.enumPolyline:T=Mo(C,S,y,u,g);break;case F.G.enumPoint:T=Vo(C,S,y,u);break;case F.G.enumMultiPoint:T=Ha(C,S,y,u,g)}break;case F.G.enumPolyline:switch(A){case F.G.enumPolygon:T=Mo(S,C,y,Vn(u),g);break;case F.G.enumPolyline:T=function qo(P,t,m,u,g){const d=new Gi;d.resetMatrix_(),d.setPredicates_(u),d.setLineLinePredicates_();const y=R.J.constructEmpty(),C=R.J.constructEmpty();P.queryEnvelope(y),t.queryEnvelope(C);let S=!1;if(Fi(y,C,m)&&(d.lineLineDisjointPredicates_(P,t),S=!0),S||Xe(P,t),!S){const b=new c.E,A=b.addGeometry(P),T=b.addGeometry(t);d.setEditShapeCrackAndCluster_(b,new dt.C(m,0),g),d.m_clusterIndexA=d.m_topoGraph.createUserIndexForClusters(),d.m_clusterIndexB=d.m_topoGraph.createUserIndexForClusters(),ji(A,d.m_topoGraph,d.m_clusterIndexA),ji(T,d.m_topoGraph,d.m_clusterIndexB),d.computeMatrixTopoGraphHalfEdges_(A,T),d.m_topoGraph.deleteUserIndexForClusters(d.m_clusterIndexA),d.m_topoGraph.deleteUserIndexForClusters(d.m_clusterIndexB),d.m_topoGraph.removeShape()}return Bs(d.m_matrix,d.m_scl)}(C,S,y,u,g);break;case F.G.enumPoint:T=za(C,S,y,u,g);break;case F.G.enumMultiPoint:T=Wr(C,S,y,u,g)}break;case F.G.enumPoint:switch(A){case F.G.enumPolygon:T=Vo(S,C,y,Vn(u));break;case F.G.enumPolyline:T=za(S,C,y,Vn(u),g);break;case F.G.enumPoint:T=function Lm(P,t,m,u,g){const d=P.getXY(),y=t.getXY(),C=(0,Y.d)(9,-1);return Y.P.sqrDistance(d,y)<=m*m?C[0]=0:(C[2]=0,C[6]=0),C[8]=2,Bs(C,u)}(C,S,y,u);break;case F.G.enumMultiPoint:T=jr(S,C,y,Vn(u))}break;case F.G.enumMultiPoint:switch(A){case F.G.enumPolygon:T=Ha(S,C,y,Vn(u),g);break;case F.G.enumPolyline:T=Wr(S,C,y,Vn(u),g);break;case F.G.enumMultiPoint:T=function on(P,t,m,u,g){const d=new Gi;d.resetMatrix_(),d.setPredicates_(u),d.setPointPointPredicates_();const y=new R.J,C=new R.J;P.queryEnvelope(y),t.queryEnvelope(C);let S=!1;if(Fi(y,C,m)&&(d.pointPointDisjointPredicates_(),S=!0),!S){const b=new c.E,A=b.addGeometry(P),T=b.addGeometry(t);d.setEditShapeCrackAndCluster_(b,new dt.C(m,0),g),d.computeMatrixTopoGraphClusters_(A,T),d.m_topoGraph.removeShape()}return Bs(d.m_matrix,d.m_scl)}(C,S,y,u,g);break;case F.G.enumPoint:T=jr(C,S,y,u)}break;default:T=!1}return T}function qn(P){if(9!==P.length)return 1;for(let t=0;t<9;t++){const m=P[t];if("*"!==m&&"T"!==m&&"F"!==m&&"0"!==m&&"1"!==m&&"2"!==m)return 2}return 0}function Mo(P,t,m,u,g){const d=new Gi;d.resetMatrix_(),d.setPredicates_(u),d.setAreaLinePredicates_();const y=R.J.constructEmpty(),C=R.J.constructEmpty();P.queryEnvelope(y),t.queryEnvelope(C);let S=!1;if(Fi(y,C,m)&&(d.areaLineDisjointPredicates_(P,t),S=!0),S||Xe(P,t),!S){const b=new c.E,A=b.addGeometry(P),T=b.addGeometry(t);d.setEditShapeCrackAndCluster_(b,new dt.C(m,0),g),d.m_clusterIndexB=d.m_topoGraph.createUserIndexForClusters(),ji(T,d.m_topoGraph,d.m_clusterIndexB),d.computeMatrixTopoGraphHalfEdges_(A,T),d.m_topoGraph.deleteUserIndexForClusters(d.m_clusterIndexB),d.m_topoGraph.removeShape()}return Bs(d.m_matrix,d.m_scl)}function Ha(P,t,m,u,g){const d=new Gi;d.resetMatrix_(),d.setPredicates_(u),d.setAreaPointPredicates_();const y=R.J.constructEmpty(),C=R.J.constructEmpty();P.queryEnvelope(y),t.queryEnvelope(C);let S=!1;if(Fi(y,C,m)&&(d.areaPointDisjointPredicates_(P),S=!0),S||Xe(P,t),!S){const b=new c.E,A=b.addGeometry(P),T=b.addGeometry(t);d.setEditShapeCrackAndCluster_(b,new dt.C(m,0),g),d.computeMatrixTopoGraphClusters_(A,T),d.m_topoGraph.removeShape()}return Bs(d.m_matrix,d.m_scl)}function Wr(P,t,m,u,g){const d=new Gi;d.resetMatrix_(),d.setPredicates_(u),d.setLinePointPredicates_();const y=R.J.constructEmpty(),C=R.J.constructEmpty();P.queryEnvelope(y),t.queryEnvelope(C);let S=!1;if(Fi(y,C,m)&&(d.linePointDisjointPredicates_(P),S=!0),S||Xe(P,t),!S){const b=new c.E,A=b.addGeometry(P),T=b.addGeometry(t);d.setEditShapeCrackAndCluster_(b,new dt.C(m,0),g),d.m_clusterIndexA=d.m_topoGraph.createUserIndexForClusters(),ji(A,d.m_topoGraph,d.m_clusterIndexA),d.computeMatrixTopoGraphClusters_(A,T),d.m_topoGraph.deleteUserIndexForClusters(d.m_clusterIndexA),d.m_topoGraph.removeShape()}return Bs(d.m_matrix,d.m_scl)}function Vo(P,t,m,u,g){const d=new Gi;d.resetMatrix_(),d.setPredicates_(u),d.setAreaPointPredicates_();const y=R.J.constructEmpty();P.queryEnvelope(y);const C=t.getXY();let S=!1;if(fn(C,y,m)&&(d.areaPointDisjointPredicates_(P),S=!0),!S){const b=ti(P,C,m);if(1===b)d.m_matrix[0]=0,d.m_matrix[2]=2,d.m_matrix[3]=-1,d.m_matrix[5]=1,d.m_matrix[6]=-1;else if(2===b)if(d.m_matrix[6]=-1,0!==P.calculateArea2D())d.m_matrix[0]=-1,d.m_matrix[3]=0,d.m_matrix[2]=2,d.m_matrix[5]=1;else{d.m_matrix[0]=0,d.m_matrix[3]=-1,d.m_matrix[5]=-1;const A=R.J.constructEmpty();P.queryEnvelope(A),d.m_matrix[2]=A.height()||A.width()?1:-1}else d.areaPointDisjointPredicates_(P)}return Bs(d.m_matrix,u)}function za(P,t,m,u,g){const d=new Gi;d.resetMatrix_(),d.setPredicates_(u),d.setLinePointPredicates_();const y=R.J.constructEmpty();P.queryEnvelope(y);let C=!1;if(fn(t.getXY(),y,m)&&(d.linePointDisjointPredicates_(P),C=!0),!C){let S=null,b=!1,A=!1;if((d.m_performPredicates[0]||d.m_performPredicates[6])&&(Ki(P,t,m,4,g)?(d.m_matrix[0]=-1,d.m_matrix[6]=0):(d.m_performPredicates[0]&&(S=(0,c.c)(P),A=!Ki(S,t,m,4,g),b=!0,d.m_matrix[0]=A?-1:0),d.m_matrix[6]=-1)),d.m_performPredicates[3]&&(null!==S&&S.isEmpty()?d.m_matrix[3]=-1:(b||(null==S&&(S=(0,c.c)(P)),A=!Ki(S,t,m,4,g),b=!0),d.m_matrix[3]=A?0:-1)),d.m_performPredicates[5])if(null!==S&&S.isEmpty())d.m_matrix[5]=-1;else if(b&&!A)d.m_matrix[5]=0;else{null===S&&(S=(0,c.c)(P));const T=Ki(S,t,m,3,g);d.m_matrix[5]=T?-1:0}if(d.m_performPredicates[2])if(0!==P.calculateLength2D())d.m_matrix[2]=1;else{const T=new c.M({vd:P.getDescription()});T.addPoints(P,0,P.getPointCount());const M=Ki(T,t,m,3,g);d.m_matrix[2]=M?-1:0}}return Bs(d.m_matrix,d.m_scl)}function jr(P,t,m,u,g){const d=new Gi;d.resetMatrix_(),d.setPredicates_(u),d.setPointPointPredicates_();const y=R.J.constructEmpty();P.queryEnvelope(y);const C=t.getXY(),S=new Y.P;let b=!1;if(fn(C,y,m)&&(d.pointPointDisjointPredicates_(),b=!0),!b){let A=!1,T=!0;const M=m*m;for(let X=0;X<P.getPointCount()&&(P.queryXY(X,S),Y.P.sqrDistance(S,C)<=M?A=!0:T=!1,!A||T);X++);A?(d.m_matrix[0]=0,d.m_matrix[2]=T?-1:0,d.m_matrix[6]=-1):(d.m_matrix[0]=-1,d.m_matrix[2]=0,d.m_matrix[6]=0)}return Bs(d.m_matrix,u)}function Bs(P,t){for(let m=0;m<9;m++)switch(t[m]){case"T":if(-1===P[m])return!1;break;case"F":if(-1!==P[m])return!1;break;case"0":if(0!==P[m])return!1;break;case"1":if(1!==P[m])return!1;break;case"2":if(2!==P[m])return!1}return!0}function ji(P,t,m){const u=t.getGeometryID(P);for(let g=t.getFirstCluster();g!==c.n;g=t.getNextCluster(g)){if(!(t.getClusterParentage(g)&u))continue;const d=t.getClusterHalfEdge(g);if(d===c.n){t.setClusterUserIndex(g,m,0);continue}let y=d,C=0;do{const S=y;t.getHalfEdgeParentage(S)&u&&C++,y=t.getHalfEdgeNext(t.getHalfEdgeTwin(S))}while(y!==d);t.setClusterUserIndex(g,m,C)}}class Gi{nullFunc(){return(0,F.c)("should not be called"),!1}constructor(){this.m_clusterIndexA=-1,this.m_clusterIndexB=-1,this.m_visitedIndex=-1,this.m_topoGraph=new Qs,this.m_matrix=(0,Y.d)(9,0),this.m_maxDim=(0,Y.d)(9,0),this.m_performPredicates=(0,Y.d)(9,!1),this.m_scl="",this.m_predicateCount=0,this.m_predicatesHalfEdge=this.nullFunc,this.m_predicatesCluster=this.nullFunc}resetMatrix_(){this.m_matrix.fill(-2),this.m_maxDim.fill(-2)}setPredicates_(t){this.m_scl=t;for(let m=0;m<9;m++)"*"!==this.m_scl[m]?(this.m_performPredicates[m]=!0,this.m_predicateCount++):this.m_performPredicates[m]=!1}setRemainingPredicatesToFalse_(){for(let t=0;t<9;t++)this.m_performPredicates[t]&&-2===this.m_matrix[t]&&(this.m_matrix[t]=-1,this.m_performPredicates[t]=!1)}isPredicateKnown_(t){return!(-2===this.m_matrix[t]||(-1===this.m_matrix[t]?(this.m_performPredicates[t]=!1,this.m_predicateCount--,0):"T"!==this.m_scl[t]&&"F"!==this.m_scl[t]&&this.m_matrix[t]<this.m_maxDim[t]||(this.m_performPredicates[t]=!1,this.m_predicateCount--,0)))}setAreaAreaPredicates_(){this.m_predicatesHalfEdge=this.areaAreaPredicates_,this.m_maxDim[0]=2,this.m_maxDim[1]=1,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=1,this.m_maxDim[5]=1,this.m_maxDim[6]=2,this.m_maxDim[7]=1,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaLinePredicates_(){this.m_predicatesHalfEdge=this.areaLinePredicates_,this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=0,this.m_maxDim[5]=1,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLineLinePredicates_(){this.m_predicatesHalfEdge=this.lineLinePredicates_,this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=0,this.m_maxDim[5]=0,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaPointPredicates_(){this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=2,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLinePointPredicates_(){this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=0,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setPointPointPredicates_(){this.m_predicatesCluster=this.pointPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=0,this.m_maxDim[3]=-1,this.m_maxDim[4]=-1,this.m_maxDim[5]=-1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[3]&&(this.m_matrix[3]=-1,this.m_performPredicates[3]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[5]&&(this.m_matrix[5]=-1,this.m_performPredicates[5]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}areaAreaDisjointPredicates_(t,m){this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5]),this.areaGeomContainsOrDisjointPredicates_(m,this.m_performPredicates[6]?6:-1,this.m_scl[6],this.m_performPredicates[7]?7:-1,this.m_scl[7])}areaGeomContainsOrDisjointPredicates_(t,m,u,g,d){const y=-1!==m,C=-1!==g;if(y||C)if(("T"!==u&&"F"!==u&&y||"T"!==d&&"F"!==d&&C)&&0===t.calculateArea2D()){if(C&&(this.m_matrix[g]=-1),y){const S=R.J.constructEmpty();t.queryEnvelope(S),this.m_matrix[m]=S.height()||S.width()?1:0}}else y&&(this.m_matrix[m]=2),C&&(this.m_matrix[g]=1)}areaAreaContainsPredicates_(t){this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1,this.m_matrix[7]=-1,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[0]?0:-1,this.m_scl[0],this.m_performPredicates[1]?1:-1,this.m_scl[1])}areaAreaWithinPredicates_(t){this.areaAreaContainsPredicates_(t),Ka(this.m_matrix)}areaLineDisjointPredicates_(t,m){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[6]){const u=this.m_scl[6],g="T"===u||"F"===u||0!==m.calculateLength2D();this.m_matrix[6]=g?1:0}if(this.m_performPredicates[7]){const u=(0,c.J)(m);this.m_matrix[7]=u?0:-1}this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaLineContainsPredicates_(t,m){if(this.m_performPredicates[0]){const u=this.m_scl[0],g="T"===u||"F"===u||0!==m.calculateLength2D();this.m_matrix[0]=g?1:0}if(this.m_performPredicates[1]){const u=(0,c.J)(m);this.m_matrix[1]=u?0:-1}this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1,this.m_matrix[7]=-1}areaPointDisjointPredicates_(t){this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_matrix[6]=0,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaPointContainsPredicates_(t){this.m_matrix[0]=0,this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1}lineLineDisjointPredicates_(t,m){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[2]){const u=this.m_scl[2],g="T"===u||"F"===u||0!==t.calculateLength2D();this.m_matrix[2]=g?1:0}if(this.m_performPredicates[5]){const u=(0,c.J)(t);this.m_matrix[5]=u?0:-1}if(this.m_performPredicates[6]){const u=this.m_scl[6],g="T"===u||"F"===u||0!==m.calculateLength2D();this.m_matrix[6]=g?1:0}if(this.m_performPredicates[7]){const u=(0,c.J)(m);this.m_matrix[7]=u?0:-1}}linePointDisjointPredicates_(t){if(this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_performPredicates[2]){const m=this.m_scl[2],u="T"===m||"F"===m||0!==t.calculateLength2D();this.m_matrix[2]=u?1:0}if(this.m_performPredicates[5]){const m=(0,c.J)(t);this.m_matrix[5]=m?0:-1}this.m_matrix[6]=0}pointPointDisjointPredicates_(){this.m_matrix[0]=-1,this.m_matrix[2]=0,this.m_matrix[6]=0}areaAreaPredicates_(t,m,u){let g=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorArea_(t,m,u);const d=this.isPredicateKnown_(0);g&&=d}if(this.m_performPredicates[1]){this.interiorAreaBoundaryArea_(t,m,1);const d=this.isPredicateKnown_(1);g&&=d}if(this.m_performPredicates[2]){this.interiorAreaExteriorArea_(t,m,u,2);const d=this.isPredicateKnown_(2);g&&=d}if(this.m_performPredicates[3]){this.interiorAreaBoundaryArea_(t,u,3);const d=this.isPredicateKnown_(3);g&&=d}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryArea_(t,m,u);const d=this.isPredicateKnown_(4);g&&=d}if(this.m_performPredicates[5]){this.boundaryAreaExteriorArea_(t,m,u,5);const d=this.isPredicateKnown_(5);g&&=d}if(this.m_performPredicates[6]){this.interiorAreaExteriorArea_(t,u,m,6);const d=this.isPredicateKnown_(6);g&&=d}if(this.m_performPredicates[7]){this.boundaryAreaExteriorArea_(t,u,m,7);const d=this.isPredicateKnown_(7);g&&=d}return g}areaLinePredicates_(t,m,u){let g=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorLine_(t,m,u);const d=this.isPredicateKnown_(0);g&&=d}if(this.m_performPredicates[1]){this.interiorAreaBoundaryLine_(t,m,u,this.m_clusterIndexB);const d=this.isPredicateKnown_(1);g&&=d}if(this.m_performPredicates[2]){this.interiorAreaExteriorLine_(t,m,u);const d=this.isPredicateKnown_(2);g&&=d}if(this.m_performPredicates[3]){this.boundaryAreaInteriorLine_(t,m,u,this.m_clusterIndexB);const d=this.isPredicateKnown_(3);g&&=d}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryLine_(t,m,u,this.m_clusterIndexB);const d=this.isPredicateKnown_(4);g&&=d}if(this.m_performPredicates[5]){this.boundaryAreaExteriorLine_(t,m,u);const d=this.isPredicateKnown_(5);g&&=d}if(this.m_performPredicates[6]){this.exteriorAreaInteriorLine_(t,m);const d=this.isPredicateKnown_(6);g&&=d}if(this.m_performPredicates[7]){this.exteriorAreaBoundaryLine_(t,m,u,this.m_clusterIndexB);const d=this.isPredicateKnown_(7);g&&=d}return g}lineLinePredicates_(t,m,u){let g=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorLine_(t,m,u,this.m_clusterIndexA,this.m_clusterIndexB);const d=this.isPredicateKnown_(0);g&&=d}if(this.m_performPredicates[1]){this.interiorLineBoundaryLine_(t,m,u,this.m_clusterIndexA,this.m_clusterIndexB,1);const d=this.isPredicateKnown_(1);g&&=d}if(this.m_performPredicates[2]){this.interiorLineExteriorLine_(t,m,u,2);const d=this.isPredicateKnown_(2);g&&=d}if(this.m_performPredicates[3]){this.interiorLineBoundaryLine_(t,u,m,this.m_clusterIndexB,this.m_clusterIndexA,3);const d=this.isPredicateKnown_(3);g&&=d}if(this.m_performPredicates[4]){this.boundaryLineBoundaryLine_(t,m,u,this.m_clusterIndexA,this.m_clusterIndexB);const d=this.isPredicateKnown_(4);g&&=d}if(this.m_performPredicates[5]){this.boundaryLineExteriorLine_(t,m,u,this.m_clusterIndexA,5);const d=this.isPredicateKnown_(5);g&&=d}if(this.m_performPredicates[6]){this.interiorLineExteriorLine_(t,u,m,6);const d=this.isPredicateKnown_(6);g&&=d}if(this.m_performPredicates[7]){this.boundaryLineExteriorLine_(t,u,m,this.m_clusterIndexB,7);const d=this.isPredicateKnown_(7);g&&=d}return g}areaPointPredicates_(t,m,u){let g=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorPoint_(t,m);const d=this.isPredicateKnown_(0);g&&=d}if(this.m_performPredicates[2]){this.interiorAreaExteriorPoint_(t,m);const d=this.isPredicateKnown_(2);g&&=d}if(this.m_performPredicates[3]){this.boundaryAreaInteriorPoint_(t,m,u);const d=this.isPredicateKnown_(3);g&&=d}if(this.m_performPredicates[5]){this.boundaryAreaExteriorPoint_(t,m);const d=this.isPredicateKnown_(5);g&&=d}if(this.m_performPredicates[6]){this.exteriorAreaInteriorPoint_(t,m);const d=this.isPredicateKnown_(6);g&&=d}return g}linePointPredicates_(t,m,u){let g=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorPoint_(t,m,u,this.m_clusterIndexA);const d=this.isPredicateKnown_(0);g&&=d}if(this.m_performPredicates[2]){this.interiorLineExteriorPoint_(t,m,u,this.m_clusterIndexA);const d=this.isPredicateKnown_(2);g&&=d}if(this.m_performPredicates[3]){this.boundaryLineInteriorPoint_(t,m,u,this.m_clusterIndexA);const d=this.isPredicateKnown_(3);g&&=d}if(this.m_performPredicates[5]){this.boundaryLineExteriorPoint_(t,m,u,this.m_clusterIndexA);const d=this.isPredicateKnown_(5);g&&=d}if(this.m_performPredicates[6]){this.exteriorLineInteriorPoint_(t,m,u);const d=this.isPredicateKnown_(6);g&&=d}return g}pointPointPredicates_(t,m,u){let g=!0;if(this.m_performPredicates[0]){this.interiorPointInteriorPoint_(t,m,u);const d=this.isPredicateKnown_(0);g&&=d}if(this.m_performPredicates[2]){this.interiorPointExteriorPoint_(t,m,u,2);const d=this.isPredicateKnown_(2);g&&=d}if(this.m_performPredicates[6]){this.interiorPointExteriorPoint_(t,u,m,6);const d=this.isPredicateKnown_(6);g&&=d}return g}interiorAreaInteriorArea_(t,m,u){if(2===this.m_matrix[0])return;const g=this.m_topoGraph.getHalfEdgeFaceParentage(t);g&m&&g&u&&(this.m_matrix[0]=2)}interiorAreaBoundaryArea_(t,m,u){if(1===this.m_matrix[u])return;const g=this.m_topoGraph.getHalfEdgeFaceParentage(t),d=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));g&m&&d&m&&(this.m_matrix[u]=1)}interiorAreaExteriorArea_(t,m,u,g){if(2===this.m_matrix[g])return;const d=this.m_topoGraph.getHalfEdgeFaceParentage(t);d&m&&!(d&u)&&(this.m_matrix[g]=2)}boundaryAreaBoundaryArea_(t,m,u){if(1===this.m_matrix[4])return;const g=this.m_topoGraph.getHalfEdgeParentage(t);if(g&m&&g&u)this.m_matrix[4]=1;else if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const d=this.m_topoGraph.getHalfEdgeTo(t),y=this.m_topoGraph.getClusterParentage(d);if(y&m&&y&u)return void(this.m_matrix[4]=0)}}boundaryAreaExteriorArea_(t,m,u,g){if(1===this.m_matrix[g])return;const d=this.m_topoGraph.getHalfEdgeFaceParentage(t),y=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));d&u||y&u||(this.m_matrix[g]=1)}interiorAreaInteriorLine_(t,m,u){if(1===this.m_matrix[0])return;const g=this.m_topoGraph.getHalfEdgeFaceParentage(t),d=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));g&m&&d&m&&(this.m_matrix[0]=1)}interiorAreaBoundaryLine_(t,m,u,g){if(0!==this.m_matrix[1]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const d=this.m_topoGraph.getHalfEdgeTo(t),y=this.m_topoGraph.getClusterParentage(d);if(!(y&m)&&this.m_topoGraph.getHalfEdgeFaceParentage(t)&m){const C=this.m_topoGraph.getClusterUserIndex(d,g);if(y&u&&C%2!=0)return void(this.m_matrix[1]=0)}}}interiorAreaExteriorLine_(t,m,u){2!==this.m_matrix[2]&&this.m_topoGraph.getHalfEdgeParentage(t)&m&&(this.m_matrix[2]=2)}boundaryAreaInteriorLine_(t,m,u,g){if(1===this.m_matrix[3])return;const d=this.m_topoGraph.getHalfEdgeParentage(t);if(d&m&&d&u)this.m_matrix[3]=1;else if(0!==this.m_matrix[3]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const y=this.m_topoGraph.getHalfEdgeTo(t),C=this.m_topoGraph.getClusterParentage(y);if(C&m){const S=this.m_topoGraph.getClusterUserIndex(y,g);if(C&u&&S%2==0)return void(this.m_matrix[3]=0)}}}boundaryAreaBoundaryLine_(t,m,u,g){if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const d=this.m_topoGraph.getHalfEdgeTo(t),y=this.m_topoGraph.getClusterParentage(d);if(y&m){const C=this.m_topoGraph.getClusterUserIndex(d,g);if(y&u&&C%2!=0)return void(this.m_matrix[4]=0)}}}boundaryAreaExteriorLine_(t,m,u){if(1===this.m_matrix[5])return;const g=this.m_topoGraph.getHalfEdgeParentage(t);g&m&&!(g&u)&&(this.m_matrix[5]=1)}exteriorAreaInteriorLine_(t,m){if(1===this.m_matrix[6])return;const u=this.m_topoGraph.getHalfEdgeFaceParentage(t),g=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));u&m||g&m||(this.m_matrix[6]=1)}exteriorAreaBoundaryLine_(t,m,u,g){if(0!==this.m_matrix[7]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const d=this.m_topoGraph.getHalfEdgeTo(t),y=this.m_topoGraph.getClusterParentage(d);if(!(y&m||this.m_topoGraph.getHalfEdgeFaceParentage(t)&m)){const C=this.m_topoGraph.getClusterUserIndex(d,g);if(y&u&&C%2!=0)return void(this.m_matrix[7]=0)}}}interiorLineInteriorLine_(t,m,u,g,d){if(1===this.m_matrix[0])return;const y=this.m_topoGraph.getHalfEdgeParentage(t);if(y&m&&y&u)this.m_matrix[0]=1;else if(0!==this.m_matrix[0]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const C=this.m_topoGraph.getHalfEdgeTo(t),S=this.m_topoGraph.getClusterParentage(C);if(S&m&&S&u){const b=this.m_topoGraph.getClusterUserIndex(C,g),A=this.m_topoGraph.getClusterUserIndex(C,d);if(b%2==0&&A%2==0)return void(this.m_matrix[0]=0)}}}interiorLineBoundaryLine_(t,m,u,g,d,y){if(0!==this.m_matrix[y]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const C=this.m_topoGraph.getHalfEdgeTo(t),S=this.m_topoGraph.getClusterParentage(C);if(S&m&&S&u){const b=this.m_topoGraph.getClusterUserIndex(C,g),A=this.m_topoGraph.getClusterUserIndex(C,d);if(b%2==0&&A%2!=0)return void(this.m_matrix[y]=0)}}}interiorLineExteriorLine_(t,m,u,g){if(1===this.m_matrix[g])return;const d=this.m_topoGraph.getHalfEdgeParentage(t);d&m&&!(d&u)&&(this.m_matrix[g]=1)}boundaryLineBoundaryLine_(t,m,u,g,d){if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const y=this.m_topoGraph.getHalfEdgeTo(t),C=this.m_topoGraph.getClusterParentage(y);if(C&m&&C&u){const S=this.m_topoGraph.getClusterUserIndex(y,g),b=this.m_topoGraph.getClusterUserIndex(y,d);if(S%2!=0&&b%2!=0)return void(this.m_matrix[4]=0)}}}boundaryLineExteriorLine_(t,m,u,g,d){if(0!==this.m_matrix[d]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const y=this.m_topoGraph.getHalfEdgeTo(t);if(!(this.m_topoGraph.getClusterParentage(y)&u)&&this.m_topoGraph.getClusterUserIndex(y,g)%2!=0)return void(this.m_matrix[d]=0)}}interiorAreaInteriorPoint_(t,m){if(0!==this.m_matrix[0]&&!(this.m_topoGraph.getClusterParentage(t)&m)){const u=this.m_topoGraph.getClusterChain(t);if(this.m_topoGraph.getChainParentage(u)&m)return void(this.m_matrix[0]=0)}}interiorAreaExteriorPoint_(t,m){2!==this.m_matrix[2]&&this.m_topoGraph.getClusterParentage(t)&m&&(this.m_matrix[2]=2)}boundaryAreaInteriorPoint_(t,m,u){if(0===this.m_matrix[3])return;const g=this.m_topoGraph.getClusterParentage(t);g&m&&g&u&&(this.m_matrix[3]=0)}boundaryAreaExteriorPoint_(t,m){1!==this.m_matrix[5]&&this.m_topoGraph.getClusterParentage(t)&m&&(this.m_matrix[5]=1)}exteriorAreaInteriorPoint_(t,m){if(0!==this.m_matrix[6]&&!(this.m_topoGraph.getClusterParentage(t)&m)){const u=this.m_topoGraph.getClusterChain(t);if(!(this.m_topoGraph.getChainParentage(u)&m))return void(this.m_matrix[6]=0)}}interiorLineInteriorPoint_(t,m,u,g){if(0===this.m_matrix[0])return;const d=this.m_topoGraph.getClusterParentage(t);d&m&&d&u&&this.m_topoGraph.getClusterUserIndex(t,g)%2==0&&(this.m_matrix[0]=0)}interiorLineExteriorPoint_(t,m,u,g){if(1!==this.m_matrix[2])if(-1===this.m_topoGraph.getClusterHalfEdge(t)){if(0!==this.m_matrix[2]&&!(this.m_topoGraph.getClusterParentage(t)&u))return void(this.m_matrix[2]=0)}else this.m_matrix[2]=1}boundaryLineInteriorPoint_(t,m,u,g){if(0===this.m_matrix[3])return;const d=this.m_topoGraph.getClusterParentage(t);d&m&&d&u&&this.m_topoGraph.getClusterUserIndex(t,g)%2!=0&&(this.m_matrix[3]=0)}boundaryLineExteriorPoint_(t,m,u,g){if(0===this.m_matrix[5])return;const d=this.m_topoGraph.getClusterParentage(t);!(d&m)||d&u||this.m_topoGraph.getClusterUserIndex(t,g)%2==0||(this.m_matrix[5]=0)}exteriorLineInteriorPoint_(t,m,u){if(0===this.m_matrix[6])return;const g=this.m_topoGraph.getClusterParentage(t);g&m||!(g&u)||(this.m_matrix[6]=0)}interiorPointInteriorPoint_(t,m,u){if(0===this.m_matrix[0])return;const g=this.m_topoGraph.getClusterParentage(t);g&m&&g&u&&(this.m_matrix[0]=0)}interiorPointExteriorPoint_(t,m,u,g){if(0===this.m_matrix[g])return;const d=this.m_topoGraph.getClusterParentage(t);!(d&m)||d&u||(this.m_matrix[g]=0)}computeMatrixTopoGraphHalfEdges_(t,m){let u=!1;const g=this.m_topoGraph.getGeometryID(t),d=this.m_topoGraph.getGeometryID(m);this.m_visitedIndex=this.m_topoGraph.createUserIndexForHalfEdges();for(let y=this.m_topoGraph.getFirstCluster();y!==c.n;y=this.m_topoGraph.getNextCluster(y)){const C=this.m_topoGraph.getClusterHalfEdge(y);if(C===c.n){if(null!==this.m_predicatesCluster&&(u=this.m_predicatesCluster(y,g,d),u))break;continue}let S=C;do{let b=S;if(1!==this.m_topoGraph.getHalfEdgeUserIndex(b,this.m_visitedIndex))do{if(u=this.m_predicatesHalfEdge(b,g,d),u)break;this.m_topoGraph.setHalfEdgeUserIndex(b,this.m_visitedIndex,1),b=this.m_topoGraph.getHalfEdgeNext(b)}while(b!==S&&!u);if(u)break;S=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(b))}while(S!==C);if(u)break}u||this.setRemainingPredicatesToFalse_(),this.m_topoGraph.deleteUserIndexForHalfEdges(this.m_visitedIndex)}computeMatrixTopoGraphClusters_(t,m){let u=!1;const g=this.m_topoGraph.getGeometryID(t),d=this.m_topoGraph.getGeometryID(m);for(let y=this.m_topoGraph.getFirstCluster();y!==c.n&&(u=this.m_predicatesCluster(y,g,d),!u);y=this.m_topoGraph.getNextCluster(y));u||this.setRemainingPredicatesToFalse_()}setEditShape_(t,m){this.m_topoGraph.setEditShape(t,m)}setEditShapeCrackAndCluster_(t,m,u){let g=0;if(t.hasCurves()){const d=new ci,y=t.getEnvelope2D(u),C=oi(m.total(),y);g=xi(C,0),ri(t,C,m.total(),0,d,null,u),d.clearStitcher(t)}qi(t,m.add(g),u,!1,!1),t.filterClosePoints(0,!0,!0,!1,c.n);for(let d=t.getFirstGeometry();d!==c.n;d=t.getNextGeometry(d))t.getGeometryType(d)===F.G.enumPolygon&&ui(t,d,-1,!1,c.n,u);this.setEditShape_(t,u)}}function Ka(P){const t=P[1],m=P[2],u=P[5];P[1]=P[3],P[2]=P[6],P[5]=P[7],P[3]=t,P[6]=m,P[7]=u}function $a(P,t,m){const u=P.getGeometryType();if((0,F.f)(u)){const g=new c.P({vd:P.getDescription()});return g.addSegment(P,!0),g}if(u===F.G.enumEnvelope){const g=P,d=R.J.constructEmpty();if(P.queryEnvelope(d),d.height()<=t&&d.width()<=t){const C=new dt.P({vd:P.getDescription()});return g.getCenter(C),C}if(d.height()<=t||d.width()<=t){const C=new c.P({vd:P.getDescription()}),S=new dt.P;return g.queryCornerByVal(0,S),C.startPathPoint(S),g.queryCornerByVal(2,S),C.lineToPoint(S),C}const y=new c.a({vd:P.getDescription()});return y.addEnvelope(g,!1),y}return P}function Vn(P){return`${P[0]}${P[3]}${P[6]}${P[1]}${P[4]}${P[7]}${P[2]}${P[5]}${P[8]}`}class $s{nullFunc(){return(0,F.c)("should not be called"),!1}constructor(t,m,u,g=!1){this.m_bDone=!1,this.m_tolerance=0,this.m_elementHandle=-1,this.m_query=R.J.constructEmpty(),this.m_envInter=R.J.constructEmpty(),this.m_quadTree=null,this.m_intersector=null,this.m_function=this.nullFunc;const d=t.getAccelerators();let y=null;null!=d&&(y=g?d.getQuadTreeForPaths():d.getQuadTree());const C=m.getAccelerators();let S=null;if(null!=C&&(S=g?C.getQuadTreeForPaths():C.getQuadTree()),null===y&&null===S&&!g){const b=t.getPointCount(),A=m.getPointCount();if(b>10&&A>10){const T=R.J.constructEmpty(),M=R.J.constructEmpty(),X=R.J.constructEmpty();t.queryLooseEnvelope(T),m.queryLooseEnvelope(M),T.inflateCoords(u,u),M.inflateCoords(u,u),X.setCoords({env2D:T}),X.intersect(M),b>=A?y=(0,F.h)(t.getGeometryType())?(0,dt.G)(t,X):(0,dt.Y)(t,X):S=(0,F.h)(m.getGeometryType())?(0,dt.G)(m,X):(0,dt.Y)(m,X)}}this.construct_(t,y,m,S,u,g)}next(){if(this.m_bQuadTree){if(this.m_bDone)return!1;for(;this.m_function(););return!this.m_bDone}return!!this.m_intersector&&this.m_intersector.next()}getRedElement(){return this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElement(this.m_elementHandle):(0,F.h)(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_bSwapElements?this.m_intersector.getBlueElement(this.m_intersector.getHandleB()):this.m_intersector.getRedElement(this.m_intersector.getHandleA())}getBlueElement(){return this.m_bQuadTree?this.m_bSwapElements?(0,F.h)(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_quadTree.getElement(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedElement(this.m_intersector.getHandleA()):this.m_intersector.getBlueElement(this.m_intersector.getHandleB())}getRedEnvelope(){return this.m_bPaths||(0,F.m)(""),this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_query:this.m_bSwapElements?this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB()):this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA())}getBlueEnvelope(){return this.m_bPaths||(0,F.m)(""),this.m_bQuadTree?this.m_bSwapElements?this.m_query:this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA()):this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB())}construct_(t,m,u,g,d,y){const C=R.J.constructEmpty(),S=R.J.constructEmpty();t.queryLooseEnvelope(C),u.queryLooseEnvelope(S),C.inflateCoords(d,d),S.inflateCoords(d,d),this.m_envInter.setCoords({env2D:C}),this.m_envInter.intersect(S),this.m_multiVertexImplA=t,this.m_multiVertexImplB=u;const b=t.getGeometryType(),A=u.getGeometryType();this.m_bPaths=y,this.m_pathIndex=-1,this.m_pointIndex=-1,this.m_bSwapElements=!1,this.m_queryType=F.G.enumUnknown,this.m_bQuadTree=!1,null!==m&&(this.m_bDone=!1,this.m_tolerance=d,this.m_quadTree=m,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!0,(0,F.h)(A)?(this.m_queryType=A,this.m_function=this.nextPath_,y?this.m_pathIndex=u.getPathCount():this.m_segIter=u.querySegmentIterator()):(this.m_queryType=A,this.m_function=this.nextPoint_,this.m_pointIndex=u.getPointCount())),this.m_bQuadTree||null!==g&&(this.m_bDone=!1,this.m_tolerance=d,this.m_quadTree=g,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!1,(0,F.h)(b)?(this.m_queryType=b,this.m_function=this.nextPath_,y?this.m_pathIndex=t.getPathCount():this.m_segIter=t.querySegmentIterator()):(this.m_queryType=b,this.m_function=this.nextPoint_,this.m_pointIndex=t.getPointCount())),this.m_bQuadTree||(y&&(0,F.h)(b)&&(0,F.h)(A)?this.m_intersector=(0,dt.a0)(t,u,d):(0,F.h)(b)&&(0,F.h)(A)?(this.m_intersector=(0,dt.Z)(t,u,d),this.m_bSwapElements=!1):(0,F.h)(b)&&!(0,F.h)(A)?(this.m_intersector=(0,dt._)(t,u,d),this.m_bSwapElements=!1):!(0,F.h)(b)&&(0,F.h)(A)?(this.m_intersector=(0,dt._)(u,t,d),this.m_bSwapElements=!0):(this.m_intersector=(0,dt.$)(t,u,d),this.m_bSwapElements=!1))}nextPath_(){return this.m_bPaths?-1==--this.m_pathIndex?(this.m_bDone=!0,!1):(this.m_bSwapElements?this.m_multiVertexImplB.queryPathEnvelope(this.m_pathIndex,this.m_query):this.m_multiVertexImplA.queryPathEnvelope(this.m_pathIndex,this.m_query),this.m_qtIter.resetIterator(this.m_query,this.m_tolerance),this.m_function=this.iterate_,!0):this.m_segIter.nextPath()?(this.m_function=this.nextSegment_,!0):(this.m_bDone=!0,!1)}nextSegment_(){if(!this.m_segIter.hasNextSegment())return this.m_function=this.nextPath_,!0;const t=this.m_segIter.nextSegment(),m=new R.J;return t.queryLooseEnvelope(m),!m.isIntersecting(this.m_envInter)||(this.m_qtIter.resetIterator(t,this.m_tolerance),this.m_function=this.iterate_,!0)}nextPoint_(){if(-1==--this.m_pointIndex)return this.m_bDone=!0,!1;const t=new Y.P;if(this.m_bSwapElements){const m=this.m_multiVertexImplB.getXY(this.m_pointIndex);t.setCoordsPoint2D(m)}else{const m=this.m_multiVertexImplA.getXY(this.m_pointIndex);t.setCoordsPoint2D(m)}return!this.m_envInter.contains(t)||(this.m_qtIter.resetIterator(R.J.construct(t.x,t.y,t.x,t.y),this.m_tolerance),this.m_function=this.iterate_,!0)}iterate_(){return this.m_elementHandle=this.m_qtIter.next(),-1===this.m_elementHandle&&((0,F.h)(this.m_queryType)?(this.m_function=this.m_bPaths?this.nextPath_:this.nextSegment_,!0):(this.m_function=this.nextPoint_,!0))}}function Yo(P){return 2===P?1:1===P?2:128===P?64:64===P?128:P}function th(P,t,m){let u;if(P instanceof Nn||null===P){const g=R.J.constructEmpty();g.setCoords({env2D:t}),g.mergeEnvelope2D(m),u=(0,dt.c)(P,g,!1)}else u=P;return u}function Ki(P,t,m,u,g){if(P.isEmpty()||t.isEmpty())return 4===u;(0,F.d)(P),(0,F.d)(t);let d=P.getGeometryType(),y=t.getGeometryType();if(d===F.G.enumEnvelope){if(y===F.G.enumEnvelope)return function gr(P,t,m,u,g){if(P.isEmpty()||t.isEmpty())return 4===u;const d=R.J.constructEmpty();P.queryEnvelope(d);const y=R.J.constructEmpty();t.queryEnvelope(y);const C=th(m,d,y);switch(u){case 4:return Fi(d,y,C);case 2:return Sr(y,d,C,!1);case 128:return Sr(y,d,C,!0);case 1:return Sr(d,y,C,!1);case 64:return Sr(d,y,C,!0);case 3:return en(d,y,C);case 8:return function ol(P,t,m,u){if(P.height()<=m||P.width()<=m||t.height()<=m||t.width()<=m)return!1;const g=new R.J;return g.setCoords({env2D:P}),g.inflateCoords(-m,-m),g.intersect(t),!(!g.isEmpty()&&g.height()>m&&g.width()>m||(g.setCoords({env2D:P}),g.inflateCoords(m,m),g.intersect(t),g.isEmpty()))}(d,y,C);case 32:return function bh(P,t,m,u){if(P.height()<=m||P.width()<=m||t.height()<=m||t.width()<=m||ys(P,t,m)||ys(t,P,m))return!1;const g=new R.J;return g.setCoords({env2D:P}),g.inflateCoords(-m,-m),g.intersect(t),!g.isEmpty()&&(g.height()>m||g.width()>m)}(d,y,C);case 16:return!1}return!1}(P,t,m,u);if(y===F.G.enumPoint)return eh(t,P,m,Yo(u))}else if(d===F.G.enumPoint){if(y===F.G.enumEnvelope)return eh(P,t,m,u);if(y===F.G.enumPoint)return function _r(P,t,m,u,g){if(P.isEmpty()||t.isEmpty())return 4===u;const d=P.getXY(),y=t.getXY();let C;if(m instanceof Nn||null===m){const S=R.J.constructEmpty();S.setCoords({pt:d}),S.merge(y),C=(0,dt.c)(m,S,!1)}else C=m;switch(u){case 4:return function Sh(P,t,m,u){return Y.P.sqrDistance(P,t)>m*m}(d,y,C);case 2:case 128:return zo(y,d,C);case 1:case 64:return zo(d,y,C);case 3:return yr(d,y,C)}return!1}(P,t,m,u)}const C=R.J.constructEmpty();P.queryEnvelope(C);const S=R.J.constructEmpty();t.queryEnvelope(S);const b=th(m,C,S);if(Fi(C,S,b))return 4===u;let A=!1,T=null,M=null,X=null,k=null;switch((0,F.f)(d)?(T=new c.P({vd:P.getDescription()}),T.addSegment(P,!0),X=T,d=F.G.enumPolyline):X=P,(0,F.f)(y)?(M=new c.P({vd:t.getDescription()}),M.addSegment(t,!0),k=M,y=F.G.enumPolyline):k=t,d!==F.G.enumEnvelope&&y!==F.G.enumEnvelope?(X.getDimension()<k.getDimension()||d===F.G.enumPoint&&y===F.G.enumMultiPoint)&&(u=Yo(u)):d!==F.G.enumPolygon&&y!==F.G.enumEnvelope&&(u=Yo(u)),d){case F.G.enumPolygon:switch(y){case F.G.enumPolygon:A=function Yn(P,t,m,u,g){switch(u){case 4:return function hh(P,t,m,u){return Xe(P,t,0,!0),1===vr(P,t,m,!0)}(P,t,m);case 2:return mh(t,P,m,g);case 128:return Ro(t,P,m);case 1:return mh(P,t,m,g);case 64:return Ro(P,t,m);case 3:return ah(P,t,m,g);case 8:return function Um(P,t,m,u){return Xe(P,t),Wo(P,t,m,null)}(P,t,m);case 32:return function Om(P,t,m,u){return Xe(P,t),Nh(P,t,m,u)}(P,t,m,g)}return!1}(X,k,b,u,g);break;case F.G.enumPolyline:A=sh(X,k,b,u,g);break;case F.G.enumPoint:A=dr(X,k,b,u);break;case F.G.enumMultiPoint:A=Xo(X,k,b,u);break;case F.G.enumEnvelope:A=Jr(X,k,b,u,g)}break;case F.G.enumPolyline:switch(y){case F.G.enumPolygon:A=sh(k,X,b,u,g);break;case F.G.enumPolyline:A=function Hm(P,t,m,u,g){switch(u){case 4:return function xh(P,t,m,u){Xe(P,t);const g=P.getImpl(),d=t.getImpl();return!new $s(g,d,m,!0).next()||!Dh(P,t,m)}(P,t,m);case 2:return an(t,P,m,g);case 128:return to(t,P,m,g);case 1:return an(P,t,m,g);case 64:return to(P,t,m,g);case 3:return function fh(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!!en(g,d,m)&&(Xe(P,t),!!wh(P,t,m)||(P.hasNonLinearSegments()||t.hasNonLinearSegments()?pi(P,t,m,"**F**FFF*",u,!1):wr(P,t,m,!1)))}(P,t,m,g);case 8:return function Qm(P,t,m,u){Xe(P,t);const g=[],d=Dr(P,t,m,g);if(-2===d){const b=R.J.constructEmpty(),A=R.J.constructEmpty(),T=R.J.constructEmpty();let M,X;if(P.queryEnvelope(b),t.queryEnvelope(A),b.inflateCoords(1e3*m,1e3*m),A.inflateCoords(1e3*m,1e3*m),T.setCoords({env2D:b}),T.intersect(A),P.getPointCount()>10){if(M=(0,Rt.c)(P,T,m,0,u),M.isEmpty())return!1}else M=P;if(t.getPointCount()>10){if(X=(0,Rt.c)(t,T,m,0,u),X.isEmpty())return!1}else X=t;return pi(M,X,m,"F********",u,!1)}if(0!==d)return!1;const y=new c.M;for(let b=0;b<g.length;b+=2)y.addXY(g[b],g[b+1]);const C=P.getBoundary(),S=t.getBoundary();return C.addPoints(S,0,S.getPointCount()),!C.isEmpty()&&tn(C,y,m)}(P,t,m,g);case 32:return function Ph(P,t,m,u){Xe(P,t);const g=R.J.constructEmpty(),d=R.J.constructEmpty();P.queryEnvelope(g),t.queryEnvelope(d);const y=br(g,d,m),C=br(d,g,m),S=P.hasNonLinearSegments(),b=t.hasNonLinearSegments(),A=Dr(P,t,m,null);if(-1===A)return!1;if(1===A){if(y&&C)return!0;if(!S&&!b)return y&&!C?!Mi(t,P,m,!1):C&&!y?!Mi(P,t,m,!1):!Mi(P,t,m,!1)&&!Mi(t,P,m,!1)}const T=R.J.constructEmpty(),M=R.J.constructEmpty(),X=R.J.constructEmpty();let k,H;T.setCoords({env2D:g}),T.inflateCoords(1e3*m,1e3*m),M.setCoords({env2D:d}),M.inflateCoords(1e3*m,1e3*m),X.setCoords({env2D:T}),X.intersect(M);let U="";if(U+="1*",y){if(t.getPointCount()>10){if(H=(0,Rt.c)(t,X,m,0,u),H.isEmpty())return!1}else H=t;U+="****"}else H=t,U+="T***";if(C){if(P.getPointCount()>10){if(k=(0,Rt.c)(P,X,m,0,u),k.isEmpty())return!1}else k=P;U+="***"}else k=P,U+="T**";return pi(k,H,m,U,u,!1)}(P,t,m,g);case 16:return function Km(P,t,m,u){Xe(P,t);const g=[],d=Dr(P,t,m,g);if(-2===d){const b=R.J.constructEmpty(),A=R.J.constructEmpty(),T=R.J.constructEmpty();let M,X;if(P.queryEnvelope(b),t.queryEnvelope(A),b.inflateCoords(1e3*m,1e3*m),A.inflateCoords(1e3*m,1e3*m),T.setCoords({env2D:b}),T.intersect(A),P.getPointCount()>10){if(M=(0,Rt.c)(P,T,m,0,u),M.isEmpty())return!1}else M=P;if(t.getPointCount()>10){if(X=(0,Rt.c)(t,T,m,0,u),X.isEmpty())return!1}else X=t;return pi(M,X,m,"0********",u,!1)}if(0!==d)return!1;const y=new c.M;for(let b=0;b<g.length;b+=2)y.addXY(g[b],g[b+1]);const C=P.getBoundary(),S=t.getBoundary();return C.addPoints(S,0,S.getPointCount()),!!C.isEmpty()||!tn(C,y,m)}(P,t,m,g)}return!1}(X,k,b,u,g);break;case F.G.enumPoint:A=ih(X,k,b,u);break;case F.G.enumMultiPoint:A=nh(X,k,b,u);break;case F.G.enumEnvelope:A=rh(X,k,b,u,g)}break;case F.G.enumPoint:switch(y){case F.G.enumPolygon:A=dr(k,X,b,u);break;case F.G.enumPolyline:A=ih(k,X,b,u);break;case F.G.enumMultiPoint:A=Zr(k,X,b,u)}break;case F.G.enumMultiPoint:switch(y){case F.G.enumPolygon:A=Xo(k,X,b,u);break;case F.G.enumPolyline:A=nh(k,X,b,u);break;case F.G.enumMultiPoint:A=function zm(P,t,m,u,g){switch(u){case 4:return function Pr(P,t,m,u){const g=P,d=t,y=new $s(g,d,m,!1),C=m*m,S=new Y.P,b=new Y.P;for(;y.next();){const A=y.getRedElement(),T=y.getBlueElement();if(g.queryXY(A,S),d.queryXY(T,b),Y.P.sqrDistance(S,b)<=C)return!1}return!0}(P,t,m);case 2:case 128:return tn(t,P,m);case 1:case 64:return tn(P,t,m);case 3:return function Xn(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!!en(g,d,m)&&(!!function Ir(P,t,m,u){if(P.getPointCount()!==t.getPointCount())return!1;const g=new Y.P,d=new Y.P;let y=!0;const C=m*m;for(let S=0;S<P.getPointCount();S++)if(P.queryXY(S,g),t.queryXY(S,d),Y.P.sqrDistance(g,d)>C){y=!1;break}return!!y}(P,t,m)||oo(P,t,m,!1,!0,!1))}(P,t,m);case 32:return function Ho(P,t,m,u){return oo(P,t,m,!1,!1,!0)}(P,t,m)}return!1}(X,k,b,u);break;case F.G.enumPoint:A=Zr(X,k,b,u);break;case F.G.enumEnvelope:A=oh(X,k,b,u)}break;case F.G.enumEnvelope:switch(y){case F.G.enumPolygon:A=Jr(k,X,b,u,g);break;case F.G.enumPolyline:A=rh(k,X,b,u,g);break;case F.G.enumMultiPoint:A=oh(k,X,b,u)}}return A}function eh(P,t,m,u,g){if(P.isEmpty()||t.isEmpty())return 4===u;const d=P.getXY(),y=R.J.constructEmpty();t.queryEnvelope(y);const C=function Bm(P,t,m){let u;if(P instanceof Nn||null===P){const g=R.J.constructEmpty();g.setCoords({pt:t}),g.mergeEnvelope2D(m),u=(0,dt.c)(P,g,!1)}else u=P;return u}(m,d,y);switch(u){case 4:return fn(d,y,C);case 2:case 128:return function Cr(P,t,m,u){if(t.height()<=m||t.width()<=m)return!1;const g=R.J.constructEmpty();return g.setCoords({env2D:t}),g.inflateCoords(-m,-m),g.containsExclusive(P)}(d,y,C);case 1:case 64:return!1;case 3:return function vh(P,t,m,u){const g=new R.J;return g.setCoords({pt:P}),en(g,t,m)}(d,y,C);case 8:return function Er(P,t,m,u){if(t.height()<=m||t.width()<=m)return!1;const g=new R.J,d=new R.J;return g.setCoords({env2D:t}),g.inflateCoords(m,m),!!g.contains(P)&&(d.setCoords({env2D:t}),d.inflateCoords(-m,-m),!d.containsExclusive(P))}(d,y,C)}return!1}function Fi(P,t,m){const u=R.J.constructEmpty();return u.setCoords({env2D:t}),u.inflateCoords(m,m),!P.isIntersecting(u)}function Xe(P,t,m,u=!1){const g=P.getGeometryType(),d=t.getGeometryType();if((0,F.i)(g)){const y=P.getImpl().getAccelerators();if(null!==y){const C=y.getRasterizedGeometry();(0,F.g)(null===C)}}if((0,F.i)(d)){const y=t.getImpl().getAccelerators();if(null!==y){const C=y.getRasterizedGeometry();(0,F.g)(null===C)}}return 0}function fn(P,t,m,u){const g=R.J.constructEmpty();return g.setCoords({env2D:t}),g.inflateCoords(m,m),!g.contains(P)}function sh(P,t,m,u,g){switch(u){case 4:return function Wm(P,t,m,u){return Xe(P,t,0,!0),1===vr(P,t,m,!0)}(P,t,m);case 1:return function ch(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!!ys(g,d,m)&&(Xe(P,t),function Zo(P,t,m,u){const g=[!1],d=Uo(P,t,m,g);if(g[0])return d;const y=R.J.constructEmpty();let C;if(t.queryEnvelope(y),y.inflateCoords(1e3*m,1e3*m),P.getPointCount()>10){if(C=(0,Rt.c)(P,y,m,0,u),C.isEmpty())return!1}else C=P;return function Ba(P,t,m,u){const g=new Gi;g.resetMatrix_(),g.setPredicates_("T*****F**"),g.setAreaLinePredicates_();const d=R.J.constructEmpty(),y=R.J.constructEmpty();P.queryEnvelope(d),t.queryEnvelope(y);let C=!1;if(Fi(d,y,m)&&(g.areaLineDisjointPredicates_(P,t),C=!0),C||Xe(P,t),C)return Bs(g.m_matrix,g.m_scl);const S=new c.E,b=S.addGeometry(P),A=S.addGeometry(t);return g.setEditShapeCrackAndCluster_(S,new dt.C(m,0),u),0!==S.getPointCount(b)&&(g.computeMatrixTopoGraphHalfEdges_(b,A),g.m_topoGraph.removeShape(),Bs(g.m_matrix,g.m_scl))}(C,t,m,u)}(P,t,m,u))}(P,t,m,g);case 64:return function Qr(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!!ys(g,d,m)&&(Xe(P,t),2===vr(P,t,m,!1))}(P,t,m);case 8:return lh(P,t,m,g);case 16:return function uh(P,t,m,u){return Xe(P,t),function Jo(P,t,m,u){const g=P.getImpl(),d=t.getImpl(),y=g.querySegmentIterator(),C=d.querySegmentIterator(),S=(0,Y.d)(2,Number.NaN),b=(0,Y.d)(2,Number.NaN),A=new $s(g,d,m);let T=!1;for(;A.next();){const Z=A.getRedElement(),st=A.getBlueElement();y.resetToVertex(Z,-1),C.resetToVertex(st,-1);const mt=y.nextSegment(),ht=C.nextSegment();let ut=0;if(Ln(mt,ht)?!T&&ht.isIntersecting(mt,m)&&(T=!0):ut=ht.intersect(mt,null,b,S,m),2===ut)T=!0;else if(ut){const ct=S[0],Et=b[0];if(ct>0&&ct<1&&Et>0&&Et<1)return!0;T=!0}}if(!T)return!1;const M=R.J.constructEmpty(),X=R.J.constructEmpty(),k=R.J.constructEmpty(),H=R.J.constructEmpty(),U=R.J.constructEmpty();if(P.queryEnvelope(M),t.queryEnvelope(X),br(X,M,m)){let Z,st;if(k.setCoords({env2D:M}),k.inflateCoords(1e3*m,1e3*m),H.setCoords({env2D:X}),H.inflateCoords(1e3*m,1e3*m),U.setCoords({env2D:k}),U.intersect(H),P.getPointCount()>10){if(Z=(0,Rt.c)(P,U,m,0,u),Z.isEmpty())return!1}else Z=P;if(t.getPointCount()>10){if(st=(0,Rt.c)(t,U,m,0,u),st.isEmpty())return!1}else st=t;return pi(Z,st,m,"T********",u,!1)}return pi(P,t,m,"T*****T**",u,!1)}(P,t,m,null)}(P,t,m)}return!1}function dr(P,t,m,u,g){switch(u){case 4:return function ko(P,t,m,u){return 0===Gh(P,t,m)}(P,t,m);case 1:case 64:return function Jm(P,t,m,u){return function hl(P,t,m,u){return 1===ti(P,t,m)}(P,t.getXY(),m)}(P,t,m);case 8:return function jm(P,t,m,u){return function ml(P,t,m,u){return 2===ti(P,t,m)}(P,t.getXY(),m)}(P,t,m)}return!1}function Xo(P,t,m,u,g){switch(u){case 4:return function gh(P,t,m,u,g){return Xe(P,t),1===function Ih(P,t,m,u,g){const d=R.J.constructEmpty();P.queryEnvelope(d),d.inflateCoords(m,m);const y=new Y.P,C=P.getImpl(),S=new c.a;let b=P,A=!1,T=!1,M=!1;for(let X=0;X<t.getPointCount();X++){if(t.queryXY(X,y),d.contains(y)){const k=ti(b,y,m);if(1===k)return T=!0,4;if(2===k)return 4;M=!0}else M=!0;A||(!_s(P,t.getPointCount()-1)||null!==C.getAccelerators()&&null!=C.getAccelerators().getQuadTree()?b=P:(P.copyTo(S),S.getImpl().buildQuadTreeAccelerator(1),b=S),A=!0)}return T?M?4:2:1}(P,t,m)}(P,t,m);case 1:return $r(P,t,m,!1);case 64:return $r(P,t,m,!0);case 8:return function pr(P,t,m,u){Xe(P,t);const g=R.J.constructEmpty();P.queryEnvelope(g),g.inflateCoords(m,m);const d=new Y.P;let y=!1;const C=P.getImpl(),S=new c.a;let b=P,A=!1;for(let T=0;T<t.getPointCount();T++){if(t.queryXY(T,d),g.contains(d)){const M=ti(b,d,m);if(2===M)y=!0;else if(1===M)return!1}A||(!_s(P,t.getPointCount()-1)||null!==C.getAccelerators()&&null!==C.getAccelerators().getQuadTree()?b=P:(P.copyTo(S),S.getImpl().buildQuadTreeAccelerator(1),b=S),A=!0)}return!!y}(P,t,m);case 16:return function Kr(P,t,m,u){Xe(P,t);const g=new R.J,d=new R.J,y=new R.J;P.queryEnvelope(g),t.queryEnvelope(y),d.setCoords({env2D:g}),d.inflateCoords(m,m);let C=!1,S=!1;const b=new Y.P,A=P.getImpl(),T=new c.a;let M=P,X=!1;for(let k=0;k<t.getPointCount();k++){if(t.queryXY(k,b),d.contains(b)){const H=ti(M,b,m);0===H?S=!0:1===H&&(C=!0)}else S=!0;if(C&&S)return!0;X||(!_s(P,t.getPointCount()-1)||null!==A.getAccelerators()&&null!==A.getAccelerators().getQuadTree()?M=P:(P.copyTo(T),T.getImpl().buildQuadTreeAccelerator(1),M=T),X=!0)}return!1}(P,t,m)}return!1}function Jr(P,t,m,u,g){if(function Zm(P,t,m,u){Xe(P,t);const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!ys(d,g,m)&&0===ti(P,d.getLowerLeft(),0)&&!d.contains(P.getXY(0))&&!Oo(P,d,m)}(P,t,m))return 4===u;if(4===u)return!1;switch(u){case 2:return dh(P,t,m,!1);case 128:return dh(P,t,m,!0);case 1:return ph(P,t,m,!1,g);case 64:return ph(P,t,m,!0,g);case 3:return function xn(P,t,m,u){const g=new R.J,d=new R.J;if(P.queryEnvelope(g),t.queryEnvelope(d),!en(g,d,m))return!1;const y=new c.a;return y.addEnvelope(t,!1),ah(P,y,m,u)}(P,t,m,g);case 8:return function _h(P,t,m,u){Xe(P,t);const g=new R.J,d=new R.J;if(P.queryEnvelope(g),t.queryEnvelope(d),ys(d,g,m)||d.height()<=m||d.width()<=m)return!1;const y=new c.a;return y.addEnvelope(t,!1),Wo(P,y,m,u)}(P,t,m,g);case 32:return function $i(P,t,m,u){Xe(P,t);const g=new R.J,d=new R.J;if(P.queryEnvelope(g),t.queryEnvelope(d),ys(d,g,m)||d.height()<=m||d.width()<=m)return!1;const y=new c.a;return y.addEnvelope(t,!1),Nh(P,y,m,u)}(P,t,m,g);case 16:return!1}return!1}function ih(P,t,m,u,g){switch(u){case 4:return function fr(P,t,m,u){return Xe(P,t),!Th(P,t.getXY(),m)}(P,t,m);case 1:case 64:return function $m(P,t,m,u){return Xe(P,t),function al(P,t,m){return Th(P,t,m)&&!yn(P,t,m)}(P,t.getXY(),m)}(P,t,m);case 8:return function Lo(P,t,m,u){return Xe(P,t),yn(P,t.getXY(),m)}(P,t,m)}return!1}function nh(P,t,m,u,g){switch(u){case 4:return function xr(P,t,m,u){return Xe(P,t),!Rn(P,t,m,!1)}(P,t,m);case 1:case 64:return function tl(P,t,m,u,g){const d=R.J.constructEmpty(),y=R.J.constructEmpty();if(P.queryEnvelope(d),t.queryEnvelope(y),!ys(d,y,m))return!1;Xe(P,t);const C=Rn(P,t,m,!0);if(!C)return C;const S=P.getBoundary();return S.isEmpty()?C:!tn(S,t,m)}(P,t,m);case 8:return function yh(P,t,m,u){Xe(P,t);const g=P.getImpl(),d=t.getImpl(),y=new c.M,C=new $s(g,d,m,!1),S=g.querySegmentIterator();let b=!1;for(;C.next();){const T=C.getRedElement(),M=C.getBlueElement();S.resetToVertex(T,-1);const X=S.nextSegment(),k=d.getXY(M);X.isIntersectingPoint(k,m)&&(b=!0,y.addPoint2D(k))}if(!b)return!1;const A=P.getBoundary();return!A.isEmpty()&&tn(A,y,m)}(P,t,m);case 16:return function Eh(P,t,m,u){Xe(P,t);const g=P.getImpl(),d=t.getImpl(),y=d.getPointCount(),C=(0,Y.d)(y,!1),S=new $s(g,d,m,!1),b=g.querySegmentIterator();let A=!1;for(;S.next();){const k=S.getRedElement(),H=S.getBlueElement();b.resetToVertex(k,-1);const U=b.nextSegment(),Z=d.getXY(H);U.isIntersectingPoint(Z,m)&&(A=!0,C[H]=!0)}if(!A)return!1;let T=!1;for(let k=0;k<y;k++)if(!C[k]){T=!0;break}if(!T)return!1;const M=P.getBoundary();if(M.isEmpty())return!0;const X=new c.M;for(let k=0;k<y;k++)C[k]&&X.addPoint2D(d.getXY(k));return!tn(M,X,m)}(P,t,m)}return!1}function rh(P,t,m,u,g){if(function Bo(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();P.queryEnvelope(g),t.queryEnvelope(d);const y=function ni(P,t,m){const u=R.J.constructEmpty();return u.setCoords({env2D:P}),u.inflateCoords(m,m),u.containsEnvelope(t)?1073741824:u.isIntersecting(t)?P.isIntersecting(t)?P.xmin<t.xmin&&t.xmax<P.xmax?t.ymin<P.ymin&&t.ymax>P.ymax?0:1073741824:P.ymin<t.ymin&&t.ymax<P.ymax?t.xmin<P.xmin&&t.xmax>P.xmax?0:1073741824:0:0:4}(d,g,m);return 0===y?!Oo(P,d,m):4===y}(P,t,m))return 4===u;if(4===u)return!1;switch(u){case 2:return eo(P,t,m,!1);case 128:return eo(P,t,m,!0);case 1:case 64:case 32:return!1;case 3:return function el(P,t,m,u){const g=new R.J,d=new R.J;return P.queryEnvelope(g),t.queryEnvelope(d),!(d.height()>m&&d.width()>m)&&en(g,d,m)}(P,t,m);case 8:return function ps(P,t,m,u){const g=new R.J,d=new R.J;if(P.queryEnvelope(g),t.queryEnvelope(d),d.height()<=m||d.width()<=m)return!1;const y=new R.J,C=new R.J;if(y.setCoords({env2D:d}),C.setCoords({env2D:d}),y.inflateCoords(m,m),C.inflateCoords(-m,-m),C.containsEnvelope(g)||!g.isIntersecting(y))return!1;const S=P.getImpl().querySegmentIterator();S.stripAttributes();const b=P.getImpl().getAccelerators();let A=null,T=null;null!==b&&(A=b.getQuadTree(),null!==A&&(T=A.getIterator(d,m))),T||S.nextPath()||(0,F.c)("relational_operations");let M=!1,X=null;const k=new Y.P,H=new Y.P,U=P.hasNonLinearSegments();let Z=!1;for(;;){if(null!==T){const mt=T.next();if(-1===mt)break;S.resetToVertex(A.getElement(mt),-1),X=S.nextSegment()}else{for(;!S.hasNextSegment()&&S.nextPath(););if(!S.hasNextSegment())break;X=S.nextSegment()}if(U&&X.getGeometryType()!==F.G.enumLine){const mt=new R.J;if(X.queryEnvelope(mt),C.containsEnvelope(mt))return!1;if(y.isIntersecting(mt)){Z=!0;break}}else{k.assign(X.getStartXY()),H.assign(X.getEndXY());let mt=C.clipLine(k,H);if(0!==mt)return!1;M||(mt=y.clipLine(k,H),0!==mt&&(M=!0))}}if(!Z)return M;const st=new c.a;return st.addEnvelope(d,!1),lh(st,P,m,u)}(P,t,m,g);case 16:return function Ni(P,t,m,u){const g=new R.J,d=new R.J;if(P.queryEnvelope(g),t.queryEnvelope(d),d.height()<=m||d.width()<=m)return!1;const y=new R.J;if(y.setCoords({env2D:d}),y.inflateCoords(m,m),y.containsEnvelope(g))return!1;const S=new R.J;if(S.setCoords({env2D:d}),S.inflateCoords(-m,-m),!S.isIntersecting(g))return!1;const b=P.getImpl().querySegmentIterator();b.stripAttributes();const A=P.getImpl().getAccelerators();let T=null,M=null;if(null!==A&&(T=A.getQuadTree(),null!==T&&(M=T.getIterator(d,m))),!M){const ut=b.nextPath();(0,F.g)(ut)}let X=!1,k=null;const H=new Y.P,U=new Y.P;let Z=null,st=null,mt=null,ht=null;for(P.hasNonLinearSegments()&&(Z=new c.L,st=new c.L,mt=new c.L,ht=new c.L,S.querySide(0,Z),S.querySide(1,st),S.querySide(2,mt),S.querySide(3,ht));;){if(null!==M){const ut=M.next();if(-1===ut)break;b.resetToVertex(T.getElement(ut),-1),k=b.nextSegment()}else{for(;!b.hasNextSegment()&&b.nextPath(););if(!b.hasNextSegment())break;k=b.nextSegment()}if(k.getGeometryType()===F.G.enumLine){if(H.assign(k.getStartXY()),U.assign(k.getEndXY()),0!==S.clipLine(H,U)){X=!0;break}}else{if(Z.isIntersecting(k,m)){X=!0;break}if(st.isIntersecting(k,m)){X=!0;break}if(mt.isIntersecting(k,m)){X=!0;break}if(ht.isIntersecting(k,m)){X=!0;break}}}return X&&!0}(P,t,m)}return!1}function Zr(P,t,m,u,g){switch(u){case 4:return io(P,t,m);case 2:case 128:return function sl(P,t,m,u){return so(P,t,m)}(P,t,m);case 1:case 64:return function il(P,t,m,u){return!io(P,t,m)}(P,t,m);case 3:return so(P,t,m)}return!1}function oh(P,t,m,u,g){switch(u){case 4:return function no(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();if(P.queryEnvelope(g),t.queryEnvelope(d),ys(d,g,m))return!1;const y=R.J.constructEmpty();y.setCoords({env2D:d}),y.inflateCoords(m,m);const C=new Y.P;for(let S=0;S<P.getPointCount();S++)if(P.queryXY(S,C),y.contains(C))return!1;return!0}(P,t,m);case 2:return ro(P,t,m,!1);case 128:return ro(P,t,m,!0);case 1:case 64:return!1;case 3:return function nl(P,t,m,u){const g=new R.J,d=new R.J;return P.queryEnvelope(g),t.queryEnvelope(d),!(d.height()>m||d.width()>m)&&en(g,d,m)}(P,t,m);case 8:return function rl(P,t,m,u){const g=new R.J,d=new R.J,y=new R.J;if(t.queryEnvelope(g),g.height()<=m||g.width()<=m)return!1;d.setCoords({env2D:g}),y.setCoords({env2D:g}),d.inflateCoords(m,m),y.inflateCoords(-m,-m);const C=new Y.P;let S=!1;for(let b=0;b<P.getPointCount();b++)if(P.queryXY(b,C),d.contains(C)){if(y.containsExclusive(C))return!1;S=!0}return S}(P,t,m);case 16:return function Ch(P,t,m,u){const g=new R.J,d=new R.J;if(P.queryEnvelope(g),t.queryEnvelope(d),ys(d,g,m)||d.height()<=m||d.width()<=m)return!1;const y=new R.J,C=new R.J;y.setCoords({env2D:d}),y.inflateCoords(-m,-m),C.setCoords({env2D:d}),C.inflateCoords(m,m);const S=new Y.P;let b=!1,A=!1;for(let T=0;T<P.getPointCount();T++)if(P.queryXY(T,S),!b&&y.containsExclusive(S)&&(b=!0),A||C.contains(S)||(A=!0),b&&A)return!0;return!1}(P,t,m)}return!1}function ah(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();if(P.queryEnvelope(g),t.queryEnvelope(d),!en(g,d,m))return!1;if(Xe(P,t),wh(P,t,m))return!0;const y=P.calculateLength2D(),C=t.calculateLength2D(),S=Math.max(P.getPointCount(),t.getPointCount());return!(Math.abs(y-C)>4*S*m)&&(P.hasNonLinearSegments()||t.hasNonLinearSegments()?pi(P,t,m,"**F**FFF*",u,!1):wr(P,t,m,!0))}function mh(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!!ys(g,d,m)&&(Xe(P,t),kn(P,t,m,u))}function Ro(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!!ys(g,d,m)&&(Xe(P,t),2===vr(P,t,m,!1))}function lh(P,t,m,u){return Xe(P,t),function jo(P,t,m,u){const g=P.getImpl(),d=t.getImpl(),y=g.querySegmentIterator(),C=d.querySegmentIterator(),S=(0,Y.d)(2,Number.NaN),b=(0,Y.d)(2,Number.NaN),A=new $s(g,d,m);let T=!1;for(;A.next();){const Z=A.getRedElement(),st=A.getBlueElement();y.resetToVertex(Z,-1),C.resetToVertex(st,-1);const mt=y.nextSegment(),ht=C.nextSegment();let ut=0;if(Ln(mt,ht)?!T&&ht.isIntersecting(mt,m)&&(T=!0):ut=ht.intersect(mt,null,b,S,m),2===ut)T=!0;else if(ut){const ct=S[0],Et=b[0];if(ct>0&&ct<1&&Et>0&&Et<1)return!1;T=!0}}if(!T)return!1;const M=R.J.constructEmpty(),X=R.J.constructEmpty(),k=R.J.constructEmpty();let H,U;if(P.queryEnvelope(M),t.queryEnvelope(X),M.inflateCoords(1e3*m,1e3*m),X.inflateCoords(1e3*m,1e3*m),k.setCoords({env2D:M}),k.intersect(X),P.getPointCount()>10){if(H=(0,Rt.c)(P,k,m,0,u),H.isEmpty())return!1}else H=P;if(t.getPointCount()>10){if(U=(0,Rt.c)(t,k,m,0,u),U.isEmpty())return!1}else U=t;return pi(H,U,m,"F********",u,!1)}(P,t,m,u)}function $r(P,t,m,u,g){const d=R.J.constructEmpty(),y=R.J.constructEmpty();if(P.queryEnvelope(d),t.queryEnvelope(y),!ys(d,y,m))return!1;Xe(P,t);let C=!1;const S=new Y.P,b=P.getImpl(),A=new c.a;let T=P,M=!1;for(let X=0;X<t.getPointCount();X++){if(t.queryXY(X,S),!d.contains(S))return!1;const k=ti(T,S,m);if(1===k)C=!0;else if(0===k)return!1;if(u&&2===k)return!1;M||(!_s(P,t.getPointCount()-1)||null!==b.getAccelerators()&&null!==b.getAccelerators().getQuadTree()?T=P:(P.copyTo(A),A.getImpl().buildQuadTreeAccelerator(1),T=A),M=!0)}return C}function dh(P,t,m,u,g){const d=R.J.constructEmpty(),y=R.J.constructEmpty();return P.queryEnvelope(d),t.queryEnvelope(y),u?Pn(y,d,m):ys(y,d,m)}function ph(P,t,m,u,g){const d=R.J.constructEmpty(),y=R.J.constructEmpty();if(P.queryEnvelope(d),t.queryEnvelope(y),!ys(d,y,m))return!1;Xe(P,t);const C=new c.a;return C.addEnvelope(t,!1),u?2===vr(P,C,m,!1):kn(P,C,m,g)}function an(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!!ys(g,d,m)&&(Xe(P,t),P.hasNonLinearSegments()||t.hasNonLinearSegments()?pi(P,t,m,"******FF*",u,!1):Mi(t,P,m,!1))}function to(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!!ys(g,d,m)&&(Xe(P,t),pi(P,t,m,"T**FF*FF*",u,!1))}function eo(P,t,m,u,g){const d=R.J.constructEmpty(),y=R.J.constructEmpty();if(P.queryEnvelope(d),t.queryEnvelope(y),y.height()<=m||y.width()<=m)return!1;if(u)return Pn(y,d,m);if(!ys(y,d,m))return!1;const C=R.J.constructEmpty();C.setCoords({env2D:y}),C.inflateCoords(-m,-m);const S=R.J.constructEmpty();if(S.setCoords({env2D:y}),S.inflateCoords(m,m),C.containsEnvelope(d))return!0;const b=P.getImpl().querySegmentIterator();b.stripAttributes(),b.nextPath()||(0,F.c)("relational_operations");let A,T,M,X,k,H,U=!1;const Z=P.hasNonLinearSegments();for(Z&&(M=new c.L,X=new c.L,k=new c.L,H=new c.L,C.querySide(0,M),C.querySide(1,X),C.querySide(2,k),C.querySide(3,H));;){for(;!b.hasNextSegment()&&b.nextPath(););if(!b.hasNextSegment())break;const st=b.nextSegment();if(Z&&st.getGeometryType()!==F.G.enumLine){if(st.isIntersecting(M,m)){U=!0;break}if(st.isIntersecting(X,m)){U=!0;break}if(st.isIntersecting(k,m)){U=!0;break}if(st.isIntersecting(H,m)){U=!0;break}}else if(A=st.getStartXY(),T=st.getEndXY(),0!==C.clipLine(A,T)){U=!0;break}}return U}function tn(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),!!ys(g,d,m)&&oo(t,P,m,!0,!1,!1)}function so(P,t,m,u){const g=R.J.constructEmpty(),d=R.J.constructEmpty();return P.queryEnvelope(g),t.queryEnvelope(d),en(g,d,m)}function io(P,t,m,u){return Ah(P,t.getXY(),m)}function ro(P,t,m,u,g){const d=R.J.constructEmpty(),y=R.J.constructEmpty();if(P.queryEnvelope(d),t.queryEnvelope(y),y.height()<=m||y.width()<=m)return!1;if(u)return Pn(y,d,m);if(!ys(y,d,m))return!1;let C=!1;const S=R.J.constructEmpty(),b=R.J.constructEmpty();S.setCoords({env2D:y}),b.setCoords({env2D:y}),S.inflateCoords(-m,-m),b.inflateCoords(m,m);const A=new Y.P;for(let T=0;T<P.getPointCount();T++){if(P.queryXY(T,A),!b.contains(A))return!1;S.containsExclusive(A)&&(C=!0)}return C}function yr(P,t,m,u){return Y.P.sqrDistance(P,t)<=m*m}function zo(P,t,m,u){return yr(P,t,m)}function en(P,t,m,u){return ys(P,t,m)&&ys(t,P,m)}function Sr(P,t,m,u,g){if(P.height()<=m||P.width()<=m)return!1;if(u)return Pn(P,t,m);if(!ys(P,t,m))return!1;const d=R.J.constructEmpty();return d.setCoords({env2D:P}),d.inflateCoords(-m,-m),d.intersect(t),!d.isEmpty()}function vr(P,t,m,u,g){const d=new Y.P,y=new Y.P,C=R.J.constructEmpty(),S=R.J.constructEmpty(),b=P.getImpl(),A=t.getImpl(),T=A.getGeometryType(),M=new $s(b,A,m,!0);if(!M.next())return 1;if(Dh(P,t,m))return u?4:0;const X=new c.a;let k=P;const H=new c.a;let U=null;T===F.G.enumPolygon&&(U=t);const Z=T===F.G.enumPolygon?(0,Y.d)(b.getPathCount(),!1):[],st=(0,Y.d)(A.getPathCount(),!1);let mt=!1,ht=!1,ut=!1,ct=!1,Et=!1,Tt=!1;do{if(ut&&Et||ct&&Tt||ut&&ct)break;const Pt=M.getRedElement(),At=M.getBlueElement();if(!st[At]&&(y.assign(t.getXY(t.getPathStart(At))),C.setCoords({env2D:M.getRedEnvelope()}),C.inflateCoords(m,m),C.contains(y))){if(0!==ti(k,y,0)){if(ct=!0,u)return 4}else Tt=!0;st[At]=!0}if(T===F.G.enumPolygon&&!Z[Pt]&&(d.assign(P.getXY(P.getPathStart(Pt))),S.setCoords({env2D:M.getBlueEnvelope()}),S.inflateCoords(m,m),S.contains(d))){if(0!==ti(U,d,0)){if(ut=!0,u)return 4}else Et=!0;Z[Pt]=!0}if(mt||(!_s(P,t.getPathCount()-1)||null!==b.getAccelerators()&&null!==b.getAccelerators().getQuadTree()?k=P:(P.copyTo(X),X.getImpl().buildQuadTreeAccelerator(1),k=X),mt=!0),T===F.G.enumPolygon&&!ht){const Ht=t;!_s(Ht,P.getPathCount()-1)||null!==A.getAccelerators()&&null!==A.getAccelerators().getQuadTree()?U=t:(Ht.copyTo(H),H.getImpl().buildQuadTreeAccelerator(1),U=H),ht=!0}}while(M.next());if(!ut&&!ct)return 1;if(!Et||!Tt){if(T===F.G.enumPolygon)for(let Pt=0,At=b.getPathCount();Pt<At;Pt++)if(!Z[Pt]){Et=!0;break}for(let Pt=0,At=A.getPathCount();Pt<At;Pt++)if(!st[Pt]){Tt=!0;break}}return ut&&Et||ct&&Tt||ut&&ct?4:ct?2:3}function Uo(P,t,m,u,g){u[0]=!1;const d=P.getImpl(),y=t.getImpl(),C=d.querySegmentIterator(),S=y.querySegmentIterator(),b=[0,0],A=[0,0],T=new $s(d,y,m);let M=!1;for(;T.next();){const X=T.getRedElement(),k=T.getBlueElement();C.resetToVertex(X,-1),S.resetToVertex(k,-1);const H=C.nextSegment(),U=S.nextSegment();let Z=0;if(Ln(H,U)?!M&&U.isIntersecting(H,m)&&(M=!0):Z=U.intersect(H,null,A,b,m),0!==Z&&(M=!0,1===Z)){const st=b[0],mt=A[0];if(st>0&&st<1&&mt>0&&mt<1)return u[0]=!0,!1}}if(!M){u[0]=!0;const X=R.J.constructEmpty();P.queryEnvelope(X),X.inflateCoords(m,m);const k=new c.a;let H=P,U=!1;for(let ct=0,Et=t.getPathCount();ct<Et;ct++)if(t.getPathSize(ct)>0){const Tt=R.J.constructEmpty();if(t.queryPathEnvelope(ct,Tt),!X.isIntersecting(Tt))return!1;{const Pt=ns(H,t.getXY(t.getPathStart(ct)),0);if((0,F.g)(-1!==Pt),0===Pt)return!1}U||(!_s(P,t.getPathCount()-1)||null!==d.getAccelerators()&&null!==d.getAccelerators().getQuadTree()?H=P:(P.copyTo(k),k.getImpl().buildQuadTreeAccelerator(1),H=k),U=!0)}if(1===P.getPathCount()||t.getGeometryType()===F.G.enumPolyline)return!0;const Z=t,st=R.J.constructEmpty();Z.queryEnvelope(st),st.inflateCoords(m,m);const mt=new c.a;let ht=Z,ut=!1;for(let ct=0,Et=P.getPathCount();ct<Et;ct++)if(P.getPathSize(ct)>0){const Tt=R.J.constructEmpty();if(P.queryPathEnvelope(ct,Tt),st.isIntersecting(Tt)){const Pt=ns(ht,P.getXY(P.getPathStart(ct)),0);if((0,F.g)(-1!==Pt),1===Pt)return!1}ut||(!_s(Z,P.getPathCount()-1)||null!==y.getAccelerators()&&null!==y.getAccelerators().getQuadTree()?ht=Z:(Z.copyTo(mt),mt.getImpl().buildQuadTreeAccelerator(1),ht=mt),ut=!0)}return!0}return!1}function ys(P,t,m){const u=R.J.constructEmpty();return u.setCoords({env2D:P}),u.inflateCoords(m,m),u.containsEnvelope(t)}function Pn(P,t,m){const u=R.J.constructEmpty();return u.setCoords({env2D:t}),u.inflateCoords(m,m),P.containsExclusiveEnvelope(u)}function br(P,t,m){const u=R.J.constructEmpty();return u.setCoords({env2D:t}),u.inflateCoords(m,m),!(u.contains(P.getLowerLeft())&&u.contains(P.getLowerRight())&&u.contains(P.getUpperLeft())&&u.contains(P.getUpperRight()))}function wh(P,t,m,u){if(P.getPathCount()!==t.getPathCount()||P.getPointCount()!==t.getPointCount())return!1;if(P.hasNonLinearSegments()||t.hasNonLinearSegments())return P.equals(t);const g=new Y.P,d=new Y.P;let y=!0;const C=m*m;for(let S=0;S<P.getPathCount();S++){if(P.getPathEnd(S)!==t.getPathEnd(S)){y=!1;break}for(let b=P.getPathStart(S);b<t.getPathEnd(S);b++)if(P.queryXY(b,g),t.queryXY(b,d),Y.P.sqrDistance(g,d)>C){y=!1;break}if(!y)break}return!!y}function oo(P,t,m,u,g,d,y){const C=P.getImpl(),S=t.getImpl(),b=C.getPointCount(),A=S.getPointCount(),T=(0,Y.d)(b,!1),M=g||d?(0,Y.d)(A,!1):[],X=m*m,k=new $s(C,S,m);for(;k.next();){const mt=k.getRedElement(),ht=k.getBlueElement(),ut=C.getXY(mt),ct=S.getXY(ht);Y.P.sqrDistance(ut,ct)<=X&&(T[mt]=!0,(g||d)&&(M[ht]=!0))}let H=!1,U=!1;for(let mt=0;mt<b;mt++){const ht=T[mt];if(H||=!ht,U||=ht,(g||u)&&H)return!1}if(u)return!0;let Z=!1,st=!1;for(let mt=0;mt<A;mt++){const ht=M[mt];if(Z||=!ht,st||=ht,g&&Z)return!1}return!!g||H&&U&&Z&&st}function wr(P,t,m,u){return Mi(P,t,m,u)&&Mi(t,P,m,u)}function Mi(P,t,m,u){if((0,F.l)(P),(0,F.l)(t),t.isEmpty())return!1;let g=!0;const d=(0,Y.d)(2,Number.NaN),y=(0,Y.d)(2,Number.NaN),C=[],S=new ul;let b;const A=R.J.constructEmpty(),T=R.J.constructEmpty(),M=R.J.constructEmpty();P.queryEnvelope(A),t.queryEnvelope(T),A.inflateCoords(m,m),T.inflateCoords(m,m),M.setCoords({env2D:A}),M.intersect(T);const X=P.getImpl().querySegmentIterator(),k=t.getImpl().querySegmentIterator(),H=t.getImpl().getAccelerators();let U=null,Z=null,st=null,mt=null;if(null!==H&&(U=H.getQuadTree(),Z=H.getQuadTreeForPaths(),null!==Z&&(mt=Z.getIteratorForQT())),null===U){const ht=P.getPointCount(),ut=t.getPointCount();ht>10&&ut>10&&(U=(0,dt.G)(t.getImpl(),M))}for(null!==U&&(st=U.getIteratorForQT());X.nextPath();)for(;X.hasNextSegment();){let ht=X.nextSegment();if(ht.queryEnvelope(A),!A.isIntersecting(M))return g=!1,!1;if(null!==mt&&(mt.resetIterator(A,m),-1===mt.next()))continue;let ut=0,ct=null;if(null!=st)st.resetIterator(ht,m);else if(k.resetToFirstPath(),!k.nextPath())return g=!1,!1;do{if(ut=0,null!==st){const wt=st.next();if(-1===wt)return g=!1,!1;k.resetToVertex(U.getElement(wt),-1),ct=k.nextSegment(),ut=ht.intersect(ct,null,d,y,m)}else{for(;!k.hasNextSegment();)if(!k.nextPath())return g=!1,!1;ct=k.nextSegment(),ct.queryEnvelope(T),T.inflateCoords(m,m),A.isIntersecting(T)&&(ut=ht.intersect(ct,null,d,y,m))}}while(2!==ut||0!==d[0]||u&&!(y[0]<=y[1]));let Et=Number.NaN,Tt=!1;do{let wt=!1;if(1===d[1]){if(!X.hasNextSegment()){Tt=!0;break}ht=X.nextSegment(),wt=!0}if(1===y[1]&&y[0]<=y[1]){if(-1===Et||(Et=1,!k.hasNextSegment()))break;ct=k.nextSegment(),wt=!0}if(0===y[1]&&y[0]>y[1]){if(1===Et)break;if(Number.isNaN(Et)){if(!k.hasPreviousSegment())break;k.previousSegment(),Et=-1}if(!k.hasPreviousSegment())break;ct=k.previousSegment(),wt=!0}if(!wt)break;ut=ht.intersect(ct,null,d,y,m)}while(2===ut&&(!u||y[0]<=y[1]));if(Tt)continue;const Pt=ht.calculateLength2D();ht.queryEnvelope(A),C.length=0,S.m_overlapEvents.length=0;let At=!1,Ht=!1,Bt=0;const kt=(0,dt.c)(null,A,!0);for(null!==st?st.resetIterator(ht,m):(k.resetToFirstPath(),k.nextPath()||(0,F.c)("relational_operations"));;){if(ut=0,null!==st){const wt=st.next();if(-1===wt)break;k.resetToVertex(U.getElement(wt),-1),ct=k.nextSegment(),ut=ht.intersect(ct,null,d,y,m)}else{for(;!k.hasNextSegment()&&k.nextPath(););if(!k.hasNextSegment())break;ct=k.nextSegment(),ct.queryEnvelope(T),T.inflateCoords(m,m),A.isIntersecting(T)&&(ut=ht.intersect(ct,null,d,y,m))}if(2===ut&&(!u||y[0]<=y[1])){const wt=X.getStartPointIndex(),Xt=X.getPathIndex(),Zt=k.getStartPointIndex(),zt=k.getPathIndex();if(b=ll(wt,Xt,d[0],d[1],Zt,zt,y[0],y[1]),S.m_overlapEvents.push(b),C.push(C.length),!(At||b.m_scalarA0<Bt&&b.m_scalarA1<Bt))if(0===Bt&&Pt*(b.m_scalarA0-Bt)>m)At=!0;else if(0!==Bt&&Pt*(b.m_scalarA0-Bt)>kt)At=!0;else if(Bt=b.m_scalarA1,Pt*(1-Bt)<=m||1===Bt){Ht=!0;break}}}if(!Ht){if(!At)return g=!1,!1;C.length>1&&C.sort((wt,Xt)=>S.compareOverlapEvents(wt,Xt)),Bt=0;for(let wt=0;wt<S.m_overlapEvents.length;wt++)if(b=S.m_overlapEvents[C[wt]],!(b.m_scalarA0<Bt&&b.m_scalarA1<Bt)){if(0===Bt&&Pt*(b.m_scalarA0-Bt)>m||0!==Bt&&Pt*(b.m_scalarA0-Bt)>kt)return g=!1,!1;if(Bt=b.m_scalarA1,Pt*(1-Bt)<=m||1===Bt)break}if(Pt*(1-Bt)>m)return g=!1,!1;C.length=0,S.m_overlapEvents.length=0}}return g}function Dh(P,t,m){const u=P.getImpl(),g=t.getImpl(),d=u.querySegmentIterator(),y=g.querySegmentIterator(),C=new $s(u,g,m);for(;C.next();){const S=C.getRedElement(),b=C.getBlueElement();d.resetToVertex(S,-1),y.resetToVertex(b,-1);const A=d.nextSegment();if(y.nextSegment().isIntersecting(A,m))return!0}return!1}function Dr(P,t,m,u){const g=P.getImpl(),d=t.getImpl(),y=g.querySegmentIterator(),C=d.querySegmentIterator(),S=(0,Y.d)(2,Number.NaN),b=new $s(g,d,m);let A=!1,T=-1;for(;b.next();){const M=b.getRedElement(),X=b.getBlueElement();y.resetToVertex(M,-1),C.resetToVertex(X,-1);const k=y.nextSegment(),H=C.nextSegment();let U=0;if(Ln(k,H)){if(H.isIntersecting(k,m))return-2}else U=k.intersect(H,null,S,null,m);if(U)if(2===U){if(k.calculateLength2D()*(S[1]-S[0])>m)return T=1,T;A=!0}else if(T=0,u){const Z=S[0],st=new Y.P;k.queryCoord2D(Z,st),u.push(st.x),u.push(st.y)}}return A?-2:T}function Rn(P,t,m,u){const g=P.getImpl(),d=t,y=d.getPointCount(),C=u?(0,Y.d)(y,!1):[],S=new $s(g,d,m,!1),b=g.querySegmentIterator();for(;S.next();){const A=S.getRedElement(),T=S.getBlueElement();b.resetToVertex(A,-1);const M=b.nextSegment(),X=d.getXY(T);if(M.isIntersectingPoint(X,m)){if(!u)return!0;C[T]=!0}}if(!u)return!1;for(let A=0;A<y;A++)if(!C[A])return!1;return!0}function Th(P,t,m){const u=new Y.P,g=m*m,d=P.querySegmentIterator(),y=P.getImpl().getAccelerators();if(null!==y){const S=y.getQuadTree();if(null!==S){const b=R.J.constructEmpty();b.setCoords({pt:t});const A=S.getIterator(b,m);for(let T=A.next();-1!==T;T=A.next())if(d.resetToVertex(S.getElement(T),-1),d.hasNextSegment()){const M=d.nextSegment(),X=M.getClosestCoordinate(t,!1);if(M.queryCoord2D(X,u),Y.P.sqrDistance(t,u)<=g)return!0}return!1}}const C=R.J.constructEmpty();for(;d.nextPath();)for(;d.hasNextSegment();){const S=d.nextSegment();if(S.queryEnvelope(C),C.inflateCoords(m,m),!C.contains(t))continue;const b=S.getClosestCoordinate(t,!1);if(S.queryCoord2D(b,u),Y.P.sqrDistance(t,u)<=g)return!0}return!1}function Oo(P,t,m,u){const g=P.querySegmentIterator(),d=P.getImpl().getAccelerators(),y=P.hasNonLinearSegments();let C=null,S=null,b=null,A=null;if(null!==d){const T=d.getQuadTree();if(null!==T){const M=T.getIterator(t,m);y&&(C=new c.L,S=new c.L,b=new c.L,A=new c.L,t.querySide(0,C),t.querySide(1,S),t.querySide(2,b),t.querySide(3,A));const X=R.J.constructEmpty();X.setCoords({env2D:t}),X.inflateCoords(m,m);for(let k=M.next();-1!==k;k=M.next())if(g.resetToVertex(T.getElement(k),-1),g.hasNextSegment()){const H=g.nextSegment();if(H.getGeometryType()===F.G.enumLine){const U=H.getStartXY(),Z=H.getEndXY();if(X.clipLine(U,Z))return!0;continue}if(t.contains(H.getStartXY())||t.contains(H.getEndXY())||H.isIntersecting(C,m)||H.isIntersecting(S,m)||H.isIntersecting(b,m)||H.isIntersecting(A,m))return!0}return!1}}if(y){C=new c.L,S=new c.L,b=new c.L,A=new c.L,t.querySide(0,C),t.querySide(1,S),t.querySide(2,b),t.querySide(3,A);const T=P.querySegmentIterator();for(;T.nextPath();)for(;T.hasNextSegment();){const M=T.nextSegment();if(t.contains(M.getStartXY())||t.contains(M.getEndXY())||M.isIntersecting(C,m)||M.isIntersecting(S,m)||M.isIntersecting(b,m)||M.isIntersecting(A,m))return!0}}else{const T=R.J.constructEmpty();T.setCoords({env2D:t}),T.inflateCoords(m,m);const M=P.getImpl(),X=M.getAttributeStreamRef(0),k=new Y.P;for(let H=0,U=M.getPathCount();H<U;H++){let Z=!0;const st=new Y.P,mt=new Y.P,ht=new Y.P,ut=M.getPathStart(H),ct=new Y.P;for(let Et=ut,Tt=M.getPathEnd(H);Et<Tt;Et++)if(Z)X.queryPoint2D(2*Et,st),ct.assign(st),Z=!1;else{if(X.queryPoint2D(2*Et,k),mt.setCoordsPoint2D(st),ht.setCoordsPoint2D(k),T.clipLine(mt,ht))return!0;st.assign(k)}if(M.isClosedPath(H)&&!Z&&(mt.setCoordsPoint2D(st),ht.setCoordsPoint2D(ct),T.clipLine(mt,ht)))return!0}}return!1}function Wo(P,t,m,u){const g=P.getImpl(),d=t.getImpl(),y=[0],C=(0,dt.M)(g.getIsSimple(0,y))&&(0,dt.M)(d.getIsSimple(0,y)),S=g.querySegmentIterator(),b=d.querySegmentIterator(),A=(0,Y.d)(2,0),T=(0,Y.d)(2,0),M=new $s(g,d,m);let X=!1;for(;M.next();){const mt=M.getRedElement(),ht=M.getBlueElement();S.resetToVertex(mt,-1),b.resetToVertex(ht,-1);const ut=S.nextSegment(),ct=b.nextSegment();let Et=0;if(Ln(ut,ct)){if(ct.isIntersecting(ut,m)){X=!0;break}}else Et=ct.intersect(ut,null,T,A,m);if(2===Et){const Tt=A[0],Pt=A[1],At=ut.calculateLength2D();if(C&&(Pt-Tt)*At>m)return!1;X=!0}else if(Et){const Tt=A[0],Pt=T[0];if(Tt>0&&Tt<1&&Pt>0&&Pt<1)return!1;X=!0}}if(!X)return!1;const k=R.J.constructEmpty(),H=R.J.constructEmpty(),U=R.J.constructEmpty();let Z,st;if(P.queryEnvelope(k),t.queryEnvelope(H),k.inflateCoords(1e3*m,1e3*m),H.inflateCoords(1e3*m,1e3*m),U.setCoords({env2D:k}),U.intersect(H),P.getPointCount()>10){if(Z=(0,Rt.c)(P,U,m,0,u),Z.isEmpty())return!1}else Z=P;if(t.getPointCount()>10){if(st=(0,Rt.c)(t,U,m,0,u),st.isEmpty())return!1}else st=t;return pi(Z,st,m,"F********",u,!1)}function Nh(P,t,m,u){const g=P.getImpl(),d=t.getImpl(),y=[0],C=(0,dt.M)(g.getIsSimple(0,y))&&(0,dt.M)(d.getIsSimple(0,y)),S=R.J.constructEmpty(),b=R.J.constructEmpty(),A=R.J.constructEmpty();P.queryEnvelope(S),t.queryEnvelope(b);let T=!1;const M=br(S,b,m),X=br(b,S,m),k=g.querySegmentIterator(),H=d.querySegmentIterator(),U=(0,Y.d)(2,Number.NaN),Z=(0,Y.d)(2,Number.NaN),st=new $s(g,d,m);for(;st.next();){const Tt=st.getRedElement(),Pt=st.getBlueElement();k.resetToVertex(Tt,-1),H.resetToVertex(Pt,-1);const At=k.nextSegment(),Ht=H.nextSegment();let Bt=0;if(Ln(At,Ht)){if(Ht.isIntersecting(At,m))break}else Bt=Ht.intersect(At,null,Z,U,m);if(2===Bt){const kt=U[0],wt=U[1],Xt=At.calculateLength2D();if(C&&(wt-kt)*Xt>m&&(T=!0,M&&X))return!0}else if(Bt){const kt=U[0],wt=Z[0];if(kt>0&&kt<1&&wt>0&&wt<1)return!0}}const mt=R.J.constructEmpty(),ht=R.J.constructEmpty();let ut,ct;mt.setCoords({env2D:S}),mt.inflateCoords(1e3*m,1e3*m),ht.setCoords({env2D:b}),ht.inflateCoords(1e3*m,1e3*m),A.setCoords({env2D:mt}),A.intersect(ht);let Et="";if(Et+=T?"**":"T*",M){if(t.getPointCount()>10){if(ct=(0,Rt.c)(t,A,m,0,u),ct.isEmpty())return!1}else ct=t;Et+="****"}else ct=t,Et+="T***";if(X){if(P.getPointCount()>10){if(ut=(0,Rt.c)(P,A,m,0,u),ut.isEmpty())return!1}else ut=P;Et+="***"}else ut=P,Et+="T**";return pi(ut,ct,m,Et,u,!1)}function kn(P,t,m,u){const g=[!1],d=Uo(P,t,m,g);if(g[0])return d;const y=R.J.constructEmpty();let C;if(t.queryEnvelope(y),y.inflateCoords(1e3*m,1e3*m),P.getPointCount()>10){if(C=(0,Rt.c)(P,y,m,0,u),C.isEmpty())return!1}else C=P;return function Fo(P,t,m,u){const g=new Gi;g.resetMatrix_(),g.setPredicates_("T*****F**"),g.setAreaAreaPredicates_();const d=R.J.constructEmpty(),y=R.J.constructEmpty();P.queryEnvelope(d),t.queryEnvelope(y);let C=!1;if(Fi(d,y,m)&&(g.areaAreaDisjointPredicates_(P,t),C=!0),C||Xe(P,t),C)return Bs(g.m_matrix,g.m_scl);let S=new c.E,b=S.addGeometry(P),A=S.addGeometry(t),T=null,M=0;if(P.hasNonLinearSegments()||t.hasNonLinearSegments()){T=new ci;const U=oi(m,S.getEnvelope2D(u));M=xi(U,0),ri(S,U,m,0,T,null,u)}qi(S,new dt.C(m,0).add(M),u,!1,!1);const X=S.getGeometry(A).getBoundary();if(S.filterClosePoints(0,!0,!0,!1,c.n),ui(S,b,-1,!1,c.n,u),0===S.getPointCount(b))return!1;ui(S,A,-1,!1,c.n,u),g.setEditShape_(S,u);const k=0===S.getPointCount(A);if(!k){g.computeMatrixTopoGraphHalfEdges_(b,A),g.m_topoGraph.removeShape();const U=Bs(g.m_matrix,g.m_scl);if(!U)return U}const H=S.getGeometry(b);return S=new c.E,b=S.addGeometry(H),A=S.addGeometry(X),g.setEditShape_(S,u),g.m_predicateCount=0,g.resetMatrix_(),g.setPredicates_(k?"T*****F**":"******F**"),g.setAreaLinePredicates_(),g.computeMatrixTopoGraphHalfEdges_(b,A),g.m_topoGraph.removeShape(),Bs(g.m_matrix,g.m_scl)}(C,t,m,u)}function Ah(P,t,m,u){const g=new Y.P,d=m*m;for(let y=0;y<P.getPointCount();y++)if(P.queryXY(y,g),Y.P.sqrDistance(g,t)<=d)return!1;return!0}function yn(P,t,m){const u=P.getBoundary();return!u.isEmpty()&&!Ah(u,t,m)}function Ln(P,t){return P.getGeometryType()!==F.G.enumLine||t.getGeometryType()!==F.G.enumLine}function ll(P,t,m,u,g,d,y,C){return{m_ivertexA:P,m_ipathA:t,m_scalarA0:m,m_scalarA1:u,m_ivertexB:g,m_ipathB:d,m_scalarB0:y,m_scalarB1:C}}class ul{constructor(){this.m_overlapEvents=[]}compareOverlapEvents(t,m){const u=this.m_overlapEvents[t],g=this.m_overlapEvents[m];return u.m_ipathA<g.m_ipathA||u.m_ipathA===g.m_ipathA&&(u.m_ivertexA<g.m_ivertexA||u.m_ivertexA===g.m_ivertexA&&(u.m_scalarA0<g.m_scalarA0||u.m_scalarA0===g.m_scalarA0&&(u.m_scalarA1<g.m_scalarA1||u.m_scalarA1===g.m_scalarA1&&u.m_ivertexB<g.m_ivertexB)))?-1:1}}function Gh(P,t,m){const u=function Je(P,t,m){return t.isEmpty()?0:ns(P,t.getXY(),m)}(P,t,m);return u?1===u?1:2:0}function ti(P,t,m){const u=ns(P,t,m);return u?1===u?1:2:0}function Qo(P,t,m,u,g){if(P.getGeometryType()===F.G.enumPolygon)!function cl(P,t,m,u,g){for(let d=0;d<m;d++)g[d]=ti(P,t[d],u)}(P,t,m,u,g);else if(P.getGeometryType()===F.G.enumEnvelope){const d=R.J.constructEmpty();P.queryEnvelope(d),function gl(P,t,m,u,g){if(P.isEmpty()){for(let C=0;C<m;C++)g[C]=0;return}const d=P.clone();d.inflateCoords(.5*-u,.5*-u);const y=P.clone();y.inflateCoords(.5*u,.5*u);for(let C=0;C<m;C++)g[C]=d.contains(t[C])?1:y.contains(t[C])?2:0}(d,t,m,u,g)}else(0,F.m)("")}function Fh(P,t,m,u,g){const d=P.getGeometryType();d===F.G.enumPolyline?function dl(P,t,m,u,g){const d=P.getImpl(),y=d.getAccelerators();let C=null;y&&(C=y.getRasterizedGeometry());let S=m;for(let b=0;b<m;b++)g[b]=1,C&&(0,F.g)(0);if(S){if(y){let A=null;null!==y&&null!==y.getQuadTree()&&(A=y.getQuadTree());const T=d.getPointCount();if(null===A&&T>20&&T*m>4*T+Math.log(T)*m&&(A=(0,dt.G)(d)),A){let M=null;const X=d.querySegmentIterator(),k=new R.J;for(let H=0;H<m&&S;H++)if(1===g[H]){k.setCoords(t[H]),null===M?M=A.getIterator(k,u):M.resetIterator(k,u);let U=-1;for(let Z=M.next();-1!==Z;Z=M.next()){if(X.resetToVertex(A.getElement(Z),U),U=X.getPathIndex(),X.nextSegment().isIntersectingPoint(t[H],u)){g[H]=2,S--;break}g[H]=0}}return}}const b=d.querySegmentIterator();for(;b.nextPath()&&S;)for(;b.hasNextSegment()&&S;){const A=b.nextSegment();for(let T=0;T<m&&S;T++)1===g[T]&&A.isIntersectingPoint(t[T],u)&&(g[T]=2,S--)}}for(let b=0;b<m;b++)1===g[b]&&(g[b]=0)}(P,t,m,u,g):(0,F.f)(d)?function fi(P,t,m,u,g){(0,F.g)(0)}():(0,F.m)("")}function _l(P){if(P.isEmpty())return 0;switch(P.getGeometryType()){case F.G.enumMultiPoint:return P.getImpl().getPointCount();case F.G.enumPolyline:return P.getImpl().getPathCount();case F.G.enumPolygon:return P.getImpl().getOGCPolygonCount();case F.G.enumGeometryCollection:return P.getGeometryCount()}return 1}function pl(){return Number.isNaN(this.radius.value())}function Bn(P,t,m,u){return{pt:P.clone(),t,err:m,checkCount:u}}class Hn{constructor(t,m,u,g,d){this.m_left=t,this.m_tracker=d,this.m_eps=u,this.m_trackerCounter=0,this.m_tolerance=g,this.m_circleCheckCounter=0,this.m_bReversedLeft=!1,this.m_leftArc=function fl(){return{ptStart:new Y.P,ptEnd:new Y.P,center:new c.W,radius:new Y.F,fcenter:new c.Y,fradius2:new Y.M,maxError:Number.NaN,isLine:pl}}()}closeToCircularArc(t,m,u,g,d,y){if(this.m_circleCheckCounter++,y.maxError=0,!Hn.checkSweepAngle(t,m))return!1;if(y.ptStart.setCoordsPoint2D(u),y.ptEnd.setCoordsPoint2D(d),t.isCircular()){const ut=t;return y.fradius2=Y.M.constructDouble(ut.getSemiMajorAxis()).mulDouble(ut.getSemiMajorAxis()),y.radius.set(ut.getSemiMajorAxis()),y.fcenter.assignPoint2D(ut.getCenter()),y.center.set(ut.getCenter()),!0}const C=y.ptEnd.sub(y.ptStart).clone();if(C.leftPerpendicularThis(),C.normalize(),Math.abs(C.dotProduct(g.sub(y.ptStart)))<=this.m_eps)return!!this.confirmIsLine(y,C)&&(y.radius.set(Number.NaN),y.center.setCoords(0,0),!0);{const ut=y.ptEnd.sub(y.ptStart),ct=g.sub(y.ptStart),Et=ut.crossProduct(ct);if(0===Et)return!1;const Tt=.5*ut.sqrLength(),Pt=.5*ct.sqrLength();let At=Tt*ct.y-Pt*ut.y;At/=Et;let Ht=ut.x*Pt-ct.x*Tt;Ht/=Et;const Bt=Math.sqrt(At*At+Ht*Ht);if(4*Number.EPSILON*Bt>this.m_eps)return!1;const kt=At+y.ptStart.x,wt=Ht+y.ptStart.y;y.radius.set(Bt),y.center.setCoords(kt,wt);const Xt=this.maxCircleApproximationError(t,m,y);if(Xt>this.m_eps)return y.maxError=Xt,!1}const S=(new c.Y).assignPoint2D(y.ptStart),b=(new c.Y).assignPoint2D(y.ptEnd).sub(S),A=(new c.Y).assignPoint2D(g).sub(S),T=b.crossProduct(A);if(T.isZero())return!1;const M=b.sqrLength().mulDouble(.5),X=A.sqrLength().mulDouble(.5),k=M.mul(A.y).sub(X.mul(b.y)),H=b.x.mul(X).sub(A.x.mul(M)),U=k.mul(k).add(H.mul(H)),Z=T.clone();Z.invertThis(),y.fradius2=U.mul(Z).mul(Z),y.fcenter.setCoords(k.mul(Z).add(S.x),H.mul(Z).add(S.y)),y.center.setWithEps(y.fcenter.asPoint2D()),y.radius.setWithEps(Math.sqrt(y.fradius2.toDouble()));const st=c.W.constructPoint2D(y.ptStart).subE(y.center),mt=c.W.constructPoint2D(y.ptEnd).subE(y.center);if(!st.dotProduct(mt).gt(Y.H))return!1;const ht=this.maxCircleApproximationError(t,m,y);return y.maxError=ht,ht<=this.m_eps}static checkSweepAngle(t,m){if(t.getGeometryType()===F.G.enumEllipticArc){const u=t,g=(0,c.Z)(u,m.vmin),d=(0,c.Z)(u,m.vmax);return!(Math.abs(d-g)>.5*Y.l)}return!0}confirmIsLine(t,m){const u=t.ptEnd.sub(t.ptStart);return!(Math.abs(m.dotProduct(u.mul(.25)))>this.m_eps||Math.abs(m.dotProduct(u.mul(.75)))>this.m_eps)}maxCircleApproximationError(t,m,u){const g=[.25,.75],d=[.1,.25,.75,.9];let y,C;t.getGeometryType()===F.G.enumEllipticArc?(y=g,C=g.length):(y=d,C=d.length);let S=0;for(let b=0;b<C;++b){const A=new Y.P;t.queryCoord2D((0,Y.q)(m.vmin,m.vmax,y[b]),A);const T=A.sub(u.center.value()).length(),M=Math.abs(T-u.radius.value());M>S&&(S=M)}return S}approximateWithCirclesImpl(t,m){let u=1;m&&m.push(0);const g=(0,Y.d)(9,Number.NaN);let d;t?d=this.m_left.getMonotonicPartParams(g.length,g):(g[0]=0,g[1]=1,d=2);const y=[],C=[],S=new Y.P(0,0);for(let b=1;b<d;b++){const A=new Y.E(g[b-1],g[b]);for(this.m_bReversedLeft=!Hn.goodOrientation(this.m_left,A),this.m_bReversedLeft?(y.push(Bn(S,A.vmin,0,0)),y.push(Bn(S,A.vmax,0,0))):(y.push(Bn(S,A.vmax,0,0)),y.push(Bn(S,A.vmin,0,0))),y[0].pt=this.m_left.getCoord2D(y[0].t),y[1].pt=this.m_left.getCoord2D(y[1].t);y.length>1;){this.progress_();const T=y.at(-1);let M=T.checkCount,X=T.err;const k=T.pt.clone(),H=T.t,U=y[y.length-2].t,Z=.5*(H+U),st=this.m_left.getCoord2D(Z);if(X<=this.m_eps||M>=5){const mt=new Y.E;if(mt.setCoords(H,U),this.closeToCircularArc(this.m_left,mt,k,st,y[y.length-2].pt,this.m_leftArc)){m&&(this.m_bReversedLeft?C.push(H):m.push(U)),u++,y.pop();continue}M=0,X=this.m_leftArc.maxError}T.t=Z,T.pt.setCoordsPoint2D(st),X*=.125,M++,T.err=X,T.checkCount=M,y.push(Bn(k,H,X,M))}this.m_bReversedLeft&&m&&(m.length=m.length+C.length,(0,Y.a)(m,C.reverse(),m.length-C.length,0,C.length),C.length=0),y.length=0}return u}approximateWithCirclesImplPolyline(t){const m=new c.P,u=[];if(!this.approximateWithCirclesImpl(!0,u))return m;let g=0;const d=this.m_left.getStartXY();m.startPath(d);for(let y=1;y<u.length;++y)if(t)m.lineTo(this.m_left.getCoord2D(u[y]));else{const C=new Y.P;this.m_left.queryCoord2D(u[y],C);const S=new Y.P;this.m_left.queryCoord2D(.5*(u[y]+g),S);const b=new c.l;b.constructCircularArcThreePoint(d,C,S),m.addSegment(b,!1),d.assign(C),g=u[y]}return m}static goodOrientation(t,m){const u=t.getCoord2D(m.vmin),g=t.getCoord2D(m.vmax);return u.compare(g)<0}progress_(t=!1){}}function ri(P,t,m,u,g,d,y){!function Tr(P,t,m,u,g,d){P.hasCurves()?(P.setCurveStitcherPointer(u),u.m_impl=new hn(d,!1,null),u.m_impl.buildMonotonicCurveParentage(P,t,m,g)):u.m_impl=null}(P,t,m,g,d,y)}function zn(P,t,m,u){if(!(0,F.h)(P.getGeometryType()))return P;const g=P.getImpl();if(!g.hasNonLinearSegments())return P;const d=P.createInstance();d.getGeometryType()===F.G.enumPolygon&&d.setFillRule(P.getFillRule()),new c.E;const y=new dt.P,C=new c.S,S=[],b=[],A=[],T=P.getDescription().getAttributeCount()>1,M=g.querySegmentIterator();for(;M.nextPath();){let X=!0;for(;M.hasNextSegment();){const k=M.isClosingSegment(),H=M.nextSegment();if(!H.isCurve()){d.addSegment(H,X,k),X=!1;continue}let U,Z=!1;const st=!0,mt=!0;switch(H.getGeometryType()){case F.G.enumEllipticArc:case F.G.enumRationalBezier2:U=(0,c.N)(H,t,m,st,mt,b,A,S),Z=!0;break;default:U=(0,c.K)(H,t,m,!0,st,b,S)}const ht=Z?2:3;b[1].isNAN()?(C.createLine(),C.get().construct(b[0],b[ht])):Z?(C.createQuadraticRationalBezier(),C.get().constructArrayWeights(b,A)):(C.createCubicBezier(),C.get().constructPoints(b)),T&&X&&(H.queryCoord(S[0],y),C.get().setStart(y)),T&&(H.queryCoord(S[1],y),C.get().setEnd(y)),d.addSegment(C.get(),X,k&&1===U),X=!1;for(let ut=1,ct=U,Et=ht;ut<ct;++ut,Et+=ht)b[Et+1].isNAN()?(C.createLine(),C.get().construct(b[Et],b[Et+ht])):Z?(C.createQuadraticRationalBezier(),C.get().constructArrayWeights(b.slice(Et),A.slice(Et))):(C.createCubicBezier(),C.get().constructPoints(b.slice(Et))),T&&(H.queryCoord(S[ut+1],y),C.get().setEnd(y)),d.addSegment(C.get(),!1,k&&ut+1===ct)}}return d}function Yh(P,t,m,u,g,d,y,C){P.hasCurves()?(P.setCurveStitcherPointer(d),d.m_impl=new hn(C,!0,g),d.m_impl.buildMonotonicCurveParentage(P,t,m,y),function El(P,t,m){ho.fixCurveTwoPointLoops(P,t,m)}(P,m,C)):d.m_impl=null}function oi(P,t){return t||(t=R.J.constructEmpty()),function Nr(P,t){let m=t.isEmpty()?P:(0,dt.a)(null,t,!0).total();return m>P&&(m=P),.125*m}(P,t)}function Ai(P,t){return.125*P}function xi(P,t){return 3*P+3*t}class ci{constructor(){this.m_impl=null}stitchCurves(t,m,u,g){this.m_impl&&(this.m_impl.stitchCurves(t,m,u),g&&this.clearStitcher(t))}clearStitcher(t){this.m_impl&&(this.m_impl.clearStitcher(t),this.m_impl=null)}getOriginalVertexIndex(t,m){return this.m_impl.getOriginalVertexIndex(t,m)}getOriginalSegmentTypeInfo(t){return this.m_impl.getOriginalSegmentTypeInfo(t)}}class hn{constructor(t,m,u){this.m_originalPlanarSegments=[],this.m_progressTracker=null,this.m_nsr=null,this.m_progressTracker=t,this.m_nsr=u,this.m_tolerance=0,this.m_originalVertexIndex=-1,this.m_type=0,this.m_progressCounter=0,this.m_bIsSimple=m}buildMonotonicCurveParentage(t,m,u,g){if(!t.hasCurves())return;(0,F.g)(!t.hasSegmentParentage()),this.m_type=1,this.m_originalPlanarSegments.length=0,this.m_bIsSimple&&(this.m_originalVertexIndex=t.createUserIndex()),this.m_tolerance=u;const C=new dt.P,S=new c.S,b=[],A=[],T=[];for(let M=t.getFirstGeometry();M!==c.n;M=t.getNextGeometry(M))for(let X=t.getFirstPath(M);X!==c.n;X=t.getNextPath(X)){let k=t.getPathSize(X),H=t.getFirstVertex(X),U=0,Z=-1;for(let st=0;st<k;st++){let mt=t.getNextVertex(H);if(!t.querySegment(H,S,!0,!1)){H=mt;continue}if(0===U){Z=t.getVertexIndex(H);const Pt=hn.regularizeCurve(t,S.get(),H,u);if(Pt>=0){this.m_nsr&&0===this.m_nsr.m_reason&&this.m_nsr.assign(new Ee(13,Z,-1)),U=Pt,k=t.getPathSize(X),mt=t.getNextVertex(H);const At=t.querySegment(H,S,!0,!1);(0,F.g)(At)}}else U--;const ht=t.getVertexIndex(H);let ut;-1!==this.m_originalVertexIndex&&t.setUserIndex(H,this.m_originalVertexIndex,Z),t.setSegmentToIndex(ht,null);let ct=!1;switch(S.get().getGeometryType()){case F.G.enumEllipticArc:case F.G.enumRationalBezier2:ut=(0,c.N)(S.get(),m,u,!1,!0,A,T,b),ct=!0;break;default:{const Pt=!this.m_bIsSimple||!S.get().isMonotoneQuickAndDirty();ut=(0,c.K)(S.get(),m,u,Pt,!1,A,b)}}const Et=this.m_originalPlanarSegments.length;if(t.setSegmentParentageAndBreak(H,Et,!0),!A[1].isNAN()){let Pt=null;Pt=ct?new c.Q({points:A,weights:T}):new c.y({cp:A}),Pt.snapControlPoints(u*u),t.setSegmentToIndex(ht,Pt)}const Tt=ct?2:3;for(let Pt=1,At=ut,Ht=Tt;Pt<At;++Pt,Ht+=Tt){S.get().queryCoord(b[Pt],C);const Bt=t.insertVertex(X,mt,C);if(-1!==this.m_originalVertexIndex&&t.setUserIndex(Bt,this.m_originalVertexIndex,Z),!A[Ht+1].isNAN())if(ct){const kt=new c.Q({points:A.slice(Ht),weights:T.slice(Ht)});kt.snapControlPoints(u*u),t.setSegmentToIndex(t.getVertexIndex(Bt),kt)}else{const kt=new c.y({cp:A.slice(Ht)});kt.snapControlPoints(u*u),t.setSegmentToIndex(t.getVertexIndex(Bt),kt)}t.setSegmentParentageAndBreak(Bt,Et,!1)}ut>1&&(st+=ut-1,k=t.getPathSize(X)),this.m_originalPlanarSegments.push(S.releaseSegment()),H=mt}}}stitchCurves(t,m,u){hn.st_stitchCurvesImpl(this,t,m,u,!1)}clearStitcher(t){this.m_originalPlanarSegments.length=0,-1!==this.m_originalVertexIndex&&(t.removeUserIndex(this.m_originalVertexIndex),this.m_originalVertexIndex=-1),t.deleteSegmentParentage()}static st_verifyParentage(t){hn.st_stitchCurvesImpl(null,t,c.n,0,!0)}getOriginalVertexIndex(t,m){return-1!==this.m_originalVertexIndex&&m!==c.n?t.getUserIndex(m,this.m_originalVertexIndex):-1}getOriginalSegmentTypeInfo(t){if(-1!==t){const m=this.m_originalPlanarSegments[t];switch(m.getGeometryType()){case F.G.enumEllipticArc:return 0===m.projectionBehavior()?0:1;case F.G.enumBezier:return 2;case F.G.enumBezier2:return 3;case F.G.enumLine:return-1;case F.G.enumRationalBezier2:return 4;default:(0,F.b)("")}}return-1}progress_(t=!1){this.m_progressCounter++}processSpan_(t,m,u,g,d,y,C){if(m===u&&0===g)return(0,F.g)(t.getNextVertex(m)===c.n),t.setSegmentToIndex(t.getVertexIndex(m),null),void t.setSegmentParentageAndBreak(m,-1);const S=t.getNextVertex(m);{let T=2;for(let M=S;M!==u;M=t.getNextVertex(M))T++;(0,F.g)(T===g)}if(null===d){t.setSegmentToIndex(t.getVertexIndex(m),null);for(let T=S;T!==u;)T=t.removeVertex(T,!0);return}const b=t.getXY(m),A=t.getXY(u);if(d.isClosed()){if(b.isEqualPoint2D(A)&&b.isEqualPoint2D(d.getStartXY())){let T;if(T=this.verifySegmentFitness(t,m,u,g,d,y,C)){const M=d.clone();return M.dropAllAttributes(),T<0&&M.reverse(),this.removeSpan(t,m,u),void t.setSegmentToIndex(t.getVertexIndex(m),M)}}}else if(b.isEqualPoint2D(d.getStartXY())){if(A.isEqualPoint2D(d.getEndXY())){const T=d.clone();if(T.dropAllAttributes(),this.verifySegmentFitness(t,m,u,g,T,y,C))return this.removeSpan(t,m,u),void t.setSegmentToIndex(t.getVertexIndex(m),T)}}else if(A.isEqualPoint2D(d.getStartXY())&&b.isEqualPoint2D(d.getEndXY())){const T=d.getReversed();if(T.dropAllAttributes(),this.verifySegmentFitness(t,m,u,g,T,y,C))return this.removeSpan(t,m,u),void t.setSegmentToIndex(t.getVertexIndex(m),T)}this.processSpanSplitSegment(t,m,u,g,d,y,C)}processSpanSplitSegment(t,m,u,g,d,y,C){if(d.isLine()||this.fitSegmentToSpan(t,m,u,g,d,y,C))return;const S=C*C;let b=g,A=m;const T=t.getXY(m);let M=d.getClosestCoordinate(T,!1);const X=d.getCoord2D(M);let k=!1;const H=Y.P.sqrDistance(T,X);if(H>S){const Et=t.getNextVertex(m);if(this.approximateSpanSection(t,m,d,y,C),Et===u)return;A=Et,k=!0,b-=1}let U=u;const Z=t.getXY(u);M=d.getClosestCoordinate(Z,!1);const st=d.getCoord2D(M);let mt=!1;const ht=Y.P.sqrDistance(Z,st);if(ht>S){const Et=t.getPrevVertex(u);if(this.approximateSpanSection(t,Et,d,y,C),Et===A)return;U=Et,mt=!0,b-=1}if((k||mt)&&this.fitSegmentToSpan(t,A,U,b,d,y,C))return;let ut=!1;if(!k&&H>0){const Et=t.getNextVertex(m);if(this.approximateSpanSection(t,m,d,y,C),Et===U)return;A=Et,k=!0,ut=!0,b-=1}if(!mt&&ht>0){const Et=t.getPrevVertex(u);if(this.approximateSpanSection(t,Et,d,y,C),Et===A)return;U=Et,mt=!0,ut=!0,b-=1}if(ut&&this.fitSegmentToSpan(t,A,U,b,d,y,C))return;let ct=A;for(;;){const Et=t.getNextVertex(ct);if(this.approximateSpanSection(t,ct,d,y,C),ct=Et,ct===U)return}}fitSegmentToSpan(t,m,u,g,d,y,C){const S=0===this.m_type,b=[];if(b.push(t.getXY(m)),S){let M=m;const X=32;if(g>X){const k=BigInt(g-1),H=BigInt(X-1);let U=H,Z=0n;for(let st=1;st<g;st++,U+=H)if(M=t.getNextVertex(M),U>=Z+k){Z+=k;const mt=t.getXY(M);b.push(mt)}(0,F.g)(M===u)}else{for(let k=1;k<g;k++){M=t.getNextVertex(M);const H=t.getXY(M);b.push(H)}(0,F.g)(M===u)}}else{let M=m;const X=new c.S;for(;;){t.querySegment(M,X,!1,!0);const k=[.1,.25,.4,.5,.6,.75,.9,1];let H=0;for(const U of k)(2===g||1&H)&&b.push(X.get().getCoord2D(U)),H++;if(M=t.getNextVertex(M),M===u)break}}const A=(()=>{let M=b[0].compare(b.at(-1));if(0===M){const X=new Y.K(0);(function ao(P,t,m){if(m.reset(),t<3)return;const u=P[0].clone(),g=u.x,d=u.y,y=P[1].clone(),C=new Y.P;for(let S=2;S<t;S++)C.assign(P[S]),m.pe((C.x-u.x)*(y.y-d)),u.assign(y),y.assign(C);m.pe((g-u.x)*(y.y-d))})(b,b.length,X),M=X.getResult()>=0?-1:1}return M>0})();A&&b.reverse();const T=d.clone();if(T.dropAllAttributes(),T.setSegmentFromCoords(b,b.length),A&&T.reverse(),T.snapControlPoints(this.m_tolerance*this.m_tolerance),this.verifySegmentFitness(t,m,u,g,T,y,C)){this.removeSpan(t,m,u);const M=t.getVertexIndex(m);return t.setSegmentToIndex(M,T),!0}return!1}approximateSpanSection(t,m,u,g,d){const y=new c.S;if(!t.querySegment(m,y,!0,!1))return;const C=u.getGeometryType();if(C!==y.get().getGeometryType()){if(C===F.G.enumEllipticArc){if(y.get().getGeometryType()!==F.G.enumRationalBezier2)return;if(0===u.projectionBehavior()){const S=[];!function Mh(P,t,m,u,g){const d=(0,c.X)(t),y=Math.max(4*d,m);new Hn(t,null,y,Number.NaN,g).approximateWithCirclesImpl(P,u)}(!1,y.get(),d,S,this.m_progressTracker);const b=t.getNextVertex(m),A=t.getPathFromVertex(m),T=new dt.P;let M=m;for(let X=1,k=S.length;X<k;X++){const H=S[X],U=y.get().getCoord2D(S[X-1]),Z=y.get().getCoord2D((0,Y.q)(S[X-1],H,.5));y.get().queryCoord(H,T);const st=T.getXY(),mt=new c.l;mt.constructCircularArcThreePoint(U,st,Z);let ht=c.n;H<1&&(ht=t.insertVertex(A,b,T)),t.setSegmentToIndex(t.getVertexIndex(M),mt),M=ht}return}{const S=(0,Y.m)(Y.P,3);y.get().queryControlPoints(S);const b=[0,0,0];y.get().queryWeights(b);const A=(0,c.O)(b),T=new c.l;return(0,c.R)(S,A*A,null,!1,T),void t.setSegmentToIndex(t.getVertexIndex(m),T)}}(0,F.c)("approximate_span_section_")}}verifySegmentFitness(t,m,u,g,d,y,C){return 0===this.m_type?this.verifySegmentFitnessLines(t,m,u,g,d,y,C):this.verifySegmentFitnessCurves(t,m,u,g,d,y,C)}verifySegmentFitnessCurves(t,m,u,g,d,y,C){const S=t.getXY(m),b=t.getXY(u);if(!S.isEqualPoint2D(d.getStartXY())||!b.isEqualPoint2D(d.getEndXY()))return 0;let A=0;if(d.isClosed()){const st=d.getCoord2D(.1).sub(S);A=d.getCoord2D(.7).sub(S).crossProduct(st)>=0?1:-1}const T=(0,Y.d)(c.T.s_maxMonotonicPartParams,Number.NaN);let M=d.getMonotonicPartParams(T.length,T);M--;const X=new c.L,k=[1,.5,.75,.25];let H=0,U=m;const Z=S.clone();for(;;){const st=t.getNextVertex(U);let mt=t.getSegment(U);null===mt&&(t.queryLineConnector(U,X,!0),mt=X);for(let ht=st===u?1:0;ht<k.length;ht++){const ut=mt.getCoord2D(k[ht]);if(!d.isCloserThanDistance(ut,Y.E.unit(),C))return 0}if(M>1)for(let ht=1;ht<M;){const ut=d.getCoord2D(T[ht]);mt.isCloserThanDistance(ut,Y.E.unit(),C)?(T[M-1]=(0,Y.b)(T[ht],T[ht]=T[M-1]),M--):ht++}if(A){const ht=mt.getCoord2D(.25);H+=ht.sub(S).crossProduct(Z.sub(S)),Z.assign(ht),ht.assign(mt.getCoord2D(.75)),H+=ht.sub(S).crossProduct(Z.sub(S)),Z.assign(ht)}if(U=st,U===u)return M>1?0:A?H<0?-A:A:1}}verifySegmentFitnessLines(t,m,u,g,d,y,C){return(0,F.g)(0),0}removeSpan(t,m,u){t.setSegmentToIndex(t.getVertexIndex(m),null);const g=t.getNextVertex(m);g!==u&&t.removeVertices(g,u)}static st_stitchCurvesImpl(t,m,u,g,d){if(m.hasSegmentParentage())return m.hasCurves()?hn.st_stitchCurvesFromCurvesImpl(t,m,u,g,d):hn.st_stitchCurvesFromLinesImpl(t,m,u,g,d)}static st_stitchCurvesFromLinesImpl(t,m,u,g,d){let y=u===c.n?m.getFirstGeometry():u;for(;y!==c.n;){for(let C=m.getFirstPath(y);C!==c.n;C=m.getNextPath(C)){let S=m.getPathSize(C);m.isClosedPath(C)&&(S+=1);let b=!0,A=!1;const T=m.getFirstVertex(C);let M=T;for(let X=0;X<S&&M!==c.n;){let k=m.getSegmentParentage(M);if(-1===k||b){b=!1,X++,M=m.getNextVertex(M),A=!0;continue}let H,U,Z=0;if(A?(H=m.getPrevVertex(M),U=M,(0,F.g)(H!==c.n),(0,F.g)(U!==H),(0,F.g)(-1===m.getSegmentParentage(H)||T===H)):(H=M,U=m.getNextVertex(H),X++,(0,F.g)(U!==c.n),(0,F.g)(U!==H),k=m.getSegmentParentage(U)),Z=2,A=!1,-1===k||m.getSegmentParentageBreakVertex(U)){M=U;continue}let st=m.getNextVertex(U);for(X++;X<S&&st!==c.n;){U=st,Z++;const mt=m.getSegmentParentage(st);if(-1===mt||m.getSegmentParentageBreakVertex(st))break;(0,F.g)(mt===k),X++,st=m.getNextVertex(st)}d||t.processSpan_(m,H,U,Z,t.m_originalPlanarSegments[k],k,g),M=U}}if(u!==c.n)break;y=m.getNextGeometry(y)}}static st_stitchCurvesFromCurvesImpl(t,m,u,g,d){let y=u===c.n?m.getFirstGeometry():u;for(;y!==c.n;)if((0,F.q)(m.getGeometryType(y))){for(let C=m.getFirstPath(y);C!==c.n;C=m.getNextPath(C)){let S=m.getPathSize(C);const b=m.isClosedPath(C);b&&(S+=1);let A=m.getFirstVertex(C);if(b){if(-1!==m.getSegmentParentage(A)){let M=A;for(let X=0;!m.getSegmentParentageBreakVertex(M);X++){if(X===S){A=m.getFirstVertex(C),m.setSegmentParentageBreakVertex(M,!0);break}M=m.getPrevVertex(M)}}}else(0,F.g)(-1===m.getSegmentParentage(A)||m.getSegmentParentageBreakVertex(A));let T=A;for(let M=0;M<S&&T!==c.n;){const X=m.getSegmentParentage(T);if(-1===X){M++,T=m.getNextVertex(T);continue}let k=0,H=c.n;const U=T;k=1;let Z=m.getNextVertex(U);for(;M<S&&Z!==c.n;){M++,H=Z,k++;const st=m.getSegmentParentage(Z);if(-1===st||m.getSegmentParentageBreakVertex(Z))break;(0,F.g)(st===X),Z=m.getNextVertex(Z)}if(H===c.n)break;d||t.processSpan_(m,U,H,k,t.m_originalPlanarSegments[X],X,g),T=H}}if(u!==c.n)break;y=m.getNextGeometry(y)}else y=u===c.n?m.getNextGeometry(y):c.n}static regularizeCurve(t,m,u,g){let d=m.snapControlPoints(g*g);if(d){const y=t.getVertexIndex(u),C=m.clone();t.setSegmentToIndex(y,C)}if(m.getGeometryType()===c.y.type){const y=[],C=m.calculateSpecialPointsForCracking(g,y);if(C>0){t.splitSegment(u,y,C),d=t.snapControlPoints(u,C+1,g*g)||d;for(let S=0;S<C;S++)u=t.getNextVertex(u),t.setSegmentParentageBreakVertex(u,!0);return C}}return d?0:-1}}function qi(P,t,m,u,g){return new ho(P,m,t,u,g).do_()}function Xh(P,t,m=1,u=1,g=1,d=1){if(u>d)return P;if(d>u)return t;const S=new dt.P;return function mr(P,t,m,u,g,d,y,C,S){const b=P.equals(t);if(u>d)return y.assignCopy(P),S[0]=u,C[0]=m,b;if(d>u)return y=t,S[0]=d,C[0]=g,b;y.assignCopy(P);const A=hr(P.getXY(),t.getXY(),m,u,g,d);y.setXY(A.pt),C[0]=A.weight,S[0]=A.rank}(P,t,m,u,g,d,S,[0],[0]),S}function yl(P,t,m){const u=(0,dt.d)(t),g=(0,dt.a1)(t);return!!function No(P,t,m,u,g){const d=new Or(g);return d.m_shape=P,d.m_sqrTolerance=t*t,d.m_cellSize=2*t,d.m_invCellSize=1/d.m_cellSize,d.m_geometry=m,d.m_bTrackChanges=!1,d.needsClustering()}(P,u,c.n,0,m)||Ct(!0,P,g,null,m)}function Rs(P){return(0,dt.d)(P)}class ho{constructor(t,m,u,g,d){this.m_shape=t,this.m_progressTracker=m,this.m_tolerance=u,this.m_bFilterDegenerateSegments=g,this.m_bTrackChanges=d,this.m_progressCounter=0}do_(){const t=new dt.C(this.m_tolerance.tolerance,this.m_tolerance.resolution),g=Rs(t);let d=(0,dt.a1)(t);const y=1.00001*d;d*=1.000001;let C=!1;const S=this.m_shape.getTotalPointCount()+10>30?1e3:(this.m_shape.getTotalPointCount()+10)*(this.m_shape.getTotalPointCount()+10),b=this.m_shape.hasPointFeatures();for(let A=0;;A++){this.m_shape.dbgCheckSelection(),A>S&&(0,F.c)("crack_and_cluster_iteration_exceeded"),this.m_shape.dbgVerifyMonotone();let T=-1;0===A&&(T=this.firstCrack_(),C||=T>0);const M=this.cluster_(g);if(this.m_shape.dbgVerifyMonotone(),C||=M,this.m_bFilterDegenerateSegments){const H=0!==this.m_shape.filterClosePoints(g,!0,!1,this.m_bTrackChanges,c.n);C||=H,this.m_shape.dbgVerifyMonotone()}const X=this.m_shape.snapControlPointsOnSelection(y*y);C||=X,this.m_shape.dbgCheckSelection();let k=!1;if((0===A&&-1===T||b||Ct(!0,this.m_shape,d,null,this.m_progressTracker))&&(k=this.crack_(y),C||=k,this.m_shape.dbgVerifyMonotone()),!k&&!ho.fixCurveTwoPointLoops(this.m_shape,g,this.m_progressTracker)){this.m_shape.dbgVerifyMonotone();break}}return C&&function xl(P){if(!P.hasSegmentParentage())return;const t=new dt.A(0),m=P.queryVertexIteratorOnSelection();for(let y=m.next();y!==c.n;y=m.next())t.add(y);if(0===t.size())return;P.sortVerticesSimpleByY(t,0,t.size()),t.add(c.n);const u=Y.P.getNAN();P.queryXY(t.read(0),u);let g=0;const d=Y.P.getNAN();for(let y=1,C=t.size();y<C;y++){{const S=t.read(y);S!==c.n?P.queryXY(S,d):d.setNAN()}if(!d.isEqualPoint2D(u)){let S=!1,b=-2;for(let A=g;A<y;++A){const T=t.read(A);if(P.getSegmentParentageBreakVertex(T)){S=!0;break}let M=P.getSegmentParentage(T);const X=P.getPrevVertex(T);if(X!==c.n){let k=P.getSegmentParentage(X);if(-1===M&&(M=k),-1===k&&(k=M),M!==k){S=!0;break}}if(-2!==b&&M!==b){S=!0;break}b=M}if(S)for(let A=g;A<y;++A)P.setSegmentParentageBreakVertex(t.read(A),!0);u.setCoordsPoint2D(d),g=y}}}(this.m_shape),C}cluster_(t){return Qi(this.m_shape,t,c.n,this.m_bTrackChanges,this.m_progressTracker)}crack_(t){return function xt(P,t,m,u){if(!lt(P))return!1;const g=new te(u);g.m_shape=P,g.m_tolerance=t,g.m_bTrackChanges=m;let d=!1;const y=P.hasCurves()?5:15;return d=P.getTotalPointCount()<y?g.crackBruteForce_():g.crackerPlaneSweep_(),d}(this.m_shape,t,this.m_bTrackChanges,this.m_progressTracker)}static fixCurveTwoPointLoops(t,m,u){if(!t.hasCurves())return!1;t.dbgVerifyCurves();const g=t.createUserIndexUninitialized(),d=new dt.A(0),y=t.queryVertexIteratorOnSelection();for(let T=y.next();T!==c.n;T=y.next())d.add(T),t.setUserIndex(T,g,-1);if(0===d.size())return!1;d.add(c.n),t.sortVerticesSimpleByY(d,0,d.size()-1);let C=0;const S=t.getXY(d.read(C)),b=new Y.P(Number.NaN,Number.NaN),A=[];for(let T=1,M=d.size();T<M;++T){const X=d.read(T),k=X!==c.n?t.getXY(X):b;if(k.equals(S))continue;const H=[];for(let U=C;U<T;U++){const Z=d.read(U),st=t.getPrevVertex(Z);if(st!==c.n&&-1===t.getUserIndex(st,g)){const ht=sn(t.getXY(st),t.getSegment(st));0!==Y.P.sqrDistance(S,ht.otherPt)&&(ht.vert=st,ht.dir=-1,H.push(ht)),t.setUserIndex(st,g,1)}const mt=t.getNextVertex(Z);if(mt!==c.n&&-1===t.getUserIndex(Z,g)){const ht=sn(t.getXY(mt),t.getSegment(Z));0!==Y.P.sqrDistance(S,ht.otherPt)&&(ht.vert=Z,ht.dir=1,H.push(ht)),t.setUserIndex(Z,g,1)}}if(H.length>1){H.sort((st,mt)=>lo(st,mt));const U=sn(b.clone(),null);H.push(U);let Z=0;for(let st=1,mt=H.length;st<mt;st++)if(!H[st].otherPt.equals(H[st-1].otherPt)){if(st-Z>1&&null!==H[Z].seg){let ht=!1;const ut=Z;for(let ct=Z+1;ct<st;ct++)if(!Rh(H[ut],H[ct])){ht=!0;break}if(ht)for(let ct=Z;ct<st&&null!==H[ct].seg;ct++)A.push(H[ct].vert)}Z=st}}C=T,S.setCoordsPoint2D(k)}for(const T of A){const M=t.getSegment(T);(0,F.g)(null!==M);const X=t.getXY(T),k=t.getXY(t.getNextVertex(T));if(Y.P.distance(X,k)<3*m)t.setSegmentToIndex(t.getVertexIndex(T),null);else{const H=M.lengthToT(.5*M.calculateLength2D());t.splitSegment(T,[H],1)}}return t.removeUserIndex(g),A.length>0}firstCrack_(){const t=this.m_shape.getEnvelope2D(this.m_progressTracker),m=(0,dt.a)(null,t,!0).total();if(4*m<this.m_tolerance.total()){let u=!1;const d=m,y=this.cluster_(1.1*m);u||=y;let C=0;this.m_bFilterDegenerateSegments&&(C=this.m_shape.filterClosePoints(0,!0,!1,this.m_bTrackChanges,c.n));const S=this.crack_(d);return u||=S,u?1:C?2:0}return-1}progress_(t=!1){this.m_progressCounter++,!t&&4095&this.m_progressCounter||(this.m_progressCounter=0)}}function sn(P,t){return{otherPt:P,seg:t,vert:-1,dir:0}}function Rh(P,t){if((0,F.g)(P.otherPt.equals(t.otherPt)),null===P.seg)return null===t.seg;if(null===t.seg)return!1;const m=P.seg.getGeometryType();if(m!==t.seg.getGeometryType())return!1;if(m===F.G.enumBezier){const u=P.seg,g=t.seg;let d=u.getControlPoint1(),y=u.getControlPoint2();-1===P.dir&&(y=(0,Y.b)(d,d=y));let C=g.getControlPoint1(),S=g.getControlPoint2();return-1===t.dir&&(S=(0,Y.b)(C,C=S)),d.equals(C)&&y.equals(S)}if(m===F.G.enumRationalBezier2){const u=P.seg,g=t.seg,d=u.getControlPoint1(),y=g.getControlPoint1();if(!d.equals(y))return!1;const C=[0,0,0];u.queryWeights(C),-1===P.dir&&(C[2]=(0,Y.b)(C[0],C[0]=C[2]));const S=[0,0,0];return g.queryWeights(S),-1===t.dir&&(S[2]=(0,Y.b)(S[0],S[0]=S[2])),C[0]===S[0]&&C[1]===S[1]&&C[2]===S[2]}(0,F.c)("")}function lo(P,t){const m=P.otherPt.compare(t.otherPt);return 0!==m?m:function mo(P,t){if(null===P.seg||null===t.seg)return null!==P.seg?-1:null!==t.seg?1:0;const m=P.seg.getGeometryType(),u=t.seg.getGeometryType();return m<u?-1:m>u?1:0}(P,t)}var uo=F.h,co=F.f,mn=F.A;function ln(P){switch(P){case 1:return 1;case 2:return 2;case 3:return 3;case 4:return 4;case 0:return 0;default:(0,F.g)(0,"unrecognized cut side")}return 3}function Cl(P,t,m,u){return new ai(u).autoCompleteImpl(P,t,m)}function Ko(P,t,m,u,g,d,y){const C=new ai(g);C.m_bOGCOutput=!0;const S=P.getGeometryType()===F.G.enumPolygon&&1===P.getFillRule()&&!(0,dt.M)(u);return C.planarSimplifyImpl_(P,t,S,m,u,g,d,y)}function Un(P,t,m,u,g,d,y,C){return new ai(d).planarSimplifyImpl_(P,t,m,u,g,d,y,C)}function $o(P,t,m){return function Fr(P,t,m,u){const g=P.createInstance(),d=(0,Y.m)(Y.P,100),y=new Array(100),C=P.getPointCount();let S=!0;const b=2===t.getDimension();1!==t.getDimension()&&2!==t.getDimension()&&(0,F.c)("");for(let A=0;A<C;){const T=P.queryCoordinates(d,d.length,A,-1)-A;b?Qo(t,d,T,m.total(),y):Fh(t,d,T,m.total(),y);let M=0;for(let X=0;X<T;X++)0===y[X]&&(S&&(S=!1,g.addPoints(P,0,A)),M!==X&&g.addPoints(P,A+M,A+X),M=X+1);S||M===T||g.addPoints(P,A+M,A+T),A+=T}return S?P:g}(P,t,m)}function Bh(P,t,m,u){if(P.getDimension()>t.getDimension())return hi(us(P),P,0,"^");if(P.getDimension()<t.getDimension()||P.isEmpty())return hi(us(t),P,0,"^");if(t.isEmpty())return hi(us(P),P,0,"^");const g=new R.J;P.queryEnvelope(g);const d=new R.J;t.queryEnvelope(d);const y=new R.J;y.setCoords({env2D:g}),y.mergeEnvelope2D(d);const C=(0,dt.a)(m,y,!0),S=new ai(u),b=new c.E,A=b.addGeometry(us(P)),T=b.addGeometry(us(t));let M=0,X=null;if(b.hasCurves()){X=new ci;const U=b.getEnvelope2D(u);M=Ai(C.total()),ri(b,oi(C.total(),U),C.total(),0,X,null,u)}S.setEditShapeCrackAndCluster(b,C);const k=S.symmetricDifference(A,T);null!==X&&X.stitchCurves(b,k,M,!0);const H=hi(b.getGeometry(k),P,0,"^");return uo(H.getGeometryType())&&(H.getImpl().setIsSimple(4,C.total()),H.getGeometryType()===F.G.enumPolygon&&H.getImpl().updateOGCFlagsProtected()),H}function ta(P,t,m){return function Hh(P,t,m,u){if(P.isEmpty())return P.createInstance();if(t.isEmpty())return u?P.createInstance():new dt.P({copy:P});const g=[new Y.P],d=[0],y=2===t.getDimension();1!==t.getDimension()&&2!==t.getDimension()&&(0,F.c)(""),g[0]=P.getXY(),y?Qo(t,g,1,m.total(),d):Fh(t,g,1,m.total(),d);let C=0===d[0];return u||(C=!C),C?P.createInstance():P}(P,t,m,!0)}function Gr(P,t,m,u,g,d=!1){0===t&&(0,F.t)("not enough geometries to dissolve");let y=0;for(let k=0,H=t;k<H;k++)y=Math.max(P[k].getDimension(),y);if(2===y||1===y)return new ai(u).dissolveMultiPaths_(y,!1,P,t,m,g,d);let C=0,S=-1;for(let k=0,H=t;k<H;k++)P[k].getDimension()===y&&(-1===S&&(S=k),P[k].isEmpty()||(S=k,C++));if(C<2)return us(P[S]);const b=dt.n.constructEmpty(),A=new c.E;let T=c.n;for(let k=0,H=t;k<H;k++)if(P[k].getDimension()===y&&!P[k].isEmpty()){T===c.n?T=A.addGeometry(us(P[k])):A.appendGeometry(T,us(P[k]));const U=dt.n.constructEmpty();P[k].queryLooseEnvelope(U),b.mergeEnv3D(U)}const M=(0,dt.a)(m,b.getEnvelope2D(),!0),X=new ai(u);if(d){const k=(0,dt.N)(m,b.getEnvelopeZs(),!0);return X.planarSimplify3DImpl_(A,M,k,0,!0)}return X.m_bOGCOutput=!0,X.planarSimplifyMultiPoints(A,M,!1,-1)}function ia(P,t,m,u,g,d=!1){t<2&&(0,F.t)("not enough geometries to dissolve");let y=0;for(let H=0,U=t;H<U;H++)y=Math.max(P[H].getDimension(),y);if(2===y||1===y)return new ai(u).dissolveMultiPaths_(y,!0,P,t,m,g,d);const C=dt.n.constructEmpty(),S=new c.E;let b=c.n,A=0,T=-1;for(let H=0,U=t;H<U;H++)if(P[H].getDimension()===y&&(-1===T&&(T=H),!P[H].isEmpty())){T=H,b===c.n?b=S.addGeometry(us(P[H])):S.appendGeometry(b,us(P[H]));const Z=dt.n.constructEmpty();P[H].queryLooseEnvelope(Z),C.mergeEnv3D(Z),A++}if(A<2)return us(P[T]);const M=0===y?m:null,X=(0,dt.a)(M,C.getEnvelope2D(),!0),k=new ai(u);if(d){const H=(0,dt.N)(M,C.getEnvelopeZs(),!0);return k.m_bOGCOutput=!0,k.planarSimplify3DImpl_(S,X,H,0,!0)}return k.planarSimplifyMultiPoints(S,X,!0,-1)}class ai{constructor(t){this.m_topoGraph=null,this.m_maskLookup=[],this.m_dummyPt1=Y.P.getNAN(),this.m_dummyPt2=Y.P.getNAN(),this.m_fromEdgeForPolylines=c.n,this.m_progressCounter=0,this.m_bOGCOutput=!1,this.m_progressTracker=t}linesToPolygonsImpl(t,m){let u=0,g=0,d=null;if(t.hasCurves()){d=new ci;const b=t.getEnvelope2D(this.m_progressTracker);g=Ai(m.total());const A=oi(m.total(),b);u=xi(A,g),ri(t,A,m.total(),0,d,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,m.add(u));const y=this.m_topoGraph.createUserIndexForChains(),C=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(C,y,1);for(let b=this.m_topoGraph.getChainFirstIsland(C);b!==c.n;b=this.m_topoGraph.getChainNextInParent(b))this.m_topoGraph.setChainUserIndex(b,y,1);const S=[];for(let b=this.m_topoGraph.getFirstChain();b!==c.n;b=this.m_topoGraph.getChainNext(b)){if(1===this.m_topoGraph.getChainUserIndex(b,y))continue;this.m_topoGraph.setChainUserIndex(b,y,1);for(let M=this.m_topoGraph.getChainFirstIsland(b);M!==c.n;M=this.m_topoGraph.getChainNextInParent(M))this.m_topoGraph.setChainUserIndex(M,y,1);if(0===this.m_topoGraph.getChainArea(b))continue;const A=this.m_topoGraph.extractPolygonFromChainAndIslands(t,c.n,b,c.n);d?.stitchCurves(t,A,g,!1);const T=t.getGeometry(A);S.push(T)}return new ee.S(S)}autoCompleteImpl(t,m,u){let g=0,d=0,y=null;if(t.hasCurves()){y=new ci;const T=t.getEnvelope2D(this.m_progressTracker);d=Ai(u.total());const M=oi(u.total(),T);g=xi(M,d),ri(t,M,u.total(),0,y,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,u.add(g));const C=this.m_topoGraph.getGeometryID(m),S=this.m_topoGraph.createUserIndexForChains(),b=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(b,S,1);for(let T=this.m_topoGraph.getChainFirstIsland(b);T!==c.n;T=this.m_topoGraph.getChainNextInParent(T))this.m_topoGraph.setChainUserIndex(T,S,1);const A=[];for(let T=this.m_topoGraph.getFirstChain();T!==c.n;T=this.m_topoGraph.getChainNext(T)){if(1===this.m_topoGraph.getChainUserIndex(T,S))continue;this.m_topoGraph.setChainUserIndex(T,S,1);for(let Z=this.m_topoGraph.getChainFirstIsland(T);Z!==c.n;Z=this.m_topoGraph.getChainNextInParent(Z))this.m_topoGraph.setChainUserIndex(Z,S,1);if(0!==this.m_topoGraph.getChainParentage(T))continue;const M=this.m_topoGraph.getChainHalfEdge(T);let X=M,k=!1;do{const Z=this.m_topoGraph.getHalfEdgeTwin(X);if(this.m_topoGraph.getHalfEdgeChain(Z)!==T&&this.m_topoGraph.getHalfEdgeParentage(X)&C){k=!0;break}X=this.m_topoGraph.getHalfEdgeNext(X)}while(X!==M);if(!k||0===this.m_topoGraph.getChainArea(T))continue;const H=this.m_topoGraph.extractPolygonFromChainAndIslands(t,c.n,T,c.n);null!==y&&y.stitchCurves(t,H,d,!1);const U=t.getGeometry(H);A.push(U)}return new ee.S(A)}setEditShape(t,m=!1){null===this.m_topoGraph&&(this.m_topoGraph=new Qs),this.m_topoGraph.setEditShape(t,this.m_progressTracker,!0,m)}setEditShapeCrackAndCluster(t,m){qi(t,m,this.m_progressTracker,!0,!1);for(let u=t.getFirstGeometry();u!==c.n;u=t.getNextGeometry(u))t.getGeometryType(u)===F.G.enumPolygon&&ui(t,u,-1,this.m_bOGCOutput,c.n,this.m_progressTracker);this.setEditShape(t)}setHalfEdgeOrientations_(t,m){const u=this.m_topoGraph.getShape();for(let g=u.getFirstGeometry();g!==c.n;g=u.getNextGeometry(g))if(g===m)for(let d=u.getFirstPath(g);d!==c.n;d=u.getNextPath(d)){let y=u.getFirstVertex(d);if(y===c.n)continue;let C=u.getNextVertex(y);for(;C!==c.n;){const S=this.m_topoGraph.getClusterFromVertex(y),b=this.m_topoGraph.getClusterFromVertex(C),A=this.m_topoGraph.getHalfEdgeConnector(S,b);if(A!==c.n){const T=this.m_topoGraph.getHalfEdgeTwin(A);this.m_topoGraph.setHalfEdgeUserIndex(A,t,1),this.m_topoGraph.setHalfEdgeUserIndex(T,t,2)}y=C,C=u.getNextVertex(y)}}}flushVertices_(t,m){const u=this.m_topoGraph.getShape(),g=u.hasSegmentParentage(),d=new c.S,y=u.insertPath(t,c.n);m.push(m[0]);const C=m.length;let S=c.n;for(let b=0;b<C;b++){const A=m[b];if(S=u.addVertex(y,A),!g)continue;const T=this.m_topoGraph.getClusterFromVertex(A);if(b>0&&this.m_topoGraph.isBreakNode(T)&&u.setSegmentParentageBreakVertex(S,!0),b<C-1){const M=this.m_topoGraph.getHalfEdgeConnector(T,this.m_topoGraph.getClusterFromVertex(m[b+1])),X=this.m_topoGraph.getSegmentParentage(M);u.setSegmentParentageAndBreak(S,X,b>0||this.m_topoGraph.isBreakNode(T)),this.m_topoGraph.isHalfEdgeCurve(M)&&(this.m_topoGraph.querySegmentXY(M,d),u.setSegmentToIndex(u.getVertexIndex(S),d.get().clone()))}}if(g){const b=this.m_topoGraph.getClusterFromVertex(m[C-1]);this.m_topoGraph.isBreakNode(b)&&u.setSegmentParentageBreakVertex(S,!0)}u.setClosedPath(y,!0)}processPolygonCuts_(t,m,u,g){const d=this.m_topoGraph.getGeometryID(u),y=this.m_topoGraph.getGeometryID(g),C=[],S=this.m_topoGraph.getShape(),b=this.m_topoGraph.createUserIndexForHalfEdges();for(let A=this.m_topoGraph.getFirstCluster();A!==c.n;A=this.m_topoGraph.getNextCluster(A)){const T=this.m_topoGraph.getClusterHalfEdge(A);if(T===c.n)continue;let M=T;do{if(1!==this.m_topoGraph.getHalfEdgeUserIndex(M,b)){let X=M,k=M,H=!1,U=0;do{if(this.m_topoGraph.setHalfEdgeUserIndex(X,b,1),!H&&this.m_topoGraph.getHalfEdgeParentage(X)&y&&this.m_topoGraph.getHalfEdgeFaceParentage(X)&d&&(k=X,H=!0),H){const Z=this.m_topoGraph.getHalfEdgeOrigin(X),st=this.m_topoGraph.getClusterVertexIterator(Z),mt=this.m_topoGraph.getVertexFromVertexIterator(st);C.push(mt),-1!==t&&this.m_topoGraph.getHalfEdgeParentage(X)&y&&(U|=this.m_topoGraph.getHalfEdgeUserIndex(X,t))}X=this.m_topoGraph.getHalfEdgeNext(X)}while(X!==k);if(H&&this.m_topoGraph.getChainArea(this.m_topoGraph.getHalfEdgeChain(k))>0){const Z=S.createGeometry(F.G.enumPolygon);this.flushVertices_(Z,C),-1!==m&&S.setGeometryUserIndex(Z,m,U)}C.length=0}M=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(M))}while(M!==T)}this.m_topoGraph.deleteUserIndexForHalfEdges(b)}cutPolygonPolyline_(t,m,u,g){this.m_topoGraph.removeSpikes_();let d=-1;-1!==t&&(d=this.m_topoGraph.createUserIndexForHalfEdges(),this.setHalfEdgeOrientations_(d,u)),this.processPolygonCuts_(d,t,m,u),-1!==d&&(this.m_topoGraph.deleteUserIndexForHalfEdges(d),d=-1);const y=this.m_topoGraph.getShape();for(let C=y.getFirstGeometry();C!==c.n;C=y.getNextGeometry(C))C!==m&&C!==u&&g.push(C);g.sort((C,S)=>{const b=y.getFirstPath(C),A=y.getRingArea(b),T=y.getFirstPath(S),M=y.getRingArea(T);return A<M?-1:A>M?1:0})}cut(t,m,u,g,d){const y=this.m_topoGraph.getShape().getGeometryType(u),C=this.m_topoGraph.getShape().getGeometryType(g),S=(0,F.A)(y),b=(0,F.A)(C);2!==S||1!==b?1!==S||1!==b?(0,F.c)(""):new bl(this,t,m,u,g,d).Do():this.cutPolygonPolyline_(m,u,g,d)}progress_(t=!1){}isGoodParentage(t){return t>=0&&t<this.m_maskLookup.length&&this.m_maskLookup[t]}normalizeInputGeometry(t){const m=t.getGeometryType();if(m===F.G.enumEnvelope){const u=new c.a({vd:t.getDescription()});return t.isEmpty()||u.addEnvelope(t,!1),u}if(m===F.G.enumPoint){const u=new c.M({vd:t.getDescription()});return t.isEmpty()||u.add(t),u}if((0,F.f)(m)){const u=new c.P({vd:t.getDescription()});return t.isEmpty()||u.addSegment(t,!0),u}return m!==F.G.enumMultiPoint&&m!==F.G.enumPolyline&&m!==F.G.enumPolygon&&(0,F.t)("Unexpected geometry type"),t}dissolveNonSimplePolygons(t,m,u,g){(0,F.g)(m>0);const d=new c.E;let y=0,C=-1;for(let S=0,b=m;S<b;S++)2===t[S].getDimension()&&(-1===C&&(C=S),t[S].isEmpty()||(y++,d.addGeometry(t[S])));return 0===y?((0,F.g)(C>=0),this.normalizeInputGeometry(t[C])):this.planarSimplifyPolygons(d,u,!0,!1,-1,!0)}dissolveMultiPaths_(t,m,u,g,d,y,C){(0,F.g)(t>=1&&t<=2),(0,F.g)(g>0);const S=8&y?1:2,b=dt.n.constructEmpty();let A=0,T=-1,M=!0;for(let wt=0,Xt=g;wt<Xt;wt++)if(u[wt].getDimension()===t&&(-1===T&&(T=wt),!u[wt].isEmpty())){T=wt,A++;const Zt=dt.n.constructEmpty();if(u[wt].queryLooseEnvelope(Zt),b.mergeEnv3D(Zt),2===t&&M&&u[wt].getGeometryType()===F.G.enumPolygon)if(16&y){const zt=[0],ge=u[wt].getImpl().getIsSimple(0,zt),qt=this.m_bOGCOutput?5===ge:(0,dt.i)(ge);M&&=qt}else{const zt=(0,dt.f)(u[wt],0);M&&=zt}}if(A<2&&((0,F.g)(T>=0),0===A||!(16&y)))return this.normalizeInputGeometry(u[T]);if(!M){const wt=(0,dt.a)(m?null:d,b.getEnvelope2D(),!0);return this.dissolveNonSimplePolygons(u,g,wt,y)}const X=u.slice(0,g),k=(0,dt.a)(d,b.getEnvelope2D(),!0),H=10*(0,dt.d)(k);let U=new dt.C(0,0);if(C&&(U=(0,dt.N)(d,b.getEnvelopeZs(),!0)),1===A&&1===t&&2===S&&!m)return C?function Sl(P,t,m,u,g,d,y){return(0,F.g)(0),{}}():this.m_bOGCOutput?Ko(X[T],k,!1,-1,this.m_progressTracker,S,!1):Un(X[T],k,!1,!1,-1,this.m_progressTracker,S,!1);const Z=new dt.Q;Z.startConstruction();let st=2===t?3:4,mt=0;for(let wt=0,Xt=g;wt<Xt;wt++){if(X[wt].getDimension()!==t||X[wt].isEmpty())continue;let Zt=X[wt].getGeometryType();if(Zt!==F.G.enumEnvelope){if((0,F.f)(Zt)?(X[wt]=this.normalizeInputGeometry(X[wt]),Zt=F.G.enumPolyline):(0,F.g)((0,F.h)(Zt)),1===t){(0,F.g)(Zt===F.G.enumPolyline);let ge=-1;if(C)(0,F.g)(0,"3d not implemented yet");else{const qt=[0];ge=X[wt].getImpl().getIsSimple(k.total(),qt)}if(this.m_bOGCOutput?5!==ge:!(0,dt.i)(ge))if(m)st=-1;else{C?(0,F.g)(0,"3d not implemented yet"):X[wt]=this.m_bOGCOutput?Ko(X[wt],k,!1,-1,this.m_progressTracker,S,!1):Un(X[wt],k,!1,!1,-1,this.m_progressTracker,S,!1);const qt=[0];(0,F.g)((0,dt.i)(X[wt].getImpl().getIsSimple(k.total(),qt)))}}else{(0,F.g)(Zt===F.G.enumPolygon);const ge=[0],qt=X[wt].getImpl().getIsSimple(0,ge);(0,F.g)((0,dt.M)(qt))}const zt=X[wt].getImpl();for(let ge=0,qt=zt.getPathCount();ge<qt;ge++){const ce=R.J.constructEmpty();zt.queryLoosePathEnvelope(ge,ce),ce.inflateCoords(H,H),Z.addEnvelope(mt,ce),mt++}}else{(0,F.g)(Zt===F.G.enumEnvelope);const zt=R.J.constructEmpty();X[wt].queryLooseEnvelope(zt),zt.inflateCoords(H,H),Z.addEnvelope(mt,zt),mt++,st=-1}}Z.endConstruction();const ht=mt,ut=(0,Y.d)(ht,-2147483647),ct=(0,Y.d)(ht,-1);let Et=0;T=-1,mt=0;for(let wt=0,Xt=g;wt<Xt;wt++){if(X[wt].getDimension()!==t||(-1===T&&(T=wt),X[wt].isEmpty()))continue;T=wt,Et++;const Zt=X[wt].getGeometryType();if((0,F.h)(Zt))for(let zt=0,ge=X[wt].getPathCount();zt<ge;zt++)ct[mt]=wt,ut[mt]=-zt-1,mt++;else(0,F.g)(Zt===F.G.enumEnvelope),ct[mt]=wt,ut[mt]=-1,mt++}if(Et<2&&2===t)return(0,F.g)(T>=0),this.normalizeInputGeometry(X[T]);let Tt=ht;for(;Z.next()&&Tt>0;){this.progress_();const wt=Z.getHandleA(),Xt=Z.getHandleB(),Zt=Z.getElement(wt),zt=Z.getElement(Xt);ct[Zt]!==ct[zt]&&(ut[Zt]<0&&(Tt--,ut[Zt]=-(ut[Zt]+1)),ut[zt]<0&&(Tt--,ut[zt]=-(ut[zt]+1)))}const Pt=new c.E;let Bt,At=!1,Ht=0;for(let wt=0,Xt=g;wt<Xt;wt++){if(X[wt].getDimension()!==t||X[wt].isEmpty())continue;const Zt=X[wt].getGeometryType(),zt=Ht;let ge=0,qt=0;const ce=(0,F.h)(Zt)?X[wt]:null;for(let be=zt,Me=ut.length;be<Me&&ct[be]===wt;be++)ut[be]>=0&&(ge++,qt+=ce?ce.getPathSize(ut[be]):(0,F.v)(X[wt])),Ht++;if(qt>.95*(0,F.v)(X[wt])){Pt.addGeometry(this.normalizeInputGeometry(X[wt]));for(let be=zt;be<Ht;be++)ut[be]<0&&(ut[be]=-(ut[be]+1))}else{if(0===ge){At=!0;continue}{At=!0,(0,F.g)((0,F.h)(Zt)),(0,F.g)(null!=ce);const be=new c.a({vd:X[wt].getDescription()}),Me=new c.P({vd:X[wt].getDescription()}),Es=Zt===F.G.enumPolygon?be:Me;for(let ts=zt;ts<Ht;ts++)ut[ts]>=0&&Es.addPath(ce,ut[ts],!0);Pt.addGeometry(Es)}}}if(Pt.getFirstGeometry()!==c.n){const wt=2===t,Xt=m?(0,dt.a)(null,b.getEnvelope2D(),!0):k;let Zt=new dt.C(0,0);if(C&&(Zt=m?(0,dt.N)(null,b.getEnvelopeZs(),!0):U),2===t&&!(2&y)){Pt.collapseAllGeometriesToFirst();let zt=0,ge=null;if(Pt.hasCurves()&&!Pt.hasSegmentParentage()){ge=new ci;const qt=Pt.getEnvelope2D(this.m_progressTracker);zt=Ai(Xt.total()),ri(Pt,oi(Xt.total(),qt),Xt.total(),0,ge,null,this.m_progressTracker)}(function V(P,t,m,u){m>0&&Qi(P,m,t,!1,u),new it(u).executeImpl_(P,t)})(Pt,Pt.getFirstGeometry(),Xt.total(),this.m_progressTracker),null!==ge&&ge.stitchCurves(Pt,c.n,zt,!0)}if(C)Bt=this.planarSimplify3DImpl_(Pt,Xt,Zt,S,!0);else if(2===t)Bt=this.planarSimplifyPolygons(Pt,Xt,wt,m,-1,!1);else{const zt={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};zt.ogcRule=this.m_bOGCOutput,zt.allCrossRoadsImpassable=!0,zt.unsplitBehavior=S,Bt=this.planarSimplifyPolylines(Pt,Xt,m,zt,-1)}if(!At){const zt=[0];st=Bt.getImpl().getIsSimple(Xt.total(),zt)}}else(0,F.g)(At),(0,F.g)(T>=0),Bt=2===t?new c.a({vd:X[T].getDescription()}):new c.P({vd:X[T].getDescription()});if(At){let wt=0;for(let Xt=0,Zt=ut.length;Xt<Zt;Xt++){const zt=ct[Xt];if(!(zt<0)&&ut[Xt]<0){const ge=X[zt].getGeometryType(),qt=(0,F.h)(ge)?X[zt]:null;wt+=qt?qt.getPathSize(-(ut[Xt]+1)):4}}Bt.reserve(Bt.getPointCount()+wt);for(let Xt=0,Zt=ut.length;Xt<Zt;Xt++){const zt=ct[Xt];if(!(zt<0)&&ut[Xt]<0){const ge=X[zt].getGeometryType(),qt=(0,F.h)(ge)?X[zt]:null;qt?Bt.addPath(qt,-(ut[Xt]+1),!0):ge===F.G.enumEnvelope?Bt.addEnvelope(X[zt],!1):((0,F.g)((0,F.f)(ge)),Bt.addSegment(X[zt],!0))}}}let kt=0;if(2===t?-1!==st&&(st=3,kt=m?0:k.total()):((0,F.g)(1===t),m||-1===st||(kt=k.total())),C||Bt.getImpl().setIsSimple(st,kt),!m&&At)if(2===t){if(!C)return(new Vi).execute(Bt,d,!1,this.m_progressTracker);(0,F.g)(0,"3d not yet implemented")}else 1===t&&1!==S&&(Bt=C?function Lh(P,t,m,u){return(0,F.g)(0),{}}():function kh(P,t,m,u){const g=new ai(u),d=new c.E,y=d.addGeometry(t),C=g.planarSimplifyNoCrackingAndCluster(P,d,y,m);return(0,F.g)(C,"planar_simplify_no_cracking_and_cluster"),d.getGeometry(y)}(this.m_bOGCOutput,Bt,S,this.m_progressTracker),Bt.getImpl().setIsSimple(st,kt));return Bt}dissolveTopoGraphCommonEdges_(){const t=this.m_topoGraph.createUserIndexForHalfEdges(),m=[];for(let u=this.m_topoGraph.getFirstCluster();u!==c.n;u=this.m_topoGraph.getNextCluster(u)){const g=this.m_topoGraph.getClusterHalfEdge(u);let d=g;if(g!==c.n)do{if(this.progress_(),1!==this.m_topoGraph.getHalfEdgeUserIndex(d,t)){const y=this.m_topoGraph.getHalfEdgeTwin(d);this.m_topoGraph.setHalfEdgeUserIndex(y,t,1),this.m_topoGraph.setHalfEdgeUserIndex(d,t,1);const C=this.m_topoGraph.getHalfEdgeFaceParentage(d);if(this.isGoodParentage(C)){const S=this.m_topoGraph.getHalfEdgeFaceParentage(y);this.isGoodParentage(S)&&m.push(d)}}d=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(d))}while(d!==g)}this.m_topoGraph.deleteUserIndexForHalfEdges(t),this.m_topoGraph.deleteEdgesBreakFaces_(m)}chooseVertexByOrder(t,m,u,g){let d=(0,Y.j)(),y=c.n;for(let S=this.m_topoGraph.getClusterVertexIterator(t);S!==c.n;S=this.m_topoGraph.incrementVertexIterator(S)){const b=this.m_topoGraph.getVertexFromVertexIterator(S),A=m.getUserIndex(b,u);A>=0&&A<d&&(d=A,y=b)}(0,F.g)(y!==c.n);let C=m.getUserIndex(y,g);return C>0&&(m.setUserIndex(y,g,--C),0===C&&m.setUserIndex(y,u,-1)),y}chooseVertexFromCluster_(t,m){return this.m_topoGraph.getVertexDominantFromCluster(t,m)}chooseVertexFromVertexCluster_(t,m){return this.m_topoGraph.getVertexDominant(t,m)}collectPolygonPathsPreservingFrom_(t,m,u,g,d){const y=this.m_topoGraph.getShape();if(y.getGeometryType(t)!==F.G.enumPolygon)return;const C=y.hasSegmentParentage(),S=new c.S;for(let b=y.getFirstPath(t);b!==c.n;b=y.getNextPath(b)){const A=y.getFirstVertex(b);this.m_topoGraph.getClusterFromVertex(A);const T=this.m_topoGraph.getHalfEdgeFromVertex(A);if(T===c.n)continue;const M=this.m_topoGraph.getHalfEdgeUserIndex(T,u);if(1===M||2===M)continue;const X=this.m_topoGraph.getHalfEdgeFaceParentage(T);if(!this.isGoodParentage(X)){this.m_topoGraph.setHalfEdgeUserIndex(T,u,2);continue}this.m_topoGraph.setHalfEdgeUserIndex(T,u,1);const k=y.insertPath(m,c.n);y.setClosedPath(k,!0);let H=T,U=A,Z=this.m_topoGraph.getClusterFromVertex(U),st=1;do{this.progress_();const mt=this.chooseVertexFromVertexCluster_(U,d),ht=y.addVertex(k,mt);if(this.m_topoGraph.isHalfEdgeCurve(H)&&(this.m_topoGraph.querySegmentXY(H,S),y.setSegmentToIndex(y.getVertexIndex(ht),S.get().clone())),C){const Tt=this.m_topoGraph.getSegmentParentage(H);y.setSegmentParentageAndBreak(ht,Tt,this.m_topoGraph.isBreakNode(Z))}let ut,ct;-1!==g&&this.m_topoGraph.setClusterUserIndex(Z,g,1),this.m_topoGraph.setHalfEdgeUserIndex(H,u,1),H=this.m_topoGraph.getHalfEdgeNext(H);do{ut=1===st?y.getNextVertex(U):y.getPrevVertex(U),ct=ut!==c.n?this.m_topoGraph.getClusterFromVertex(ut):c.n}while(ct===Z);const Et=this.m_topoGraph.getHalfEdgeOrigin(H);if(Et!==ct){do{ut=1===st?y.getPrevVertex(U):y.getNextVertex(U),ct=ut!==c.n?this.m_topoGraph.getClusterFromVertex(ut):c.n}while(ct===Z);if(Et!==ct){ct=Et;const Tt=this.m_topoGraph.getClusterVertexIterator(ct);ut=this.m_topoGraph.getVertexFromVertexIterator(Tt)}else st=-st}Z=ct,U=ut}while(H!==T)}}topoOperationPolygonPolygonHelper_(t,m,u,g,d,y){this.progress_(!0),t!==c.n&&this.collectPolygonPathsPreservingFrom_(t,u,d,y,g),m!==c.n&&this.collectPolygonPathsPreservingFrom_(m,u,d,y,g);const C=new c.S,S=this.m_topoGraph.getShape();S.dbgVerifyCurves();const b=S.hasSegmentParentage();for(let A=this.m_topoGraph.getFirstCluster();A!==c.n;A=this.m_topoGraph.getNextCluster(A)){const T=this.m_topoGraph.getClusterHalfEdge(A);if(T===c.n)continue;let M=T;do{this.progress_();const X=this.m_topoGraph.getHalfEdgeUserIndex(M,d);if(1!==X&&2!==X){const k=this.m_topoGraph.getHalfEdgeFaceParentage(M);if(this.isGoodParentage(k)){const H=S.insertPath(u,c.n);S.setClosedPath(H,!0);let U=M;do{const Z=this.m_topoGraph.getHalfEdgeVertexIterator(U);let st=c.n;if(Z!==c.n)st=this.m_topoGraph.getVertexFromVertexIterator(Z);else{const ut=this.m_topoGraph.getHalfEdgeVertexIterator(this.m_topoGraph.getHalfEdgeTwin(U));st=this.m_topoGraph.getVertexFromVertexIterator(ut),st=S.getNextVertex(st)}const mt=this.chooseVertexFromVertexCluster_(st,g),ht=S.addVertex(H,mt);if(b){const ut=this.m_topoGraph.getSegmentParentage(U),ct=this.m_topoGraph.getHalfEdgeOrigin(U);S.setSegmentParentageAndBreak(ht,ut,this.m_topoGraph.isBreakNode(ct))}if(this.m_topoGraph.isHalfEdgeCurve(U)&&(this.m_topoGraph.querySegmentXY(U,C),S.setSegmentToIndex(S.getVertexIndex(ht),C.get().clone())),this.m_topoGraph.setHalfEdgeUserIndex(U,d,1),-1!==y){const ut=this.m_topoGraph.getClusterFromVertex(mt);this.m_topoGraph.setClusterUserIndex(ut,y,1)}U=this.m_topoGraph.getHalfEdgeNext(U)}while(U!==M)}else this.m_topoGraph.setHalfEdgeUserIndex(M,d,2)}M=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(M))}while(M!==T)}}topoOperationPolygonPolygon_(t,m,u,g=!1){this.dissolveTopoGraphCommonEdges_();const d=this.m_topoGraph.getShape(),y=d.createGeometry(F.G.enumPolygon),C=this.m_topoGraph.createUserIndexForHalfEdges();return this.topoOperationPolygonPolygonHelper_(t,m,y,u,C,-1),this.m_topoGraph.deleteUserIndexForHalfEdges(C),g||ui(d,y,3,this.m_bOGCOutput,c.n,this.m_progressTracker),y}topoOperationPolyline_(t,m){const u={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return u.ogcRule=m,u.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(c.n,t,!1,u).first}topoOperationMultiPoint_(){const t=this.m_topoGraph.getShape(),m=t.createGeometry(F.G.enumMultiPoint),u=t.insertPath(m,c.n);for(let g=this.m_topoGraph.getFirstCluster();g!==c.n;g=this.m_topoGraph.getNextCluster(g)){const d=this.m_topoGraph.getClusterParentage(g);if(this.isGoodParentage(d)){let y=c.n;for(let C=this.m_topoGraph.getClusterVertexIterator(g);C!==c.n;C=this.m_topoGraph.incrementVertexIterator(C)){const S=this.m_topoGraph.getVertexFromVertexIterator(C);y===c.n&&(y=S);const b=t.getGeometryFromPath(t.getPathFromVertex(S)),A=this.m_topoGraph.getGeometryID(b);if(this.isGoodParentage(A)){y=S;break}}t.addVertex(u,y)}}return m}intersection(t,m){const u=this.m_topoGraph.getShape().getGeometryType(t),g=this.m_topoGraph.getShape().getGeometryType(m),d=(0,F.A)(u),y=(0,F.A)(g),C=this.m_topoGraph.getGeometryID(t),S=this.m_topoGraph.getGeometryID(m);(0,F.g)(C>=0),(0,F.g)(S>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(C|S),this.m_maskLookup[C|S]=!0;let b=c.n;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(b=t),2===d&&2===y?this.topoOperationPolygonPolygon_(t,m,b):1===d&&y>0||1===y&&d>0?this.topoOperationPolyline_(b,this.m_bOGCOutput):0===d||0===y?this.topoOperationMultiPoint_():void(0,F.c)("")}topoOperationPolygonPolygonEx(t,m,u){const g=this.m_topoGraph.getShape(),d=g.createGeometry(F.G.enumPolygon),y=g.createGeometry(F.G.enumPolyline),C=g.createGeometry(F.G.enumMultiPoint);this.dissolveTopoGraphCommonEdges_();let S=c.n;const b=this.m_topoGraph.createUserIndexForHalfEdges(),A=this.m_topoGraph.createUserIndexForClusters();g.dbgVerifyCurves(),this.topoOperationPolygonPolygonHelper_(t,m,d,u,b,A),g.dbgVerifyCurves();const T=g.hasSegmentParentage(),M=new c.S;for(let k=this.m_topoGraph.getFirstCluster();k!==c.n;k=this.m_topoGraph.getNextCluster(k)){const H=this.m_topoGraph.getClusterHalfEdge(k);if(H===c.n)continue;let U=H;do{let Z=this.m_topoGraph.getHalfEdgeUserIndex(U,b),st=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(U),b),mt=Z|st;if(2===mt){let ht=this.m_topoGraph.getHalfEdgeParentage(U);if(this.isGoodParentage(ht)){const ut=g.insertPath(y,c.n);let ct=U;const Et=this.chooseVertexFromCluster_(k,u);let Tt=g.addVertex(ut,Et);if(T){const Pt=this.m_topoGraph.getSegmentParentage(U),At=this.m_topoGraph.getHalfEdgeOrigin(U);g.setSegmentParentageAndBreak(Tt,Pt,this.m_topoGraph.isBreakNode(At))}this.m_topoGraph.isHalfEdgeCurve(U)&&(this.m_topoGraph.querySegmentXY(U,M),g.setSegmentToIndex(g.getVertexIndex(Tt),M.get().clone())),this.m_topoGraph.setClusterUserIndex(k,A,1);do{this.progress_();const Pt=this.m_topoGraph.getHalfEdgeTo(ct),At=this.chooseVertexFromCluster_(Pt,u);if(Tt=g.addVertex(ut,At),T){const Ht=this.m_topoGraph.getSegmentParentage(U),Bt=this.m_topoGraph.getHalfEdgeOrigin(U);g.setSegmentParentageAndBreak(Tt,Ht,this.m_topoGraph.isBreakNode(Bt))}if(this.m_topoGraph.setHalfEdgeUserIndex(ct,b,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(ct),b,1),this.m_topoGraph.setClusterUserIndex(Pt,A,1),ct=this.m_topoGraph.getHalfEdgeNext(ct),Z=this.m_topoGraph.getHalfEdgeUserIndex(ct,b),st=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(ct),b),mt=Z|st,2!==mt)break;if(ht=this.m_topoGraph.getHalfEdgeParentage(ct),!this.isGoodParentage(ht)){this.m_topoGraph.setHalfEdgeUserIndex(ct,b,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(ct),b,1);break}this.m_topoGraph.isHalfEdgeCurve(U)&&ct!==U&&(this.m_topoGraph.querySegmentXY(U,M),g.setSegmentToIndex(g.getVertexIndex(Tt),M.get().clone()))}while(ct!==U)}else this.m_topoGraph.setHalfEdgeUserIndex(U,b,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(U),b,1)}U=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(U))}while(U!==H)}for(let k=this.m_topoGraph.getFirstCluster();k!==c.n;k=this.m_topoGraph.getNextCluster(k)){if(this.progress_(),1===this.m_topoGraph.getClusterUserIndex(k,A))continue;const H=this.m_topoGraph.getClusterParentage(k);if(this.isGoodParentage(H)){S===c.n&&(S=g.insertPath(C,c.n));const U=this.m_topoGraph.getClusterVertexIterator(k);let Z=c.n;if(U!==c.n){Z=this.m_topoGraph.getVertexFromVertexIterator(U);const st=this.chooseVertexFromVertexCluster_(Z,u);g.addVertex(S,st)}}}this.m_topoGraph.deleteUserIndexForClusters(A),this.m_topoGraph.deleteUserIndexForHalfEdges(b),g.dbgVerifyCurves(),ui(g,d,3,this.m_bOGCOutput,c.n,this.m_progressTracker);const X=[c.n,c.n,c.n];return X[0]=C,X[1]=y,X[2]=d,X}topoOperationPolylinePolylineOrPolygonEx(t,m){const u={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return u.ogcRule=m,u.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(c.n,t,!0,u)}topoOperationMultiPoint(){const t=this.m_topoGraph.getShape(),m=t.createGeometry(F.G.enumMultiPoint),u=t.insertPath(m,c.n);for(let g=this.m_topoGraph.getFirstCluster();g!==c.n;g=this.m_topoGraph.getNextCluster(g)){const d=this.m_topoGraph.getClusterParentage(g);if(this.isGoodParentage(d)){let y=c.n;for(let C=this.m_topoGraph.getClusterVertexIterator(g);C!==c.n;C=this.m_topoGraph.incrementVertexIterator(C)){const S=this.m_topoGraph.getVertexFromVertexIterator(C);y===c.n&&(y=S);const b=t.getGeometryFromPath(t.getPathFromVertex(S)),A=this.m_topoGraph.getGeometryID(b);if(this.isGoodParentage(A)){y=S;break}}t.addVertex(u,y)}}return m}intersectionEx(t,m){const u=this.m_topoGraph.getShape().getGeometryType(t),g=this.m_topoGraph.getShape().getGeometryType(m),d=mn(u),y=mn(g),C=this.m_topoGraph.getGeometryID(t),S=this.m_topoGraph.getGeometryID(m);(0,F.g)(C>=0),(0,F.g)(S>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(C|S),this.m_maskLookup[C|S]=!0;let b=c.n;if(this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(b=t),2===d&&2===y)return this.topoOperationPolygonPolygonEx(t,m,b);if(1===d&&y>0||1===y&&d>0){const{first:A,second:T}=this.topoOperationPolylinePolylineOrPolygonEx(b,this.m_bOGCOutput);return[T,A]}if(0===d||0===y){const A=[];return A.push(this.topoOperationMultiPoint()),A}(0,F.c)("")}getCombinedHalfEdgeParentage(t){return this.m_topoGraph.getHalfEdgeParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t))}prevailingDirection(t,m){const u=this.getCombinedHalfEdgeParentage(m),g=this.m_topoGraph.getHalfEdgeOrigin(m),d=this.m_topoGraph.getHalfEdgeTo(m);let y=0,C=0;for(let S=this.m_topoGraph.getClusterVertexIterator(g);S!==c.n;S=this.m_topoGraph.incrementVertexIterator(S)){const b=this.m_topoGraph.getVertexFromVertexIterator(S),A=t.getPathFromVertex(b),T=t.getGeometryFromPath(A),M=this.m_topoGraph.getGeometryID(T),X=t.getFirstVertex(A),k=!!(M&u);k&&X===b&&(this.m_fromEdgeForPolylines=m);const H=t.getNextVertex(b);if(H!==c.n&&this.m_topoGraph.getClusterFromVertex(H)===d){if(y++,k){if(this.m_fromEdgeForPolylines===c.n&&X===H){const U=this.m_topoGraph.getHalfEdgeNext(m);this.isGoodParentage(this.getCombinedHalfEdgeParentage(U))&&(this.m_fromEdgeForPolylines=U)}C++}}else{const U=t.getPrevVertex(b);if(U!==c.n&&this.m_topoGraph.getClusterFromVertex(U)===d&&(y--,k)){if(this.m_fromEdgeForPolylines===c.n&&X===U){const Z=this.m_topoGraph.getHalfEdgeNext(m);this.isGoodParentage(this.getCombinedHalfEdgeParentage(Z))&&(this.m_fromEdgeForPolylines=Z)}C--}}}return this.m_topoGraph.queryXY(g,this.m_dummyPt1),this.m_topoGraph.queryXY(d,this.m_dummyPt2),(0!==C?C:y)*Y.P.distance(this.m_dummyPt1,this.m_dummyPt2)}tryMoveThroughCrossroadBackwards(t,m){const u=this.m_topoGraph.getHalfEdgePrev(t),g=this.m_topoGraph.getHalfEdgeTwin(u);if(!m){if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t)))return c.n;const C=this.m_topoGraph.getHalfEdgeTwin(t);if(g===this.m_topoGraph.getHalfEdgeNext(C))return u}let d=g,y=c.n;for(;d!==t;){const C=this.getCombinedHalfEdgeParentage(d);if(this.isGoodParentage(C)){if(y!==c.n)return c.n;y=this.m_topoGraph.getHalfEdgeTwin(d)}d=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgePrev(d))}return y}tryMoveThroughCrossroadForward(t,m){const u=this.m_topoGraph.getHalfEdgeNext(t),g=this.m_topoGraph.getHalfEdgeTwin(u);if(!m){const C=this.m_topoGraph.getHalfEdgeTwin(t);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(C)))return c.n;if(g===this.m_topoGraph.getHalfEdgePrev(C))return u}let d=g,y=c.n;for(;d!==t;){const C=this.getCombinedHalfEdgeParentage(d);if(this.isGoodParentage(C)){if(y!==c.n)return c.n;y=this.m_topoGraph.getHalfEdgeTwin(d)}d=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgeNext(d))}return y}isOnALoop(t,m){let u=t;const g=2*this.m_topoGraph.getShape().getTotalPointCount()+10;for(let d=0;d<g;d++){if(1===this.m_topoGraph.getHalfEdgeUserIndex(u,m))return!1;const y=this.m_topoGraph.getHalfEdgeNext(u);if(y===this.m_topoGraph.getHalfEdgeTwin(u))return!1;if(u=y,u===t)return!0}(0,F.c)("is_on_a_loop_")}restorePolylineParts(t,m,u,g,d,y,C,S,b,A){(0,F.g)(d===c.n&&y>=0&&C>=0||-1===y&&-1===C),(0,F.g)(-1===S&&1!==A.unsplitBehavior||-1!==S&&1===A.unsplitBehavior);const T=A.ogcRule,M=A.allCrossRoadsImpassable,X=1===A.unsplitBehavior,k=0===A.unsplitBehavior,H=this.m_topoGraph.getShape(),U=H.hasSegmentParentage();let Z=t,st=this.m_topoGraph.getHalfEdgeTwin(Z);const mt=new c.S;this.m_fromEdgeForPolylines=c.n;let ht=this.prevailingDirection(H,Z),ut=Z,ct=c.n,Et=!1,Tt=!1,Pt=!1;if(!X)for(;;){const ts=this.m_topoGraph.getHalfEdgePrev(Z);if(ts===st){Pt=!0;break}const He=this.m_topoGraph.getHalfEdgeNext(st);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(He))){Et=!0;break}if(this.m_topoGraph.getHalfEdgeTwin(ts)!==He){if(M){Et=!0;break}if(Z=this.tryMoveThroughCrossroadBackwards(Z,!0),Z===c.n){Et=!0;break}st=this.m_topoGraph.getHalfEdgeTwin(Z)}else Z=ts,st=He;if(1===this.m_topoGraph.getHalfEdgeUserIndex(Z,u)){Pt=!0;break}if(Z===t){ct=t,Tt=!0;break}const Ke=this.getCombinedHalfEdgeParentage(Z);if(!this.isGoodParentage(Ke))break;ut=Z,ht+=this.prevailingDirection(H,Z)}if(ct===c.n){for(Z=t,st=this.m_topoGraph.getHalfEdgeTwin(Z),ct=Z;;){const He=this.m_topoGraph.getHalfEdgeNext(Z),Ke=this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(He));if(Ke){Et=!0;break}if(He===st){Pt=!0;break}if(-1!==S){const di=this.m_topoGraph.getHalfEdgeOrigin(st);if(1===this.m_topoGraph.getClusterUserIndex(di,S)){Et=!0;break}}const rs=this.m_topoGraph.getHalfEdgePrev(st);if(this.m_topoGraph.getHalfEdgeTwin(He)!==rs){if(Ke||M){Et=!0;break}if(Z=this.tryMoveThroughCrossroadForward(Z,!0),Z===c.n){Et=!0;break}st=this.m_topoGraph.getHalfEdgeTwin(Z)}else Z=He,st=rs;if(1===this.m_topoGraph.getHalfEdgeUserIndex(Z,u)){Pt=!0;break}const Fe=this.getCombinedHalfEdgeParentage(Z);if(!this.isGoodParentage(Fe))break;ct=Z,ht+=this.prevailingDirection(H,Z)}const ts=this.m_topoGraph.getHalfEdgeOrigin(ut);Tt=this.m_topoGraph.getHalfEdgeTo(ct)===ts}else if(this.m_fromEdgeForPolylines!==c.n){ut=t,ct=this.tryMoveThroughCrossroadBackwards(ut,!1),(0,F.g)(ct!==c.n);const ts=this.m_topoGraph.getHalfEdgeTwin(ut);this.m_topoGraph.getHalfEdgeNext(ts)}let At=Tt;Tt||Pt||b&&(At=this.isOnALoop(t,u),At||(At=this.isOnALoop(st,u)));const Ht=ht>=0;let Bt=!1;At&&Et&&(Tt?(Bt=T,Ht&&(Bt||X||k)&&ut!==t&&((0,F.g)(!X),ut=t,Bt=!1)):(X||Ht&&k)&&(ut=t));let kt=0;for(Z=ut;st=this.m_topoGraph.getHalfEdgeTwin(Z),this.m_topoGraph.setHalfEdgeUserIndex(Z,u,1),this.m_topoGraph.setHalfEdgeUserIndex(st,u,1),kt++,Z!==ct;)Z=M?this.m_topoGraph.getHalfEdgeNext(Z):this.tryMoveThroughCrossroadForward(Z,!1);Ht||(ct=(0,Y.b)(ut,ut=ct),ct=this.m_topoGraph.getHalfEdgeTwin(ct),ut=this.m_topoGraph.getHalfEdgeTwin(ut));let wt=H.insertPath(m,c.n);Z=ut;const Xt=this.m_topoGraph.getHalfEdgeOrigin(ut);let Zt;Zt=-1!==y?this.chooseVertexByOrder(Xt,H,y,C):this.chooseVertexFromCluster_(Xt,d),this.m_topoGraph.isStrongPathNode(Xt)&&H.setStrongPathStart(wt,!0);let zt=H.addVertex(wt,Zt),ge=zt;-1!==g&&this.m_topoGraph.setClusterUserIndex(Xt,g,1);let qt=0;const ce=Bt?Math.trunc((kt+1)/2):-1;let be=c.n,Me=!0,Es=c.n;for(;;){if(U){const rs=this.m_topoGraph.getSegmentParentage(Z),Fe=this.m_topoGraph.getHalfEdgeOrigin(Z);H.setSegmentParentageAndBreak(ge,rs,Me||this.m_topoGraph.isBreakNode(Fe))}Me=!1,this.m_topoGraph.isHalfEdgeCurve(Z)&&(this.m_topoGraph.querySegmentXY(Z,mt),H.setSegmentToIndex(H.getVertexIndex(ge),mt.get().clone())),be!==c.n&&-1!==C&&H.addToUserIndex(be,C,-1);const ts=M?this.m_topoGraph.getHalfEdgeNext(Z):this.tryMoveThroughCrossroadForward(Z,!1),He=this.m_topoGraph.getHalfEdgeTo(Z);let Ke;if(Ke=-1!==y?this.chooseVertexByOrder(He,H,y,C):this.chooseVertexFromCluster_(He,d),zt=H.addVertex(wt,Ke),Es=He,-1!==g&&this.m_topoGraph.setClusterUserIndex(He,g,1),U&&this.m_topoGraph.isBreakNode(He)&&H.setSegmentParentageBreakVertex(zt,!0),be=Ke,qt++,Bt&&qt===ce&&(wt=H.insertPath(m,c.n),zt=H.addVertex(wt,Ke),Me=!0,-1!==C&&H.addToUserIndex(Ke,C,-1),be=c.n),Z===ct)break;Z=ts,ge=zt}Es!==c.n&&this.m_topoGraph.isStrongPathNode(Es)&&H.setStrongPathEnd(wt,!0)}topoOperationPolylineSimplify_(t,m){return this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,c.n,!1,m).first}topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,m,u,g){(0,F.g)(m===c.n||t===c.n);const d=this.m_topoGraph.getShape(),y=k=>t===c.n?k===c.n?d.getFirstGeometry():d.getNextGeometry(k):k===c.n?t:c.n,C=d.createGeometry(F.G.enumPolyline);let S=-1;u&&(S=this.m_topoGraph.createUserIndexForClusters());const b=this.m_topoGraph.createUserIndexForHalfEdges(),A=m===c.n?d.createUserIndex():-1,T=m===c.n?d.createUserIndex():-1;let M=-1;if(1===g.unsplitBehavior){M=this.m_topoGraph.createUserIndexForClusters();for(let k=y(c.n);k!==c.n;k=y(k))for(let H=d.getFirstPath(k);H!==c.n;H=d.getNextPath(H)){{const U=d.getFirstVertex(H),Z=this.m_topoGraph.getClusterFromVertex(U);this.m_topoGraph.setClusterUserIndex(Z,M,1)}if(!d.isClosedPath(H)){const U=d.getLastVertex(H),Z=this.m_topoGraph.getClusterFromVertex(U);this.m_topoGraph.setClusterUserIndex(Z,M,1)}}}if(m===c.n){let k=0;for(let H=y(c.n);H!==c.n;H=y(H))for(let U=d.getFirstPath(H);U!==c.n;U=d.getNextPath(U))if(d.isClosedPath(U)){let Z=d.getFirstVertex(U);for(let st=0,mt=d.getPathSize(U);st<mt;st++,Z=d.getNextVertex(Z))d.setUserIndex(Z,A,k++),d.setUserIndex(Z,T,2)}else{const Z=d.getFirstVertex(U);d.setUserIndex(Z,A,k++),d.setUserIndex(Z,T,1);let st=d.getNextVertex(Z);for(let mt=1,ht=d.getPathSize(U)-1;mt<ht;++mt)d.setUserIndex(st,A,k++),d.setUserIndex(st,T,2),st=d.getNextVertex(st);d.setUserIndex(st,A,k++),d.setUserIndex(st,T,1)}}for(let k=y(c.n);k!==c.n;k=y(k))for(let H=d.getFirstPath(k);H!==c.n;H=d.getNextPath(H)){let U=d.getFirstVertex(H);for(let Z=0,st=d.getPathSize(H);Z<st;Z++,U=d.getNextVertex(U)){const mt=this.m_topoGraph.getHalfEdgeFromVertex(U);if(mt===c.n||1===this.m_topoGraph.getHalfEdgeUserIndex(mt,b))continue;const ht=this.getCombinedHalfEdgeParentage(mt);this.isGoodParentage(ht)&&this.restorePolylineParts(mt,C,b,S,m,A,T,M,0===Z,g)}}let X=c.n;if(u){X=d.createGeometry(F.G.enumMultiPoint);let k=c.n;for(let H=this.m_topoGraph.getFirstCluster();H!==c.n;H=this.m_topoGraph.getNextCluster(H))if(this.progress_(),1!==this.m_topoGraph.getClusterUserIndex(H,S)){const U=this.m_topoGraph.getClusterParentage(H);if(this.isGoodParentage(U)){k===c.n&&(k=d.insertPath(X,c.n));const Z=this.m_topoGraph.getClusterVertexIterator(H);if(Z!==c.n){let st;this.m_topoGraph.getVertexFromVertexIterator(Z),st=-1!==A?this.chooseVertexByOrder(H,d,A,T):this.chooseVertexFromCluster_(H,m),d.addVertex(k,st)}}}}return-1!==T&&d.removeUserIndex(T),-1!==A&&d.removeUserIndex(A),-1!==S&&d.removeUserIndex(S),this.m_topoGraph.deleteUserIndexForHalfEdges(b),(0,Y.n)(C,X)}difference(t,m){const u=this.m_topoGraph.getShape().getGeometryType(t),g=this.m_topoGraph.getShape().getGeometryType(m),d=(0,F.A)(u),y=(0,F.A)(g);if(d>y)return t;const C=this.m_topoGraph.getGeometryID(t),S=this.m_topoGraph.getGeometryID(m);if(this.m_maskLookup.length=0,this.m_maskLookup.length=1+(C|S),this.m_maskLookup[C]=!0,2===d&&2===y){let b=c.n;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(b=t),this.topoOperationPolygonPolygon_(t,m,b)}if(1===d&&2===y){const b={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return b.ogcRule=this.m_bOGCOutput,b.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,c.n,!1,b).first}if(1===d&&1===y){const b={unsplitBehavior:0,allCrossRoadsImpassable:!0,ogcRule:!1};return b.ogcRule=this.m_bOGCOutput,b.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,c.n,!1,b).first}if(0===d)return this.topoOperationMultiPoint_();(0,F.c)("")}symmetricDifference(t,m){const u=this.m_topoGraph.getShape().getGeometryType(t),g=this.m_topoGraph.getShape().getGeometryType(m),d=mn(u),y=mn(g),C=this.m_topoGraph.getGeometryID(t),S=this.m_topoGraph.getGeometryID(m);return(0,F.g)(C>=0),(0,F.g)(S>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(C|S),this.m_maskLookup[C]=!0,this.m_maskLookup[C]=!0,this.m_maskLookup[S]=!0,2===d&&2===y?this.topoOperationPolygonPolygon_(t,m,c.n):1===d&&1===y?this.topoOperationPolyline_(c.n,this.m_bOGCOutput):0===d&&0===y?this.topoOperationMultiPoint():void(0,F.c)("")}planarSimplifyNoCrackingAndCluster(t,m,u,g){this.m_bOGCOutput=t,this.m_topoGraph=new Qs;const d=m.getFillRule(u),y=m.getGeometryType(u);if(1!==d||y===F.G.enumMultiPoint?this.m_topoGraph.setAndSimplifyEditShapeAlternate(m,u,this.m_progressTracker):this.m_topoGraph.setAndSimplifyEditShapeWinding(m,u,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return!1;this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const C=this.m_topoGraph.getGeometryID(u);if((0,F.g)(C>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=C+1,this.m_maskLookup[C]=!0,m.getGeometryType(u)===F.G.enumPolygon||1===d&&m.getGeometryType(u)!==F.G.enumMultiPoint){m.setFillRule(u,0);const S=this.topoOperationPolygonPolygon_(u,c.n,c.n);if(m.swapGeometry(S,u),m.removeGeometry(S),1===d&&this.m_bOGCOutput)return this.planarSimplifyNoCrackingAndCluster(t,m,u,g)}else if(m.getGeometryType(u)===F.G.enumPolyline){const S={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};S.ogcRule=this.m_bOGCOutput,S.allCrossRoadsImpassable=!0,S.unsplitBehavior=g;const b=this.topoOperationPolylineSimplify_(m.getFirstGeometry(),S);m.swapGeometry(b,u),m.removeGeometry(b)}else if(m.getGeometryType(u)===F.G.enumMultiPoint){const S=this.topoOperationMultiPoint_();m.swapGeometry(S,u),m.removeGeometry(S)}else(0,F.c)("");return!0}unsplitPolylineExact(t){return(0,F.g)(0),new c.P}planarSimplifyPolylines(t,m,u,g,d){for(let X=t.getFirstGeometry();X!==c.n;X=t.getNextGeometry(X)){const k=t.getGeometryType(X);(0,F.g)(k===F.G.enumPolyline)}let y=0,C=0,S=null;if(t.hasCurves()&&!t.hasSegmentParentage()){S=new ci;const X=t.getEnvelope2D(this.m_progressTracker);C=Ai(m.total());const k=oi(m.total(),X);y=xi(k,C),ri(t,k,m.total(),0,S,null,this.m_progressTracker)}{const X=Rs(m.add(y));t.filterClosePoints(X,!1,!1,!1,c.n)}if(this.m_topoGraph=new Qs,4!==d&&5!==d)if(null===S&&u){const X=new w(this.m_progressTracker,!1);X.sweepVertical(t,m.total()),X.hadComplications()?(qi(t,m,this.m_progressTracker,!0,!1),u=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(m.total())}else qi(t,m.add(y),this.m_progressTracker,!0,!1),u=!1;else u=!1;t.removeSelection(),t.collapseAllGeometriesToFirst();const b=t.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,b,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return(0,F.g)(u&&null===S),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolylines(t,m,!1,g,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const A=this.m_topoGraph.getGeometryID(b);(0,F.g)(A>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=A+1,this.m_maskLookup[A]=!0;const T=this.topoOperationPolylineSimplify_(t.getFirstGeometry(),g);null!==S&&S.stitchCurves(t,T,C,!0);const M=t.getGeometry(T);return u||M.getImpl().setIsSimple(4,m.total()),M}planarSimplifyMultiPoints(t,m,u,g){for(let b=t.getFirstGeometry();b!==c.n;b=t.getNextGeometry(b)){const A=t.getGeometryType(b);(0,F.g)(A===F.G.enumMultiPoint)}this.m_topoGraph=new Qs,4!==g&&5!==g&&qi(t,m,this.m_progressTracker,!0,!1),t.removeSelection(),t.collapseAllGeometriesToFirst();const d=t.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,d,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return(0,F.g)(!1),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyMultiPoints(t,m,!1,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const y=this.m_topoGraph.getGeometryID(d);(0,F.g)(y>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=y+1,this.m_maskLookup[y]=!0;const C=this.topoOperationMultiPoint(),S=t.getGeometry(C);return S.getImpl().setIsSimple(4,m.total()),S}planarSimplifyPolygons(t,m,u,g,d,y){for(let U=t.getFirstGeometry();U!==c.n;U=t.getNextGeometry(U)){const Z=t.getGeometryType(U);(0,F.g)(Z===F.G.enumPolygon||Z===F.G.enumPolyline&&u)}let C=0,S=0,b=null;if(t.hasCurves()&&!t.hasSegmentParentage()){b=new ci;const U=t.getEnvelope2D(this.m_progressTracker);S=Ai(m.total());const Z=oi(m.total(),U);C=xi(Z,S),ri(t,Z,m.total(),0,b,null,this.m_progressTracker)}if(y){qi(t,m.add(C),this.m_progressTracker,!0,!1);for(let U=t.getFirstGeometry();U!==c.n;U=t.getNextGeometry(U))t.getGeometryType(U)===F.G.enumPolygon&&ui(t,U,-1,!1,c.n,this.m_progressTracker)}if(this.m_topoGraph=new Qs,y||4===d||5===d)g=!1;else if(null===b&&g){const U=new w(this.m_progressTracker,!1);U.sweepVertical(t,m.total()),U.hadComplications()?(qi(t,m,this.m_progressTracker,!0,!1),g=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(m.total())}else qi(t,m.add(C),this.m_progressTracker,!0,!1),g=!1;t.removeSelection(),t.collapseAllGeometriesToFirst();const A=t.getFirstGeometry();if(u?this.m_topoGraph.setAndSimplifyEditShapeWinding(t,A,this.m_progressTracker):this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,A,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return(0,F.g)(g&&null===b),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolygons(t,m,u,!1,-1,!1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const T=this.m_topoGraph.getGeometryID(A);(0,F.g)(T>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=T+1,this.m_maskLookup[T]=!0,t.setFillRule(A,0);const M=this.m_bOGCOutput&&u;let k=this.topoOperationPolygonPolygon_(A,c.n,c.n,M);M&&(this.m_topoGraph.removeShape(),this.m_topoGraph=null,t.removeGeometry(A),this.m_topoGraph=new Qs,this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,k,this.m_progressTracker),k=this.topoOperationPolygonPolygon_(k,c.n,c.n,!1)),null!==b&&b.stitchCurves(t,k,S,!0);const H=t.getGeometry(k);return H.setFillRule(0),g?H.getImpl().setIsSimple(3,0):(H.getImpl().setIsSimple(4,m.total()),H.getImpl().updateOGCFlagsProtected()),H}planarSimplify3DImpl_(t,m,u,g,d){return(0,F.g)(0),{}}planarSimplifyImpl_(t,m,u,g,d,y,C,S){if(t.isEmpty())return t.clone();const b=t.getGeometryType(),A=new c.E,T=A.addGeometry(t);if((0,dt.M)(d)&&b===F.G.enumPolygon&&(u=!1,A.setFillRule(T,0)),S&&(t.hasAttribute(1)&&A.replaceNaNs(1,0),A.removeNaNVertices()),b===F.G.enumPolygon||b===F.G.enumPolyline&&u)return this.planarSimplifyPolygons(A,m,u,g,d,!1);if(b===c.P.type){const M={unsplitBehavior:0,allCrossRoadsImpassable:!0,ogcRule:!1};return M.ogcRule=this.m_bOGCOutput,M.unsplitBehavior=C,this.planarSimplifyPolylines(A,m,g,M,d)}if(b===F.G.enumMultiPoint)return this.planarSimplifyMultiPoints(A,m,g,d);(0,F.c)("what else?")}}function hi(P,t,m,u){const g=P.getGeometryType();if(g===F.G.enumEnvelope){const d=new c.a({vd:P.getDescription()});return P.isEmpty()||d.addEnvelope(P,!1),d}if(g===F.G.enumPoint&&("|"===u||"^"===u)){const d=new c.M({vd:P.getDescription()});return P.isEmpty()||d.add(P),d}if(g===F.G.enumLine){const d=new c.P({vd:P.getDescription()});return P.isEmpty()||d.addSegment(P,!0),d}if(g===F.G.enumMultiPoint&&"-"===u&&t.getGeometryType()===F.G.enumPoint){const d=new dt.P({vd:P.getDescription()});return P.isEmpty()||P.getPointByVal(0,d),d}if(g===F.G.enumMultiPoint&&"&"===u&&t.getGeometryType()===F.G.enumPoint){const d=new dt.P({vd:P.getDescription()});return P.isEmpty()||P.getPointByVal(0,d),d}return P}function us(P){const t=P.getGeometryType();if(t===F.G.enumEnvelope){const m=new c.a({vd:P.getDescription()});return P.isEmpty()||m.addEnvelope(P,!1),m}if(t===F.G.enumPoint){const m=new c.M({vd:P.getDescription()});return P.isEmpty()||m.add(P),m}if(co(t)){const m=new c.P({vd:P.getDescription()});return P.isEmpty()||m.addSegment(P,!0),m}return t!==F.G.enumMultiPoint&&t!==F.G.enumPolyline&&t!==F.G.enumPolygon&&(0,F.t)("Unexpected geometry type"),P}function On(P,t,m,u){const g=m===c.n?P.getClusterHalfEdge(t):m;let d=g;(0,F.g)(P.getHalfEdgeOrigin(g)===t);do{u(d),d=P.getHalfEdgeNext(P.getHalfEdgeTwin(d))}while(d!==g)}class bl{constructor(t,m,u,g,d,y){this.m_rParent=t,this.m_rTopoGraph=t.m_topoGraph,this.m_rShape=this.m_rTopoGraph.getShape(),this.m_IDCuttee=this.m_rTopoGraph.getGeometryID(g),this.m_IDCutter=this.m_rTopoGraph.getGeometryID(d),this.m_IDBoth=this.m_IDCuttee|this.m_IDCutter,this.m_bConsiderTouch=m,this.m_sideIndex=u,this.m_cuttee=g,this.m_cutter=d,this.m_rCutHandles=y,this.m_cutteeBreadcrumbsIndex=this.m_rShape.createUserIndexUninitialized(),this.m_clusterParentageIndex=this.m_rShape.createUserIndexUninitialized();for(let C=this.m_rShape.getFirstPath(this.m_cuttee);C!==c.n;C=this.m_rShape.getNextPath(C)){let S=0;const b=this.m_rShape.getPathSize(C);for(let A=this.m_rShape.getFirstVertex(C);S<b;S++,A=this.m_rShape.getNextVertex(A))this.m_rShape.setUserIndex(A,this.m_clusterParentageIndex,this.m_rTopoGraph.getClusterParentage(this.m_rTopoGraph.getClusterFromVertex(A)))}}Do(){this.cutPolylinePolyline_(),this.m_rShape.removeUserIndex(this.m_cutteeBreadcrumbsIndex),this.m_rShape.removeUserIndex(this.m_clusterParentageIndex)}setTbd(t){return 8|t}classifyStandardCut(t,m,u,g){const d=this.m_rShape.getPrevVertex(t),y=this.m_rShape.getNextVertex(t),C=d===c.n?c.n:this.m_rTopoGraph.getHalfEdgeConnector(m,this.m_rTopoGraph.getClusterFromVertex(d)),S=y===c.n?c.n:this.m_rTopoGraph.getHalfEdgeConnector(m,this.m_rTopoGraph.getClusterFromVertex(y)),b=this.m_rTopoGraph.getHalfEdgeConnector(m,this.m_rTopoGraph.getClusterFromVertex(u)),A=this.m_rTopoGraph.getHalfEdgeConnector(m,this.m_rTopoGraph.getClusterFromVertex(g));let T=1,M=32,X=32;if(On(this.m_rTopoGraph,m,A,k=>{k===b&&(T=2),k===C&&(M=T),k===S&&(X=T)}),this.m_bConsiderTouch)32!==M&&this.m_rShape.setUserIndex(d,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(d,this.m_cutteeBreadcrumbsIndex)|M),32!==X&&this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|X);else{if(32===M||32===X||M===X&&C!==b&&C!==A&&S!==b&&S!==A)return 1;this.m_rShape.setUserIndex(d,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(d,this.m_cutteeBreadcrumbsIndex)|M),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|X)}return 0}classifyTouchCut(t,m,u,g){const d=this.m_rShape.getPrevVertex(t),y=this.m_rShape.getNextVertex(t),C=d===c.n?c.n:this.m_rTopoGraph.getHalfEdgeConnector(m,this.m_rTopoGraph.getClusterFromVertex(d)),S=y===c.n?c.n:this.m_rTopoGraph.getHalfEdgeConnector(m,this.m_rTopoGraph.getClusterFromVertex(y)),b=u===c.n?c.n:this.m_rTopoGraph.getHalfEdgeConnector(m,this.m_rTopoGraph.getClusterFromVertex(u)),A=g===c.n?c.n:this.m_rTopoGraph.getHalfEdgeConnector(m,this.m_rTopoGraph.getClusterFromVertex(g));if(!this.m_bConsiderTouch){let T;return(T=b===C||A===C)?this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))):(T=b===S||A===S)&&this.m_rShape.setUserIndex(d,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(d,this.m_cutteeBreadcrumbsIndex))),T?0:1}if(C===c.n)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(S===c.n)return this.m_rShape.setUserIndex(d,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(d,this.m_cutteeBreadcrumbsIndex))),0;if(C===S)return this.m_rShape.setUserIndex(d,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(d,this.m_cutteeBreadcrumbsIndex))),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(A!==c.n){if(C===A)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(S===A)return this.m_rShape.setUserIndex(d,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(d,this.m_cutteeBreadcrumbsIndex))),0;let T=1;On(this.m_rTopoGraph,m,A,M=>{if(M===C){const X=this.m_rShape.getUserIndex(d,this.m_cutteeBreadcrumbsIndex)|T;this.m_rShape.setUserIndex(d,this.m_cutteeBreadcrumbsIndex,X),T=2}else if(M===S){const X=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|T;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,X),T=2}})}else{if(C===b)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(S===b)return this.m_rShape.setUserIndex(d,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(d,this.m_cutteeBreadcrumbsIndex))),0;let T=2;On(this.m_rTopoGraph,m,b,M=>{if(M===C){const X=this.m_rShape.getUserIndex(d,this.m_cutteeBreadcrumbsIndex)|T;this.m_rShape.setUserIndex(d,this.m_cutteeBreadcrumbsIndex,X),T=1}else if(M===S){const X=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|T;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,X),T=1}})}return 0}classifyCutVertex(t,m){let u=0,g=0;for(let d=this.m_rTopoGraph.getClusterVertexIterator(m);d!==c.n;d=this.m_rTopoGraph.incrementVertexIterator(d)){const y=this.m_rTopoGraph.getVertexFromVertexIterator(d);if(this.m_rShape.getGeometryFromVertex(y)===this.m_cutter){g++;const C=this.m_rShape.getPrevVertex(y),S=this.m_rShape.getNextVertex(y);u+=C===c.n||S===c.n?this.classifyTouchCut(t,m,C,S):this.classifyStandardCut(t,m,C,S)}}g&&u===g&&!this.m_bConsiderTouch&&this.m_rShape.setUserIndex(t,this.m_clusterParentageIndex,this.m_IDCuttee)}cutPolylinePolyline_(){this.m_rShape.getGeometryType(this.m_cuttee),this.m_rShape.getGeometryType(this.m_cutter),this.m_rParent.m_maskLookup.length=0,this.m_rParent.m_maskLookup.length=this.m_IDBoth+1,this.m_rParent.m_maskLookup[this.m_IDBoth]=!0;for(let C=this.m_rShape.getFirstPath(this.m_cuttee);C!==c.n;C=this.m_rShape.getNextPath(C)){const S=this.m_rShape.getPathSize(C);let b=this.m_rShape.getFirstVertex(C);for(let A=0;A<S;++A,b=this.m_rShape.getNextVertex(b))this.m_rShape.setUserIndex(b,this.m_cutteeBreadcrumbsIndex,0);b=this.m_rShape.getFirstVertex(C);for(let A=0;A<S;++A,b=this.m_rShape.getNextVertex(b)){const T=this.m_rTopoGraph.getClusterFromVertex(b);this.m_rTopoGraph.getClusterParentage(T)===this.m_IDBoth&&this.classifyCutVertex(b,T)}}const t=(C,S)=>{let b=this.m_rShape.getUserIndex(C,this.m_cutteeBreadcrumbsIndex);const A=this.m_rTopoGraph.getHalfEdgeConnector(this.m_rTopoGraph.getClusterFromVertex(C),this.m_rTopoGraph.getClusterFromVertex(S));return(this.m_rTopoGraph.getHalfEdgeParentage(A)&this.m_IDBoth)===this.m_IDBoth&&(b|=4),b};for(let C=this.m_rShape.getFirstPath(this.m_cuttee);C!==c.n;C=this.m_rShape.getNextPath(C)){let S=this.m_rShape.getFirstVertex(C);const b=this.m_rShape.isClosedPath(C),A=this.m_rShape.getPathSize(C)+(b?1:0);let T=1,M=32;for(let k=this.m_rShape.getNextVertex(S);T<A;++T,S=k,k=this.m_rShape.getNextVertex(k)){const H=t(S,k);this.m_rShape.getUserIndex(S,this.m_clusterParentageIndex)===this.m_IDBoth&&(M=H),32!==M&&this.m_rShape.setUserIndex(S,this.m_cutteeBreadcrumbsIndex,M|H)}S=this.m_rShape.getLastVertex(C);let X=32;T=1;for(let k=this.m_rShape.getPrevVertex(S);T<A;++T,S=k,k=this.m_rShape.getPrevVertex(k)){const H=t(k,S);this.m_rShape.getUserIndex(S,this.m_clusterParentageIndex)===this.m_IDBoth&&(X=H),32!==X&&this.m_rShape.setUserIndex(k,this.m_cutteeBreadcrumbsIndex,X|H)}}let m=c.n,u=c.n,g=32;const d=this.m_rShape.hasSegmentParentage(),y=new c.S;for(let C=this.m_rShape.getFirstPath(this.m_cuttee);C!==c.n;C=this.m_rShape.getNextPath(C)){const S=this.m_rShape.isClosedPath(C),b=this.m_rShape.getPathSize(C)+(S?1:0);let A=1,T=this.m_rShape.getFirstVertex(C),M=c.n,X=!0;for(let k=this.m_rShape.getNextVertex(T);A<b;++A,k=this.m_rShape.getNextVertex(k)){let H=this.m_rShape.getUserIndex(T,this.m_cutteeBreadcrumbsIndex);8===H?H=3:(H&=-9,4&H?H=4:3&~H||(H=3)),H!==g?(m!==c.n&&(M=this.m_rShape.addVertex(u,T),d&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(T))&&this.m_rShape.setSegmentParentageBreakVertex(M,!0),this.m_rCutHandles.push(m),this.m_rShape.setGeometryUserIndex(m,this.m_sideIndex,g)),m=this.m_rShape.createGeometry(F.G.enumPolyline),u=this.m_rShape.insertPath(m,c.n),g=H,X=!0):this.m_rShape.getUserIndex(T,this.m_clusterParentageIndex)===this.m_IDBoth&&4!==H&&(M=this.m_rShape.addVertex(u,T),d&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(T))&&this.m_rShape.setSegmentParentageBreakVertex(M,!0),u=this.m_rShape.insertPath(m,c.n),X=!0),M=this.m_rShape.addVertex(u,T);const U=this.m_rTopoGraph.getClusterFromVertex(T);!X&&d&&this.m_rTopoGraph.isBreakNode(U)&&this.m_rShape.setSegmentParentageBreakVertex(M,!0);const Z=this.m_rTopoGraph.getHalfEdgeFromVertex(T);if(d){const st=this.m_rTopoGraph.getSegmentParentage(Z);this.m_rShape.setSegmentParentageAndBreak(M,st,X||this.m_rTopoGraph.isBreakNode(U))}this.m_rTopoGraph.isHalfEdgeCurve(Z)&&(this.m_rTopoGraph.querySegmentXY(Z,y),this.m_rShape.setSegmentToIndex(this.m_rShape.getVertexIndex(M),y.get().clone())),T=k,X=!1}M=this.m_rShape.addVertex(u,T),d&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(T))&&this.m_rShape.setSegmentParentageBreakVertex(M,!0),this.m_rCutHandles.push(m),this.m_rShape.setGeometryUserIndex(m,this.m_sideIndex,g),m=c.n,u=c.n,g=32}}}function Il(P,t,m){return new ai(m).linesToPolygonsImpl(P,t)}function zh(P,t,m,u,g){if(u&&(u.m_reason=0,u.m_vertexIndex1=-1,u.m_vertexIndex2=-1),P.isEmpty())return 5;const d=P.getGeometryType();if(d===F.G.enumPoint)return En(P,u);const y=(0,dt.b)(t,P,!1).total();if(d===F.G.enumEnvelope){const T=P,M=new R.J;return T.queryEnvelope(M),M.isDegenerate(y)?(u&&(u.m_reason=4,u.m_vertexIndex1=-1,u.m_vertexIndex2=-1),0):5}if((0,F.f)(d)){const T=P,M=new c.P({vd:T.getDescription()});return M.addSegment(T,!0),zh(M,t,m,u,g)}(0,F.C)(d),(0,F.i)(d)||(0,F.b)("OGC simplify is not implemented for this geometry type");const S=P.getImpl().getIsSimple(y,[0]);let b=m?-1:S;if(5===b||0===b)return b;const A=new Gs(P,t,b,g,!0);return d===F.G.enumMultiPoint||d===F.G.enumPolyline||d===F.G.enumPolygon?(b=A.isSimplePlanarImpl(),(0,dt.i)(b)&&(b=5)):(0,F.c)(""),P.getImpl().setIsSimple(b,y),u&&u.assign(A.m_nonSimpleResult),b}function na(P,t,m,u,g){if(u&&(u.m_reason=0,u.m_vertexIndex1=-1,u.m_vertexIndex2=-1),P.isEmpty())return 5;const d=P.getGeometryType();if(d===F.G.enumPoint)return En(P,u);const y=(0,dt.b)(t,P,!1).total();if(d===F.G.enumEnvelope){const T=P,M=R.J.constructEmpty();return T.queryEnvelope(M),M.isDegenerate(y)?(u&&(u.m_reason=4,u.m_vertexIndex1=-1,u.m_vertexIndex2=-1),0):5}if((0,F.f)(d)){const T=P,M=new c.P({vd:T.getDescription()});return M.addSegment(T,!0),na(M,t,m,u,g)}const S=P.getImpl().getIsSimple(y,[0]);let b=m?-1:S;if(-1!==b)return b;const A=new Gs(P,t,b,g,!1);return d===F.G.enumMultiPoint?b=A.multipointIsSimpleAsFeature():d===F.G.enumPolyline?b=A.polylineIsSimpleAsFeature():d===F.G.enumPolygon?b=A.polygonIsSimpleAsFeature():(0,F.c)(""),P.getImpl().setIsSimple(b,y),u&&u.assign(A.m_nonSimpleResult),b}function ra(P,t,m,u){if(P.isEmpty())return P;const g=P.getGeometryType();if(g===F.G.enumPoint){const T=new Ee;if(En(P,T),3===T.m_reason){const M=P.clone();return M.replaceNaNs(1,0),M}return 2===T.m_reason?P.createInstance():P}if(g===F.G.enumEnvelope){const T=(0,dt.b)(t,P,!0).total(),M=P,X=R.J.constructEmpty();return M.queryEnvelope(X),X.isDegenerate(T)?M.createInstance():P}if((0,F.f)(g)){const T=P,M=new c.P({vd:T.getDescription()});return M.addSegment(T,!0),ra(M,t,m,u)}(0,F.C)(g);const d=(0,dt.b)(t,P,!1).total(),C=P.getImpl().getIsSimple(d,[0]),S=m?-1:C;if((0,dt.i)(S)){if(g===F.G.enumPolygon&&0!==P.getFillRule()){const T=P.clone();return T.setFillRule(0),T}return P}if((g===F.G.enumMultiPoint||g===F.G.enumPolyline)&&S>=1)return P;const b=new Gs(P,t,S,u,!1);let A;return g===F.G.enumMultiPoint?A=b.multipointSimplifyAsFeature():g===F.G.enumPolyline?A=b.polylineSimplifyAsFeature():g===F.G.enumPolygon?A=b.polygonSimplifyAsFeature():(0,F.c)(""),A}function Uh(P,t,m,u){if(P.isEmpty())return P;const g=P.getGeometryType();if(g===F.G.enumPoint){const b=new Ee;if(En(P,b),3===b.m_reason){const A=P.clone();return A.replaceNaNs(1,0),A}return 2===b.m_reason?P.createInstance():P}if(g===F.G.enumEnvelope){const b=P,A=new R.J;b.queryEnvelope(A);const T=(0,dt.b)(t,P,!0).total();return A.isDegenerate(T)?b.createInstance():P}if((0,F.f)(g)){const b=P,A=new c.P({vd:b.getDescription()});return A.addSegment(b,!0),Uh(A,t,m,u)}(0,F.C)(g),(0,F.i)(g)||(0,F.b)("OGC simplify is not implemented for this geometry type");const d=(0,dt.b)(t,P,!1).total(),C=P.getImpl().getIsSimple(d,[0]),S=m?-1:C;if(5===S){if(g===F.G.enumPolygon&&0!==P.getFillRule()){const b=P.clone();return b.setFillRule(0),b}return P}return Ko(P,(0,dt.b)(t,P,!0),!1,S,u,0,!0)}function En(P,t){const m=P.getX(),u=P.getY();if(!Number.isFinite(m)||!Number.isFinite(u))return t&&(t.m_reason=2,t.m_vertexIndex1=-1,t.m_vertexIndex2=-1),0;if(P.hasAttribute(1)){const g=P.getZ();if(!Number.isFinite(g))return t&&(t.m_reason=Number.isNaN(g)?3:2,t.m_vertexIndex1=-1,t.m_vertexIndex2=-1),0}return 5}class Oh{constructor(){this.m_segment=null,this.m_vertexIndex=-1,this.m_pathIndex=-1,this.m_flags=0}setReversed(t){this.m_flags&=-2,this.m_flags=this.m_flags|(t?1:0)}getReversed(){return!!(1&this.m_flags)}getRightSide(){return this.getReversed()?0:1}}function oa(P,t,m,u,g){return{x:P,y:t,ipath:m,ivertex:u,ipolygon:g}}function Tl(P,t){return P.x===t.x&&P.y===t.y&&P.ipath===t.ipath&&P.ivertex===t.ivertex&&P.ipolygon===t.ipolygon}function Nl(P,t){P.x=t.x,P.y=t.y,P.ipath=t.ipath,P.ivertex=t.ivertex,P.ipolygon=t.ipolygon}function aa(P,t,m,u,g,d){return{x:P,y:t,ipath:m,ivertex:u,bBoundary:g,bEndPoint:d}}function Wh(P,t){P.x=t.x,P.y=t.y,P.ipath=t.ipath,P.ivertex=t.ivertex,P.bBoundary=t.bBoundary,P.bEndPoint=t.bEndPoint}class Gl extends dt.a6{constructor(t){super(),this.m_helper=t}compare(t,m,u){const g=t.getElement(u),d=this.m_helper.m_xy.read(2*m)-this.m_helper.m_xy.read(2*g);return d<0?-1:d>0?1:0}}class Ue extends dt.a6{constructor(t){super(),this.m_helper=t}compare(t,m,u){const g=t.getElement(u),d=this.m_helper.m_edges[m],y=this.m_helper.m_edges[g],C=d.getReversed(),S=y.getReversed();let b=d.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0),A=y.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0);if(b===A){const T=C?d.m_segment.getStartY():d.m_segment.getEndY(),M=S?y.m_segment.getStartY():y.m_segment.getEndY(),X=Math.min(T,M);let k=.5*(X-this.m_helper.m_yScanline)+this.m_helper.m_yScanline;k===this.m_helper.m_yScanline&&(k=X),b=d.m_segment.intersectionOfYMonotonicWithAxisX(k,0),A=y.m_segment.intersectionOfYMonotonicWithAxisX(k,0)}return b<A?-1:b>A?1:0}}class Gs{constructor(t,m,u,g,d){this.m_multiVertexGeom=null,this.m_edges=[],this.m_freeEdges=[],this.m_lineEdgesRecycle=[],this.m_newEdges=[],this.m_recycledSegIter=null,this.m_crossOverHelperList=new dt.a2,this.m_progressTracker=null,this.m_progressCounter=0,this.m_AET=new dt.T,this.m_xyToNode1=null,this.m_xyToNode2=null,this.m_pathOrientations=null,this.m_pathParentage=null,this.m_xy=null,this.m_pairs=[],this.m_pairIndices=null,this.m_pathsForOGCTests=[],this.m_curveStitcher=null,this.m_editShape=null,this.m_multiPathStitcher=null,this.m_nonSimpleResult=new Ee,this.m_progressCounter=0,this.m_progressTracker=g,this.m_geometry=t,this.m_knownSimpleResult=u,this.m_sr=m;const y=(0,dt.b)(m,t,!1);this.m_toleranceIsSimple=y,this.m_toleranceIsSimpleClustering=(0,dt.d)(y),this.m_toleranceIsSimpleCracking=(0,dt.a1)(y),this.m_toleranceSimplify=(0,dt.b)(m,t,!0),this.m_description=this.m_geometry.getDescription(),this.m_attributeCount=this.m_description.getAttributeCount(),this.m_bOGCRestrictions=d,this.m_bPlanarSimplify=this.m_bOGCRestrictions,this.m_unknownOrientationPathCount=-1,this.m_yScanline=0,this.m_progressCounter=0}isSimplePlanarImpl(){if(this.m_bPlanarSimplify=!0,!this.checkStructure())return 0;const t=this.m_geometry.getGeometryType();return(0,F.h)(t)&&!this.checkDegenerateSegments(!1)?0:this._CheckClustering()?(0,F.h)(t)?this._CheckCracking()?this.m_geometry.getGeometryType()===F.G.enumPolyline?this.checkSelfIntersectionsPolylinePlanar()?4:0:this._CheckSelfIntersections()?this._CheckValidRingOrientation():0:0:5:0}isSimplePlanarImpl3D(){return(0,F.g)(0),7}generateSortedPairs(t){let m=null;(0,F.h)(t.getGeometryType())&&(m=t);const u=(this.m_bPlanarSimplify||this.m_bOGCRestrictions)&&null!==m,g=t.getPointCount();this.m_xy=t.getAttributeStreamRef(0),this.m_pairs.length=0,this.m_pairIndices=new dt.A(0),u&&(this.m_pathsForOGCTests.length=0);let d=0;for(let S=0;S<g;S++)if(this.m_pairs.push(2*S),this.m_pairs.push(2*S+1),this.m_pairIndices.add(2*S),this.m_pairIndices.add(2*S+1),u){for(;S>=m.getPathEnd(d);)d++;this.m_pathsForOGCTests.push(d)}const y=new dt.B,C={parent:this,workPt:new Y.P,userSort(S,b,A){A.sort(S,b,(T,M)=>this.parent.compareVerticesForPlanarClustering(T,M,u))},getValue(S){const b=this.parent.m_pairs[S];return this.parent.m_xy.queryPoint2D(2*(b>>1),this.workPt),this.workPt.y+(1&b?this.parent.m_toleranceIsSimpleClustering:-this.parent.m_toleranceIsSimpleClustering)}};y.sort(this.m_pairIndices,0,2*g,C)}_TestToleranceDistancePlanar(t,m){const u=this.m_xy.read(2*t),g=this.m_xy.read(2*t+1),d=this.m_xy.read(2*m),y=this.m_xy.read(2*m+1);return!rn(u,g,d,y,this.m_toleranceIsSimpleClustering*this.m_toleranceIsSimpleClustering)||0!==this.m_geometry.getDimension()&&u===d&&g===y}checkStructure(){const t=this.m_geometry.getGeometryType();if((0,F.h)(t)){const m=this.m_geometry.getImpl(),u=this.m_geometry.getGeometryType()===F.G.enumPolygon?3:2;for(let g=0,d=m.getPathCount();g<d;g++)if(m.getPathSize(g)<u){if(m.hasNonLinearSegments()&&m.hasNonLinearSegmentsPath(g)&&m.getPathSize(g)>0)continue;return this.m_nonSimpleResult=new Ee(1,g,0),!1}}if((0,F.i)(t)){const m=this.m_geometry.getImpl(),u=m.getAttributeStreamRef(0);for(let g=0,d=m.getPointCount();g<d;g++)if(!u.readPoint2D(2*g).isFinite())return this.m_nonSimpleResult=new Ee(2,g,0),!1;if(this.m_geometry.hasAttribute(1)){const g=m.getAttributeStreamRef(1);for(let d=0,y=m.getPointCount();d<y;d++){const C=g.read(d);if(!Number.isFinite(C))return this.m_nonSimpleResult=Number.isNaN(C)?new Ee(3,d,0):new Ee(2,d,0),!1}}}return!0}checkDegenerateSegments(t){const m=this.m_geometry.getImpl(),u=m.querySegmentIterator(),g=m.hasAttribute(1),d=g?(0,dt.a3)(this.m_sr,m,!1).total():0,y=m.hasNonLinearSegments(),C=this.m_toleranceIsSimple.total();for(;u.nextPath();)for(;u.hasNextSegment();){const S=u.nextSegment();let b=S.calculateLowerLength2D();if(!(b>C||y&&S.isCurve()&&(b=S.calculateLength2D(),b>C))){if(t&&g){const A=S.getStartAttributeAsDbl(1,0),T=S.getEndAttributeAsDbl(1,0);if(Math.abs(T-A)>d)continue}return this.m_nonSimpleResult=new Ee(4,u.getStartPointIndex(),-1),!1}}return!0}checkDegenerateSegments3D(){return(0,F.g)(0),!1}_CheckClustering(){const t=this.m_geometry.getImpl();this.generateSortedPairs(t);const m=t.getPointCount();this.m_AET.clear(),this.m_AET.setComparator(new Gl(this)),this.m_AET.setCapacity(m);for(let u=0,g=2*m;u<g;u++){this.progress_();const d=this.m_pairIndices.read(u),y=this.m_pairs[d],C=y>>1;if(1&y){const S=this.m_AET.search(C),b=this.m_AET.getPrev(S),A=this.m_AET.getNext(S);if(this.m_AET.deleteNode(S),b!==dt.T.st_nullNode()&&A!==dt.T.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(b),this.m_AET.getElement(A)))return this.m_nonSimpleResult=new Ee(5,this.m_AET.getElement(b),this.m_AET.getElement(A)),!1}else{const S=this.m_AET.addElement(C),b=this.m_AET.getPrev(S);if(b!==dt.T.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(b),C))return this.m_nonSimpleResult=new Ee(5,C,this.m_AET.getElement(b)),!1;const A=this.m_AET.getNext(S);if(A!==dt.T.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(A),C))return this.m_nonSimpleResult=new Ee(5,C,this.m_AET.getElement(A)),!1}}return!0}_CheckCracking(){const t=this.m_geometry.getImpl(),m=t.getPointCount();return!t.hasNonLinearSegments()&&m<10?this._CheckCrackingBrute():this._CheckCrackingPlanesweep()}_CheckCrackingPlanesweep(){if(this.m_editShape=new c.E,this.m_editShape.addGeometry(this.m_geometry),this.m_editShape.hasCurves()){this.m_curveStitcher=new ci;const m=R.J.constructEmpty();this.m_geometry.queryEnvelope(m);const u=oi(this.m_toleranceSimplify.total(),m),g=new Ee;if(Yh(this.m_editShape,u,this.m_toleranceSimplify.total(),0,g,this.m_curveStitcher,null,this.m_progressTracker),0!==g.m_reason)return this.m_editShape=null,this.m_nonSimpleResult.assign(g),!1}const t=new Ee;return Ct(!1,this.m_editShape,this.m_toleranceIsSimpleCracking,t,this.m_progressTracker)?(null!=this.m_curveStitcher?(t.m_vertexIndex1=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,t.m_vertexIndex1),t.m_vertexIndex2=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,t.m_vertexIndex2),this.m_curveStitcher=null):(t.m_vertexIndex1=this.m_editShape.getVertexIndex(t.m_vertexIndex1),t.m_vertexIndex2=this.m_editShape.getVertexIndex(t.m_vertexIndex2)),this.m_editShape=null,this.m_nonSimpleResult.assign(t),!1):(null==this.m_curveStitcher&&(this.m_editShape=null),!0)}_CheckCrackingBrute(){const t=this.m_geometry.getImpl(),m=t.querySegmentIterator(),u=t.querySegmentIterator();for(;m.nextPath();)for(;m.hasNextSegment();){const g=m.nextSegment();if(!m.isLastSegmentInPath()||!m.isLastPath()){u.resetTo(m);do{for(;u.hasNextSegment();){const d=u.nextSegment(),y=(0,c._)(!0,g,d,this.m_toleranceIsSimpleCracking,!0);if(y)return this.m_nonSimpleResult=new Ee(2===y?7:6,m.getStartPointIndex(),u.getStartPointIndex()),!1}}while(u.nextPath())}}return!0}_CheckSelfIntersections(){let t=this.m_geometry.getImpl();null!==this.m_curveStitcher&&(this.m_multiPathStitcher=this.m_editShape.getGeometry(this.m_editShape.getFirstGeometry()),t=this.m_multiPathStitcher.getImpl(),this.generateSortedPairs(t)),this.m_edges.length=0,this.m_lineEdgesRecycle.length=0,this.m_recycledSegIter=t.querySegmentIterator(),this.m_recycledSegIter.setCirculator(!0);const m=[],u=t.getPointCount();let g=Number.NaN,d=0;for(let y=0,C=2*u;y<C;y++){this.progress_();const S=this.m_pairIndices.read(y),b=this.m_pairs[S];if(1&b)continue;const A=b>>1,T=this.m_xy.read(2*A),M=this.m_xy.read(2*A+1);if(m.length&&(T!==g||M!==d)){if(!this.processBunchForSelfIntersectionTest(m))return!1;m.length=0}m.push(A),g=T,d=M}return!!this.processBunchForSelfIntersectionTest(m)}checkSelfIntersectionsPolylinePlanar(){const t=this.m_geometry.getImpl(),m=[];for(let C=0,S=t.getPathCount();C<S;C++)m.push(t.isClosedPathInXYPlane(C));const u={x:-1,y:-1,ipath:-1,ivertex:-1,bBoundary:!1,bEndPoint:!1};let g,d,y;{const C=this.m_pairIndices.read(0),S=this.m_pairs[C]>>1,b=this.m_xy.readPoint2D(2*S),A=this.m_pathsForOGCTests[S];g=m[A],d=t.getPathStart(A),y=t.getPathEnd(A)-1,u.bEndPoint=S===d||S===y,u.bBoundary=this.m_bOGCRestrictions?!g&&u.bEndPoint:u.bEndPoint,u.ipath=A,u.x=b.x,u.y=b.y,u.ivertex=S}for(let C=1,S=this.m_pairIndices.size();C<S;C++){const b=this.m_pairIndices.read(C),A=this.m_pairs[b];if(1&A)continue;const T=A>>1,M=this.m_xy.readPoint2D(2*T),X=this.m_pathsForOGCTests[T];let k;X!==u.ipath&&(g=m[X],d=t.getPathStart(X),y=t.getPathEnd(X)-1);const H=T===d||T===y;k=this.m_bOGCRestrictions?!g&&H:H;const U=aa(M.x,M.y,X,T,k,H);if(U.x===u.x&&U.y===u.y)if(this.m_bOGCRestrictions){if(!(U.bBoundary&&u.bBoundary||U.ipath===u.ipath&&U.bEndPoint&&u.bEndPoint))return this.m_nonSimpleResult=new Ee(10,U.ivertex,u.ivertex),!1}else if(!U.bEndPoint||!u.bEndPoint)return this.m_nonSimpleResult=new Ee(7,U.ivertex,u.ivertex),!1;Wh(u,U)}return!0}checkSelfIntersectionsPolylinePlanar3D(t){return(0,F.g)(0),!1}checkSelfIntersectionsPolygonsOGC(){const t=this.m_geometry.getImpl(),m=[];let u=-1,g=!1;for(let T=0,M=t.getPathCount();T<M;T++)t.isExteriorRingOGC(T)&&(g=!1,u++,T<M-1&&(t.isExteriorRingOGC(T+1)||(g=!0))),m.push(g?u:-1);const d={x:-1,y:-1,ipath:-1,ivertex:-1,ipolygon:-1};{const T=this.m_pairIndices.read(0),M=this.m_pairs[T]>>1,X=this.m_xy.readPoint2D(2*M),k=this.m_pathsForOGCTests[M];d.ipath=k,d.x=X.x,d.y=X.y,d.ivertex=M,d.ipolygon=m[k]}const y=[];for(let T=1,M=this.m_pairIndices.size();T<M;T++){const X=this.m_pairIndices.read(T),k=this.m_pairs[X];if(1&k)continue;const H=k>>1,U=this.m_xy.readPoint2D(2*H),Z=this.m_pathsForOGCTests[H],st=oa(U.x,U.y,Z,H,m[Z]);if(st.x===d.x&&st.y===d.y){if(st.ipath===d.ipath)return this.m_nonSimpleResult=new Ee(11,st.ivertex,d.ivertex),!1;m[st.ipath]>=0&&m[st.ipath]===m[d.ipath]&&(0!==y.length&&Tl(y.at(-1),d)||y.push({...d}),y.push(st))}Nl(d,st)}if(0===y.length)return!0;const C=new dt.a2(!0);m.fill(-1);let S=-1;const b=new Y.P;for(let T=0,M=y.length;T<M;T++){const X=y[T];X.x===b.x&&X.y===b.y||(S=C.createList(0),b.x=X.x,b.y=X.y);let k=m[X.ipath];-1===k&&(k=C.createList(2),m[X.ipath]=k),C.addElement(k,S),C.addElement(S,k)}const A=[];for(let T=C.getFirstList();-1!==T;T=C.getNextList(T)){const M=C.getListData(T);if(1&M||!(2&M))continue;let X=-1;for(A.push(T),A.push(-1);A.length;){const k=A.at(-1);A.pop();const H=A.at(-1);A.pop();const U=C.getListData(H);if(1&U){X=2&U?H:k;break}C.setListData(H,1|U);for(let Z=C.getFirst(H);-1!==Z;Z=C.getNext(Z)){const st=C.getData(Z);st!==k&&(A.push(st),A.push(H))}}if(-1!==X){const k=m.indexOf(X);return this.m_nonSimpleResult=new Ee(12,k,-1),!1}}return!0}_CheckValidRingOrientation(){const t=null!==this.m_multiPathStitcher?this.m_multiPathStitcher.getImpl():this.m_geometry.getImpl();if(t.calculateArea2D()<=0)return this.m_nonSimpleResult=new Ee(8,1===t.getPathCount()?1:-1,-1),0;if(1===t.getPathCount())return this.m_bOGCRestrictions&&!this.checkSelfIntersectionsPolygonsOGC()?0:4;this.m_pathOrientations=new dt.a4(t.getPathCount(),0),this.m_pathParentage=new dt.A(t.getPathCount(),-1);let m=-1,u=0;for(let y=0,C=t.getPathCount();y<C;y++){const S=t.calculateRingArea2D(y);if(this.m_pathOrientations.write(y,S<0?0:8),S>0)m=y,u=S;else{if(0===S)return this.m_nonSimpleResult=new Ee(8,y,-1),0;if((m<0||u<Math.abs(S))&&(this.m_nonSimpleResult=new Ee(9,y,-1),this.m_bOGCRestrictions))return 0;this.m_pathParentage.write(y,m)}}this.m_unknownOrientationPathCount=t.getPathCount(),this.m_newEdges.length=0;const g=t.getPointCount();this.m_yScanline=Number.NaN;const d=[];this.m_xyToNode1=new dt.A(g,dt.T.st_nullNode()),this.m_xyToNode2=new dt.A(g,dt.T.st_nullNode()),this.m_freeEdges.length=0,this.m_AET.clear(),this.m_AET.setComparator(new Ue(this));for(let y=0,C=2*g;this.m_unknownOrientationPathCount>0&&y<C;y++){const S=this.m_pairIndices.read(y),b=this.m_pairs[S];if(1&b)continue;const A=b>>1,T=this.m_xy.read(2*A+1);if(T!==this.m_yScanline&&d.length){if(!this.processBunchForRingOrientationTest(d))return 0;d.length=0}d.push(A),this.m_yScanline=T}return this.m_unknownOrientationPathCount>0&&!this.processBunchForRingOrientationTest(d)?0:this.m_bOGCRestrictions?0!==this.m_nonSimpleResult.m_reason?0:this.checkSelfIntersectionsPolygonsOGC()?5:0:0===this.m_nonSimpleResult.m_reason?4:3}processBunchForSelfIntersectionTest(t){if(1===t.length)return!0;for(let C=0,S=t.length;C<S;C++){const b=t[C];this.m_recycledSegIter.resetToVertex(b,-1);const A=this.m_recycledSegIter.previousSegment();this.m_edges.push(this.createEdge(A,b,this.m_recycledSegIter.getPathIndex(),!0)),this.m_recycledSegIter.nextSegment();const T=this.m_recycledSegIter.nextSegment();this.m_edges.push(this.createEdge(T,b,this.m_recycledSegIter.getPathIndex(),!1))}this.m_edges.sort((C,S)=>this.edgeAngleCompare(C,S));let m=this.m_crossOverHelperList.getFirstList();-1===m&&(m=this.m_crossOverHelperList.createList(0)),this.m_crossOverHelperList.reserveNodes(this.m_edges.length);for(let C=0,S=this.m_edges.length;C<S;C++)this.m_crossOverHelperList.addElement(m,C);let u=!0,g=-1,d=-1;for(;u;){u=!1;let C=this.m_crossOverHelperList.getFirst(m);if(-1===C)break;let S=this.m_crossOverHelperList.getNext(C);for(;-1!==S;){const b=this.m_crossOverHelperList.getData(C),A=this.m_crossOverHelperList.getData(S);if(g=this.m_edges[b].m_vertexIndex,d=this.m_edges[A].m_vertexIndex,g!==d)C=S,S=this.m_crossOverHelperList.getNext(C);else if(u=!0,this.m_crossOverHelperList.deleteElement(m,C),C=this.m_crossOverHelperList.getPrev(S),S=this.m_crossOverHelperList.deleteElement(m,S),-1===S||-1===C)break}}const y=this.m_crossOverHelperList.getListSize(m);if(this.m_crossOverHelperList.clear(m),y>0)return this.m_nonSimpleResult=new Ee(7,g,d),!1;for(let C=0,S=t.length;C<S;C++)this.recycleEdge(this.m_edges[C]);return this.m_edges.length=0,!0}processBunchForRingOrientationTest(t){for(let m=0,u=t.length;m<u;m++){const g=t[m];let d=this.m_xyToNode1.read(g);if(d!==dt.T.st_nullNode()){const y=this.m_AET.getElement(d);this.m_freeEdges.push(y),this.m_AET.deleteNode(d),this.recycleEdge(this.m_edges[y]),this.m_edges[y]=null,this.m_xyToNode1.write(g,dt.T.st_nullNode())}if(d=this.m_xyToNode2.read(g),d!==dt.T.st_nullNode()){const y=this.m_AET.getElement(d);this.m_freeEdges.push(y),this.m_AET.deleteNode(d),this.recycleEdge(this.m_edges[y]),this.m_edges[y]=null,this.m_xyToNode2.write(g,dt.T.st_nullNode())}}for(let m=0,u=t.length;m<u;m++){const g=t[m];this.m_recycledSegIter.resetToVertex(g,-1);const d=this.m_recycledSegIter.previousSegment();if(d.getStartY()>d.getEndY()){const C=this.m_recycledSegIter.getStartPointIndex(),S=this.createEdge(d,g,this.m_recycledSegIter.getPathIndex(),!0);let b;this.m_freeEdges.length>0?(b=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[b]=S):(b=this.m_edges.length,this.m_edges.push(S));const A=this.m_AET.addElement(b);this.m_xyToNode1.read(C)===dt.T.st_nullNode()?this.m_xyToNode1.write(C,A):this.m_xyToNode2.write(C,A),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(A)}this.m_recycledSegIter.nextSegment();const y=this.m_recycledSegIter.nextSegment();if(y.getStartY()<y.getEndY()){const C=this.m_recycledSegIter.getEndPointIndex(),S=this.createEdge(y,g,this.m_recycledSegIter.getPathIndex(),!1);let b;this.m_freeEdges.length>0?(b=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[b]=S):(b=this.m_edges.length,this.m_edges.push(S));const A=this.m_AET.addElement(b);this.m_xyToNode1.read(C)===dt.T.st_nullNode()?this.m_xyToNode1.write(C,A):this.m_xyToNode2.write(C,A),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(A)}}for(let m=0,u=this.m_newEdges.length;m<u&&this.m_unknownOrientationPathCount>0;m++){const g=this.m_newEdges[m],d=this.m_AET.getElement(g);if(!(3&this.m_pathOrientations.read(this.m_edges[d].m_pathIndex))){let C=-1,S=this.m_AET.getPrev(g),b=g,A=0;{let T=-1,M=null,X=-1,k=0;for(;S!==dt.T.st_nullNode()&&(T=this.m_AET.getElement(S),M=this.m_edges[T],X=M.m_pathIndex,k=this.m_pathOrientations.read(X),!(3&k));)b=S,S=this.m_AET.getPrev(S);S===dt.T.st_nullNode()?(A=1,S=b):(C=1==(3&k)?X:this.m_pathParentage.read(X),A=M.getRightSide()?0:1,S=this.m_AET.getNext(S))}do{const T=this.m_AET.getElement(S),M=this.m_edges[T],X=M.m_pathIndex;let k=this.m_pathOrientations.read(X);if(!(3&k)){if(A!==M.getRightSide())return this.m_nonSimpleResult=new Ee(8,X,-1),!1;const H=A&&!M.getReversed()?1:2;if(k=-4&k|H,this.m_pathOrientations.write(X,k),2===H&&0===this.m_nonSimpleResult.m_reason){const U=this.m_pathParentage.read(X);if(U!==C&&(this.m_nonSimpleResult=new Ee(9,X,U),this.m_bOGCRestrictions))return!1}if(this.m_unknownOrientationPathCount--,!this.m_unknownOrientationPathCount)return!0}C=1==(3&k)?X:this.m_pathParentage.read(X),b=S,S=this.m_AET.getNext(S),A=A?0:1}while(b!==g)}}return this.m_newEdges.length=0,!0}createEdge(t,m,u,g){let d;return t.getGeometryType()===F.G.enumLine?d=this.createEdgeLine(t):(d=new Oh,d.m_segment=t.clone()),d.m_vertexIndex=m,d.m_pathIndex=u,d.m_flags=0,d.setReversed(g),d}createEdgeLine(t){let m;return this.m_lineEdgesRecycle.length>0?(m=this.m_lineEdgesRecycle.at(-1),this.m_lineEdgesRecycle.pop(),t.copyTo(m.m_segment)):(m=new Oh,m.m_segment=t.clone()),m}recycleEdge(t){t.m_segment.getGeometryType()===F.G.enumLine&&this.m_lineEdgesRecycle.push(t)}static isShortSegment(t,m,u,g){let d=t.calculateLowerLength2D();if(d<=u){let y=!0;if(t.isCurve()&&(d=t.calculateLength2D(),y=d<=u),y){if(m){let C=t.getEndAttributeAsDbl(1,0);Number.isNaN(C)&&(C=0);let S=t.getStartAttributeAsDbl(1,0);return Number.isNaN(S)&&(S=0),Math.abs(S-C)<=g}return!0}return!1}return!1}static isShortSegmentPoints(t,m,u,g,d){if(u){const y=t.getXYZ(),C=m.getXYZ();return(0,dt.a5)(y,C,g,d)}{const y=t.getXY(),C=m.getXY();return Y.P.sqrDistance(y,C)<=g*g}}removeDegenerateSegmentsFromCurvedPath(t,m,u,g){const d=t.hasAttribute(1),y=t.querySegmentIterator();y.resetToPath(m),(0,F.g)(y.nextPath());const C=this.m_toleranceSimplify.total();let S=!1,b=!0;const A=new dt.P,T=new dt.P,M=new Y.P;for(;y.hasNextSegment();){this.progress_();const H=y.nextSegment();if(Gs.isShortSegment(H,d,C,u))if(S){if(H.queryEnd(T),Gs.isShortSegmentPoints(A,T,d,C,u))continue;b&&(g.startPathPoint(A),b=!1),H.queryEnd(A),g.lineToPoint(A),S=!1}else M.assign(H.getStartXY()),H.queryStart(A),S=!0;else if(S)if(H.isCurve()){const U=H.clone();if(U.setCoordsForIntersector(M,H.getEndXY(),!1),U.setStart(A),Gs.isShortSegment(U,d,C,u))continue;g.addSegment(U,b),b=!1,S=!1}else{if(H.queryEnd(T),Gs.isShortSegmentPoints(A,T,d,C,u))continue;b&&(g.startPathPoint(A),b=!1),g.lineToPoint(T),S=!1}else g.addSegment(H,b),b=!1}if(b||!S)return;t.isClosedPath(m)?t.getPointByVal(t.getPathStart(m),A):t.getPointByVal(t.getPathEnd(m)-1,A);const X=g.querySegmentIterator();X.resetToLastPath(),X.resetToLastSegment();const k=g.getDescription().getAttributeCount()>1;for((0,F.g)(X.previousPath());X.hasPreviousSegment();){const H=X.previousSegment();if(H.isCurve()){const U=H.clone();if(U.setCoordsForIntersector(H.getStartXY(),A.getXY(),!1),!Gs.isShortSegment(U,d,C,u)){k&&U.setEnd(A);const Z=X.getEndPointIndex();for(let st=g.getPointCount()-1;st>=Z;st--)g.removePoint(st);return void g.addSegment(U,!1)}}else if(H.queryStart(T),!Gs.isShortSegmentPoints(T,A,d,C,u)){const U=X.getEndPointIndex();for(let Z=g.getPointCount()-1;Z>=U;Z--)g.removePoint(Z);return void g.lineToPoint(A)}}g.removePath(g.getPathCount()-1)}multipointIsSimpleAsFeature(){if(!this.checkStructure())return 0;const t=this.m_geometry.getImpl();this.m_multiVertexGeom=t;const m=t.getPointCount(),u=(0,Y.d)(m,0);for(let g=0;g<m;g++)u[g]=g;u.sort((g,d)=>this.compareVerticesMultiPoint(g,d));for(let g=1;g<m;g++)if(0===this.compareVerticesMultiPoint(u[g-1],u[g]))return this.m_nonSimpleResult=new Ee(5,u[g-1],u[g]),0;return 1}polylineIsSimpleAsFeature(){return this.checkStructure()&&this.checkDegenerateSegments(!0)?1:0}polygonIsSimpleAsFeature(){return this.isSimplePlanarImpl()}multipointSimplifyAsFeature(){let t=this.m_geometry.getImpl();const m=Gs.hasNanZs(t);let u,g=this.m_geometry;m&&(u=this.m_geometry.clone(),t=u.getImpl(),u.replaceNaNs(1,dt.V.getDefaultValue(1)),g=u),this.m_multiVertexGeom=t;const d=t.getPointCount(),y=(0,Y.d)(d,0);for(let M=0;M<d;M++)y[M]=M;y.sort((M,X)=>this.compareVerticesMultiPoint(M,X));const C=new Array(d);C.fill(!1);let S=-1;for(let M=0;M<d;M++){const X=y[M];t.getXY(X).isFinite()&&((S<0||0!==this.compareVerticesMultiPoint(S,X))&&(C[X]=!0),S=X)}const b=this.m_geometry.createInstance();let A=0,T=0;for(let M=0;M<d;M++)C[M]?T=M+1:(A<T&&b.addPoints(g,A,T),A=M+1);return A<T&&b.addPoints(g,A,T),b.getImpl().setIsSimple(1,this.m_toleranceSimplify.total()),b}polylineSimplifyAsFeature(){const t=this.m_geometry.getImpl(),m=t.querySegmentIterator(),u=t.querySegmentIterator(),g=this.m_geometry.createInstance(),d=this.m_geometry,y=t.hasAttribute(1),C=y?(0,dt.a3)(this.m_sr,t,!0).total():0,S=[],b=[];let A=null;y&&(A=t.getAttributeStreamRef(1));const T=new dt.P,M=t.hasNonLinearSegments(),X=this.m_toleranceSimplify.total();for(;m.nextPath();){if(u.nextPath(),t.getPathSize(m.getPathIndex())<2)continue;if(M&&t.hasNonLinearSegmentsPath(m.getPathIndex())){this.removeDegenerateSegmentsFromCurvedPath(t,m.getPathIndex(),C,g);continue}u.resetToLastSegment();let k=0,H=0,U=!0,Z=!0;for(;m.hasNextSegment();){this.progress_();const st=m.nextSegment(),mt=u.previousSegment();if(m.getStartPointIndex()>u.getStartPointIndex())break;if(U){const ht=m.getStartPointIndex();t.getXY(ht).isNAN()||(U=!1,S.push(ht))}if(Z){const ht=u.getEndPointIndex();t.getXY(ht).isNAN()||(b.push(ht),Z=!1)}if(!U){const ht=S.at(-1),ut=m.getEndPointIndex();if(ut-ht>1){const ct=new Y.P;ct.setSub(t.getXY(ht),t.getXY(ut)),k=ct.length()}else k=st.calculateLength2D();if(k>X)S.push(ut),k=0;else if(y){let ct=A.read(ht);Number.isNaN(ct)&&(ct=0);let Et=A.read(ut);Number.isNaN(Et)&&(Et=0),Math.abs(Et-ct)>C&&(S.push(ut),k=0)}}if(!Z){const ht=b.at(-1),ut=u.getStartPointIndex();if(ut-ht>1){const ct=new Y.P;ct.setSub(t.getXY(ht),t.getXY(ut)),H=ct.length()}else H=mt.calculateLength2D();if(H>X)b.push(ut),H=0;else if(y){let ct=A.read(ht);Number.isNaN(ct)&&(ct=0);let Et=A.read(ut);Number.isNaN(Et)&&(Et=0),Math.abs(Et-ct)>C&&(b.push(ut),H=0)}}}if(S.length>0&&b.length>0&&(S.at(-1)<b.at(-1)?S.length>b.length?S.pop():b.pop():(S.at(-1)===b.at(-1)||b.pop(),b.pop())),b.length+S.length>=2){let st=!1;for(let mt=0,ht=S.length;mt<ht;mt++)d.getPointByVal(S[mt],T),st?g.lineToPoint(T):(g.startPathPoint(T),st=!0);for(let mt=b.length-1;mt>0;mt--)d.getPointByVal(b[mt],T),st?g.lineToPoint(T):(g.startPathPoint(T),st=!0);d.isClosedPath(m.getPathIndex())?g.closePathWithLine():b.length>0&&(d.getPointByVal(b[0],T),g.lineToPoint(T))}S.length=0,b.length=0}return y&&g.replaceNaNs(1,0),g.getImpl().setIsSimple(1,X),g}polygonSimplifyAsFeature(){return this.simplifyPlanar()}simplifyPlanar(){if(1===this.m_geometry.getFillRule()&&!(0,dt.M)(this.m_knownSimpleResult))return Un(this.m_geometry,this.m_toleranceSimplify,!0,!1,this.m_knownSimpleResult,this.m_progressTracker,0,!0);const t=new c.E;if(t.addGeometry(this.m_geometry),this.m_geometry.hasAttribute(1)&&t.replaceNaNs(1,0),t.removeNaNVertices(),0!==t.getTotalPointCount()){let u=null,g=0,d=0;if(t.hasCurves()){u=new ci;const y=R.J.constructEmpty();this.m_geometry.queryEnvelope(y);const C=oi(this.m_toleranceSimplify.total(),y);g=Ai(this.m_toleranceSimplify.total()),d=xi(C,g),ri(t,C,this.m_toleranceSimplify.total(),0,u,null,this.m_progressTracker)}(0,dt.M)(this.m_knownSimpleResult)||qi(t,this.m_toleranceSimplify.add(d),this.m_progressTracker,!0,!1),this.m_geometry.getGeometryType()===F.G.enumPolygon&&ui(t,t.getFirstGeometry(),this.m_knownSimpleResult,!1,-1,this.m_progressTracker),null!==u&&u.stitchCurves(t,t.getFirstGeometry(),g,!0)}const m=t.getGeometry(t.getFirstGeometry());return m.getGeometryType()===F.G.enumPolygon&&(m.getImpl().updateOGCFlagsProtected(),m.setFillRule(0)),m.getImpl().setIsSimple(4,this.m_toleranceSimplify.total()),m}progress_(){}static hasNanZs(t){if(t.hasAttribute(1)){const m=t.getAttributeStreamRef(1);for(let u=0,g=t.getPointCount();u<g;u++){const d=m.read(u);if(Number.isNaN(d))return!0}}return!1}compareVerticesForPlanarClustering(t,m,u){if(t===m)return 0;const g=this.m_pairs[t],d=this.m_pairs[m],y=g>>1,C=d>>1,S=this.m_xy.readPoint2D(2*y);S.y+=1&g?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const b=this.m_xy.readPoint2D(2*C);b.y+=1&d?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const A=S.compare(b);return 0===A&&u?(0,Y.e)(this.m_pathsForOGCTests[y]-this.m_pathsForOGCTests[C]):A}compareVerticesMultiPoint(t,m){if(t===m)return 0;const u=this.m_multiVertexGeom.getXY(t),g=this.m_multiVertexGeom.getXY(m),d=!u.isFinite(),y=!g.isFinite();if(d||y)return d<y?-1:d>y?1:0;if(u.y<g.y)return-1;if(u.y>g.y)return 1;if(u.x<g.x)return-1;if(u.x>g.x)return 1;for(let C=1;C<this.m_attributeCount;C++){const S=this.m_description.getSemantics(C),b=dt.V.getComponentCount(S);for(let A=0;A<b;A++){const T=this.m_multiVertexGeom.getAttributeAsDbl(S,t,A),M=this.m_multiVertexGeom.getAttributeAsDbl(S,m,A),X=(0,Y.r)(T,M);if(0!==X)return X}}return 0}edgeAngleCompare(t,m){if(t===m)return 0;const u=t.m_segment.getTangent(t.getReversed()?1:0);t.getReversed()&&u.negateThis();const g=m.m_segment.getTangent(m.getReversed()?1:0);m.getReversed()&&g.negateThis();const d=u.getQuarter(),y=g.getQuarter();if(y===d){const C=u.crossProduct(g);return C<0?1:C>0?-1:0}return d<y?-1:1}}class Vi{getOperatorType(){return 10103}accelerateGeometry(t,m,u){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}isSimpleAsFeature(t,m,u,g,d){const y=na(t,m,u,g,d);return(0,dt.R)(t.getGeometryType(),y)}isSimplePlanarDONOTUSE(t,m,u,g,d){const y=function wl(P,t,m,u,g){if(u&&(u.m_reason=0,u.m_vertexIndex1=-1,u.m_vertexIndex2=-1),P.isEmpty())return 5;const d=P.getGeometryType();if(d===F.G.enumPoint)return En(P,u);const y=(0,dt.b)(t,P,!1).total();if(d===F.G.enumEnvelope){const T=P,M=new R.J;return T.queryEnvelope(M),M.isDegenerate(y)?(u&&(u.m_reason=4,u.m_vertexIndex1=-1,u.m_vertexIndex2=-1),0):5}if((0,F.f)(d)){const T=P,M=new c.P({vd:T.getDescription()});return M.addSegment(T,!0),na(M,t,m,u,g)}const S=P.getImpl().getIsSimple(y,[0]);let b=m?-1:S;if((0,dt.i)(b)||0===b)return b;const A=new Gs(P,t,b,g,!1);return d===F.G.enumMultiPoint||d===F.G.enumPolyline||d===F.G.enumPolygon?b=A.isSimplePlanarImpl():(0,F.c)(""),P.getImpl().setIsSimple(b,y),u&&u.assign(A.m_nonSimpleResult),b}(t,m,u,g,d);return(0,dt.i)(y)}executeMany(t,m,u,g){return new Fl(t,m,u,g)}execute(t,m,u,g){const d=new ee.S([t]),y=this.executeMany(d,m,u,g).next();return y||(0,F.c)("null geometry"),y}}class Fl extends ee.G{constructor(t,m,u,g){super(),this.m_progressTracker=g,this.m_bForceSimplify=u,this.m_index=-1,this.m_inputGeometryCursor=t,this.m_spatialReference=m}next(){const t=this.m_inputGeometryCursor.next();return t?(this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(t)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(t){if(t||(0,F.t)(""),t.getGeometryType()===F.G.enumGeometryCollection){const m=(0,c.g)(t,-1),u=(new Vi).executeMany(m,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker),g=t.createInstance();for(let d=u.next();null!=d;d=u.next())g.addGeometry(d);return g}return ra(t,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}class gi{constructor(t,m,u,g){this.m_intersectorGeom=null,this.m_sr=null,this.m_dimensionMask=-1,this.m_progressTracker=null,this.m_intersectorGeomType=F.G.enumUnknown,this.m_geomIntersectorEmptyGeom=null,this.m_intersectorGeom=t,this.m_sr=m,this.m_dimensionMask=u,this.m_progressTracker=g,this.m_intersectorGeomType=t.getGeometryType()}intersect(t){const m=this.tryFastImplementation(t);if(null!==m)return m;const u=(0,dt.g)(this.m_intersectorGeom,t),g=(0,dt.a)(this.m_sr,u,!0).total(),d=R.J.constructEmpty();this.m_intersectorGeom.queryEnvelope(d);const y=R.J.constructEmpty();t.queryEnvelope(y),d.inflateCoords(2*g,2*g),d.intersect(y),d.inflateCoords(100*g,100*g);let S=(0,Rt.c)(this.m_intersectorGeom,d,0,0,this.m_progressTracker),b=(0,Rt.c)(t,d,0,0,this.m_progressTracker);return t.getDimension()>this.m_intersectorGeom.getDimension()&&(S=(0,Y.b)(b,b=S)),function ea(P,t,m,u){const g=R.J.constructEmpty();P.queryEnvelope(g);const d=R.J.constructEmpty();t.queryEnvelope(d);const y=R.J.constructEmpty();y.setCoords({env2D:g}),y.mergeEnvelope2D(d);const C=(0,dt.a)(m,y,!0),S=new R.J(d),b=(0,dt.d)(C);if(S.inflateCoords(b,b),!g.isIntersecting(S)){if(P.getDimension()<=t.getDimension())return hi(us(P.createInstance()),P,0,"&");if(P.getDimension()>t.getDimension())return hi(us(t.createInstance()),P,0,"&")}const A=new ai(u),T=new c.E,M=T.addGeometry(us(P)),X=T.addGeometry(us(t));let k=0,H=0,U=null;if(T.hasCurves()){U=new ci;const mt=T.getEnvelope2D(u);H=Ai(C.total());const ht=oi(C.total(),mt);k=xi(ht,H),ri(T,ht,C.total(),0,U,null,u)}A.setEditShapeCrackAndCluster(T,C.add(k));const Z=A.intersection(M,X);null!==U&&U.stitchCurves(T,Z,H,!0);const st=hi(T.getGeometry(Z),P,0,"&");return uo(st.getGeometryType())&&(st.getImpl().setIsSimple(4,C.total()),st.getGeometryType()===F.G.enumPolygon&&st.getImpl().updateOGCFlagsProtected()),st}(b,S,this.m_sr,this.m_progressTracker)}intersectEx(t){const m=this.tryFastImplementation(t);if(null!==m){const T=[];return T.length=3,T[m.getDimension()]=m,this.prepareVector(t.getDescription(),this.m_dimensionMask,T)}const u=(0,dt.g)(this.m_intersectorGeom,t),g=(0,dt.a)(this.m_sr,u,!0).total(),d=R.J.constructEmpty();this.m_intersectorGeom.queryEnvelope(d);const y=R.J.constructEmpty();t.queryEnvelope(y),d.inflateCoords(2*g,2*g),d.intersect(y),d.inflateCoords(100*g,100*g);let S=(0,Rt.c)(this.m_intersectorGeom,d,0,0,this.m_progressTracker),b=(0,Rt.c)(t,d,0,0,this.m_progressTracker);t.getDimension()>this.m_intersectorGeom.getDimension()&&(S=(0,Y.b)(b,b=S));const A=function sa(P,t,m,u){const g=new Array(3),d=R.J.constructEmpty();P.queryEnvelope(d);const y=R.J.constructEmpty();t.queryEnvelope(y);const C=R.J.constructEmpty();C.setCoords({env2D:d}),C.mergeEnvelope2D(y);const S=(0,dt.a)(m,C,!0),b=new R.J(y),A=(0,dt.d)(S);if(b.inflateCoords(A,A),!d.isIntersecting(b)){if(P.getDimension()<=t.getDimension()){const mt=hi(us(P.createInstance()),P,0,"&");return g[mt.getDimension()]=mt,g}if(P.getDimension()>t.getDimension()){const mt=hi(us(t.createInstance()),P,0,"&");return g[mt.getDimension()]=mt,g}}const T=new ai(u),M=new c.E,X=M.addGeometry(us(P)),k=M.addGeometry(us(t));let H=0,U=0,Z=null;if(M.hasCurves()){Z=new ci;const mt=M.getEnvelope2D(u);U=Ai(S.total());const ht=oi(S.total(),mt);H=xi(ht,U),ri(M,ht,S.total(),0,Z,null,u)}T.setEditShapeCrackAndCluster(M,S.add(H)),M.dbgVerifyCurves();const st=T.intersectionEx(X,k);for(const mt of st){null!==Z&&Z.stitchCurves(M,mt,U,!1);const ht=hi(M.getGeometry(mt),P,0,"&");uo(ht.getGeometryType())&&(ht.getImpl().setIsSimple(4,S.total()),ht.getGeometryType()===F.G.enumPolygon&&ht.getImpl().updateOGCFlagsProtected()),g[ht.getDimension()]=ht}return null!==Z&&Z.clearStitcher(M),g}(b,S,this.m_sr,this.m_progressTracker);return this.prepareVector(t.getDescription(),this.m_dimensionMask,A)}init(t,m,u,g=null){(0,F.g)(0)}static intersectPoints(t,m,u){const g=(0,dt.g)(t,m);return function Ar(P,t,m){return P.isEmpty()||t.isEmpty()?P.createInstance():function Pl(P,t,m){const u=(0,dt.d)(P);return rn(t.getX(),t.getY(),m.getX(),m.getY(),(0,Y.s)(u))}(m,P,t)?new dt.P({copy:Xh(P,t)}):P.createInstance()}(t,m,(0,dt.a)(u,g,!0))}tryFastImplementation(t){const m=t.getGeometryType();if(this.m_intersectorGeomType===F.G.enumPoint&&m===F.G.enumPoint){const S=gi.intersectPoints(t,this.m_intersectorGeom,this.m_sr);if(-1!==this.m_dimensionMask){const b=new c.M({vd:S.getDescription()});return S.isEmpty()||b.add(S),b}return S}if(m===F.G.enumEnvelope&&this.m_intersectorGeomType===F.G.enumEnvelope&&(-1===this.m_dimensionMask||4===this.m_dimensionMask)){const b=this.m_intersectorGeom,A=new dt.E({copy:t});return A.intersect(b),A}const u=(0,dt.g)(t,this.m_intersectorGeom),g=(0,dt.a)(this.m_sr,u,!0),d=t.isEmpty(),y=this.m_intersectorGeom.isEmpty();let C=d||y;if(!C){const S=function Yi(P,t,m){const u=new R.J;P.queryEnvelope(u);const g=new R.J;t.queryEnvelope(g);const d=new R.J(g);if(d.inflate(2*m),!d.isIntersecting(u))return 4;const y=P.getGeometryType(),C=t.getGeometryType();if(y===F.G.enumEnvelope&&u.containsEnvelope(d))return 1;if(C===F.G.enumEnvelope){const S=new R.J(u);if(S.inflate(2*m),g.containsEnvelope(S))return 2}return 0}(this.m_intersectorGeom,t,g.total());if(4===S)C=!0;else{if(2&S)return this.m_intersectorGeom;if(1&S)return t}}if(C){const S=(0,F.A)(m),b=(0,F.A)(this.m_intersectorGeomType);return S<b?gi.ReturnEmpty(t,d):S>b||0===S&&m===F.G.enumMultiPoint&&this.m_intersectorGeomType===F.G.enumPoint?this.ReturnEmptyIntersector():gi.ReturnEmpty(t,d)}if(m===F.G.enumEnvelope&&0===(0,F.A)(this.m_intersectorGeomType)||this.m_intersectorGeomType===F.G.enumEnvelope&&0===(0,F.A)(m)){const S=m===F.G.enumEnvelope?t:this.m_intersectorGeom,b=m===F.G.enumEnvelope?this.m_intersectorGeom:t,A=R.J.constructEmpty();return S.queryEnvelope(A),(0,Rt.c)(b,A,g.total(),0,this.m_progressTracker)}if(0===(0,F.A)(m)&&(0,F.A)(this.m_intersectorGeomType)>0||(0,F.A)(m)>0&&0===(0,F.A)(this.m_intersectorGeomType)){if(m===F.G.enumMultiPoint)return $o(t,this.m_intersectorGeom,g);if(m===F.G.enumPoint)return ta(t,this.m_intersectorGeom,g);if(this.m_intersectorGeomType===F.G.enumMultiPoint)return $o(this.m_intersectorGeom,t,g);if(this.m_intersectorGeomType===F.G.enumPoint)return ta(this.m_intersectorGeom,t,g);(0,F.c)("")}return null}ReturnEmptyIntersector(){return null===this.m_geomIntersectorEmptyGeom&&(this.m_geomIntersectorEmptyGeom=this.m_intersectorGeom.createInstance()),this.m_geomIntersectorEmptyGeom}static ReturnEmpty(t,m){return m?t:t.createInstance()}prepareVector(t,m,u){let g=0;return 1&m?(u[0]||(u[0]=new c.M({vd:t})),g++):u.shift(),2&m?(u[g]||(u[g]=new c.P({vd:t})),g++):u.splice(g,1),4&m?u[g]||(u[g]=new c.a({vd:t})):u.splice(g,1),new ee.S(u)}}class jh extends ee.G{constructor(t,m,u,g,d){super(),this.m_smallCursor=null,this.m_progressTracker=g,this.m_geomIntersector=m.next(),this.m_intersector=new gi(this.m_geomIntersector,u,d,g),this.m_index=-1,this.m_inputGeoms=t,this.m_dimensionMask=d,-1!==this.m_dimensionMask&&(this.m_dimensionMask<=0||this.m_dimensionMask>7)&&(0,F.t)("bad dimension mask")}next(){if(!this.m_geomIntersector)return null;let t;if(null!==this.m_smallCursor){if(t=this.m_smallCursor.next(),t)return t;this.m_smallCursor=null}for(;t=this.m_inputGeoms.next();)return(0,F.d)(t),this.m_index=this.m_inputGeoms.getGeometryID(),-1===this.m_dimensionMask?this.m_intersector.intersect(t):(this.m_smallCursor=this.m_intersector.intersectEx(t),this.m_smallCursor.next());return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class mi{getOperatorType(){return 1e4}accelerateGeometry(t,m,u){if(!this.canAccelerateGeometry(t))return!1;(0,dt.b)(m,t,!0);let g=0;return t.getGeometryType()!==F.G.enumPolygon&&t.getGeometryType()!==F.G.enumPolyline||!(0,c.U)(t)||0===u||(g|=t.getImpl().buildQuadTreeAccelerator(u)?1:0),!!g}canAccelerateGeometry(t){return(0,c.U)(t)}supportsCurves(){return!0}executeMany(t,m,u,g,d=-1){return new jh(t,m,u,g,d)}execute(t,m,u,g){if(t.getGeometryType()===F.G.enumPoint&&m.getGeometryType()===F.G.enumPoint)return gi.intersectPoints(t,m,u);const d=new ee.S([t]),y=new ee.S([m]),C=this.executeMany(d,y,u,g,-1).next();return C||(0,F.c)("null output"),C}}function ha(P,t,m){return t.m_projector.project(P,m)}function ma(P,t,m,u,g){return P.m_projector.transformInPlaceZ(t,null,m,u,null,g)}function la(P,t,m,u){if(P&&t&&t.isPannable()||(0,F.t)("fold_into_360_range_geodetic"),P.isEmpty())return P;if(4===m)return Mr(P,t,u);let g=P;const d=g.getGeometryType();if((0,F.h)(d)){g=Fs(P,t);const y=new R.J;g.queryEnvelope(y);const C=(0,dt.a)(t,y,!1).total(),S=t.getPannableExtent();let b=Math.floor((y.xmin-S.xmin)/S.width())*S.width()+S.xmin,A=g;for(;b<y.xmax;)b>y.xmin+C&&b<y.xmax-C&&(A=Kn(A,t,m,!0,b)),b+=S.width();g=A}else{if(d===F.G.enumEnvelope){const y=new c.a({vd:g.getDescription()});return y.addEnvelope(g,!1),la(y,t,m,u)}if((0,F.f)(d)){const y=new c.P({vd:g.getDescription()});return y.addSegment(g,!0),la(y,t,m,u)}}return Mr(g,t,u)}function Mr(P,t,m){if(P&&t&&t.isPannable()||(0,F.t)(""),P.isEmpty())return P;let u;const g=P.getGeometryType();if(g===F.G.enumEnvelope){const y=new c.a({vd:P.getDescription()});y.addEnvelope(P,!1),u=y}else if((0,F.f)(g)){const y=new c.P({vd:P.getDescription()});y.addSegment(P,!0),u=y}else u=P;const d=Fs(u,t);return d.isEmpty()?d:Qn(d,t,0,d!==P,0,m)}function ua(P,t,m,u){const g=t.getXYGridRange(),d=P.hasAttribute(1),y=P.hasAttribute(2);let C=new Y.E,S=new Y.E;d&&(C=t.getZGridRange()),y&&(S=t.getMGridRange());let b=(new Rt.O).execute(P,g,m,u);if(d){const A=b.queryInterval(1,0);C.contains(A)||(P===b&&(b=b.clone()),(0,dt.U)(b,C,1,0))}if(y){const A=b.queryInterval(2,0);S.contains(A)||(P===b&&(b=b.clone()),(0,dt.U)(b,S,2,0))}return b}class ql{constructor(t){this.m_inputPCSHorizonClipOption=0,this.m_outputPCSHorizonClipOption=0,this.m_bDontGeonormalizePolygon=!1,this.m_bClipOutCurvedPoles=!1,this.m_bNormalizeOutputGeometry=!1,this.m_bDontHackPolesInGeogToGeog=!1,this.m_centralMeridianOfOutputGCS=0,this.m_densificationStepInput=0,t||(0,F.t)(""),this.m_projTransform=t,this.m_bClipOutCurvedPoles=!1;const m=this.m_projTransform.getExtendedParamsImpl();this.m_bNormalizeOutputGeometry=m.normalizeResultGeometry,this.m_bNormalizeOutputGeometry&&(m.legacyHorizonClipping?this.m_bNormalizeOutputGeometry=!1:this.m_projTransform.getOutputSR().isPannable()||(this.m_bNormalizeOutputGeometry=!1)),m.clipWithInputHorizon?(this.m_inputPCSHorizonClipOption=0,!m.legacyHorizonClipping&&this.m_projTransform.getInputSR().isPannable()&&(this.m_inputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_inputPCSHorizonClipOption=1,m.clipWithOutputHorizon?(this.m_outputPCSHorizonClipOption=0,!m.legacyHorizonClipping&&this.m_projTransform.getOutputSR().isPannable()&&(this.m_outputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_outputPCSHorizonClipOption=1,this.m_centralMeridianOfOutputGCS=m.centralMeridianOfOutputGCS,this.m_densificationStepInput=m.densificationStep;const u=this.m_projTransform.getExtendedParamsInternal();this.m_bDontGeonormalizePolygon=u.hasFlag(2147483648),this.m_bDontHackPolesInGeogToGeog=u.hasFlag(1073741824),this.m_bClipOutCurvedPoles=u.hasFlag(536870912)}project(t,m){if(this.m_projTransform.isIdentity()||t.isEmpty())return t;const u=t.getGeometryType();if(u===F.G.enumPoint)return this.projectPoint(t,m);const g=this.m_projTransform.getInputSR().getCoordinateSystemType(),d=this.m_projTransform.getOutputSR().getCoordinateSystemType(),y=this.m_projTransform.getInputSR(),C=this.m_projTransform.getOutputSR();if(0===g&&g===d){const S=Pi(y,C),b=t.clone();return b.applyTransformation(S),b}switch(u){case F.G.enumPolyline:case F.G.enumPolygon:return this.projectMultiPath(t,m);case F.G.enumMultiPoint:return this.projectMultiPoint(t,m);case F.G.enumEnvelope:return this.projectEnvelope(t,m);case F.G.enumGeometryCollection:return this.projectGeometryCollection(t,m);default:(0,F.c)("")}}projectPoint(t,m){const u=[t.getXY()];let g,d=null;(g=t.hasAttribute(1))&&(d=[t.getZ()]),this.transformInPlaceZ(u,d,1,u,d,null);const y=t.clone();return y.setXY(u[0]),g&&y.setZ(d[0]),y}projectMultiPoint(t,m){let u=new c.M({copy:t});const g=this.m_projTransform.getInputSR(),d=this.m_projTransform.getOutputSR(),y=g.getCoordinateSystemType(),C=d.getCoordinateSystemType();if(3===y&&(0,F.g)(0),u=Dn(u,g,this.m_inputPCSHorizonClipOption,m),u.isEmpty())return u;2===y&&E(g,0,u),K(this.m_projTransform,u,!1);let S=0;3===C&&(0,F.g)(0);const b=2===C;return b?S=d.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(S=this.m_centralMeridianOfOutputGCS),b&&0!==this.m_outputPCSHorizonClipOption||(u=Qn(u,Tm(d),S,!1,0,m)),b&&(u=Na(u,d,this.m_outputPCSHorizonClipOption,m),l(d,u,this.m_bNormalizeOutputGeometry),u.isEmpty()),u}projectMultiPath(t,m){const u=t.getGeometryType();return u===F.G.enumPolygon?this.projectPolygon(t,m):u===F.G.enumPolyline?this.projectPolyline(t,m):void(0,F.c)("project_multi_path_")}projectEnvelope(t,m){this.m_projTransform.getInputSR(),this.m_projTransform.getOutputSR();const u=this.m_projTransform.isVertical()&&t.hasAttribute(1);let g=Y.E.constructEmpty();if(u&&(g=t.queryInterval(1,0)),g.width()>0){const d=t.clone();d.setInterval(1,0,g.vmin,g.vmin);const y=this.projectEnvelopeHelper(d,m);d.setInterval(1,0,g.vmax,g.vmax);const C=this.projectEnvelopeHelper(d,m);return y.merge(C),y}return this.projectEnvelopeHelper(t,m)}projectPolygon(t,m){(0,F.g)(t.getGeometryType()===F.G.enumPolygon),(0,F.g)(!this.m_projTransform.isIdentity()),(0,F.g)(!t.isEmpty());const u=this.m_projTransform.getInputSR(),g=this.m_projTransform.getOutputSR(),d=u.getCoordinateSystemType(),y=g.getCoordinateSystemType(),C=new c.a({copy:t});3===d&&(0,F.g)(0),3===y&&(0,F.g)(0);const S=2===d,b=2===y,A=S?u.getGCS():u,T=b?g.getGCS():g,M=!b&&!this.m_bDontHackPolesInGeogToGeog;let X=!1,k=Dn(C,u,this.m_inputPCSHorizonClipOption,m);if(k.isEmpty())return k;let H=this.m_densificationStepInput;const U=!Number.isNaN(H);let Z;U&&(k=(new Se.O).execute(k,H,0,0,m));let st=b?g.getPCSInfo():null,mt=Number.NaN;S&&(mt=u.getCentralMeridian());const ht=null!==g.getGCSSplitLines();if(this.m_bDontGeonormalizePolygon){const ut=k;if(S&&(j(u,mt,ut),U)){const ct=u.getUnitsPerMillimeter();H*=u.getGCS().getUnitsPerMillimeter()/ct}if(ot(this.m_projTransform,ut,M),U){const ct=u.getGCS().getUnitsPerMillimeter();H*=g.getGCS().getUnitsPerMillimeter()/ct}Z=ut}else{let ut=new c.P({vd:k.getDescription()});if(ut.addAndExplicitlyOpenAllPaths(k,!1),S){if(j(u,mt,ut),U){const Pt=u.getUnitsPerMillimeter();H*=u.getGCS().getUnitsPerMillimeter()/Pt}if(this.m_bClipOutCurvedPoles){const Pt=u.getPCSInfo(),At=Pt.getSouthPoleGeometry()===zs.PE_POLE_LINE_CURVED,Ht=Pt.getNorthPoleGeometry()===zs.PE_POLE_LINE_CURVED;if(At||Ht){const Bt=R.J.constructEmpty();ut.queryLooseEnvelope(Bt),Bt.inflateCoords(1,1);const kt=89.9999*A.getOneDegreeGCSUnit();At&&(Bt.ymin=-kt),Ht&&(Bt.ymax=kt),ut=(0,Rt.a)(ut,Bt,A,0,0,m)}}}if(ot(this.m_projTransform,ut,M),U){const Pt=Tm(u).getUnitsPerMillimeter();H*=Tm(g).getUnitsPerMillimeter()/Pt}let ct=Number.NaN;b?(st=g.getPCSInfo(),ct=g.getCentralMeridian()):Number.isNaN(this.m_centralMeridianOfOutputGCS)||(ct=this.m_centralMeridianOfOutputGCS);let Et=un(u)|un(g),Tt=10*T.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(Et=3,Tt=10*T.getTolerance(0)),Z=function Ma(P,t,m,u,g,d,y,C,S){return new fo(P,null,m,t,u,g,y,C,d).geoNormalizePolygonGeometry(S)}(k,u,ut,T,ct,m,Et,Tt,this.m_bNormalizeOutputGeometry),Et=0}if(ht&&((0,F.g)(!g.isPannable()),Z=cs(Z,g,m)),b){if(!X){const ut=T.getPannableExtent().width();if(Z.queryInterval(0,0).width()>=ut-10*T.getTolerance(0)){const ct=st.getNorthPoleLocation(),Et=st.getSouthPoleLocation(),Tt=st.getNorthPoleGeometry(),Pt=st.getSouthPoleGeometry();let At=0;Tt===zs.PE_POLE_POINT&&ct!==zs.PE_POLE_OUTSIDE_BOUNDARY&&(At=1),Pt===zs.PE_POLE_POINT&&Et!==zs.PE_POLE_OUTSIDE_BOUNDARY&&(At|=2),X||=0!==At}}Z=Na(Z,g,this.m_outputPCSHorizonClipOption,m),U&&(Z=(new Se.O).execute(Z,H,0,0,m)),x(g,Z,this.m_bNormalizeOutputGeometry)}return Z.isEmpty()||X&&(Z=(new Vi).execute(Z,g,!1,m)),Z}projectPolyline(t,m){(0,F.g)(t.getGeometryType()===F.G.enumPolyline),(0,F.g)(!this.m_projTransform.isIdentity()),(0,F.g)(!t.isEmpty());const u=this.m_projTransform.getInputSR(),g=this.m_projTransform.getOutputSR(),d=u.getCoordinateSystemType(),y=g.getCoordinateSystemType(),C=new c.P({copy:t});3===d&&(0,F.g)(0),3===y&&(0,F.g)(0);const S=2===d,b=2===y;S&&u.getGCS();const A=b?g.getGCS():g,T=!b&&!this.m_bDontHackPolesInGeogToGeog;let M=Dn(C,u,this.m_inputPCSHorizonClipOption,m);if(M.isEmpty())return M;let X=Number.NaN;S&&(X=u.getCentralMeridian());const k=null!==g.getGCSSplitLines();let H=this.m_densificationStepInput;const U=!Number.isNaN(H);let Z;if(U&&(M=(new Se.O).execute(M,H,0,0,m)),this.m_bDontGeonormalizePolygon){if(S&&(j(u,X,M),U)){const st=u.getUnitsPerMillimeter();H*=u.getGCS().getUnitsPerMillimeter()/st}if(ot(this.m_projTransform,M,T),U){const st=u.getGCS().getUnitsPerMillimeter();H*=g.getGCS().getUnitsPerMillimeter()/st}Z=M}else{const st=new c.P({vd:M.getDescription()});if(st.addAndExplicitlyOpenAllPaths(M,!1),S&&(j(u,X,st),U)){const ct=u.getUnitsPerMillimeter();H*=u.getGCS().getUnitsPerMillimeter()/ct}if(ot(this.m_projTransform,st,T),U){const ct=u.getGCS().getUnitsPerMillimeter();H*=g.getGCS().getUnitsPerMillimeter()/ct}let mt=Number.NaN;b?mt=g.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(mt=this.m_centralMeridianOfOutputGCS);let ht=un(u)|un(g),ut=10*A.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(ht=3,ut=0),Z=function $l(P,t,m,u,g,d,y,C,S){return new fo(P,null,m,t,u,g,y,C,d).geoNormalizePolylineGeometry(S)}(M,u,st,A,mt,m,ht,ut,this.m_bNormalizeOutputGeometry),ht=0}return k&&((0,F.g)(!g.isPannable()),Z=cs(Z,g,m)),b&&(Z=Na(Z,g,this.m_outputPCSHorizonClipOption,m),U&&(Z=(new Se.O).execute(Z,H,0,0,m)),x(g,Z,this.m_bNormalizeOutputGeometry)),Z.isEmpty(),Z}projectGeometryCollection(t,m){return(0,F.g)(0),{}}projectEnvelopeHelper(t,m){const u=(t.height()+t.width())/400;if(0!==u){const g=(new Se.O).execute(t,u,0,0,m),d=this.projectMultiPath(g,m),y=new dt.E({vd:t.getDescription()});if(d.isEmpty()){const C=Math.min(t.height(),t.width()),S=(0,dt.b)(this.m_projTransform.getInputSR(),t,!0).total();if(C>100*S){const k=R.J.constructEmpty(),H=(0,dt.a)(this.m_projTransform.getOutputSR(),k,!0).total(),U=this.m_projTransform.getInputSR().getOneMeter()/this.m_projTransform.getOutputSR().getOneMeter();if(C>100*Math.max(S,H*U))return y}const b=new c.P;b.addAndExplicitlyOpenAllPaths(g,!1),this.projectMultiPath(b,m).queryEnvelope(y);const A=new c.M({vd:t.getDescription()});A.reserve(4);const T=new dt.P;for(let k=0;k<4;k++)t.queryCornerByVal(k,T),A.add(T);const M=this.projectMultiPoint(A,m),X=new dt.E;return M.queryEnvelope(X),y.merge(X),y}return d.queryEnvelope(y),y}{const g=t.getCenterXY(),d=new dt.P(g),y=this.projectPoint(d,m),C=new dt.E({vd:t.getDescription()});if(y.isEmpty())C.setEmpty();else{t.copyTo(C);const S=y.getXY();C.setCoords(S.x,S.y,S.x,S.y)}return C}}transformInPlace(t,m,u,g){return(0,F.g)(0),0}transformInPlaceZ(t,m,u,g,d,y){if(this.m_projTransform.isIdentity())return t!==g&&(0,Y.au)(g,t,u),m!==d&&(0,Y.a)(d,m,0,0,u),u;const C=this.m_projTransform,S=C.getInputSR(),b=C.getOutputSR(),A=S.getCoordinateSystemType(),T=b.getCoordinateSystemType();if(0===A&&A===T)return Pi(S,b).transformPoints2D(t,u,g),C.isVertical()&&(0,F.g)(0),u;3===A&&(0,F.b)("image: transform_in_place_"),3===T&&(0,F.b)("image: transform_in_place_"),function ke(P,t,m,u,g,d){const y=u.getCoordinateSystemType();if(2===y){if(0===g)m!==P&&(0,Y.au)(m,P,t),function Cm(P,t,m){const u=P.getPCSHorizon();if(u.getGeometryType()!==F.G.enumPolygon)if(u.getGeometryType()!==F.G.enumEnvelope)(0,F.t)("");else{const g=u;for(let d=0;d<m;d++)g.contains(t[d])||t[d].setNAN()}else{const g=P.getDefaultPrecisionSR().getTolerance(0),d=u;for(let y=0;y<m;y++)1!==ti(d,t[y],g)&&t[y].setNAN()}}(u,m,t);else if(m!==P&&(0,Y.au)(m,P,t),u.isPannable()){const C=u.getTolerance(0);(function Ql(P,t,m,u){for(let g=0;g<t;g++)P[g].y<m.ymin||P[g].y>m.ymax?P[g].setNAN():P[g].x=In(P[g].x,m,u)})(m,t,u.getPannableExtent(),C),nn(m,t,u,0)}}else{(0,F.g)(1===y);const C=u.getTolerance(0),S=u.getPannableExtent();for(let b=0;b<t;b++)m[b].assign(tu(P[b],S,C))}}(t,u,g,S,this.m_inputPCSHorizonClipOption),d!==m&&(0,Y.a)(d,m,0,0,u),2===A&&Q(S,0,g,u),gt(this.m_projTransform,g,d,u,!1);let M=0;const X=2===T;if(X?M=b.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(M=this.m_centralMeridianOfOutputGCS),X&&0!==this.m_outputPCSHorizonClipOption||nn(g,u,b.getGCS(),M),X){if(!Fa(g,u,b,this.m_outputPCSHorizonClipOption))for(let H=0;H<u;++H)g[H].setNAN();f(b,g,u,!1)}let k=u;for(let H=0;H<u;++H)g[H].isNAN()&&(d&&(d[H]=Number.NaN),k--);return k}}function un(P){if(2!==P.getCoordinateSystemType())return 0;let t=0;const m=P.getPCSInfo(),u=m.getNorthPoleLocation(),g=m.getSouthPoleLocation(),d=m.getNorthPoleGeometry(),y=m.getSouthPoleGeometry();return d===zs.PE_POLE_POINT&&u!==zs.PE_POLE_OUTSIDE_BOUNDARY&&(t=1),y===zs.PE_POLE_POINT&&g!==zs.PE_POLE_OUTSIDE_BOUNDARY&&(t|=2),t}function Pi(P,t){const m=P.getHorzUnitFactor(),u=t.getHorzUnitFactor();let g=1,d=1;const y=20015077/180;1===P.getUnit().getUnitType()&&(g=y),1===t.getUnit().getUnitType()&&(d=y);const C=m/u*(g!==d?g/d:1),S=new Wt.T;return S.setScaleCoords(C,C),S}let Ji=class{getOperatorType(){return 10300}supportsCurves(){return!0}accelerateGeometry(P,t,m){return!1}canAccelerateGeometry(P){return!1}executeMany(P,t,m){return!t||t.isIdentity()?P:new Vl(P,t,m)}execute(P,t,m){return t.isIdentity()?P:ha(P,t,m)}transform(P,t,m,u,g=!0){return g?function Ml(P,t,m,u,g){P.m_projector.transformInPlaceZ(t,null,m,u,null,g);const d=u.slice(0,m).filter(y=>!y.isNAN());for(let y=0,C=d.length;y<C;++y)u[y].assign(d[y]);return d.length}(P,t,m,u,null):ma(P,t,m,u,null)}transform3D(P,t,m,u,g=!0){return(0,F.g)(0),0}foldInto360Range(P,t){return Mr(P,t,null)}foldInto360RangeGeodetic(P,t,m){return la(P,t,m,null)}normalizeGeometryEx(P,t,m,u,g=0){return function ss(P,t,m,u,g){if(!t.isPannable()||P.isEmpty())return P;const d=P.getGeometryType();d===F.G.enumGeometryCollection&&(0,F.b)("not yet impl for geometry collection");const y=t.getPannableExtent();Number.isNaN(m)&&(m=y.getCenterX());const C=y.width(),S=.5*C,b=g>0,A=P.queryInterval(0,0);if(!b&&A.width()<S||!(0,F.i)(P.getGeometryType())){const T=A.getCenter();if(Math.abs(T-m)<=S)return P;{const M=new Wt.T,X=(0,Y.av)((m-T)/C)*C;M.setShiftCoords(X,0);const k=P.clone();return k.applyTransformation(M),k}}if(d===F.G.enumPolygon){let T=new c.P({vd:P.getDescription()});T.addAndExplicitlyOpenAllPaths(P,!1),b&&(T=ca(T,t,2,g,Number.NaN,null,!0));const M=[];if(!u){{let X=P;b&&(X=new c.a,X.add(T,!1));const k=function Ci(P,t,m){const u=Lr();t.querySpheroidData(u);const g=t.getGCS()!==t?t.getSRToGCSTransform():null,d=(0,Y.m)(Y.P,100),y=new dt.h(0,0,0),C=P.getPointCount(),S=t.getGCS().getUnit().getUnitToBaseFactor();for(let M=0,X=C;M<X;){const k=Math.min(100,X-M);P.queryCoordinates(d,k,M,M+k),g&&(new Ji).transform(g,d,k,d,!1);for(let H=0;H<k;H++){if(d[H].isNAN())continue;d[H].scale(S);const U=$t(u.majorSemiAxis,u.e2,d[H]);y.addThis(U)}M+=k}const b=Ie(0,u.e2,y);b.scale(1/S);const A=P;if(!new Pa(t.getGCS(),b).project(A))return 0;m.length=P.getPathCount();const T=A.calculateArea2D()<0;for(let M=0,X=P.getPathCount();M<X;M++){const k=A.calculateRingArea2D(M);m[M]=T?k<0:k>0}return T?-1:1}(P,t,M);if(k)k<0&&T.reverseAllPaths();else{const H=X.getPathCount();for(let U=0;U<H;U++)M.push(X.calculateRingArea2D(U)>0)}}u=M}return new fo(null,u,T,null,t,m,3,0,null).geoNormalizePolygonGeometry(!0)}if(d===F.G.enumPolyline){let T=new c.P({vd:P.getDescription()});return T.addAndExplicitlyOpenAllPaths(P,!1),b&&(T=ca(T,t,2,g,Number.NaN,null,!0)),new fo(null,null,T,null,t,m,3,0,null).geoNormalizePolylineGeometry(!0)}if(d===F.G.enumMultiPoint){const T=P,M=T.getAttributeStreamRef(0);let X,k=null,H=m,U=0;const Z=.1*C;for(let st=0,mt=T.getPointCount();st<mt;st++){const ht=M.read(2*st);let ut=ht-H;Math.abs(ut)>S&&(ut=(0,Y.av)(ut/C)*C,U-=ut,Math.abs(U)<Z&&(U=0)),0!==U&&(k||(X=P.clone(),k=X.getAttributeStreamRef(0)),k.write(2*st,ht+U)),H=ht}return k?(X.notifyModified(),X):P}(0,F.c)("")}(P,t,m,u,g)}normalizeGeometry(P,t,m){return function Jh(P,t,m){if(!t.isPannable()||P.isEmpty())return P;const u=t.getPannableExtent().width(),g=.5*u,d=P.queryInterval(0,0);if(d.width()<g||!(0,F.i)(P.getGeometryType())){if(Number.isNaN(m))return P;const Z=d.getCenter();if(Math.abs(Z-m)<=g)return P;{const st=new Wt.T,mt=(0,Y.av)((m-Z)/u)*u;st.setShiftCoords(mt,0);const ht=P.clone();return ht.applyTransformation(st),ht}}const y=P.getGeometryType(),C=P,S=C.getAttributeStreamRef(0),b=P.clone(),A=b.getAttributeStreamRef(0);let T=0,M=0,X=0,k=(0,F.h)(y)?0:-1;const H=Y.E.constructEmpty();let U=!1;for(let Z=0,st=C.getPointCount();Z<st;Z++){const mt=S.read(2*Z);Z===M&&((0,F.h)(y)?(0===k&&Number.isNaN(m)&&(U=!0),k>0&&Number.isNaN(m)&&(m=H.getCenter(),U=!1),M=C.getPathEnd(k),k++):M=C.getPointCount(),Number.isNaN(m)?X=mt:(X=m,T=0));let ht=mt-X;Math.abs(ht)>g&&(ht=(0,Y.av)(ht/u)*u,T-=ht,Math.abs(T)<.1*u&&(T=0));const ut=mt+T;A.write(2*Z,ut),U&&H.mergeCoordinate(ut),X=mt}return b.notifyModified(),b}(P,t,m)}clipToSpatialReference(P,t,m,u=0){return function Qh(P,t,m,u){const g=t.getCoordinateSystemType();if(0===g){const C=new _i;return t.queryPrecisionDescriptor(C),ua(P,C,t,m)}let d=P;2!==u&&3!==u||!t.isPannable()||(d=Mr(d,t,m));const y=new _i;if(t.queryPrecisionDescriptor(y),d=ua(d,y,t,m),0===u||d.isEmpty())return d;if(1===g){if(1===u){const C=new R.J;d.queryLooseEnvelope(C);const S=t.getPannableExtent(),b=.01*S.width();return S.xmin=C.xmin-b,S.xmax=C.xmax+b,(new Rt.O).execute(d,S,t,m)}return d}if(2===g){const C=t.getPCSHorizon();if(1===u||2===u){const S=(new mi).execute(d,C,t,m);return S===C?S.clone():S}return d}if(3===g)return d;(0,F.c)("missing implementation")}(P,t,m,u)}};class Vl extends ee.G{constructor(t,m,u){super(),this.m_projTrans=m,this.m_progressTracker=u,this.m_index=-1,t||(0,F.t)(""),this.m_inputGeoms=t}next(){const t=this.m_inputGeoms.next();return null!=t?((0,F.l)(t),(0,F.d)(t),this.m_index=this.m_inputGeoms.getGeometryID(),ha(t,this.m_projTrans,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}function ca(P,t,m,u,g,d,y=!1){P||(0,F.t)("Geometry.Geodetic_densify.densify");let C=P.getGeometryType();if((0,F.d)(P),P.isEmpty()||(0,F.e)(C))return P;const S=new _a;S.m_sr=t,S.m_gcs=t.getGCS(),S.m_transform=S.m_gcs!==t?t.getSRToGCSTransform():null,S.m_progressTracker=d;const b=Lr();let A,T,M;if(S.m_gcs.querySpheroidData(b),S.m_a=b.majorSemiAxis,S.m_eSquared=b.e2,S.m_rpu=S.m_gcs.getUnit().getUnitToBaseFactor(),S.m_gcsTolerance=S.m_gcs.getTolerance(0),S.m_radTolerance=S.m_gcsTolerance*S.m_rpu,S.m_maxLength=u,S.m_maxDeviation=g,S.m_curveType=m,C===F.G.enumEnvelope){const X=new c.a({vd:P.getDescription()});X.addEnvelope(P,!1),A=X,C=F.G.enumPolygon}else if((0,F.f)(C)){const X=new c.P({vd:P.getDescription()});X.addSegment(P,!0),A=X,C=F.G.enumPolyline}else A=P;if(4!==S.m_curveType){if((0,F.g)((0,F.h)(C)),T=S.replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(A),T.isEmpty())return T;T=ga(S.m_rpu,T);let X=S.geodeticDensify(T);y||(X=(new Ji).foldInto360RangeGeodetic(X,S.m_gcs,S.m_curveType)),M=S.m_transform&&!S.m_transform.isIdentity()?(new Ji).execute(X,S.m_transform.getInverse(),d):X}else{let X;if((0,F.g)((0,F.h)(C)),t.isPannable())X=Fs(A,t);else{const k=t.getPCSHorizon();X=(new mi).execute(A,k,t,d),X===k&&(X=k.clone())}if(T=X,T.isEmpty())return T;M=S.shapePreservingDensify(T)}return M}function ga(P,t){const m=new R.J;if(t.queryLooseEnvelope(m),m.width()*P<Math.PI)return t;let u=!1;const g=t.querySegmentIterator(),d=new Y.P,y=new Y.P;for(;g.nextPath();)for(;g.hasNextSegment();){const k=g.nextSegment();if(d.setCoordsPoint2D(k.getStartXY()),y.setCoordsPoint2D(k.getEndXY()),d.scale(P),y.scale(P),Math.abs(d.x-y.x)>Math.PI){if(!yi(d,y)){u=!0;break}if(Math.abs(d.x-y.x)>2*Math.PI){u=!0;break}}}if(!u)return t;const C=t.createInstance();C.reserve(t.getPointCount());const S=t.getDescription().getAttributeCount()>1,b=new Y.P,A=new Y.P,T=new Y.P(0,0),M=new Y.P(0,0),X=new dt.P;for(g.resetToFirstPath();g.nextPath();){let k=Number.NaN,H=0;for(;g.hasNextSegment();){const U=g.nextSegment();if(d.setCoordsPoint2D(U.getStartXY()),y.setCoordsPoint2D(U.getEndXY()),d.scale(P),y.scale(P),Number.isNaN(k)?(H=cn(d.x,Number.NaN,H),T.setCoordsPoint2D(d)):T.setCoordsPoint2D(M),k=T.x,yi(d,y)){if(y.x-d.x>2*Math.PI)for(;y.x-d.x>2*Math.PI;)y.x-=2*Math.PI;else if(y.x-d.x<2*-Math.PI)for(;y.x-d.x<2*-Math.PI;)y.x+=2*Math.PI;H=cn(y.x,Number.NaN,H),M.setCoordsPoint2D(y)}else b.setCoordsPoint2D(y),am(b),H=cn(b.x,k,H),M.setCoords(H+b.x,b.y);if(Math.abs(M.x-y.x)<.5&&M.setCoordsPoint2D(y),S)U.queryCoord(0,X),A.setCoordsPoint2D(T),A.scale(1/P),X.setXY(A),g.isFirstSegmentInPath()?C.startPathPoint(X):C.lineToPoint(X),g.isLastSegmentInPath()&&!g.isPathClosed()&&(U.queryCoord(1,X),A.setCoordsPoint2D(M),A.scale(1/P),X.setXY(A),C.lineToPoint(X));else{g.isFirstSegmentInPath()&&C.insertPath2D(-1,null,0,0,!0);const Z=C.getPathCount()-1;A.setCoordsPoint2D(T),A.scale(1/P),C.insertPoint2D(Z,-1,A),g.isLastSegmentInPath()&&!g.isPathClosed()&&(A.setCoordsPoint2D(M),A.scale(1/P),C.insertPoint2D(Z,-1,A))}}}return C}function Kh(P,t,m,u,g,d,y,C,S,b,A,T){const M=new Y.P,X=new Y.P,k=u.compare(g)>0;pa(k,u,g,M,X);const H=Ei(P,t,m,M,X,d,y,C,S,b,null,A,T);return k&&_o(S,b,null,A),H}function yi(P,t){return!(!es(P.y,Y.l)||!es(t.y,Y.l))||!(!es(P.y,-Y.l)||!es(t.y,-Y.l))}function $h(P,t){return!(!es(P.y,Y.l)||es(t.y,Y.l))||!(!es(P.y,-Y.l)||es(t.y,-Y.l))}function Yl(P,t){return!(!es(t.y,Y.l)||es(P.y,Y.l))||!(!es(t.y,-Y.l)||es(P.y,-Y.l))}class _a{constructor(){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_progressTracker=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_gcsTolerance=0,this.m_radTolerance=0,this.m_maxLength=0,this.m_maxDeviation=0,this.m_curveType=0}geodeticDensify(t){const m=t.createInstance(),u=t.querySegmentIterator(),g=[],d=[],y=new c.S,C=t.getDescription().getAttributeCount()>1;for(;u.nextPath();){const S=[0];for(;u.hasNextSegment();){const b=u.nextSegment(),A=b.getStartXY(),T=b.getEndXY();A.scale(this.m_rpu),T.scale(this.m_rpu);const M=new Y.P,X=new Y.P,k=A.compare(T)>0;pa(k,A,T,M,X),g.length=0,d.length=0,this.m_maxLength>0?Ei(this.m_a,this.m_eSquared,this.m_curveType,M,X,this.m_maxLength,this.m_maxDeviation,this.m_radTolerance,null,null,C?d:null,g,S):(0,F.g)(0),k&&_o(null,null,C?d:null,g),g[0].setCoordsPoint2D(b.getStartXY()),g.at(-1).setCoordsPoint2D(b.getEndXY());const H=1/this.m_rpu;for(let U=1,Z=g.length-1;U<Z;U++)g[U].scale(H);if(C){const U=sm(k,b,y);go(u.isFirstSegmentInPath(),u.isLastSegmentInPath()&&!u.isPathClosed(),b,U,d,g,m)}else tm(u.isFirstSegmentInPath(),u.isLastSegmentInPath()&&!u.isPathClosed(),g,m)}}return m}shapePreservingDensify(t){const m=t.createInstance(),u=t.querySegmentIterator(),g=[],d=[],y=new c.S,C=t.getDescription().getAttributeCount()>1;for(;u.nextPath();)for(;u.hasNextSegment();){const S=u.nextSegment(),b=S.getStartXY(),A=S.getEndXY(),T=b.compare(A)>0,M=sm(T,S,y);g.length=0,d.length=0,da(this.m_a,this.m_eSquared,this.m_rpu,M,this.m_sr,this.m_maxLength,this.m_maxDeviation,C?d:null,g),T&&_o(null,null,C?d:null,g),C?go(u.isFirstSegmentInPath(),u.isLastSegmentInPath()&&!u.isPathClosed(),S,M,d,g,m):tm(u.isFirstSegmentInPath(),u.isLastSegmentInPath()&&!u.isPathClosed(),g,m)}return m}replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(t){const m=t.hasNonLinearSegments();if((!this.m_transform||this.m_transform.isIdentity())&&(t=Fs(t,this.m_gcs),!m))return t;const u=t.createInstance();u.reserveParts(t.getPointCount(),t.getPathCount());for(let g=0,d=t.getPathCount();g<d;++g){let y=new c.M;const C=t.getPathStart(g),S=t.getPathEnd(g);y.addPoints(t,C,S);const b=t.isClosedPath(g);let A=!1;if(b&&S-C==1&&t.hasNonLinearSegmentsPath(g)){const T=new dt.P;t.getPointByVal(C,T),y.add(T),A=!0}if(this.m_transform&&!this.m_transform.isIdentity()){if(b&&!A){const T=new dt.P;t.getPointByVal(C,T),y.add(T)}if(y=(new Ji).execute(y,this.m_transform,this.m_progressTracker),b&&y.getPointCount()>1){const T=y.getXY(0),M=y.getXY(y.getPointCount()-1);T.equals(M)&&y.removePoint(y.getPointCount()-1)}}y.getPointCount()>1&&(u.addPathMultiPoint(y,0,-1,!0),b&&u.closePathWithLine())}return u}}function tm(P,t,m,u){P&&u.insertPath2D(-1,null,0,0,!0);const g=u.getPathCount()-1;u.insertPointsFromPoints(g,-1,m,0,m.length-1,!0),t&&u.insertPoint2D(g,-1,m.at(-1))}function go(P,t,m,u,g,d,y){y.reserve(y.getPointCount()+d.length-1);const C=new dt.P;if(m.queryStart(C),P?y.startPathPoint(C):y.lineToPoint(C),d.length>2){const S=u.calculateLength2D();for(let b=1;b<d.length-1;b++){const A=u.lengthToT(g[b]*S);u.queryCoord(A,C),C.setXY(d[b]),y.lineToPoint(C)}}t&&(m.queryEnd(C),y.lineToPoint(C))}function Ei(P,t,m,u,g,d,y,C,S,b,A,T,M){const X={stack:[],error:void 0,hasError:!1};try{const k=(0,vt.b)(X,new js,!1),H=(0,vt.b)(X,new js,!1),U=(0,vt.b)(X,new js,!1);Si.geodeticDistance(P,t,u.x,u.y,g.x,g.y,U,k,H,m);const Z=U.val,st=k.val;let ht=st,ut=H.val;ht<0&&(ht+=2*Math.PI),ut<0&&(ut+=2*Math.PI),S&&(S[0]=ht),b&&(b[0]=ut);let ct=Number.NaN,Et=Number.NaN;if(null!==A){const ce=Xa.q90(P,t),be=Xa.q(P,t,u.y);ct=(ce-be)/Z,Et=(ce+be)/Z}const Tt=$h(u,g),Pt=Yl(u,g),At=Tt||Pt,Ht=function fa(P,t,m){return!(!om(P,t,m)||es(P.y,Y.l)||es(P.y,-Y.l)||es(t.y,Y.l)||es(t.y,-Y.l))}(u,g,C),Bt=(0,vt.b)(X,new Y.S(new js,new js),!1),kt=new Y.P,wt=new Y.P,Xt=new Y.P;M[0]=cn(u.x,Number.NaN,M[0]);let Zt=M[0];if(Z<=d)return T.push(u.clone()),M[0]=cn(g.x,Number.NaN,M[0]),A?.push(0),At?(Tt&&im(u,g,A,T),Pt&&nm(u,g,A,T)):Ht?rm(u,g,st,ct,Et,A,T):y>0&&(wt.setCoords(u.x-Zt,u.y),kt.setCoords(g.x-M[0],g.y),Zt=em()),T.push(g.clone()),Z;const zt=1+Math.ceil(Z/d),ge=Z/(zt-1),qt=new Y.P;T.push(u.clone()),qt.setCoordsPoint2D(u),wt.setCoords(u.x-M[0],u.y),null!==A&&A.push(0);for(let ce=1;ce<zt;ce++){let be;ce<zt-1?(Si.geodeticCoordinate(P,t,u.x,u.y,ce*ge,st,Bt.at(0),Bt.at(1),m),kt.setCoords(Bt.at(0).val,Bt.at(1).val),M[0]=cn(kt.x,qt.x,M[0]),Xt.setCoords(M[0]+kt.x,kt.y),be=ce/(zt-1)):(M[0]=cn(g.x,Number.NaN,M[0]),kt.setCoords(g.x-M[0],g.y),Xt.setCoordsPoint2D(g),be=1),At?(1===ce&&Tt&&im(u,Xt,A,T),ce===zt-1&&Pt&&nm(qt,g,A,T)):Ht?om(qt,Xt,C)&&(u.x<g.x?qt.x>Xt.x&&(M[0]+=2*Math.PI,Xt.setCoords(M[0]+kt.x,kt.y)):qt.x<Xt.x&&(M[0]-=2*Math.PI,Xt.setCoords(M[0]+kt.x,kt.y)),rm(qt,Xt,st,ct,Et,A,T)):y>0&&em(),T.push(Xt.clone()),A?.push(be),qt.setCoordsPoint2D(Xt),wt.setCoordsPoint2D(kt),Zt=M[0]}return Z}catch(k){X.error=k,X.hasError=!0}finally{(0,vt.c)(X)}}function em(P,t,m,u,g,d,y,C,S,b,A,T,M,X,k){return(0,F.g)(0),0}function Xl(P,t,m,u){const g=$t(P,t,m),d=$t(P,t,u);return dt.h.distance(g,d)}function Rl(P,t,m,u,g,d,y,C){const S=new Array,b=(0,Y.m)(Array,8);let A=2,T=g.getCoord2D(d);b[0][0]=T.x,b[0][1]=T.y,T=g.getCoord2D(y),b[1][0]=T.x,b[1][1]=T.y;const M=H=>{if(null!==m){const U=Hs.projToGeog(m,H,b);(0,F.g)(U===H)}for(const U of b)U[0]*=u,U[1]*=u};M(2),S.push($t(P,t,new Y.P(b[0][0],b[0][1]))),S.push($t(P,t,new Y.P(b[1][0],b[1][1])));let X=dt.h.distance(S[0],S[1]);if(X>C)return X;let k=0;for(A=3;A<=17;){const H=1/(A-1);let U=0;for(let ht=1;ht<A;++ht)if(1&ht){const ut=(0,Y.q)(d,y,ht*H);g.queryCoord2D(ut,T),b[U][0]=T.x,b[U][1]=T.y,U++}M(U);let Z=1;for(let ht=0;ht<U;++ht)S.splice(Z,0,$t(P,t,new Y.P(b[ht][0],b[ht][1]))),Z++;Z=0;let st=S[Z];Z++;let mt=0;for(;Z!==S.length;++Z){const ht=S[Z];mt+=dt.h.distance(st,ht),st=ht}if(mt>C)return mt;if(k=mt-X,(0,F.g)(k>=0||Math.abs(k)<1e-14*mt),k<0&&(k=0),X=mt,mt+k<=C)return mt+k;A=2*A-1}return X+k}function da(P,t,m,u,g,d,y,C,S){const b=u.isCurve(),A=function gs(P,t){return P*Math.sqrt(1-t)}(P,t)*Math.PI*179/180;let T=d;d>0&&!(d>A)||(T=A);const X=y>0;let k=Number.NaN;X&&(k=function fs(P,t,m){const u=m/(2*ds(P,t)),g=u*u;return m*(1-g*(.16666666666666666-.008333333333333333*g))}(P,t,y));const H=1===g.getCoordinateSystemType();let U=null;H||(U=g.getPECoordSys());const Z=g.getTolerance(0),st=u.getStartXY(),mt=u.getEndXY(),ht=new Y.P,ut=new Y.P;if(H)ht.setCoordsPoint2D(st),ht.scale(m),ut.setCoordsPoint2D(mt),ut.scale(m);else{const Zt=[st.x,st.y,mt.x,mt.y];Hs.projToGeog(U,2,Zt),ht.setCoords(Zt[0],Zt[1]),ht.scale(m),ut.setCoords(Zt[2],Zt[3]),ut.scale(m)}let ct=0,Et=0;const Tt=[],Pt=[],At=[];Tt.push(mt.clone()),Pt.push(ut.clone()),At.push(1),S.push(st.clone()),null!==C&&C.push(Et);const Ht=g.isPannable(),Bt=st.clone(),kt=[.5,.33333333333333337,.6666666666666666,.16666666666666669,.8333333333333333];let wt=5;b||(X?(kt[0]=.5,kt[1]=.25,kt[2]=.75,wt=3):wt=1),(0,F.g)(T>0);const Xt=Zt=>{if(Zt=Zt.clone(),null!==U){const zt=[Zt.x,Zt.y];Hs.projToGeog(U,1,zt),Zt.setCoords(zt[0],zt[1])}return Zt.scale(m),Zt};for(;Pt.length>0;){const Zt=Tt.at(-1).clone();ut.assign(Pt.at(-1));const zt=At.at(-1);let ge=!1,qt=Number.NaN;const ce=Rl(P,t,U,m,u,Et,zt,T);let be=T>=ce&&Math.abs(ht.y-ut.y)<.9*Math.PI;H&&be&&(be=Math.abs(ht.x-ut.x)<.9*Math.PI);const Me=new Y.P,Es=new Y.P;let ts=!1;if(!X&&be&&be&&(ts=!0),u.calculateSubLength(Et,zt)<=Z&&(ts=!0),!ts)for(let He=0;He<wt;He++){const Ke=(0,Y.q)(Et,zt,kt[He]),rs=new Y.P;u.queryCoord2D(Ke,rs);const Fe=Xt(rs);if(0===He&&(qt=Ke,Me.setCoordsPoint2D(rs),Es.setCoordsPoint2D(Fe),!be)){ge=!0;break}if((0,F.g)(X),H&&Math.abs(ht.x-Fe.x)>=Math.PI){ge=!0;break}let di=new Y.P,Js=new Y.P;b?(di=Y.P.lerp(Bt,Zt,kt[He]),Js=Xt(di)):(di=rs.clone(),Js=Fe.clone());const Zs=Le(P,t,ht,ut,kt[He]),Cs=Zs.clone();if(H?(Cs.x/=m,Cs.y/=m):(Cs.x/=m,Cs.y/=m,ma(g.getGCSToSRTransform(),[Cs],1,[Cs],null)),Cs.isNAN()){const vi=$t(P,t,Fe),Ds=$t(P,t,ht),Zi=$t(P,t,ut),{second:si}=Ss(P,t,vi,Ds,Zi,2,null);if(si>k){ge=!0;break}}else{if(Ht){const bs=g.getPannableExtent().width(),si=(0,Y.q)(u.getStartX(),u.getEndX(),.5);for(;Cs.x<si-.5*bs;)Cs.x+=bs;for(;Cs.x>=si+.5*bs;)Cs.x-=bs}const vi=u.getClosestCoordinateOnInterval(Cs,new Y.E(Et,zt),-1);let Ds=u.getCoord2D(vi);Ds=Xt(Ds);let Zi=Xl(P,t,Ds,Zs);if(Zi>k){if(Zi<4*k){const bs=$t(P,t,Ds),si=$t(P,t,ht),Hi=$t(P,t,ut),{second:_n}=Ss(P,t,bs,si,Hi,2,null);Zi=_n}if(Zi>k){ge=!0;break}}else if(b){let bs=$t(P,t,Fe);const si=$t(P,t,ht),Hi=$t(P,t,ut);let{second:zi}=Ss(P,t,bs,si,Hi,3,null);if(zi<=k){bs=$t(P,t,Js);const{second:Ra}=Ss(P,t,bs,si,Hi,3,null);zi=Ra}if(zi>k){ge=!0;break}}}}ge?(Tt.push(Me.clone()),Pt.push(Es.clone()),At.push(qt)):(Tt.pop(),Pt.pop(),At.pop(),S.push(Zt.clone()),ct+=ce,null!==C&&C.push(ct),Bt.setCoordsPoint2D(Zt),ht.setCoordsPoint2D(ut),Et=zt)}if(null!==C){const Zt=1/ct;for(let zt=0;zt<C.length;zt++)C[zt]*=Zt}}function _o(P,t,m,u){if(u.reverse(),null!==m&&m.reverse(),P){const g=P[0];P[0]=t[0],t[0]=g}}function pa(P,t,m,u,g){P?(u.setCoordsPoint2D(m),g.setCoordsPoint2D(t)):(u.setCoordsPoint2D(t),g.setCoordsPoint2D(m))}function sm(P,t,m){return P?(m.create(t.getGeometryType()),t.copyTo(m.get()),m.get().reverse(),m.get()):t}function cn(P,t,m){if(Number.isNaN(t)){for(;m-P>Math.PI;)m-=2*Math.PI;for(;P-m>Math.PI;)m+=2*Math.PI;return m}return m+P-t>Math.PI?m-=2*Math.PI:t-(m+P)>Math.PI&&(m+=2*Math.PI),m}function im(P,t,m,u){if(P.y>0){const g=new Y.P;g.setCoords(t.x,Y.l),es(P.x,g.x)||es(t.y,g.y)||(u.push(g),null!==m&&m.push(0))}else{const g=new Y.P;g.setCoords(t.x,-Y.l),es(P.x,g.x)||es(t.y,g.y)||(u.push(g),null!==m&&m.push(0))}}function nm(P,t,m,u){if(t.y>0){const g=new Y.P;g.setCoords(P.x,Y.l),es(t.x,g.x)||es(P.y,g.y)||(u.push(g),null!==m&&m.push(1))}else{const g=new Y.P;g.setCoords(P.x,-Y.l),es(t.x,g.x)||es(P.y,g.y)||(u.push(g),null!==m&&m.push(1))}}function rm(P,t,m,u,g,d,y){if(function wc(P){return function Ic(P,t){return 0===P||Math.abs(P)<=t}(P,Uu)}(m)){if(Y.l-P.y>0){const C=new Y.P;C.setCoords(P.x,Y.l),y.push(C),null!==d&&d.push(u)}if(Y.l-t.y>0){const C=new Y.P;C.setCoords(t.x,Y.l),y.push(C),null!==d&&d.push(u)}}else{if(Y.l+P.y>0){const C=new Y.P;C.setCoords(P.x,-Y.l),y.push(C),null!==d&&d.push(g)}if(Y.l+t.y>0){const C=new Y.P;C.setCoords(t.x,-Y.l),y.push(C),null!==d&&d.push(g)}}}function om(P,t,m){return Math.abs(Math.abs(P.x-t.x)-Math.PI)<=m}function am(P){if(P.x<-Math.PI)for(;P.x<-Math.PI;)P.x+=2*Math.PI;else if(P.x>Math.PI)for(;P.x>Math.PI;)P.x-=2*Math.PI}function Cn(P,t,m,u){const g={stack:[],error:void 0,hasError:!1};try{const d=[m.x],y=[m.y-u],C=[m.x],S=[m.y+u];ye(d,y),ye(C,S);const b=(0,vt.b)(g,new js,!1),A=(0,vt.b)(g,new js,!1);return Si.greatEllipticDistance(P,t,m.x,m.y,d[0],y[0],b,null,null),Si.greatEllipticDistance(P,t,m.x,m.y,C[0],S[0],A,null,null),Math.min(b.val,A.val)}catch(d){g.error=d,g.hasError=!0}finally{(0,vt.c)(g)}}function xa(P,t,m,u,g){const d=new R.J;m.queryEnvelope(d);const y=(0,dt.b)(null,m,!0).total();if(t.xmin-d.xmin<=y&&d.xmax-t.xmax<=y)return m;const C=t.width();let S=0;for(;t.xmin+S*C<d.xmin;)S++;for(;t.xmin+S*C>d.xmin;)S--;const b=S*C,A=new Wt.T;A.setShiftCoords(-b,0);const T=m;T.applyTransformation(A);const M=new R.J;T.queryEnvelope(M);let X=null;if(M.xmax>t.xmax){let k=0;const H=new R.J;H.setCoords({env2D:t}),H.ymin-=1,H.ymax+=1;let U=T;for(;H.xmin<M.xmax;){M.xmax>H.xmax&&(U=Kn(U,P,2,!0,H.xmax));const Z=(0,dt.e)(U,H),st=(0,dt.a)(null,Z,!0).total(),mt=(0,Rt.c)(U,H,st,Number.NaN,g);null===X?X=mt===U?mt.clone():mt:(A.setShiftCoords(-k*C,0),mt.applyTransformation(A),X.add(mt,!1)),k++,H.xmin=H.xmax,H.xmax=t.xmax+k*C}}else X=T;return X}class Pa{constructor(t,m){this.m_basisX=new dt.h,this.m_basisY=new dt.h,this.m_normal=new dt.h,(0,F.g)(1===t.getCoordinateSystemType()),this.m_gcs=t;const u=Lr();t.querySpheroidData(u),this.m_a=u.majorSemiAxis,this.m_e2=u.e2,this.m_rpu=t.getUnit().getUnitToBaseFactor(),this.m_curvCenterRad=m.mul(this.m_rpu);const g=this.m_curvCenterRad.x,d=this.m_curvCenterRad.y,y=Math.cos(g),C=Math.sin(g),S=Math.cos(d),b=Math.sin(d);this.m_cartCenter3D=function Te(P,t,m,u,g,d){return Pe(P,t,m,u,g,d,0)}(this.m_a,this.m_e2,y,C,S,b),this.m_normal.setCoordsPoint3D(this.m_cartCenter3D),this.m_d=this.m_cartCenter3D.length(),this.m_normal.divThis(this.m_d),dt.h.selectRightHandedBasisFromNormal(this.m_normal,this.m_basisX,this.m_basisY),this.m_northPolePcs=this.projectPoint(Y.P.construct(0,.5*Math.PI/this.m_rpu)),this.m_southPolePcs=this.projectPoint(Y.P.construct(0,.5*-Math.PI/this.m_rpu))}project(t){const m=t.getGeometryType();if((0,F.i)(m))return(0,F.l)(t),this.projectMultiVertex(t);(0,F.t)("Gnomonic.project")}unproject(t,m,u){const g=t.getGeometryType();if((0,F.i)(g)){(0,F.l)(t);let d=t;const y=[];if(g===F.G.enumPolygon){const C=d.getPathCount();for(let S=0;S<C;S++){const b=d.calculateRingArea2D(S);y.push(b)}}return this.unprojectMultiVertex(m,d),(0,F.h)(g)?(function Ca(P,t,m){const u=P.getPannableExtent(),g=Y.P.construct(t,0);u.centerAt(g);const d=u.width(),y=.5*d,C=new Y.P;C.setNAN();let S=Number.NaN;for(let b=0;b<m.getPathCount();b++)for(let A=m.getPathStart(b);A<m.getPathEnd(b);A++){const T=m.getXY(A),M=es(T.y,u.ymax)||es(u.ymin,T.y);A===m.getPathStart(b)?(C.setNAN(),S=0):C.isNAN()||M||(S=mm(T.x,C.x,y,d,S)),T.x+=S,m.setXY(A,T),M||C.setCoordsPoint2D(T)}m.getImpl().notifyModifiedFlags(2001)}(this.m_gcs,0,d),function ya(P,t,m,u,g){const d=u.getGeometryType(),y=t.getPannableExtent();let C=u,S=!1,b=!1;if(d===F.G.enumPolygon){const A=new R.J,T=Y.P.construct(m,0);A.setCoords({env2D:y}),A.centerAt(T),S=function xs(P,t,m,u,g){const d=function Ri(P,t){const m=new R.J;t.queryEnvelope(m);const u=es(P.ymax,m.ymax),g=es(P.ymin,m.ymin),d=u||g;return!!d&&(function kl(P,t){const m=new c.a,u=new R.J;for(let g=0;g<t.getPathCount();g++){t.queryPathEnvelope(g,u);let d=es(P.ymax,u.ymax),y=es(P.ymin,u.ymin);if(!d&&!y){m.addPath(t,g,!0);continue}m.insertPath2D(-1,null,0,0,!0);const C=t.getPathStart(g),S=t.getPathEnd(g),b=S-C;let A=-1;for(A=C;A<S;A++){const k=t.getXY(A);if(d=es(P.ymax,k.y),y=es(P.ymin,k.y),!d&&!y)break}let T=A,M=!1,X=Number.NaN;do{const k=t.getXY(T);d=es(P.ymax,k.y),y=es(P.ymin,k.y);const H=C+(T+1-C)%b;if(d||y){let U=Y.P.construct(X,k.y);m.insertPoint2D(g,-1,U);const Z=t.getXY(H),st=es(P.ymax,Z.y),mt=es(P.ymin,Z.y);st||mt||(U=Y.P.construct(Z.x,k.y),M?m.setXY(m.getPointCount()-1,U):m.insertPoint2D(g,-1,U)),M=!0}else m.insertPoint2D(g,-1,k),X=k.x,M=!1;T=H}while(T!==A)}t.setEmpty(),t.add(m,!1)}(P,t),d)}(m,u),y=function hm(P,t,m,u,g){const d=[],y=[],C=.5*m.width();for(let T=0;T<u.getPathCount();T++){const M=u.getXY(u.getPathStart(T)),X=u.getXY(u.getPathEnd(T)-1),k=P[T]<0;if(Math.abs(M.x-X.x)>C){const H=Ll(k,t,m,T,u,g);d.push(H),y.push(T)}else if(!k&&u.calculateRingArea2D(T)<0){const H=Bl(t,m,T,u,g);d.push(H),y.push(T)}}if(0===d.length)return!1;const S=new c.a({vd:u.getDescription()});let b=0,A=y[b];for(let T=0;T<u.getPathCount();T++)T===A?(S.add(d[b],!1),b++,b<y.length&&(A=y[b])):S.addPath(u,T,!0);return u.setEmpty(),u.add(S,!1),!0}(P,t,m,u,g);return d||y}(P,t,A,C,g);const M=function Ea(P,t,m,u){const g=new R.J;m.queryEnvelope(g);const d=(0,dt.b)(null,m,!0).total();if(t.xmin-g.xmin<=d&&g.xmax-t.xmax<=d)return m;const y=m.createInstance();let C=m.createInstance();const S=new R.J,b=m.getPathCount();for(let A=0;A<b;A++)m.queryPathEnvelope(A,S),t.xmin-S.xmin<=d&&S.xmax-t.xmax<=d?y.addPath(m,A,!0):(C.setEmpty(),C.addPath(m,A,!0),C=xa(P,t,C,0,u),y.add(C,!0));return y}(t,A,C,g);M!==C&&(b=!0),C=M}else C=(new Ji).foldInto360RangeGeodetic(C,t,2);d===F.G.enumPolygon&&(S||b)&&(C=(new Vi).execute(C,t,!1,g)),C!==u&&(u.setEmpty(),u.add(C,!1))}(y,this.m_gcs,0,d,u)):d=Qn(d,this.m_gcs,0,!0,0,u),d}(0,F.t)("Gnomonic.unproject")}projectPoint(t){const m=t.mul(this.m_rpu),u=$t(this.m_a,this.m_e2,m),g=this.m_normal.dotProduct(u);if(g<=0)return Y.P.construct(Number.NaN,Number.NaN);const y=u.mul(this.m_d/g).sub(this.m_cartCenter3D),C=new Y.P;return C.x=this.m_basisX.dotProduct(y),C.y=this.m_basisY.dotProduct(y),C}unprojectPoint(t){const m=this.m_cartCenter3D.add(this.m_basisX.mul(t.x).add(this.m_basisY.mul(t.y)));return Ie(0,this.m_e2,m).divide(this.m_rpu)}projectMultiVertex(t){const m=t.getImpl();let u=!0;const g=new Y.P,d=new Y.P;for(let y=0,C=m.getPointCount();y<C;y++)m.queryXY(y,g),g.y*this.m_rpu>.5*Math.PI?d.assign(this.m_northPolePcs):g.y*this.m_rpu<.5*-Math.PI?d.assign(this.m_southPolePcs):d.assign(this.projectPoint(g)),m.setXY(y,d),d.isNAN()&&(u=!1);return m.notifyModifiedFlags(2001),u}unprojectMultiVertex(t,m){const u=m.getImpl(),g=t*t,d=!this.m_northPolePcs.isNAN(),y=!this.m_southPolePcs.isNAN();for(let C=0,S=u.getPointCount();C<S;C++){const b=u.getXY(C);let A=new Y.P;d&&Y.P.sqrDistance(b,this.m_northPolePcs)<=g?(A.setCoords(this.m_curvCenterRad.x,.5*Math.PI),A.scale(1/this.m_rpu)):y&&Y.P.sqrDistance(b,this.m_southPolePcs)<=g?(A.setCoords(this.m_curvCenterRad.x,.5*-Math.PI),A.scale(1/this.m_rpu)):A=this.unprojectPoint(b),u.setXY(C,A)}u.notifyModifiedFlags(2001)}}function Ll(P,t,m,u,g,d){const y=new c.a,C=new c.a,S=new Wt.T,b=g.getXY(g.getPathStart(u)),A=g.getXY(g.getPathEnd(u)-1),T=m.width(),M=.5*T,X=new R.J;g.queryEnvelope(X);const k=Math.ceil(X.width()/T)+1;let H,U;b.x>A.x?(H=-T,U=P?m.ymin:m.ymax):(H=T,U=P?m.ymax:m.ymin),S.setShiftCoords(H,0),y.addPath(g,u,!0),C.add(y,!1);const Z=new dt.P;for(let wt=0;wt<k;wt++)C.applyTransformation(S),C.getPointByVal(0,Z),y.lineToPoint(Z),y.addSegmentsFromPath(C,0,0,C.getSegmentCount()-1,!1);const st=y.getXY(0),mt=y.getXY(y.getPointCount()-1);st.y=U,mt.y=U,y.lineTo(mt);const ht=new Y.P;for(ht.setCoordsPoint2D(mt),ht.x-=.5*H;Math.abs(ht.x-st.x)>M;)y.lineTo(ht),ht.x-=.5*H;y.lineTo(st);const ut=m.getCenter().x,ct=new R.J;y.queryEnvelope(ct);let Et=0;const Tt=ct.getCenter().x;Tt-ut>M?Et=-Math.ceil((Tt-ut-M)/T):ut-Tt>M&&(Et=Math.ceil((ut-Tt-M)/T)),0!==Et&&(S.setShiftCoords(Et*T,0),y.applyTransformation(S));const Pt=new c.E,At=Pt.addGeometry(y);wn(Pt,At,t,0,2,!0,m.xmin),wn(Pt,At,t,0,2,!0,m.xmax);const Ht=Pt.getGeometry(At),Bt=(0,dt.e)(Ht,m);Bt.inflateCoords(0,1);const kt=(0,dt.a)(null,Bt,!0);return(0,Rt.c)(Ht,m,kt.total(),Number.NaN,d)}function Bl(P,t,m,u,g){const d=t.width(),y=.5*d,C=t.getCenter().x,S=new R.J;u.queryPathEnvelope(m,S);let b,A=0,T=S.getCenter().x;if(T-C>y?A=-Math.ceil((T-C-y)/d):C-T>y&&(A=Math.ceil((C-T-y)/d)),0!==A){const H=new Wt.T;H.setShiftCoords(A*d,0),u.getImpl().applyTransformationToPath(H,m),u.queryPathEnvelope(m,S),T=S.getCenter().x}const M=new R.J;t.containsExclusiveEnvelope(S)?(b=!1,M.setCoords({env2D:t})):(b=!0,M.setCoords({env2D:t}),M.xmin-=d,M.xmax+=d);let X=u.createInstance();X.addPathPoint2D(null,0,!0);const k=new Y.P;if(k.setCoords(M.xmin,M.ymin),X.insertPoint2D(0,-1,k),k.setCoords(M.xmin,M.ymax),X.insertPoint2D(0,-1,k),k.setCoords(.5*(M.xmin+M.xmax),M.ymax),X.insertPoint2D(0,-1,k),k.setCoords(M.xmax,M.ymax),X.insertPoint2D(0,-1,k),k.setCoords(M.xmax,M.ymin),X.insertPoint2D(0,-1,k),k.setCoords(.5*(M.xmin+M.xmax),M.ymin),X.insertPoint2D(0,-1,k),b){X.addPath(u,m,!0);const H=new Wt.T;H.setShiftCoords(T<C?d:-d,0),u.getImpl().applyTransformationToPath(H,m),X.addPath(u,m,!0);const U=new c.E,Z=U.addGeometry(X);wn(U,Z,P,0,2,!0,t.xmin),wn(U,Z,P,0,2,!0,t.xmax),X=U.getGeometry(Z);const st=(0,dt.e)(X,t);st.inflateCoords(0,1);const mt=(0,dt.a)(null,st,!0).total();X=(0,Rt.c)(X,t,mt,Number.NaN,g)}else X.addPath(u,m,!0);return X}function mm(P,t,m,u,g){return g+P-t>m?g-=u:t-(g+P)>m&&(g+=u),g}function lm(P,t,m,u,g,d){const y=t.getAttributeStreamRef(0),C=t.getPointCount();let S=!1;const b=new Y.P;for(let ht=0;ht<C;++ht){if(y.queryPoint2D(2*ht,b),1&d&&b.y>=m){S=!0;break}if(2&d&&b.y<=-m){S=!0;break}}if(!S)return!1;let A=!1;P&&(A=t.getImpl().isClosedPathInXYPlane(0));const T=new c.E,M=T.addGeometry(t),X=T.getFirstPath(M);let k=-1,H=!0;const U=new Y.P,Z=new dt.P;let st=c.n;const mt=po*g/360;for(let ht=T.getFirstVertex(X);ht!==c.n;ht=T.getNextVertex(ht)){T.queryXY(ht,b);let ut=1&d&&b.y>=m?1:0;if(ut|=2&d&&b.y<=-m?2:0,k>0&&k!==ut){if(U.x!==b.x){const ct=T.getPrevVertex(ht);T.queryPoint(ct,Z);const Et=T.insertVertex(X,ht,Z);U.x=b.x,T.setXY(Et,U)}if(A){let ct=st!==c.n?T.getNextVertex(st):T.getFirstVertex(X);const Et=T.getPrevVertex(ht);for(;ct!==Et;)ct=T.removeVertex(ct,!1);if(st!==c.n){const Tt=T.getXY(st),Pt=T.getXY(Et);if(Math.abs(Tt.x-Pt.x)>mt){T.queryPoint(st,Z);const At=T.insertVertex(X,Et,Z);Tt.x=(0,Y.q)(Tt.x,Pt.x,.5),T.setXY(At,Tt)}}}st=c.n}if(ut&&(b.y=(0,Y.f)(u,b.y),T.setXY(ht,b),!H&&k!==ut))if(b.x!==U.x){T.queryPoint(ht,Z);const ct=T.insertVertex(X,ht,Z);T.setXYCoords(ct,U.x,b.y),st=ct}else st=ht;k=ut,U.assign(b),H=!1}if(A){if(st!==c.n){let Tt=T.getNextVertex(st);for(;Tt!==c.n;)Tt=T.removeVertex(Tt,!1)}const ht=T.getFirstVertex(X);let ut=T.getLastVertex(X);const ct=T.getXY(ht),Et=T.getXY(ut);if(!ct.equals(Et)&&(T.queryPoint(ht,Z),ut=T.insertVertex(X,c.n,Z),Math.abs(ct.x-Et.x)>mt)){const Tt=T.insertVertex(X,ut,Z);ct.x=(0,Y.q)(ct.x,Et.x,.5),T.setXY(Tt,ct)}}return t.assignCopy(T.getGeometry(M)),!0}const po=210;class fo{constructor(t,m,u,g,d,y,C,S,b){this.m_bAdjustedAtPoles=0,this.m_inputPoly=u,this.m_progressTracker=b,this.m_originalGeometry=t,this.m_originalSR=g,this.m_polygonRingFlags=m,this.m_pannableSR=d,this.m_poleSnappingTolerance=S,this.m_poleFlags=C,this.m_bAdjustedAtPoles=0,this.m_pannableExtent=function um(P,t){const m=P.getPannableExtent();return Number.isNaN(t)||m.centerAtCoords(t,0),m}(this.m_pannableSR,y),this.m_centralLongitude=Number.isNaN(y)?this.m_pannableExtent.getCenterX():y,this.m_width360=this.m_pannableExtent.width(),this.m_degree=this.m_width360/360,this.m_GCSLargeDelta=po*this.m_degree,(0,F.g)(null===this.m_originalGeometry&&null===this.m_originalSR||null!==this.m_originalGeometry&&null!==this.m_originalSR)}geonormalizeRing(t,m,u,g,d,y,C){let S=u;const b=new c.P({vd:this.m_inputPoly.getDescription()});b.addPath(this.m_inputPoly,t,!0),0!==this.m_poleFlags&&(this.m_bAdjustedAtPoles|=lm(!0,b,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,this.m_pannableExtent.width(),this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(S=!1));let A=-1;S&&(A=this.m_originalGeometry.getPathStart(t));const T=b.getAttributeStreamRef(0),M=b.getPointCount();let X=0,k=T.read(0),H=0;const U=3*this.m_pannableSR.getTolerance(0);let Z=!1;const st=new Y.P,mt=new Y.P;let ht=!1;const ut=b.hasNonLinearSegments(),ct=new Y.P;for(let Pt=1;Pt<M;++Pt){T.queryPoint2D(2*Pt,ct);const At=ct.x;let Ht=At+X;const Bt=Ht-k;if(ct.x=Ht,Math.abs(Bt)>this.m_GCSLargeDelta){if(S){const wt=A+(Pt+1<M?Pt:0),Xt=y.read(2*(A+Pt-1)),Zt=(y.read(2*wt)-Xt)*g;Math.abs(Bt-Zt)>1*this.m_degree&&(S=!1)}S||(X-=(0,Y.f)(this.m_width360,Ht-k),Ht=At+X,++H,ht=0!==X,ct.x=Ht)}else Z||(0,dt.L)(st,mt,ct,U)&&(Z=!0);ht&&(ut&&(0,F.c)("error in geonormalize_ring_ for curves"),T.write(2*Pt,Ht)),k=Ht,st.setCoordsPoint2D(mt),mt.setCoordsPoint2D(ct)}H&&b.notifyModified();const Et=b.getXY(0),Tt=b.getXY(M-1);if(Y.P.distance(Et,Tt)<U){const Pt=this.finalizeGeoNormalizeClosedRing(b,Z,d);C.add(Pt,!1)}else{m<0&&(null!==this.m_originalGeometry?((0,F.g)(null!==this.m_originalGeometry),m=this.m_originalGeometry.calculateRingArea2D(t)>0?1:0):m=1);const Pt=this.finalizeGeoNormalizeOpenedRing(m>0,b);C.add(Pt,!1)}}geoNormalizePolygonGeometry(t){(0,F.g)(this.m_originalSR&&this.m_originalGeometry||!this.m_originalGeometry&&!this.m_originalSR),(0,F.g)(this.m_pannableSR.isPannable());let m=null,u=Number.NaN;const g=!!this.m_originalSR&&this.m_originalSR.isPannable();g&&(m=this.m_originalGeometry.getAttributeStreamRef(0),u=this.m_width360/this.m_originalSR.getPannableExtent().width()),this.m_bAdjustedAtPoles=0;const d=new c.a({vd:this.m_inputPoly.getDescription()});for(let k=0,H=this.m_inputPoly.getPathCount();k<H;++k)this.geonormalizeRing(k,this.m_polygonRingFlags?this.m_polygonRingFlags[k]?1:0:-1,g,u,t,m,d);const y=this.m_pannableSR.getTolerance(0),C=this.m_pannableExtent.width()/180;Ws(d,this.m_pannableExtent,.1*y,!1);const S=R.J.constructEmpty();if(S.setCoords({env2D:this.m_pannableExtent}),t){let k=!0;for(let H=0;H<2;H++){k=!0;const U=R.J.constructEmpty();for(let Z=0,st=d.getPathCount();Z<st;Z++)if(d.queryPathEnvelope(Z,U),!(S.xmin<=U.xmin&&S.xmax>=U.xmax||U.xmin>=S.xmax||U.xmax<=S.xmin)){k=!1;break}if(k)break;S.move(.5*this.m_width360,0)}k||S.setCoords({env2D:this.m_pannableExtent})}let b=(0,Rt.c)(d,S,y,C,this.m_progressTracker),A=d!==b;const T=this.m_originalGeometry?this.m_originalGeometry.calculateArea2D():1,M=b.calculateArea2D();let X=0;if(M>0&&T<0)X=1;else if(M<=0&&T>0)if(0===M){if(this.m_originalSR){let k=Number.NaN;2===this.m_originalSR.getCoordinateSystemType()?k=this.m_originalSR.getPCSHorizon().calculateArea2D():1===this.m_originalSR.getCoordinateSystemType()&&(k=this.m_originalSR.getPannableExtent().getArea()),T>.99*k&&(X=-1)}}else X=-1;if(0!==X){const k=function Hl(P,t){let m=new c.a({vd:P});m.addEnvelope(t,!1);const u=t.width()/180;return m=(new Se.O).execute(m,u,0,0,null),m}(b.getDescription(),S);k.add(b,!1),A=!0,b=k}return A&&(b=(new Vi).execute(b,this.m_pannableSR,!1,this.m_progressTracker)),b}geoNormalizePolylineGeometry(t){(0,F.g)(this.m_pannableSR.isPannable());let m=null;const u=this.m_originalSR&&this.m_originalSR.isPannable();let g=1;u&&((0,F.g)(this.m_originalGeometry),g=this.m_width360/this.m_originalSR.getPannableExtent().width(),m=this.m_originalGeometry.getAttributeStreamRef(0));const d=this.m_pannableExtent.width(),y=d*(0,Y.N)()*4;let C=t,S=Number.NaN;const b=Y.E.constructEmpty();this.m_bAdjustedAtPoles=0;let A=new c.P({vd:this.m_inputPoly.getDescription()});for(let X=0,k=this.m_inputPoly.getPathCount();X<k;++X){let H=u;const U=new c.P({vd:this.m_inputPoly.getDescription()});U.addPath(this.m_inputPoly,X,!0);const Z=this.m_inputPoly.isClosedPath(X);0!==this.m_poleFlags&&(this.m_bAdjustedAtPoles|=lm(Z,U,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,d,this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(H=!1));let st=-1;const mt=U.getPointCount();let ht=!1;H&&(st=this.m_originalGeometry.getPathStart(X),ht=this.m_originalGeometry.isClosedPath(X));const ut=U.getAttributeStreamRef(0);let ct=0,Et=ut.read(0),Tt=0;const Pt=new Y.P,At=new Y.P;let Ht=!1;const Bt=U.hasNonLinearSegments(),kt=new Y.P;for(let wt=1;wt<mt;++wt){ut.queryPoint2D(2*wt,kt);const Xt=kt.x;let Zt=Xt+ct;const zt=Zt-Et;if(kt.x=Zt,Math.abs(zt)>this.m_GCSLargeDelta){if(H){let qt=st;(!ht||wt+1<mt)&&(qt+=wt);const ce=m.read(2*(st+wt-1)),be=(m.read(2*qt)-ce)*g;Math.abs(zt-be)>1*this.m_degree&&(H=!1)}H||(ct-=(0,Y.f)(this.m_width360,Zt-Et),Zt=Xt+ct,++Tt,Ht=0!==ct,kt.x=Zt)}Ht&&(Bt&&(0,F.c)("error in geonormalize_ring_ for curves"),ut.write(2*wt,Zt)),Et=Zt,Pt.setCoordsPoint2D(At),At.setCoordsPoint2D(kt)}if(Tt&&U.notifyModified(),C){let wt=!1;if(!U.isEmpty()){const Xt=R.J.constructEmpty();if(U.queryEnvelope(Xt),Xt.width()>=d||Xt.ymin<=this.m_pannableExtent.ymin||Xt.ymax>=this.m_pannableExtent.ymax)wt=!0;else{if(Number.isNaN(S)){const zt=this.m_centralLongitude-.5*d;S=Xt.xmin,S+=Math.round((zt-Xt.xmin)/d)*d,S>zt&&(S-=d),(0,F.g)(S<=zt),S<zt&&(S+=d),(0,F.g)(S>=zt)}let Zt=Math.round((S-Xt.xmin)/d)*d;if(Xt.xmin+Zt>S+y&&(Zt-=d),Xt.xmin+Zt<S-y&&(Zt+=d),b.mergeCoordinate(Xt.xmin+Zt),b.mergeCoordinate(Xt.xmax+Zt),wt=b.width()>=d,!wt){const zt=new Wt.T;zt.setShiftCoords(Zt,0),U.applyTransformation(zt)}}}A.add(U,!1),wt&&(A=(()=>{const Xt=new c.P({vd:A.getDescription()});for(let Zt=0,zt=A.getPathCount();Zt<zt;++Zt){const ge=new c.P({vd:A.getDescription()});ge.addPath(A,Zt,!0);const qt=Qn(ge,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);Xt.add(qt,!1)}return Xt})(),C=!1)}else{const wt=Qn(U,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);A.add(wt,!1)}}if(C)return A;const T=this.m_pannableSR.getTolerance(0),M=this.m_pannableExtent.width()/180;return Ws(A,this.m_pannableExtent,.1*T,!1),(0,Rt.c)(A,this.m_pannableExtent,T,M,this.m_progressTracker)}finalizeGeoNormalizeOpenedRing(t,m){const u=m.getPointCount(),g=m.getXY(0),d=m.getXY(u-1);{const Pt=Math.abs(d.x-g.x),At=Math.round(Pt/this.m_width360)*this.m_width360;(0,F.g)(Math.abs(Pt-At)<this.m_pannableSR.getTolerance(0))}const y=(0,Y.e)(d.x-g.x),C=R.J.constructEmpty();m.queryLooseEnvelope(C);const S=this.m_pannableExtent.getCenterX();let b=0,A=S-this.m_width360,T=S+this.m_width360;if(y>=0){let Pt=Math.ceil((A-C.xmin)/this.m_width360);for(Pt*=this.m_width360;A>C.xmin+Pt;)Pt+=this.m_width360;for(;A<C.xmax+Pt;)Pt-=this.m_width360;for(b=Pt,C.width()>720&&(T=A+360*Math.ceil(C.width()/360));T<C.xmax;)T+=this.m_width360}else{let Pt=Math.ceil((T-C.xmax)/this.m_width360);for(Pt*=this.m_width360;T<C.xmax+Pt;)Pt-=this.m_width360;for(;T>C.xmin+Pt;)Pt+=this.m_width360;for(b=Pt,C.width()>720&&(A=T-360*Math.ceil(C.width()/360));A>C.xmin;)A-=this.m_width360}const M=Math.round(Math.abs(d.x-g.x)/this.m_width360)*this.m_width360,X=y*M,k=C.clone();k.move(b,0);const H=new Y.P(0,0),U=new Wt.T;U.setShiftCoords(b,0),m.applyTransformation(U);const Z=new c.P({vd:m.getDescription()});Z.add(m,!1),H.assign(m.getXY(u-1));let st=0,mt=Z.getXY(0).x;for(;y>0?k.xmax<T:k.xmin>A;)k.move(X,0),U.xd=X,m.applyTransformation(U),mt+=X,this.m_pannableExtent.xmin<=mt&&this.m_pannableExtent.xmax>=mt&&(st=Z.getPointCount()-1),m.setXY(0,H),H.assign(m.getXY(u-1)),Z.addSegmentsFromPath(m,0,0,u-1,!1);const ht=new c.a({vd:Z.getDescription()});ht.add(Z,!1);const ut=Z.getXY(0),ct=Z.getXY(Z.getPointCount()-1),Et=y<0?t:!t,Tt=ht.getPointCount()-1;if(Et){const Pt=new Y.P(ct.x,this.m_pannableExtent.ymax);ht.lineTo(Pt);const At=new Y.P(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymax);ht.lineTo(At);const Ht=new Y.P(ut.x,this.m_pannableExtent.ymax);ht.lineTo(Ht)}else{const Pt=new Y.P(ct.x,this.m_pannableExtent.ymin);ht.lineTo(Pt);const At=new Y.P(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymin);ht.lineTo(At);const Ht=new Y.P(ut.x,this.m_pannableExtent.ymin);ht.lineTo(Ht)}if(ht.interpolateAttributesPath(0,Tt,0),ht.getImpl().changeRingStartPoint(st),M>this.m_width360){const Pt=new c.a({copy:ht});U.setShiftCoords(this.m_width360,0),Pt.applyTransformation(U),ht.add(Pt,!1)}return ht}finalizeGeoNormalizeClosedRing(t,m,u){const g=new c.a({vd:t.getDescription()});if(g.add(t,!1),g.hasNonLinearSegments()&&(()=>{const A=g.getPointCount()-2;return g.getSegmentType(A)!==F.G.enumLine})()){const A=new c.S,T=g.getPointCount()-2;g.getSegmentBuffer(T,A,!1),g.removePointFromPath(0,T+1),g.closeLastPathWithSegment(A.get())}else g.removePointFromPath(0,g.getPointCount()-1);const y=R.J.constructEmpty();g.queryLooseEnvelope(y);let C=Math.ceil((this.m_pannableExtent.xmin-y.xmin)/this.m_width360);for(C*=this.m_width360;this.m_pannableExtent.xmin>y.xmin+C;)C+=this.m_width360;for(;this.m_pannableExtent.xmin<y.xmax+C;)C-=this.m_width360;if(C+=this.m_width360,0!==C){y.move(C,0);const A=new Wt.T;A.setShiftCoords(C,0),g.applyTransformation(A)}if(this.m_pannableExtent.xmin<=y.xmin&&this.m_pannableExtent.xmax>=y.xmax){if(m){const T=g.calculateArea2D(),M=(new Vi).execute(g,this.m_pannableSR,!0,this.m_progressTracker);if(M!==g){const X=M.calculateArea2D();(0,Y.e)(T)!==(0,Y.e)(X)&&M.reverseAllPaths(),g.assignMove(M)}}let A;if(A=new c.a(u?{copy:g}:{move:g}),u)for(;y.xmin<this.m_pannableExtent.xmax;){y.move(this.m_width360,0);const T=new Wt.T;T.setShiftCoords(this.m_width360,0),g.applyTransformation(T),A.add(g,!1)}return A}let S=new c.a({vd:t.getDescription()});S.add(g,!1);const b=m||y.width()>this.m_width360-10*this.m_pannableSR.getTolerance(0);for(;y.xmin<this.m_pannableExtent.xmax;){y.move(this.m_width360,0);const A=new Wt.T;A.setShiftCoords(this.m_width360,0),g.applyTransformation(A),S.add(g,!1)}if(b){const A=S.calculateArea2D();S.setFillRule(1),S=(new Vi).execute(S,this.m_pannableSR,!0,this.m_progressTracker);const T=S.calculateArea2D();(0,Y.e)(A)!==(0,Y.e)(T)&&S.reverseAllPaths()}return S}geonormalize_ring_(t,m,u,g,d,y,C){(0,F.g)(0)}}function Sa(P){(0,F.g)(0);const t=function hc(P){const t=new sc({},!0);return t.m_WKID=P,t}(P),m=new ba;return m.setVertProj_(t),m}function cm(P){return!1}class ba{constructor(){this.m_hashCode=0,this.m_peVertSysVal=null,this.m_verticalUnit=new Tn,this.m_verticalShift=0,this.m_userVerticalWKID=0,this.m_bIsDepth=!1}getType(){return(0,F.g)(0),0}getID(){return(0,F.g)(0),0}getLatestID(){return this.m_peVertSysVal?this.m_peVertSysVal.getLatestID():0}getOldID(){return this.m_peVertSysVal?this.m_peVertSysVal.getOldID():0}getText(){return(0,F.g)(0),""}getTextExtended(t){return(0,F.g)(0),""}getText2(t){return(0,F.g)(0),""}getUnit(){return(0,F.g)(0),{}}equals(t){return(0,F.g)(0),!1}equalForProjection(t){return(0,F.g)(0),!1}getPeVertcsCopy(){return(0,F.g)(0),{}}getOneMeter(){return 1/this.m_verticalUnit.getUnitToBaseFactor()}getUnitToBaseFactor(){return(0,F.g)(0),0}isDepth(){return(0,F.g)(0),!1}getVerticalShift(){return(0,F.g)(0),0}isCustomWkid(){return!!this.m_peVertSysVal&&this.m_peVertSysVal.isCustomWkid()}getHashCode(){return this.m_hashCode}setVertProj_(t){this.m_peVertSysVal=t}getPEVerticalCoordSys(){return this.m_peVertSysVal?this.m_peVertSysVal.m_peVertcs:null}}function Sn(P,t,m,u,g){if(P.equals(t))return!1;if(u){let C=1,S=0,b=1,A=1,T=0,M=1;Number.isNaN(P.m_heightMetersPerUnit)||(C=P.m_heightMetersPerUnit,S=P.m_heightZ0,b=P.m_heightSign,A=t.m_heightMetersPerUnit,T=t.m_heightZ0,M=t.m_heightSign);const X=b*M*C/A;for(let k=0;k<g;k++)u[k]=(u[k]-S)*X+T}let d=1,y=0;if(Number.isNaN(P.m_XYToRadians)||(d=P.m_XYToRadians/t.m_XYToRadians,y=P.m_PrimeMeridianDegrees-t.m_PrimeMeridianDegrees,0!==y&&(y=(0,c.b)(y),y/=t.m_XYToRadians)),Array.isArray(m)){const C=m;for(let S=0;S<g;S++)C[S][0]=C[S][0]*d+y,C[S][1]=C[S][1]*d}else{const C=m;for(let S=0;S<g;S++){const b=S<<1;C[b]=C[b]*d+y,C[b+1]=C[b+1]*d}}return!0}function ki(){return{m_heightMetersPerUnit:0,m_heightSign:0,m_heightZ0:0,m_XYToRadians:0,m_PrimeMeridianDegrees:0,assign(P){this.m_heightMetersPerUnit=P.m_heightMetersPerUnit,this.m_heightSign=P.m_heightSign,this.m_heightZ0=P.m_heightZ0,this.m_XYToRadians=P.m_XYToRadians,this.m_PrimeMeridianDegrees=P.m_PrimeMeridianDegrees},equals(P){return(0,Y.a3)(this.m_heightSign,P.m_heightSign)&&(0,Y.a3)(this.m_heightMetersPerUnit,P.m_heightMetersPerUnit)&&(0,Y.a3)(this.m_heightZ0,P.m_heightZ0)&&(0,Y.a3)(this.m_XYToRadians,P.m_XYToRadians)&&(0,Y.a3)(this.m_PrimeMeridianDegrees,P.m_PrimeMeridianDegrees)},initFromGcsAndVcsPe(P,t){this.m_heightSign=1,this.m_heightMetersPerUnit=Number.NaN,this.m_heightZ0=0,this.m_XYToRadians=Number.NaN,this.m_PrimeMeridianDegrees=Number.NaN,t&&(0,F.g)(0),P&&(this.m_XYToRadians=P.getUnit().getUnitFactor(),this.m_PrimeMeridianDegrees=P.getPrimem().getLongitude())},initFromGcsAndVcs(P,t){const m=P?P.getPECoordSys():null,u=t?t.getPEVerticalCoordSys():null;this.initFromGcsAndVcsPe(m,u)},processUnitParams(P){Number.isNaN(this.m_heightMetersPerUnit)&&(this.m_heightMetersPerUnit=P.m_heightMetersPerUnit,this.m_heightSign=P.m_heightSign,this.m_heightZ0=P.m_heightZ0),Number.isNaN(this.m_XYToRadians)&&(this.m_XYToRadians=P.m_XYToRadians,this.m_PrimeMeridianDegrees=P.m_PrimeMeridianDegrees)}}}class xo{constructor(t){this.m_constantsLoaded=-1,this.m_isUsable=-1,this.m_inputSR=null,this.m_outputSR=null,this.m_inputSRHorz=null,this.m_outputSRHorz=null,this.m_inputVCS=null,this.m_outputVCS=null,this.m_hashCode=0,this.m_areaOfUse=new dt.E,this.m_inputUnitParams=ki(),this.m_outputUnitParams=ki(),(0,F.g)(t),this.m_geogTran=t,this.m_vertTran=null,this.m_latestID=ws.getCode(this.m_geogTran),this.m_latestID<0&&(this.m_latestID=0);const m=this.m_geogTran.getGeogcs1();ws.getCode(m);const u=this.m_geogTran.getGeogcs2();ws.getCode(u),this.initUnitParams()}getLatestId(){return this.m_latestID}getText(){return this.m_geogTran?this.m_geogTran.toString():((0,F.g)(0),"")}getGeogtran(){return this.m_geogTran}getVerttran(){return null}loadConstants(t){let m=this.m_constantsLoaded;if(-1===m){if(!t){this.m_geogTran||(0,F.c)("vcs not impl");const u=this.m_geogTran.getParameters();null!==u[pe.PE_PARM_ND]&&(t=0===u[pe.PE_PARM_ND].getValue())}m=this.m_geogTran.loadConstants()?1:0,this.m_constantsLoaded=m}return 0!==m}isUsable(){let t=this.m_isUsable;return-1===t&&(this.m_isUsable=t=this.m_geogTran?this.m_geogTran?1:0:this.m_vertTran?1:0),1===t}getInputSr(t){return this.updateSrs(),t?this.m_inputSR:this.m_inputSRHorz}getOutputSr(t){return this.updateSrs(),t?this.m_outputSR:this.m_outputSRHorz}getHashCode(){let t=this.m_hashCode;return 0===t&&(t=this.m_latestID>0?(0,Y.ar)(this.m_latestID):(0,Y.aw)(this.getText()),0===t&&(t=345),this.m_hashCode=t),t}isGeogtran(){return null!==this.m_geogTran}prepareOrThrow(){}getName(){return this.isGeogtran()?this.getGeogtran().getName():((0,F.b)("vcs not impl"),"")}updateSrs(){if(this.m_inputSR||this.m_inputVCS)return;let t,m,u,g,d,y;if(this.m_geogTran){const C=this.m_geogTran.getGeogcs1(),S=vm(C),b=this.m_geogTran.getGeogcs2(),A=vm(b);let T=-1,M=-1;T=S.getVcsCode(),M=A.getVcsCode(),u=Ya(C,null,0,1),g=Ya(b,null,0,1),T>0&&M>0?(d=Sa(T),y=Sa(M),t={},m={}):(t=u,m=g)}else(0,F.g)(0);this.m_inputSR||this.m_inputVCS||(this.m_inputSR=t,this.m_outputSR=m,this.m_inputSRHorz=u,this.m_outputSRHorz=g,this.m_inputVCS=d,this.m_outputVCS=y)}initUnitParams(){if(this.m_inputUnitParams.m_heightSign=1,this.m_inputUnitParams.m_heightMetersPerUnit=Number.NaN,this.m_inputUnitParams.m_heightZ0=0,this.m_outputUnitParams.m_heightSign=1,this.m_outputUnitParams.m_heightMetersPerUnit=Number.NaN,this.m_outputUnitParams.m_heightZ0=0,this.m_inputUnitParams.m_XYToRadians=Number.NaN,this.m_inputUnitParams.m_PrimeMeridianDegrees=Number.NaN,this.m_outputUnitParams.m_XYToRadians=Number.NaN,this.m_outputUnitParams.m_PrimeMeridianDegrees=Number.NaN,this.m_vertTran)(0,F.g)(0);else if(this.m_geogTran){const t=this.m_geogTran;let m=t.getGeogcs1();this.m_inputUnitParams.m_XYToRadians=m.getUnit().getUnitFactor(),this.m_inputUnitParams.m_PrimeMeridianDegrees=m.getPrimem().getLongitude(),m=t.getGeogcs2(),this.m_outputUnitParams.m_XYToRadians=m.getUnit().getUnitFactor(),this.m_outputUnitParams.m_PrimeMeridianDegrees=m.getPrimem().getLongitude()}}}function vn(P,t,m,u,g,d,y){let C=null;t&&(C=t.getPEVerticalCoordSys());let S=null;P&&(S=P.getPECoordSys());let b=null;u&&(b=u.getPEVerticalCoordSys());let A=null;if(m&&(A=m.getPECoordSys()),!(S||C||A||b))return!1;const T=ki();T.initFromGcsAndVcsPe(S,C);const M=ki();return M.initFromGcsAndVcsPe(A,b),Sn(T,M,g,d,y)}function Wn(P,t,m,u,g,d,y,C){const S=t,b=P,A=ki();A.initFromGcsAndVcsPe(b,S),C.assign(u?m.m_outputUnitParams:m.m_inputUnitParams),C.processUnitParams(A),A.processUnitParams(C),y>0&&Sn(A,C,g,d,y)}function zl(P,t,m,u,g,d,y,C,S){const b=ki(),A=ki();b.assign(m?t.m_inputUnitParams:t.m_outputUnitParams),A.assign(g?u.m_outputUnitParams:u.m_inputUnitParams),b.processUnitParams(P),A.processUnitParams(b),b.processUnitParams(A),C>0&&Sn(b,A,d,y,C),S.assign(A)}function wa(P,t,m,u,g,d,y){const C=t.getVerttran(),S=t.getGeogtran();if(y.assign(m?t.m_inputUnitParams:t.m_outputUnitParams),y.processUnitParams(P),d>0){t.prepareOrThrow();const b=m?pe.PE_TRANSFORM_2_TO_1:pe.PE_TRANSFORM_1_TO_2;C?at():pt(S,d,u,g,b)}}class Po{supportsCurves(){return!0}accelerateGeometry(t,m,u){return yo(t,m,u)}canAccelerateGeometry(t){return bn(t)}}function yo(P,t,m){if(!bn(P))return!1;(0,dt.W)(t,P,!1);let u=0;const g=P.getGeometryType();return(0,F.h)(g)&&(0,c.U)(P)&&0!==m&&(u|=P.getImpl().buildQuadTreeAccelerator(m)?1:0),(0,F.h)(g)&&(0,c.V)(P)&&0!==m&&(u|=P.getImpl().buildQuadTreeForPathsAccelerator(m)?1:0),u>0}function bn(P){return(0,c.U)(P)||(0,c.V)(P)}class gm extends Po{getOperatorType(){return 8}execute(t,m,u,g){return Ki(t,m,u,1,g)}}class Eo{getOperatorType(){return 10002}supportsCurves(){return!0}accelerateGeometry(t,m,u){return!1}canAccelerateGeometry(t){return!1}executeMany(t,m,u,g){return new dm(t,m,u,g)}execute(t,m,u,g){return this.executeMany(new ee.S([t]),new ee.S([m]),u,g).next()}}class dm extends ee.G{constructor(t,m,u,g){super(),this.m_progressTracker=g,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=u;const d=m.next();this.m_geomSubtractor=d||new c.a}next(){const t=this.m_inputGeoms.next();return t?((0,F.d)(t),(0,F.B)(t),this.m_index=this.m_inputGeoms.getGeometryID(),function _m(P,t,m,u){if(P.isEmpty()||t.isEmpty())return P;const g=P.getDimension(),d=t.getDimension();if(g>d)return P;const y=P.getGeometryType(),C=t.getGeometryType(),S=new R.J,b=new R.J,A=new R.J;P.queryEnvelope(S),t.queryEnvelope(b),A.setCoords({env2D:S}),A.mergeEnvelope2D(b);const T=(0,dt.a)(m,A,!0),M=(0,dt.d)(T),X=new R.J;if(X.setCoords({env2D:S}),X.inflateCoords(M,M),!X.isIntersecting(b))return P;if(1===g&&2===d){const H=function ym(P,t,m,u,g){const d=new dt.E;P.queryEnvelope(d);const y=new R.J;t.queryEnvelope(y),d.merge(y);const C=.1*d.width(),S=.1*d.height();d.inflateCoords(C,S);const b=new c.a;b.addEnvelope(d,!1);const A=b.getImpl();if(m===F.G.enumPolygon){const T=t.getImpl();A.add(T,!0)}else A.addEnvelope(t,!0);return new gi(b,u,-1,g).tryFastImplementation(P)}(P,t,C,m,u);if(H)return H}if(y===F.G.enumPoint){let H;switch((0,F.f)(C)?(H=new c.P({vd:t.getDescription()}),H.addSegment(t,!0)):H=t,C){case F.G.enumPolygon:return function jn(P,t,m,u){return 0===Gh(t,P,m.total())?P:P.createInstance()}(P,H,T);case F.G.enumPolyline:return function pm(P,t,m,u){const g=P.getXY(),d=t.querySegmentIterator(),y=(0,dt.d)(m),C=y*y;for(;d.nextPath();)for(;d.hasNextSegment();){const S=d.nextSegment(),b=new R.J;if(S.queryEnvelope(b),b.inflateCoords(y,y),!b.contains(g))continue;if(S.isIntersectingPoint(g,m.total()))return P.createInstance();let A=S.getStartXY();if(Y.P.sqrDistance(g,A)<=C||(A=S.getEndXY(),Y.P.sqrDistance(g,A)<=C))return P.createInstance()}return P}(P,H,T);case F.G.enumMultiPoint:return function Ul(P,t,m,u){const g=t.getImpl().getAttributeStreamRef(0),d=t.getPointCount(),y=P.getXY(),C=(0,dt.d)(m),S=C*C,b=new Y.P;for(let A=0;A<d;A++)if(g.queryPoint2D(2*A,b),Y.P.sqrDistance(b,y)<=S)return P.createInstance();return P}(P,H,T);case F.G.enumEnvelope:return function Vr(P,t,m,u){const g=new R.J;t.queryEnvelope(g),g.inflate(m.total());const d=P.getXY();return g.contains(d)?P.createInstance():P}(P,H,T);case F.G.enumPoint:return function fm(P,t,m,u){const g=(0,dt.d)(m),d=g*g,y=P.getXY(),C=t.getXY();return Y.P.sqrDistance(y,C)<=d?P.createInstance():P}(P,H,T);default:(0,F.t)("invalid shape type")}}else if(y===F.G.enumMultiPoint)switch(C){case F.G.enumPolygon:return function xm(P,t,m,u){const g=new R.J;t.queryEnvelope(g),g.inflate(m.total());const d=P.getPointCount();let y=!1;const C=(0,Y.d)(d,!1),S=new Y.P;for(let A=0;A<d;A++)P.queryXY(A,S),g.contains(S)&&0!==ti(t,S,m.total())&&(y=!0,C[A]=!0);if(!y)return P;const b=P.createInstance();for(let A=0;A<d;A++)C[A]||b.addPoints(P,A,A+1);return b}(P,t,T);case F.G.enumEnvelope:return function Pm(P,t,m,u){const g=new R.J;t.queryEnvelope(g),g.inflate(m.total());const d=P.getPointCount();let y=!1;const C=(0,Y.d)(d,!1),S=new Y.P;for(let A=0;A<d;A++)P.queryXY(A,S),g.contains(S)&&(y=!0,C[A]=!0);if(!y)return P;const b=P.createInstance();for(let A=0;A<d;A++)C[A]||b.addPoints(P,A,A+1);return b}(P,t,T);case F.G.enumPoint:return function Ol(P,t,m,u){const g=P.getImpl().getAttributeStreamRef(0),d=P.getPointCount(),y=t.getXY();let C=!1;const S=(0,Y.d)(d,!1),b=(0,dt.d)(m),A=b*b,T=new Y.P;for(let X=0;X<d;X++)g.queryPoint2D(2*X,T),Y.P.sqrDistance(T,y)<=A&&(C=!0,S[X]=!0);if(!C)return P;const M=P.createInstance();for(let X=0;X<d;X++)S[X]||M.addPoints(P,X,X+1);return M}(P,t,T)}const k=new R.J(S);return k.inflate(100*T.total()),function vl(P,t,m,u){if(P.isEmpty()||t.isEmpty()||P.getDimension()>t.getDimension())return hi(us(P),P,0,"-");const g=new R.J;P.queryEnvelope(g);const d=new R.J;t.queryEnvelope(d);const y=new R.J;y.setCoords({env2D:g}),y.mergeEnvelope2D(d);const C=(0,dt.a)(m,y,!0),S=d.clone(),b=(0,dt.d)(C);if(S.inflateCoords(b,b),!g.isIntersecting(S))return hi(us(P),P,0,"-");const A=new ai(u),T=new c.E,M=T.addGeometry(us(P)),X=T.addGeometry(us(t));let k=0,H=0,U=null;if(T.hasCurves()){U=new ci;const mt=T.getEnvelope2D(u);H=Ai(C.total());const ht=oi(C.total(),mt);k=xi(ht,H),ri(T,ht,C.total(),0,U,null,u)}A.setEditShapeCrackAndCluster(T,C.add(k));const Z=A.difference(M,X);null!==U&&U.stitchCurves(T,Z,H,!0);const st=hi(T.getGeometry(Z),P,0,"-");return uo(st.getGeometryType())&&(st.getImpl().setIsSimple(4,C.total()),st.getGeometryType()===F.G.enumPolygon&&st.getImpl().updateOGCFlagsProtected()),st}(P,(0,Rt.c)(t,k,0,0,u),m,u)}(t,this.m_geomSubtractor,this.m_spatialReference,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class Co{getOperatorType(){return 10001}supportsCurves(){return!0}accelerateGeometry(t,m,u){return!1}canAccelerateGeometry(t){return!1}executeMany(t,m,u,g=0){return new Yr(t,m,u,g)}execute(t,m,u,g){const d=new ee.S([t,m]),y=new Yr(d,u,g,0).next();return y||(0,F.c)("null output"),y}}class jl{constructor(){this.binVertexCount=0,this.geometries=[]}addPair(t){this.binVertexCount+=t.vertexCount,this.geometries.push(t)}sort(){this.geometries.sort((t,m)=>function Em(P,t){return Y.P.compareZorder(P.location,t.location)?-1:P.location.equals(t.location)?0:1}(t,m))}geomCount(){return this.geometries.length}geomPairs(){return this.geometries}clear(){this.binVertexCount=0,this.geometries.length=0}getBinVertexCount(){return this.binVertexCount}}class Yr extends ee.G{constructor(t,m,u,g,d=!1){super(),this.m_index=-1,this.m_currentDim=-1,this.m_bDone=!1,this.m_unionBins=[],this.m_readyGeoms=(0,Y.as)(4),this.m_dimGeomCounts=(0,Y.d)(4,0),this.m_addedGeoms=0,this.m_maxDimension=-1,this.m_bHadGeometry=(0,Y.d)(4,!1),this.m_complexUnionGeoms=(0,Y.as)(4),this.m_totalNonEmptyGeomCounters=(0,Y.d)(4,0),this.m_progressTracker=u,this.m_bUnionAllDimensions=!!(4&g),this.m_bPreserveAllPathEnds=!!(8&g),this.m_inputGeoms=t,this.m_spatialReference=m,this.m_options=g,this.m_bIs3D=d}next(){if(this.m_bDone&&this.m_currentDim===this.m_maxDimension)return null;for(;!this.step_(););if(-1===this.m_maxDimension)return null;if(this.m_bUnionAllDimensions){if(-1===this.m_currentDim)for(let t=0;t<=this.m_maxDimension;t++)if(this.m_bHadGeometry[t]){this.m_complexUnionGeoms[t]=this.getResultGeometry(t);for(let m=t+1;m<=this.m_maxDimension;m++)this.m_complexUnionGeoms[m]=this.getResultGeometry(m),this.m_bHadGeometry[m]&&!this.m_complexUnionGeoms[m].isEmpty()&&(this.m_bIs3D?(0,F.g)(0):this.m_complexUnionGeoms[t]=(new Eo).execute(this.m_complexUnionGeoms[t],this.m_complexUnionGeoms[m],this.m_spatialReference,this.m_progressTracker))}for(;this.m_currentDim++,(this.m_currentDim>this.m_maxDimension||this.m_currentDim<0)&&(0,F.c)(""),!this.m_bHadGeometry[this.m_currentDim];);if(this.m_index++,0===this.m_currentDim&&this.m_complexUnionGeoms[this.m_currentDim].getGeometryType()===F.G.enumPoint){const t=new c.M({vd:this.m_complexUnionGeoms[this.m_currentDim].getDescription()});return this.m_complexUnionGeoms[this.m_currentDim].isEmpty()||t.add(this.m_complexUnionGeoms[this.m_currentDim]),t}return this.m_complexUnionGeoms[this.m_currentDim]}return this.m_index=0,this.m_currentDim=this.m_maxDimension,this.getResultGeometry(this.m_maxDimension)}getGeometryID(){return this.m_index}getRank(){return 1}tock(){return this.step_()}getResultGeometry(t){return this.m_readyGeoms[t]}finishDim(t,m,u){let g=m;if(!u)return 16&this.m_options&&(g=Gr([g],1,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D)),g;if(1&this.m_options)return g;if(1===t)if(8&this.m_options||!(16&this.m_options||this.m_totalNonEmptyGeomCounters[t]>1))1===this.m_totalNonEmptyGeomCounters[t]&&(this.m_bIs3D?(0,F.g)(0):g=(new Vi).execute(g,this.m_spatialReference,!1,this.m_progressTracker));else{g=Gr([g],1,this.m_spatialReference,this.m_progressTracker,16|this.m_options,this.m_bIs3D);const d=[0],y=g.getImpl().getIsSimple(0,d);(0,F.g)(this.m_bIs3D||(0,dt.i)(y))}else this.m_bIs3D?(0,F.g)(0):g=(new Vi).execute(g,this.m_spatialReference,!1,this.m_progressTracker);if(0===t&&g.getGeometryType()===F.G.enumPoint){const d=new c.M({vd:g.getDescription()});g.isEmpty()||d.add(g),g=d}return g}static getLevel(t){const u=(0,F.v)(t);let g=u>0?(Math.log(u)-Math.log(32))/Math.log(4):0;return g<0&&(g=0),Math.floor(g)}step_(){if(this.m_bDone)return!0;let t;if(this.m_inputGeoms?(t=this.m_inputGeoms.next(),null===t?(this.m_bDone=!0,this.m_inputGeoms=null):(this.checkAndThrow(t),t.isEmpty()||this.m_totalNonEmptyGeomCounters[t.getDimension()]++)):t=null,null!==t){const m=t.getDimension();this.m_bHadGeometry[m]=!0,(m>=this.m_maxDimension||this.m_bUnionAllDimensions)&&(this.addGeom(m,!1,t),m>this.m_maxDimension&&!this.m_bUnionAllDimensions&&this.removeAllBinsWithLowerDimension(m))}if(this.m_addedGeoms>0)for(let m=0;m<=this.m_maxDimension;m++){for(;this.m_dimGeomCounts[m]>1;){const u=this.collectGeometriesToUnion(m);if(null===u)break;{let g;g=1&this.m_options?Gr(u,u.length,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D):ia(u,u.length,this.m_spatialReference,this.m_progressTracker,8|this.m_options,this.m_bIs3D),this.addGeom(m,!0,g)}}if(this.m_bDone&&((0,F.g)(this.m_dimGeomCounts[m]<=1),0!==this.m_dimGeomCounts[m])){const u=this.m_unionBins[m].entries().next().value,g=u[1].geomPairs()[0].geom,d=u[1].geomPairs()[0].bUnioned;this.m_unionBins[m].clear(),this.m_readyGeoms[m]=this.finishDim(m,g,d)}}return this.m_bDone}addGeom(t,m,u){const g=function Wl(){return{geom:null,vertexCount:-1,bUnioned:!1,location:new Y.P}}();g.geom=u;const d=(0,F.v)(u);g.vertexCount=d;const y=R.J.constructEmpty();u.queryEnvelope(y),g.location=d>0?y.getCenter():new Y.P(0,0);const C=Yr.getLevel(u);if(t+1>this.m_unionBins.length)for(;this.m_unionBins.length<Math.max(2,t+1);)this.m_unionBins.push(new Map);let S=null;const b=this.m_unionBins[t].get(C);b&&(S=b),null===S&&(S=new jl,this.m_unionBins[t].set(C,S)),g.bUnioned=m,S.addPair(g),this.m_dimGeomCounts[t]++,this.m_addedGeoms++,this.m_maxDimension=Math.max(this.m_maxDimension,t)}removeAllBinsWithLowerDimension(t){for(let m=0;m<t;m++)this.m_unionBins[m].clear(),this.m_addedGeoms-=this.m_dimGeomCounts[m],this.m_dimGeomCounts[m]=0}collectGeometriesToUnion(t){if(1&this.m_options&&!this.m_bDone)return null;let m=null;const u=[];for(const g of this.m_unionBins[t].keys())u.push(g);(0,Y.v)(u);for(let g=0;g<u.length;g++){if(-1===u[g])continue;const d=this.m_unionBins[t].get(u[g]);{const S=d.getBinVertexCount()>5e3&&d.geomCount()>=4;if(this.m_bDone||S){for(let b=0;b<g;b++){if(-1===u[b])continue;const A=this.m_unionBins[t].get(u[b]);A.sort(),this.m_dimGeomCounts[t]-=A.geomCount(),this.m_addedGeoms-=A.geomCount();for(const T of A.geomPairs())m||(m=new Array),m.push(T.geom);A.clear(),this.m_unionBins[t].delete(u[b]),u[b]=-1}d.sort(),this.m_dimGeomCounts[t]-=d.geomCount(),this.m_addedGeoms-=d.geomCount();for(const b of d.geomPairs())m||(m=new Array),m.push(b.geom);if(d.clear(),this.m_unionBins[t].delete(u[g]),u[g]=-1,!this.m_bDone)break}}}return m}checkAndThrow(t){this.m_bIs3D&&(t.getDimension()>1&&(0,F.x)(),t.hasAttribute(1)||(0,F.t)("Geometry must have Zs")),(0,F.d)(t)}}class Mt extends Po{getOperatorType(){return 3}execute(t,m,u,g=null){return Ki(t,m,u,4,g)}}function cs(P,t,m){const u=t.getGCSSplitLines();if(null===u)return P;const g=t.getGCS(),d=g.getPannableExtent().width(),y=R.J.constructEmpty();P.queryLooseEnvelope(y);const C=Y.E.constructEmpty();y.queryIntervalX(C);const S=u.querySegmentIterator();let b=null;const A=new Wt.T;for(;S.nextPath();)for(;S.hasNextSegment();){const T=S.nextSegment(),M=T.queryInterval(0,0),X=Y.E.constructEmpty();X.setCoordsFromEnvelope(M);let k=0;for(;X.vmax>C.vmin;)X.move(-d),k--;for(;X.vmin<=C.vmax;){if(X.isIntersecting(C)){null===b&&(b=new c.P);const H=new c.L({start:T.getStartXY(),end:T.getEndXY()});0!==k&&(A.setShiftCoords(k*d,0),H.applyTransformation(A)),b.addSegment(H,!0)}X.move(d),++k}}if(null!==b){const T=(0,dt.b)(g,b,!0);return function It(P,t,m,u){const g=t.getGeometryType();if((0,F.h)(g))return new te(u).crackAWithBMultiPath_(P,t,m);(0,F.b)("crack_A_with_B")}(P,b,(0,dt.d)(T),m)}return P}function Da(P,t,m){let u=P.getName();return Bu(u)||(m||t>0?(u=P.toString(pe.PE_STR_NAME_CANON|pe.PE_STR_AUTH_NONE),u=function Zl(P){return P.toLocaleUpperCase("en-US")}(u)):u=P.toString(pe.PE_STR_AUTH_TOP)),u}function Jn(P,t=-1){return(t>1||t<-1)&&(0,F.t)("verbosity"),-1===t?P.toString():P.toString(0===t?pe.PE_STR_AUTH_TOP:pe.PE_STR_AUTH_ALL)}function Na(P,t,m,u){if(P.isEmpty()||1===m)return P;const g=P.getGeometryType();if(g===F.G.enumPoint){const ht=P,ut=ht.getXY();return 0===Fa([ut],1,t,m)||ut.isNAN()?ht.setEmpty():ht.setXY(ut),P}if(g===F.G.enumMultiPoint){const ht=P,ut=P.createInstance(),ct=ht.getPointCount();ut.reserve(ct);const Et=ht.getAttributeStreamRef(0),Tt=ht.getDescription().getAttributeCount()>1,Pt=new dt.P,At=Float64Array.from(Et.getArray());if(Fa(At,ct,t,m)>0)for(let Ht=0,Bt=2*ct;Ht<Bt;Ht+=2)Number.isNaN(At[Ht])||(Tt?(ht.getPointByVal(Ht>>1,Pt),Pt.setXYCoords(At[Ht],At[Ht+1]),ut.add(Pt)):ut.addXY(At[Ht],At[Ht+1]));return ut}let d=P;const y=t.getOneDegreeGCSUnit(),C=90*y,S=180*y,b=360*y,A=t.getCentralMeridian(),T=.5*y,M=R.J.constructEmpty();d.queryEnvelope(M);const X=t.getGCSHorizon(),k=t.getGCSHorisonIsInclusive(),H=X.getGeometryType()===F.G.enumEnvelope,U=R.J.constructEmpty();X.queryEnvelope(U);const Z=t.getGCS();if(2!==m&&4!==m||(U.xmin=A-S,U.xmax=U.xmin+b),4===m){if(!(M.width()>b-y)){const ht=R.J.constructEmpty();ht.setCoords({xmin:M.xmin-y,ymin:U.ymin,xmax:M.xmax+y,ymax:U.ymax}),d=(new Rt.O).execute(d,ht,Z,u);let ut=Math.floor((A-M.getCenterX())/b);for(M.move(ut*b,0);M.xmin>U.xmax;)ut-=1,M.move(-b,0);for(;M.xmin<U.xmin;)ut+=1,M.move(b,0);if(0!==ut){const ct=new Wt.T;ct.setShiftCoords(ut*b,0),d.applyTransformation(ct)}return d}m=2}if(2===m&&(U.xmin=A-S,U.xmax=U.xmin+b),M.ymin<-C||M.ymax>C){const ht=R.J.constructEmpty();if(ht.setCoords({xmin:M.xmin-y,ymin:-C,xmax:M.xmax+y,ymax:C}),d=(new Rt.O).execute(d,ht,Z,u),d.isEmpty())return d;d.queryEnvelope(M)}if(k&&(U.ymax<M.ymin||U.ymin>M.ymax))return d.createInstance();M.width()>b&&(d=gn(d,A-S,b,Z,!0,0,!0,u),d.queryEnvelope(M));let st=function $n(P,t,m,u,g){return P>=m&&t<=u?0:qa(.5*(t+P),m,u,g)}(M.xmin,M.xmax,U.xmin,U.xmax,b);if(0!==st&&M.move(st,0),M.xmax>U.xmax||M.xmin<U.xmin){if(M.xmax>U.xmax)for(;M.xmin>=U.xmax;)M.move(-b,0),st-=b;for(;M.xmin<U.xmax-b;)M.move(b,0),st+=b}const mt=(0,dt.W)(Z,X,!1);if(0!==st){const ht=new Wt.T;ht.setShiftCoords(st,0),d.applyTransformation(ht),st=0}if(k){if(H&&U.containsEnvelope(M))return d;const ht=new Array(2);for(let ut=0;ut<2;ut++){let ct;if(H?ct=(0,F.h)(g)?(0,Rt.c)(d,U,mt,T,u):(0,Rt.c)(d,U,mt,0,u):(ct=(new mi).execute(d,X,Z,u),ct===X&&(ct=ct.clone())),U.xmin<=M.xmin&&U.xmax>=M.xmax||U.xmin>=M.xmin&&U.xmax<=M.xmax)return ct;if(ht[ut]=ct,0===ut){M.move(-b,0);const Et=new Wt.T;Et.setShiftCoords(-b,0),d.applyTransformation(Et)}}return(0,F.h)(g)?ht[0].add(ht[1],!1):(0,F.c)("intersect_with_GCS_horizon: unexpected geometry type"),ht[0]}{if(U.ymax<M.ymin||U.ymin>M.ymax)return d;let ht=0;for(;!d.isEmpty()&&M.xmax>U.xmin;){if(0!==ht){const ut=new Wt.T;ut.setShiftCoords(ht,0),d.applyTransformation(ut)}if((new Mt).execute(d,X,Z,u)||(d=(new Eo).execute(d,X,Z,u),X===d&&(d=d.clone())),0!==ht){const ut=new Wt.T;ut.setShiftCoords(-ht,0),d.applyTransformation(ut)}ht-=b,M.move(-b,0)}return d}}function Kl(P,t,m,u,g,d){const y={stack:[],error:void 0,hasError:!1};try{if(2===d)return function fe(P,t,m,u,g){if(Math.abs(m.x-u.x)>Math.PI||Math.abs(m.y)>Y.l||Math.abs(u.y)>Y.l||(Math.abs(m.y)===Y.l||Math.abs(u.y)===Y.l)&&m.x!==u.x)return Number.NaN;const{first:d,second:y}=(0,Y.aC)(m.x,u.x);let C=g;if(C=xe(C,d,y),!Y.E.construct(m.x,u.x).containsCoordinate(C))return Number.NaN;const S=c.W.constructPoint2D(m),b=c.W.constructPoint2D(u),A=ve(1,t,S),T=ve(1,t,b),M=A.crossProductVector(T);if(M.z.isZero())return m.y;const X=M.x.divE(M.z.negate()),k=M.y.divE(M.z.negate()),H=X.mulE(X).addE(k.mulE(k)).sqrt();if(H.isZero()||X.isZero()&&k.isZero())return m.y;const U=Math.atan2(k.value(),X.value());let Z=Math.atan2(H.value()*Math.cos(U-C),1-t);const st=$t(1,t,Y.P.construct(C,Z)),mt=dt.h.construct(st.x,st.y,-st.z),ht=M.value().dotProduct(st),ut=M.value().dotProduct(mt);return Math.abs(ut)<Math.abs(ht)&&(Z=-Z),Z}(0,t,m,u,g);if(Math.abs(m.x-u.x)>=Math.PI||!Ms(m.x,u.x,g))return Number.NaN;m.x>u.x&&(u=(0,Y.b)(m,m=u));const C=(0,vt.b)(y,new js,!1),S=(0,vt.b)(y,new js,!1),b=(0,vt.b)(y,new js,!1),A=m.clone();Si.geodeticDistance(P,t,m.x,m.y,u.x,u.y,S,C,null,d);const T=S.val;let M=0,X=1;for(;T*(X-M)>1e-12*P;){const k=.5*(M+X);if(Si.geodeticCoordinate(P,t,m.x,m.y,T*k,C.val,S,b,d),A.x=S.val,A.y=b.val,A.x===g)return A.y;if(Ms(m.x,A.x,g))X=k;else{if(!Ms(u.x,A.x,g))return Number.NaN;M=k}}return A.y}catch(C){y.error=C,y.hasError=!0}finally{(0,vt.c)(y)}}function Ga(P,t,m,u){for(let g=0,d=0;g<u;g++,d+=2)t[m+g].x=P[d],t[m+g].y=P[d+1]}function Fa(P,t,m,u){if(0===t||1===u)return t;const g=function Aa(P,t){let m;if(Array.isArray(P)){const u=P;m=new Float64Array(2*t);for(let g=0,d=0;g<t;g++,d+=2)m[d]=u[g].x,m[d+1]=u[g].y}else m=P;return m}(P,t);if(2===u){const H=m.getPannableExtentInGCS();let U=t;for(let Z=0,st=2*t;Z<st;Z+=2)(g[Z+1]>H.ymax||g[Z+1]<H.ymin)&&(g[Z]=Number.NaN,U--);return U?(So(g,t,H.xmin,H.width(),!0),P!==g&&Ga(g,P,0,t),U):0}const d=m.getOneDegreeGCSUnit(),y=90*d,C=180*d,S=360*d;let b=t;for(let H=0,U=2*t;H<U;H+=2)(g[H+1]>y||g[H+1]<-y)&&(g[H]=Number.NaN,b--);if(!b)return 0;const A=R.J.constructEmpty();A.setFromPoints(g,t);const T=m.getGCSHorizon(),M=m.getGCSHorisonIsInclusive(),X=T.getGeometryType()===F.G.enumEnvelope,k=R.J.constructEmpty();if(T.queryEnvelope(k),M&&(k.ymax<A.ymin||k.ymin>A.ymax))return 0;if(M)if(So(g,t,k.getCenterX()-C,S,!0),b=t,X)for(let H=0,U=2*t;H<U;H+=2)k.containsCoords(g[H],g[H+1])||(g[H]=Number.NaN,b--);else{const H=(0,dt.W)(m.getGCS(),T,!1),U=new Y.P;for(let Z=0,st=2*t;Z<st;Z+=2)U.setCoords(g[Z],g[Z+1]),0!==ti(T,U,H)||(g[Z]=Number.NaN,b--)}else{So(g,t,-C,S,!0),b=t;const H=(0,dt.W)(m.getGCS(),T,!1),U=new Y.P;for(let Z=0,st=2*t;Z<st;Z+=2){U.setCoords(g[Z],g[Z+1]),U.isNAN()&&b--;const mt=qa(U.x,k.xmin,k.xmax,S);U.x+=mt,0!==ti(T,U,H)&&(g[Z]=Number.NaN,b--)}}return b>0&&Array.isArray(P)&&Ga(g,P,0,t),b}function Qn(P,t,m,u,g,d){if(t.isPannable()||(0,F.t)("fold_into_360_degree_range"),P.isEmpty())return P;let y,C;if(2===t.getCoordinateSystemType()){const S=t.getPannableExtent();C=S.xmin,y=S.width()}else{const S=t.getOneDegreeGCSUnit();y=360*S,C=m-180*S}return gn(P,C,y,t,u,g,!0,d)}function nn(P,t,m,u){let g,d;if(2===m.getCoordinateSystemType()){const y=m.getPannableExtent();g=y.xmin,d=y.width()}else{const y=m.getOneDegreeGCSUnit();d=360*y,g=u-180*y}So(P,t,g,d)}function Xr(P,t){const m=t.width();let u=(0,Y.o)(P-t.vmin,m);return u<0&&(u+=m),t.snapClip(u+t.vmin)}function In(P,t,m){return P>t.xmax&&P-t.xmax<m?t.xmax:P<t.xmin&&t.xmin-P<m?t.xmin:P}function Rr(P,t,m){if(P[0]<t.vmin||P[0]>t.vmax||m&&P[0]===t.vmax){const u=t.width();return P[0]+=Math.ceil((t.vmin-P[0])/u)*u,P[0]=t.snapClip(P[0]),!0}return!1}function Kn(P,t,m,u,g){const d=new c.E,y=d.addGeometry(P);return wn(d,y,t,(0,dt.W)(t,P,!1),m,u,g),d.getGeometry(y)}function wn(P,t,m,u,g,d,y){const C={stack:[],error:void 0,hasError:!1};try{(0,F.g)(Bi()),m.isPannable()||(0,F.m)("insert_geodetic_points");const S=m.getPannableExtent(),b=m.getGCS(),A=Lr();b.querySpheroidData(A);const T=b.getUnit().getUnitToBaseFactor(),M=A.majorSemiAxis,X=A.e2;let k=0;const H=new Y.E;S.queryIntervalX(H);let U=null;const Z=(0,Y.d)(4,Number.NaN);2===m.getCoordinateSystemType()?(U=m.getPECoordSys(),d?(Z[0]=Xr(y,H),Z[1]=S.getCenterY(),Hs.projToGeog(U,1,Z),k=Z[0]*T):(Z[0]=S.getCenterX(),Z[1]=y,Hs.projToGeog(U,1,Z),k=Z[1]*T)):k=y*T,d||0===k||2===g||(0,F.m)("insert_geodetic_points: 1");const st=(0,vt.b)(C,new js,!1),mt=new Y.P,ht=new Y.P,ut=new Y.P,ct=new Y.P,Et=new Y.P,Tt=new Y.P;for(let Pt=P.getFirstPath(t);Pt!==c.n;Pt=P.getNextPath(Pt)){const At=P.getFirstVertex(Pt);P.queryXY(At,ut);let Ht=!1;const Bt=P.getNextVertex(At);for(let kt=Bt;kt!==c.n;kt=P.getNextVertex(kt)){if(kt===Bt){if(Ht)break;Ht=!0}if(P.queryXY(kt,ct),d&&(u<y-ut.x&&ct.x-y>u||u<y-ct.x&&ut.x-y>u)||!d&&(0!==y||u<-ut.y&&ct.y>u||u<-ct.y&&ut.y>u))do{if(Math.abs(ut.x-ct.x)>=.5*H.width())break;2===m.getCoordinateSystemType()?(Z[0]=Xr(ut.x,H),Z[1]=ut.y,Z[2]=Xr(ct.x,H),Z[3]=ct.y,L(U,2,Z,0),Et.x=Z[0]*T,Et.y=Z[1]*T,Tt.y=Z[3]*T):(Et.x=ut.x*T,Et.y=ut.y*T,Tt.y=ct.y*T),Tt.x=(ct.x-ut.x)*Math.PI*2/H.width()+Et.x;let wt=0;const Xt=(0,Y.m)(Y.P,2);if(d){if(ht.x=k,ht.y=Kl(M,X,Et,Tt,k,g),Number.isNaN(ht.y))break;Xt[0]=ht,wt=1}else if(2===g){const zt=[0,0];if(wt=os(0,X,Et,Tt,k,zt),!wt)break;Xt[0].x=zt[0],Xt[0].y=k,2===wt&&(Xt[1].x=zt[1],Xt[1].y=k)}else{if(ht.x=Ge(M,X,Et,Tt,g),Number.isNaN(ht.x))break;ht.y=0,Xt[0]=ht,wt=1}let Zt=-1;for(let zt=0;zt<wt;zt++){Si.geodeticDistance(M,X,Et.x,Et.y,Tt.x,Tt.y,st,null,null,g);const ge=st.val;Si.geodeticDistance(M,X,Et.x,Et.y,Xt[zt].x,Xt[zt].y,st,null,null,g);const qt=st.val;2===m.getCoordinateSystemType()?(Z[0]=Xt[zt].x/T,Z[1]=Xt[zt].y/T,Hs.geogToProj(U,1,Z),d?(mt.y=Z[1],mt.x=y):(mt.x=ei(Z[0],ut.x,ct.x,H),mt.y=y)):d?(mt.x=y,mt.y=Xt[zt].y/T):(mt.x=ei(Xt[zt].x/T,ut.x,ct.x,H),mt.y=y);const ce=ge>0?(0,Y.c)(qt/ge,0,1):.5;if(0===ce||1===ce||Zt>ce)continue;const be=P.getPrevVertex(kt);P.splitSegment(be,[ce],1);const Me=P.getNextVertex(be);P.setXYCoords(Me,mt.x,mt.y),Zt=ce}}while(0);ut.setCoordsPoint2D(ct)}}}catch(S){C.error=S,C.hasError=!0}finally{(0,vt.c)(C)}}function Fs(P,t){(0,F.g)(t.isPannable());const m=t.getPannableExtent();if(P.getGeometryType()===F.G.enumPoint){const C=P.getY();return m.ymin<=C&&C<=m.ymax?P:P.createInstance()}const u=R.J.constructEmpty();P.queryEnvelope(u);const g=R.J.constructEmpty();g.setCoords({env2D:m}),g.xmin=u.xmin,g.xmax=u.xmax,g.inflateCoords(.01*g.height(),0);const d=(0,dt.c)(t,u,!1);let y;return y=g.containsEnvelope(u)?P:(0,Rt.c)(P,g,d,0,null),y}function qa(P,t,m,u){return(0,Y.av)((.5*(m+t)-P)/u)*u}function gn(P,t,m,u,g,d,y,C){const S=P.getGeometryType(),b=Y.E.constructEmpty();b.setCoords(t,t+m);const A=[0];if(S===F.G.enumPoint){if(A[0]=P.getX(),Rr(A,b,y)){const Tt=g?P:P.clone();return Tt.setX(A[0]),Tt}return P}const T=R.J.constructEmpty();if(P.queryEnvelope(T),T.isEmpty())return P;if(S===F.G.enumMultiPoint){const Et=g?P:P.clone(),Tt=Et.getImpl(),Pt=Tt.getAttributeStreamRef(0),At=2*Tt.getPointCount();let Ht=!1;for(let Bt=0;Bt<At;Bt+=2)A[0]=Pt.read(Bt),Rr(A,b,y)&&(Pt.write(Bt,A[0]),Ht=!0);return Ht&&Tt.notifyModifiedFlags(2001),Et}const M=Y.E.constructEmpty();if(T.queryIntervalX(M),b.contains(M))return P;const X=R.J.constructEmpty();if(X.setCoords({env2D:T}),0===M.width()){let Et=M.vmin;Et+=Math.ceil((b.vmin-Et)/m)*m,Et=b.snapClip(Et);const Tt=g?P:P.clone();return Tt.setAttributeBasic(0,0,Et),Tt}if(S===F.G.enumEnvelope){const Et=g?P:P.clone();return T.intersect(X),Et.setEnvelope(T),Et}const k=.1*Math.max(T.height(),T.width())*1;X.inflateCoords(0,k);let H=P;const U=u.getTolerance(0),Z=new Wt.T;for(;;){const Et=Math.floor((M.vmin-t)/m),Tt=Math.ceil((M.vmax-t)/m);if(!(Tt-Et>3))break;{const Pt=Math.floor(.5*(Tt+Et));X.xmin=T.xmin-k,X.xmax=t+m*Pt;const At=(0,Rt.c)(H,X,U,d,C);X.xmin=X.xmax,X.xmax=T.xmax+k;const Ht=(0,Rt.c)(H,X,U,d,C);Z.setShiftCoords((Pt-Tt)*m,0),Ht.applyTransformation(Z),S===F.G.enumPolygon?H=(new Co).execute(At,Ht,u,C):(H=At,H.add(Ht,!1)),H.queryEnvelope(T),T.queryIntervalX(M)}}X.xmin=t,X.xmax=t+m;const st=R.J.constructEmpty();st.setCoords({env2D:X}),st.inflateCoords(U,0);const mt=Math.floor((T.xmin-X.xmin)/m)*m;let ht;mt?(X.move(mt,0),Z.setShiftCoords(-mt,0)):Z.setIdentity(),ht=S===F.G.enumPolyline?new c.P({vd:H.getDescription()}):new c.a({vd:H.getDescription()});const ut=R.J.constructEmpty(),ct=R.J.constructEmpty();for(;T.xmax>X.xmin;){const Et=(0,Rt.c)(H,X,U,0,C);Et.queryEnvelope(ct);let Tt=!1;Tt=S===F.G.enumPolyline?!Et.isEmpty()&&(ct.width()>U||ct.height()>U):!Et.isEmpty()&&(S!==F.G.enumPolygon||ct.width()>U),Tt&&(Et.applyTransformation(Z),Et.queryEnvelope(ct),ht.queryEnvelope(ut),ut.inflateCoords(U,U),ut.isIntersecting(ct)&&S===F.G.enumPolygon?ht=(new Co).execute(ht,Et,u,C):ht.add(Et,!1)),X.move(m,0),Z.shiftCoords(-m,0)}return ht}function So(P,t,m,u,g=!0){const d=new Y.E;d.setCoords(m,m+u);const y=[0];if(Array.isArray(P)){const C=P;for(let S=0;S<t;S++)d.containsRightExclusive(C[S].x)||(y[0]=C[S].x,Rr(y,d,g),C[S].x=y[0])}else{const C=P;for(let S=0;S<t;S++){const b=S<<1;d.containsRightExclusive(C[b])||(y[0]=C[b],Rr(y,d,g),C[b]=y[0])}}}function Ws(P,t,m,u=!0){if(P.isEmpty())return;const g=P.getGeometryType();if(!u||g!==F.G.enumPolygon)if((0,F.i)(g)){let d=!1;if((0,F.h)(g)&&P.hasNonLinearSegments()){const y=P.getImpl(),C=y.getAttributeStreamRef(0),S=y.getSegmentFlagsStreamRef();(0,F.g)(null!==S);for(let b=0,A=y.getPathCount();b<A;b++){let T=!0;const M=y.isClosedPath(b),X=y.getPathEnd(b);M&&y.getPathSize(b)>0&&(T=1==(31&S.read(X-1)));for(let k=y.getPathStart(b);k<X;k++)if(1==(31&S.read(k))){if(T){const H=C.read(2*k),U=In(H,t,m);U!==H&&(d=!0,C.write(2*k,U))}T=!0}else T=!1}}else{const y=P.getImpl(),C=y.getAttributeStreamRef(0);for(let S=0,b=y.getPointCount();S<b;S++){const A=C.read(2*S),T=In(A,t,m);T!==A&&(d=!0,C.write(2*S,T))}}d&&P.getImpl().notifyModifiedFlags(2001)}else if(g===F.G.enumEnvelope){const d=P,y=R.J.constructEmpty();d.queryEnvelope(y),y.xmin=In(y.xmin,t,m),y.xmax=In(y.xmax,t,m),d.setEnvelope(y)}else g===F.G.enumPoint?P.setX(In(P.getX(),t,m)):(0,F.c)("")}function tu(P,t,m){const u=new Y.P;return u.x=In(P.x,t,m),u.y=P.y,u}function Dn(P,t,m,u){const g=P.getGeometryType();(0,F.g)(g===F.G.enumPolygon||g===F.G.enumPolyline||g===F.G.enumMultiPoint);const d=t.getCoordinateSystemType();if(2===d){let y=P;if(0===m){const C=function tr(P,t){if(t.isEmpty())return 0;const m=P.getPECoordSys();if(m.getProjection().getCode()===pe.PE_PRJ_AZIMUTHAL_EQUIDISTANT){const u=Lr();P.querySpheroidData(u);const g=m.getParameters();if(null===g[pe.PE_PARM_LAM0]||null===g[pe.PE_PARM_PHI0])return 0;const d=[g[pe.PE_PARM_LAM0].getValue(),g[pe.PE_PARM_PHI0].getValue()];Hs.geogToProj(m,1,d);const y=new Y.P(d[0],d[1]),C=R.J.constructEmpty();t.queryEnvelope(C);const S=(0,Y.m)(Y.P,4);C.queryCorners(S);let b=0;const A=P.getOneMeter();let T=Math.max(u.majorSemiAxis,u.minorSemiAxis)*Math.PI,M=Math.min(u.majorSemiAxis,u.minorSemiAxis)*Math.PI;M-=T/180,T*=A,M*=A;for(let X=0;X<4;X++){const k=Y.P.distance(S[X],y);if(k>T)b++;else if(k>M)return-1}if(0===b)return 1;if(4===b){const X=R.J.constructEmpty();return X.setCoords({center:y,width:T,height:T}),C.isIntersectingNe(X)?-1:0}return-1}return-1}(t,P);if(0===C)return P.createInstance();if(1===C)return P;const S=t.getPCSHorizon(),b=S.getGeometryType(),A=t.getDefaultPrecisionSR();if(b===F.G.enumEnvelope){const T=R.J.constructEmpty();S.queryEnvelope(T);const M=(0,dt.c)(A,T,!1);y=(0,Rt.c)(P,T,M,5e4*t.getOneMeterPCSUnit(),u)}else(new gm).execute(S,P,A,u)||(y=(new mi).execute(y,S,A,u),y===S&&(y=y.clone()))}else if(t.isPannable()){const C=R.J.constructEmpty();y.queryEnvelope(C);const S=t.getPannableExtent();S.containsEnvelope(C)||(Ws(y,S,t.getTolerance(0)),2!==m&&4!==m||(y=Fs(y,t)),4!==m?y=Qn(y,t,0,!0,1e5*t.getOneMeterPCSUnit(),u):g===F.G.enumPolygon&&C.width()>2*S.width()&&(y=gn(y,-2*S.width(),2*S.width(),t,!0,0,!0,u)))}return y}if((0,F.g)(1===d),g===F.G.enumMultiPoint)return Ws(P,t.getPannableExtent(),t.getTolerance(0)),P;{const y=R.J.constructEmpty();P.queryEnvelope(y);let C=P;const S=t.getPannableExtent();if(y.ymin<S.ymin||y.ymax>S.ymax){const b=Math.max(1,y.calculateToleranceFromEnvelope()),A=new R.J(y.xmin-b,S.ymin,y.xmax+b,S.ymax);if(C=(new Rt.O).execute(C,A,t,u),C.isEmpty())return C}return g===F.G.enumPolygon&&y.width()>2*S.width()&&(C=gn(C,-2*S.width(),2*S.width(),t,!0,0,!0,u)),C}}function is(P,t){const m=t.getPointCount();if(!m)return;const u=t.getImpl(),g=u.getAttributeStreamRef(0);Hs.geogToProj(P,m,g.getArray()),u.notifyModifiedFlags(2001)}function f(P,t,m,u){if(!m)return;const g=P.getPECoordSys();if(1===m){const T=[t[0].x,t[0].y];if(Hs.geogToProj(g,1,T),u){const{first:M,second:X}=P.m_peCoordSysVal.getGeogToProjFactors();T[0]=M*(t[0].x-P.getCentralMeridian())+X}return void t[0].setCoords(T[0],T[1])}const d=P.isPannable(),y=d?P.getPannableExtent().width():0,C=179*y/360;let S=0;d&&(S=P.getCentralMeridian());const A=new Float64Array(512);for(let T=0;T<m;){for(let X=T;X<m&&t[X].isNAN();++X)T++;let M=Math.min(256,m-T);if(M>0){for(let X=1,k=T+1;X<M;++X,++k)if(t[k].isNAN()){M=X;break}for(let X=0;X<M;++X){const k=X<<1;A[k]=t[T+X].x,A[k+1]=t[T+X].y}if(Hs.geogToProj(g,M,A),u){const{first:X,second:k}=P.m_peCoordSysVal.getGeogToProjFactors();for(let H=0;H<M;++H)A[H<<1]=X*(t[T+H].x-S)+k}if(d)for(let X=0,k=T;X<M;X++,k++){const H=X<<1,U=A[H],Z=(0,Y.e)(U);Z*(0,Y.e)(t[k].x-S)<0&&Math.abs(U)>C&&(A[H]-=Z*y)}Ga(A,t,T,M),T+=M}}}function n(P,t,m,u){const g=P.getSRToGCSTransform();return(new Ji).transform(g,t,m,u,!1)}function r(P,t,m,u){const g=new c.M({vd:t.getDescription()});let d;g.addPoints(t,0,-1),d=(new Ji).execute(g,P,u);const y=t.getPointCount();if(m.setEmpty(),P.getInputSR().isPannable()){if(y!==d.getPointCount())return!1;const C=new R.J;t.queryEnvelope(C);const S=new R.J;d.queryEnvelope(S);const b=C.width(),A=S.width();if(0!==b&&0!==A){const T=A/b,M=P.getOutputSR().getPannableExtent().width()/P.getInputSR().getPannableExtent().width();if(Math.abs(T/M-1)>1e-10)return!1}else if(0!==b||0!==A)return!1;m.add(t,!1);for(let T=0;T<y;T++){const M=d.getXY(T);m.setXY(T,M)}return!0}return!1}function l(P,t,m){(0,F.g)(!m||P.isPannable());const u=t.getPointCount();if(!u)return;const g=t.getImpl(),d=g.getAttributeStreamRef(0),y=P.getPECoordSys();let C=0;const S=d.readRange(0,2*u);let b=()=>{Hs.geogToProj(y,u,S)};const A=P.isPannable()&&!m,T=A?P.getPannableExtent().width():0,M=179*T/360;if(P.isPannable()&&(C=P.getCentralMeridian(),m)){const X=P.m_peCoordSysVal.getGeogToProjFactors(),k=X.first,H=X.second;b=()=>{Hs.geogToProj(y,u,S);for(let U=0;U<u;U++){const Z=U<<1,st=d.read(Z);S[Z]=k*(st-C)+H}}}if(b(),A)for(let X=0;X<u;X++){const k=X<<1,H=S[k],U=(0,Y.e)(H),Z=d.read(k)-C;U*(0,Y.e)(Z)<0&&Math.abs(H)>M&&(S[k]+=-U*T)}d.writeRangeFromArray(0,2*u,S,!0,1),g.notifyModifiedFlags(2001)}function _(P,t,m){switch(t.getGeometryType()){case F.G.enumLine:return void function Ot(P,t,m){const u=[t.getStartXY(),t.getEndXY()];f(P,u,2,m),t.setStartXY(u[0]),t.setEndXY(u[1]),t.normalizeAfterEndpointChange()}(P,t,m);case F.G.enumBezier:return void function De(P,t,m){const u=(0,Y.m)(Y.P,4);t.queryControlPoints(u),Qt(P,u,4,m),t.setControlPoints(u)}(P,t,m);case F.G.enumEllipticArc:return void function Kt(P,t,m){if(0===t.projectionBehavior())!function ne(P,t,m){ie(!0,P,0,t,m)}(P,t,m);else{const u=t.isClosed()&&t.isMajor(),g=[t.getStartXY(),u?t.getCenter():t.getEndXY()],d=[g[0].clone(),g[1].clone()];Qt(P,d,2,m);const y=new Wt.T;y.initializeFromTwoPointsArray(g,d),t.applyTransformation(y),t.setCoordsForIntersector(d[0],d[u?0:1],!1)}}(P,t,m);case F.G.enumBezier2:return void function We(P,t,m){(0,F.g)(0)}();case F.G.enumRationalBezier2:return void function Li(P,t,m){(0,F.g)(0)}();default:(0,F.c)("")}}function x(P,t,m){if(!t.hasNonLinearSegments())return void l(P,t,m);if((0,F.g)(!m||P.isPannable()),t.isEmpty())return;const g=P.getPECoordSys(),d=P.isPannable(),y=d?P.getPannableExtent().width():0,C=179*y/360;let S=0;d&&(S=P.getCentralMeridian());const b=t.createInstance();b.reserveParts(t.getPointCount(),t.getPathCount());const A=t.getImpl(),T=new c.S;for(let M=0,X=t.getPathCount();M<X;++M)if(A.hasNonLinearSegmentsPath(M)){let k=!0,H=-1;const U=A.getPathStart(M),Z=U+A.getSegmentCountPath(M);A.isClosedPath(M)&&(H=Z-1);const st=new Y.P;for(let mt=U;mt<Z;++mt){if(A.getSegmentBuffer(mt,T,!1),_(P,T.get(),m),!k&&(T.get().getStartXY().equals(st)||T.get().moveTo(st)),mt!==H)b.addSegment(T.get(),k);else{if(k){const ht=new dt.P;T.get().queryStart(ht),b.startPathPoint(ht)}b.closeLastPathWithSegment(T.get())}st.assign(T.get().getEndXY()),k=!1}}else{let H,U=A.getPathSize(M),Z=Math.min(U,1024);b.insertPath(-1,t,M,!0);const st=A.getAttributeStreamRef(0),mt=b.getAttributeStreamRef(0);for(let ht=A.getPathStart(M),ut=A.getPathEnd(M);ht<ut;){if(H=st.readRange(ht,Z),Hs.geogToProj(g,Z,H),d)for(let ct=0;ct<Z;ct++){const Et=ct<<1,Tt=H[Et],Pt=(0,Y.e)(Tt),At=st.read(2*(0+ct))-S;Pt*(0,Y.e)(At)<0&&Math.abs(Tt)>C&&(H[Et]+=-Pt*y)}mt.writeRangeFromArray(ht,Z,H,!0,1),ht+=Z,U-=Z,Z=Math.min(U,1024)}}t.assignMove(b)}function E(P,t,m){let g=m.getPointCount();if(!g)return;const d=m.getImpl(),y=d.getAttributeStreamRef(0);let C=Math.min(g,1e3),S=0;const b=P.getPECoordSys();Number.isNaN(t)&&(t=0);const A=P.isPannable(),T=P.getOneDegreeGCSUnit(),M=360*T,X=179*T;let k;for(;g;){if(k=y.readRange(2*S,2*C),L(b,C,k,t),A)for(let H=0;H<C;H++){const U=H<<1,Z=k[U]-t,st=(0,Y.e)(Z),mt=y.read(2*(S+H));st*(0,Y.e)(mt)<0&&Math.abs(Z)>X&&(k[U]+=-st*M)}y.writeRangeFromArray(2*S,2*C,k,!0,1),S+=C,g-=C,C=Math.min(g,1e3)}d.notifyModifiedFlags(2001)}function v(P,t,m){switch(m.getGeometryType()){case F.G.enumLine:return void function I(P,t,m){const u=[m.getStartXY(),m.getEndXY()];Q(P,t,u,2),m.setStartXY(u[0]),m.setEndXY(u[1]),m.normalizeAfterEndpointChange()}(P,t,m);case F.G.enumBezier:return void function q(P,t,m){const u=(0,Y.m)(Y.P,4);m.queryControlPoints(u),Ce(P,t,u,4),m.setControlPoints(u)}(P,t,m);case F.G.enumEllipticArc:return void function D(P,t,m){if(0===m.projectionBehavior())!function G(P,t,m){ie(!1,P,t,m,!1)}(P,t,m);else{const u=m.isClosed()&&m.isMajor(),g=[m.getStartXY(),u?m.getCenter():m.getEndXY()],d=[g[0].clone(),g[1].clone()];Ce(P,t,d,2);const y=new Wt.T;y.initializeFromTwoPointsArray(g,d),m.applyTransformation(y),m.setCoordsForIntersector(d[0],d[u?0:1],!1)}}(P,t,m);case F.G.enumBezier2:return void function B(P,t,m){(0,F.g)(0)}();case F.G.enumRationalBezier2:return void function z(P,t,m){(0,F.g)(0)}();default:(0,F.c)("")}}function L(P,t,m,u){const g=Hs.projToGeogCenter(P,t,m,u);for(let d=0;d<t;++d){const y=d<<1;(0,F.g)(Number.isFinite(m[y]+m[y+1]))}return g}function j(P,t,m){if(!m.hasNonLinearSegments())return void E(P,t,m);if(m.isEmpty())return;const u=P.getPECoordSys();Number.isNaN(t)&&(t=0);const g=P.isPannable(),d=P.getOneDegreeGCSUnit(),y=360*d,C=179*d,S=m.createInstance();S.reserveParts(m.getPointCount(),m.getPathCount());const b=m.getImpl(),A=new c.S;for(let T=0,M=m.getPathCount();T<M;++T)if(b.hasNonLinearSegmentsPath(T)){let X=!0,k=-1;const H=b.getPathStart(T),U=H+b.getSegmentCountPath(T);b.isClosedPath(T)&&(k=U-1);const Z=new Y.P;for(let st=H;st<U;++st){if(b.getSegmentBuffer(st,A,!1),v(P,t,A.get()),!X&&(A.get().getStartXY().equals(Z)||A.get().moveTo(Z)),st!==k)S.addSegment(A.get(),X);else{if(X){const mt=new dt.P;A.get().queryStart(mt),S.startPathPoint(mt)}S.closeLastPathWithSegment(A.get())}Z.assign(A.get().getEndXY()),X=!1}}else{let k,H=b.getPathSize(T),U=Math.min(H,1e3);S.insertPath(-1,m,T,!0);const Z=b.getAttributeStreamRef(0),st=S.getAttributeStreamRef(0);for(let mt=b.getPathStart(T),ht=b.getPathEnd(T);mt<ht;){if(k=Z.readRange(2*mt,2*U),L(u,U,k,t),g)for(let ut=0;ut<U;ut++){const ct=ut<<1,Et=k[ct]-t,Tt=(0,Y.e)(Et),Pt=Z.read(2*mt);Tt*(0,Y.e)(Pt)<0&&Math.abs(Et)>C&&(k[ct]+=-Tt*y)}st.writeRangeFromArray(2*mt,2*U,k,!0,1),mt+=U,H-=U,U=Math.min(H,1e3)}}m.assignMove(S)}function Q(P,t,m,u){const g=P.getPECoordSys();Number.isNaN(t)&&(t=0);const d=P.isPannable(),y=P.getOneDegreeGCSUnit(),C=360*y,S=179*y,A=new Float64Array(512);for(let T=0;T<u;){for(let X=T;X<u&&m[X].isNAN();++X)T++;let M=Math.min(256,u-T);if(M>0){for(let X=1,k=T+1;X<M;++X,++k)if(m[k].isNAN()){M=X;break}for(let X=0;X<M;X++){const k=X<<1;A[k]=m[T+X].x,A[k+1]=m[T+X].y}if(L(g,M,A,t),d)for(let X=0,k=T;X<M;++X,++k){const H=X<<1,U=m[k].x,Z=A[H]-t,st=(0,Y.e)(Z);st*(0,Y.e)(U)<0&&Math.abs(Z)>S&&(A[H]-=st*C)}for(let X=0;X<M;X++){const k=X<<1;m[T+X].x=A[k],m[T+X].y=A[k+1]}T+=M}}}function et(P,t,m,u){(0,F.g)(0)}function K(P,t,m){let u=t.getPointCount();if(!u)return!1;const g=t.getImpl(),d=g.getAttributeStreamRef(0);let y=null;const C=P.getInputSR(),S=P.getOutputSR();C.getVCS(),S.getVCS();const b=C.getOneDegreeGCSUnit(),A=S.getOneDegreeGCSUnit(),T=P.isVertical();T&&t.hasAttribute(1)&&(y=g.getAttributeStreamRef(1));const M=P.getDatumTransformation(),X=!!M&&1===M.getType();if(X||null===y||(et(y.getArray()),y=null),!M||0===M.count()){const At=C.getGcsUnitFactor()/S.getGcsUnitFactor(),Ht=(C.getPrimeMeridian()-S.getPrimeMeridian())*A,Bt=-90*b,kt=90*b;let wt=0;const Xt=d.getArray(),Zt=[0];for(let zt=1,ge=2*u;zt<ge;)Zt[0]=Xt[zt],wt|=(0,Y.ax)(Zt,Bt,kt)?1:0,Xt[zt]=Zt[0],zt+=2;if(0!==Ht||1!==At){wt=1;const zt=d.getArray();for(let ge=0,qt=2*u;ge<qt;){let ce=zt[ge];ce*=At,ce+=Ht,zt[ge]=ce,zt[ge+1]*=At,ge+=2}}return 0!==wt&&g.notifyModifiedFlags(2001),!!wt}let H=Math.min(u,1e3);const U=(0,Y.d)(H,Number.NaN),Z=(0,Y.d)(H,Number.NaN);let st=null;null!==y&&(st=new Float64Array(H));let mt=0,ht=Number.NaN,ut=Number.NaN;const ct=360*A,Et=A/b;m&&(ut=90*A,ht=89.9*b,Z.fill(0));let Tt=!0,Pt=0;for(;u;){let At=!1;const Ht=d.readRange(2*mt,2*H);for(let kt=0;kt<H;kt++)U[kt]=Ht[kt<<1];if(m)for(let kt=0;kt<H;kt++){const wt=1+(kt<<1),Xt=Math.abs(Ht[wt])-ht;if(Xt>0){const Zt=Ht[wt];Ht[wt]=(0,Y.f)(ht,Zt),Z[kt]=(0,Y.f)(Xt,Zt),At=!0}}const Bt=Ht[0];if(X){const kt=M;st&&y.queryRange(mt,H,st,!0,1),kt.transform(!1,Ht,st,H),st&&y.writeRangeFromArray(mt,H,st,!0,1)}else M.transform(!1,Ht,H);Tt&&(Pt=Ht[0]-Et*Bt,Tt=!1);for(let kt=0;kt<H;kt++){const wt=kt<<1,Xt=Ht[wt]-U[kt]*Et-Pt;Math.abs(Xt)>200&&(Ht[wt]+=Xt>0?-ct:ct)}if(At){for(let kt=0;kt<H;kt++)if(Z[kt]){const wt=1+(kt<<1);Ht[wt]+=Et*Z[kt],Ht[wt]>ut?Ht[wt]=ut:Ht[wt]<-ut&&(Ht[wt]=-ut)}Z.fill(0)}d.writeRangeFromArray(2*mt,2*H,Ht,!0,1),T&&y&&y.writeRangeFromArray(mt,H,st,!0,1),mt+=H,u-=H,H=Math.min(u,1e3)}return g.notifyModifiedFlags(2001),!0}function rt(P,t,m){switch(t.getGeometryType()){case F.G.enumLine:return function yt(P,t,m){const u=[t.getStartXY(),t.getEndXY()];let d=null;t.hasAttribute(1)&&(d=[0,0],d[0]=t.getAttributeAsDbl(0,1,0),d[1]=t.getAttributeAsDbl(1,1,0));const y=gt(P,u,d,2,m);return t.setStartXY(u[0]),t.setEndXY(u[1]),d&&(t.setStartAttribute(1,0,d[0]),t.setEndAttribute(1,0,d[1])),t.normalizeAfterEndpointChange(),y}(P,t,m);case F.G.enumBezier:return function Dt(P,t,m){const u=(0,Y.m)(Y.P,4);t.queryControlPoints(u);let d=null;t.hasAttribute(1)&&(d=[0,0,0,0],d[0]=t.getAttributeAsDbl(0,1,0),d[3]=t.getAttributeAsDbl(1,1,0),d[1]=(0,Y.q)(d[0],d[3],.5),d[2]=d[1]);const y=gt(P,u,d||null,u.length,m);return t.setControlPoints(u),d&&(t.setStartAttribute(1,0,d[0]),t.setEndAttribute(1,0,d[3])),t.normalizeAfterEndpointChange(),y}(P,t,m);case F.G.enumEllipticArc:return function ft(P,t,m){if(0===t.projectionBehavior())return function bt(P,t,m){const u=[t.getStartXY(),t.getEndXY(),t.getInteriorPoint(),t.getCenter()];let g=4;t.isDegenerateToLine()&&(g=2);const d=[0,0,0,0];let y=null;if(t.hasAttribute(1)){y=d,y[0]=t.getAttributeAsDbl(0,1,0),y[1]=t.getAttributeAsDbl(1,1,0);const b=(0,Y.q)(y[0],y[1],.5);y[2]=b,y[3]=b}const C=t.getStartXY().equals(t.getEndXY())&&!t.isDegenerateToLine(),S=gt(P,u,y,g,m);return C?t.constructCircleCenterAndPoint(u[3],u[0],!t.isClockwise()):t.isDegenerateToLine()?t.constructLineCircularArc(u[0],u[1]):t.constructCircularArcThreePoint(u[0],u[1],u[2]),y&&(t.setStartAttribute(1,0,y[0]),t.setEndAttribute(1,0,y[1])),S}(P,t,m);const u=t.getStartXY().equals(t.getEndXY()),g=(0,Y.m)(Y.P,3),d=(0,Y.m)(Y.P,3);let C=null;g[0].assign(t.getStartXY()),g[1].assign(u?t.getCenter():t.getEndXY());let S=!1;t.hasAttribute(1)&&(C=[0,0,0],C[0]=t.getAttributeAsDbl(0,1,0),C[1]=t.getAttributeAsDbl(1,1,0),C[2]=(0,Y.q)(C[0],C[1],.5),u&&(C[1]=C[2])),d[0].setCoordsPoint2D(g[0]),d[1].setCoordsPoint2D(g[1]);const b=new Wt.T;if(u||t.isDegenerateToLine())S=gt(P,d,C,2,m),b.initializeFromTwoPoints(g[0],g[1],d[0],d[1]);else{const A=new Y.P;t.queryCoord2D(.5,A),g[2].setCoordsPoint2D(A),d[2].setCoordsPoint2D(A),S=gt(P,d,C,3,m),b.setFromTwoTriangles(g,d)}return b.isIdentity()||(t.applyTransformation(b),t.setStartXY(d[0]),t.setEndXY(u?d[0]:d[1]),t.normalizeAfterEndpointChange()),C&&(t.setStartAttribute(1,0,C[0]),t.setEndAttribute(1,0,u?C[0]:C[1])),S}(P,t,m);case F.G.enumBezier2:return function Nt(P,t,m){return(0,F.g)(0),!1}();case F.G.enumRationalBezier2:return function Ft(P,t,m){return(0,F.g)(0),!1}();default:(0,F.c)("")}}function ot(P,t,m){if(!t.hasNonLinearSegments())return K(P,t,m);if(t.isEmpty())return!1;const u=t.createInstance();u.reserveParts(t.getPointCount(),t.getPathCount());const g=t.getImpl(),d=new c.S;for(let y=0,C=t.getPathCount();y<C;++y){let S=!0,b=-1;const A=g.getPathStart(y),T=A+g.getSegmentCountPath(y);g.isClosedPath(y)&&(b=T-1);const M=new Y.P;for(let X=A;X<T;++X){if(g.getSegmentBuffer(X,d,!1),rt(P,d.get(),m),!S&&(d.get().getStartXY().equals(M)||d.get().moveTo(M)),X!==b)u.addSegment(d.get(),S);else{if(S){const k=new dt.P;d.get().queryStart(k),u.startPathPoint(k)}u.closeLastPathWithSegment(d.get())}M.assign(d.get().getEndXY()),S=!1}}return t.assignMove(u),!0}function nt(P,t,m,u,g,d){if(P.isIdentityGeogToGeog()){const Bt=90*P.getInputSR().getOneDegreeGCSUnit();let kt=0;const wt=[0];for(let Xt=0;Xt<u;Xt++)wt[0]=t[Xt].y,kt|=(0,Y.ax)(wt,-Bt,Bt)?1:0,t[Xt].y=wt[0];return kt}const y=P.getInputSR(),C=P.getOutputSR(),S=y.getVCS(),b=C.getVCS(),A=y.getOneDegreeGCSUnit(),T=90*A,M=C.getOneDegreeGCSUnit(),X=P.isVertical(),k=P.getDatumTransformation(),H=!!k&&1===k.getType();if(X||(m=null),!k||0===k.count()){let Bt=0;const kt=[0];for(let wt=0;wt<u;wt++)kt[0]=t[wt].y,Bt|=(0,Y.ax)(kt,-T,T)?1:0,t[wt].y=kt[0];return Bt|=vn(y.getGCS(),S,C.getGCS(),b,t,m,u)?1:0,Bt}H||null===m||et();let Z=Math.min(u,1024);const st=(0,Y.d)(Z,Number.NaN),mt=(0,Y.d)(Z,Number.NaN);let ht=0,ut=Number.NaN,ct=Number.NaN;const Et=360*M,Tt=M/A;g&&(ct=90*M,ut=89.9*A);let Pt=!0,At=0,Ht=u;for(;Ht;){let Bt=!1;for(let wt=0;wt<Z;wt++)st[wt]=t[wt+ht].x;if(g)for(let wt=0;wt<Z;wt++){const Xt=Math.abs(t[wt+ht].y)-ut;if(Xt>0){const Zt=t[wt+ht].y;t[wt+ht].y=(0,Y.f)(ut,Zt),mt[wt]=(0,Y.f)(Xt,Zt),Bt=!0}}const kt=t[0].x;H?k.transform(!1,t,m,Z):k.transform(!1,t,Z),Pt&&(At=t[0].x-Tt*kt,Pt=!1);for(let wt=0;wt<Z;wt++){const Xt=t[ht+wt].x-st[wt]*Tt-At;Math.abs(Xt)>200&&(Xt>0?t[ht+wt].x-=Et:t[ht+wt].x+=Et)}if(Bt){for(let wt=0;wt<Z;wt++)mt[wt]&&(t[ht+wt].y+=Tt*mt[wt],t[ht+wt].y>ct?t[ht+wt].y=ct:t[ht+wt].y<-ct&&(t[ht+wt].y=-ct));mt.fill(0,0,Z)}ht+=Z,Ht-=Z,Z=Math.min(Ht,1024)}return 1}function at(P,t,m,u,g){return(0,F.g)(0),0}function pt(P,t,m,u,g){(0,F.g)(null===u),(0,F.g)(t<2147483647);const d=Array.isArray(m);let y;y=d?(0,Y.ay)(m):m;const C=Iu.geogToGeog(P,t,y,null,g);return d&&(0,Y.az)(y,m),C}function gt(P,t,m,u,g,d){let y=0,C=!0,S=0;for(let b=0;b<u;++b)t[b].isNAN()?C||(y|=nt(P,t.slice(S,b-S),m?m.slice(S,b-S):null,b-S,g),S=b,C=!0):C&&(S=b,C=!1);return C||(y|=nt(P,0===S?t:t.slice(S),m?0===S?m:m.slice(S):null,u-S,g)),0!==y}function Qt(P,t,m,u){f(P,t,m,u)}function Ce(P,t,m,u){Q(P,t,m,u);const g=new R.J;g.setFromPoints(m,u);const d=P.getOneDegreeGCSUnit(),y=360*d,C=180*d;if(g.width()>C){for(let S=0;S<u;S++)for(;m[S].x<t;)m[S].x+=y;if(g.setFromPoints(m,u),g.xmax>C+t)for(let S=0;S<u;S++)m[S].x-=y}}function ie(P,t,m,u,g){const d=(0,Y.m)(Y.P,3);let y=0,C=!1,S=!1;const b=u.isDegenerateToLine();b?(d[0].assign(u.getStartXY()),d[1].assign(u.getEndXY()),d[2].setCoords(0,0),y=2):u.isClosed()&&u.isMajor()?(C=!0,S=!u.isClockwise(),d[0].assign(u.getStartXY()),d[1].assign(u.getCenter()),d[2].setCoords(0,0),y=2):(d[0].assign(u.getStartXY()),d[1].assign(u.getEndXY()),d[2].assign(u.getInteriorPoint()),y=3),P?Qt(t,d,y,g):Ce(t,m,d,y),b?u.constructLineCircularArc(d[0],d[1]):C?u.constructCircleCenterAndPoint(d[1],d[0],S):u.constructCircularArcThreePoint(d[0],d[1],d[2])}function Ms(P,t,m){const u=(0,c.a3)(P),g=(0,c.a3)(t),d=(0,c.$)(u,g),y=(0,c.$)(u,(0,c.a3)(m));return 0===y||d>0&&y>0&&y<=d||d<0&&y<0&&y>=d}function Ge(P,t,m,u,g){const d={stack:[],error:void 0,hasError:!1};try{const y=m.clone(),C=u.clone();if(2===g){const U=[0,0];return os(0,t,y,C,0,U),U[0]}if(y.y>C.y){const U=new Y.P;U.assign(y),y.assign(C),C.assign(U)}const S=(0,vt.b)(d,new js,!1),b=(0,vt.b)(d,new js,!1),A=(0,vt.b)(d,new js,!1),T=new Y.E;if(T.setCoords(y.y,C.y),!T.containsCoordinate(0)||Math.abs(y.x-C.x)>=Math.PI)return Number.NaN;if(y.x===C.x)return y.x;Si.geodeticDistance(P,t,y.x,y.y,C.x,C.y,b,S,null,g);const M=b.val;let X=0,k=1;const H=y.clone();for(;M*(k-X)>1e-12*P;){const U=.5*(X+k);if(Si.geodeticCoordinate(P,t,y.x,y.y,M*U,S.val,b,A,g),H.x=b.val,H.y=A.val,T.setCoords(y.y,H.y),0===H.y)return H.x;if(T.containsCoordinate(0))k=U;else{if(T.setCoords(C.y,H.y),!T.containsCoordinate(0))return(0,F.g)(!1),Number.NaN;X=U}}return H.x}catch(y){d.error=y,d.hasError=!0}finally{(0,vt.c)(d)}}function ei(P,t,m,u){const g=new Y.E;g.setCoords(t,m);const d=u.width();let y=Math.floor((P-t)/d)*d+P;const C=g.getCenter();for(;Math.abs(y-C)>Math.abs(y+d-C);)y+=d;return y}class vs extends ee.G{constructor(){super(),this.m_geometryDeque=[],this.m_index=-1}next(){if(this.m_geometryDeque.length>0){this.m_index++;const t=this.m_geometryDeque[0];return this.m_geometryDeque.shift(),t}return null}getGeometryID(){return this.m_index}tick(t){this.m_geometryDeque.push(t)}tock(){return!0}getRank(){return 1}}class eu{constructor(t,m=!0){this.m_PCSHorizon=null,this.m_GCSHorizon=null,this.m_GCSSplitLines=null,this.m_bGCSHorisonIsInclusive=!1,this.m_oneMeterPCS=0,this.m_oneDegreeGCS=0,this.m_gcsUnitFactor=0,this.m_northPole=Y.P.getNAN(),this.m_southPole=Y.P.getNAN(),this.m_polesUpdated=0,this.m_domain=R.J.constructEmpty(),this.m_primeMeridian=Number.NaN,this.m_geogToProjFactor=1,this.m_geogToProjOffset=0,this.m_geogToProjFactorsUpdated=0,this.m_oneMillimeter=0,this.m_centralMeridian=0,this.m_pPCSInfoNoDomain=null,this.m_oldWKID=-1973,this.m_vcsWKID=-1,this.m_bIsPannable=!1,this.m_bCached=!1,this.m_pannableExtent=R.J.constructEmpty(),this.m_pannableExtentGCS=R.J.constructEmpty(),this.m_areaOfUse=null,this.m_canonicalWkt="",this.m_peCoordSys=t,this.m_WKID=ws.getCode(t),this.m_WKID<=0?(this.m_WKID=0,this.m_canonicalWkt=Da(t,0,!0),this.m_hashCode=(0,Y.aw)(this.m_canonicalWkt)):this.m_hashCode=(0,Y.A)(this.m_WKID);const u=this.m_peCoordSys.getType();this.m_csType=u===pe.PE_TYPE_PROJCS?2:1,(0,F.g)(u===pe.PE_TYPE_PROJCS||u===pe.PE_TYPE_GEOGCS),u===pe.PE_TYPE_PROJCS&&(t.loadConstants()||(0,F.t)("PeProjcs.loadConstants failed"));const g=u===pe.PE_TYPE_GEOGCS?this.m_peCoordSys:this.m_peCoordSys.getGeogcs();u!==pe.PE_TYPE_GEOGCS&&ws.getCode(g),this.m_unit=function Ut(P){const t=wo(null);return P.getType()===pe.PE_TYPE_PROJCS||P.getType()===pe.PE_TYPE_GEOGCS?t.reset(P.getUnit()):(0,F.t)("PE_coord_sys"),t.get()||(0,F.c)("cannot create units from coord sys"),function Jt(P){return P.getType()===pe.PE_TYPE_LINUNIT?new Tn(P):P.getType()===pe.PE_TYPE_ANGUNIT?new Yt(P):void(0,F.t)("peUnit")}(t.get())}(t),this.m_primeMeridian=g.getPrimem().getLongitude();{const d=g.getUnit().getUnitFactor();this.m_gcsUnitFactor=d;let y=Math.PI/(180*d);Math.abs(y-1)<1e-10&&(y=1),this.m_oneDegreeGCS=y}if(u===pe.PE_TYPE_PROJCS){const d=this.m_peCoordSys,y=d.getUnit().getUnitFactor();this.m_oneMeterPCS=1/y,this.m_oneMillimeter=.001/y,this.m_pPCSInfoNoDomain=zs.generate(d,zs.PE_PCSINFO_OPTION_NONE),this.m_pPCSInfoNoDomain||(0,F.c)("cannot create pcs info"),this.m_bIsPannable=this.m_pPCSInfoNoDomain.isPannableRectangle(),this.m_centralMeridian=this.m_pPCSInfoNoDomain.getCentralMeridian()}else{this.m_bIsPannable=!0,this.m_polesUpdated=1,this.m_oneMeterPCS=0;const d=1/g.getUnit().getUnitFactor(),y=g.getDatum().getSpheroid().getAxis();this.m_oneMillimeter=.001/y*d,this.m_centralMeridian=0}this.m_bIsPannable&&(this.updateGCSHorizon(),this.updatePCSHorizon(),this.updatePoles(),this.updateDomain(),this.updatePannableExtent(),this.updatePannableExtentGCS())}[Symbol.dispose](){}getHashCode(){return this.m_hashCode}getPCSHorizonPannable(){return this.m_PCSHorizon}getGCSHorizonPannable(){return this.m_GCSHorizon}getPCSInfo(){return(0,F.g)(this.m_pPCSInfoNoDomain),this.m_pPCSInfoNoDomain}getCentralMeridian(){return this.m_centralMeridian}updateGCSHorizon(){if(this.m_peCoordSys.getType()!==pe.PE_TYPE_PROJCS)return;let t=!0;const m=this.m_peCoordSys,u=m.getGeogcs(),g=m.horizonGcsGenerate();if(!g)return;(0,F.g)(g.length>0);const d=g[0].getNump(),y=g[0].getKind();let C,S;t=g[0].getInclusive()>0;const b=this.getOneDegreeGCSUnit(),A=90*b,T=360*b,M=370*b,X=180*b*pe.PE_HORIZON_DELTA/Math.PI,k=R.J.constructEmpty();let H=null;if(d>1)for(let U=1;U<d;U++)if(g[U].getKind()===pe.PE_HORIZON_LINE){H||(H=new c.P);const Z=g[U].getCoord();H.startPathCoords(Z[0][0],Z[0][1]),H.lineToCoords(Z[1][0],Z[1][1])}if(y===pe.PE_HORIZON_RECT){const U=g[0].getCoord();if(k.setFromPoints([new Y.P(U[0][0],U[0][1]),new Y.P(U[1][0],U[1][1])],2),Math.abs(k.ymax-A)<1e-7*X&&(k.ymax=A),Math.abs(k.ymin+A)<1e-7*X&&(k.ymin=-A),k.width()>M){const st=-400*b;k.setCoords({xmin:st,ymin:k.ymin,xmax:st+5*T,ymax:k.ymax})}const Z=new dt.E({env2D:k});this.m_GCSHorizon||(this.m_GCSHorizon=Z,this.m_bGCSHorisonIsInclusive=t)}else{let U=this.getPCSInfo().isGcsHorizonMultiOverlap();const Z=Ya(u,null,0,1),st=[],mt=new Y.E;for(let Tt=0;Tt<d;Tt++){if(g[Tt].getKind()!==pe.PE_HORIZON_POLY)continue;C=g[Tt].getSize();const Pt=g[Tt].getCoord(),At=R.J.constructEmpty();At.setFromPoints((0,Y.aB)(Pt),C),st.push(new Y.E(At.xmin,At.xmax)),At.width(),mt.merge(st.at(-1))}let ht=!1;const ut=new Y.E;mt.width()>T&&st.length>1?(ut.vmin=this.getCentralMeridian()-T,ut.vmax=ut.vmin+2*T,ht=!0,U=!0):(ut.vmin=mt.vmin,ut.vmax=ut.vmin+T);const ct=Tt=>{let Pt=0;for(;st[Tt].vmin+Pt<ut.vmin;)Pt+=T;for(;st[Tt].vmax+Pt-T>ut.vmin;)Pt-=T;return Pt};let Et=new c.a;if(U){const Tt=new vs,Pt=(new Co).executeMany(Tt,Z,null);for(let At=0;At<d;At++){if(g[At].getKind()!==pe.PE_HORIZON_POLY)continue;C=g[At].getSize();const Ht=g[At].getCoord();S=g[At].getInclusive()>0;const Bt=new c.a;if(Bt.addPathPoint2D((0,Y.aB)(Ht),C-1,!0),ht){const kt=ct(At),wt=st[At].clone();wt.move(kt);let Xt=kt;const Zt=new Wt.T;do{Zt.setShiftCoords(Xt,0);const zt=Bt.clone();zt.applyTransformation(Zt),Tt.tick(zt),Tt.tock(),Xt+=T,wt.move(T)}while(wt.vmin<ut.vmax)}else Tt.tick(Bt),Pt.tock()}Et=Pt.next()}else{Et=new c.a;for(let Tt=0;Tt<d;Tt++){if(g[Tt].getKind()!==pe.PE_HORIZON_POLY)continue;C=g[Tt].getSize();const Pt=g[Tt].getCoord();if(S=g[Tt].getInclusive()>0,(0,F.g)(S===t),ht){const At=new c.a;At.addPathPoint2D((0,Y.aB)(Pt),C-1,!0);const Ht=ct(Tt),Bt=st[Tt].clone();Bt.move(Ht);let kt=Ht;const wt=new Wt.T;do{if(0!==kt){wt.setShiftCoords(kt,0);const Xt=new c.a({copy:At});Xt.applyTransformation(wt),Et.addPath(Xt,0,!0)}else Et.addPath(At,0,!0);kt+=T,Bt.move(T)}while(Bt.vmin<ut.vmax)}else Et.addPathPoint2D((0,Y.aB)(Pt),C-1,!0)}}ht&&(Et=(new Rt.O).execute(Et,new R.J(ut.vmin,-A-b,ut.vmax,A+b),Z,null)),t?(new mi).accelerateGeometry(Et,Z,1):(new Eo).accelerateGeometry(Et,Z,1),(new Mt).accelerateGeometry(Et,Z,1),null===this.m_GCSHorizon&&(this.m_GCSHorizon=Et,this.m_bGCSHorisonIsInclusive=t,this.m_GCSSplitLines=H)}}updateAreaOfUse(){return null}updatePCSHorizon(){if(this.m_peCoordSys.getType()!==pe.PE_TYPE_PROJCS)return;const t=this.m_peCoordSys.horizonPcsGenerate();if(!t)return;let m;this.getPCSInfo();const u=t[0].getKind();t[0].getInclusive();const g=R.J.constructEmpty(),d=t[0].getNump();let y=!1;if(u===pe.PE_HORIZON_RECT){const C=t[0].getCoord();g.setFromPoints((0,Y.aB)(C),2),m=new dt.E({env2D:g})}else{let C=-1;for(let T=0;T<d;T++)t[T].getKind()===pe.PE_HORIZON_POLY&&(C=T);(0,F.g)(C>=0);const S=t[C].getSize()-1,b=t[C].getCoord(),A=new c.a;m=A,A.addPathPoint2D((0,Y.aB)(b),S,!0),y=!0}if(this.getPCSInfo().isDensificationNeeded()){(0,F.g)(u!==pe.PE_HORIZON_RECT);const C=1e5*this.getOneMeterPCSUnit();m=(new Se.O).execute(m,C,0,0,null)}if(y){{const C=new dt.E;m.queryEnvelope(C),m.calculateArea2D(),m.calculateLength2D(),m.getExteriorRingCount()}(new mi).accelerateGeometry(m,null,1)}null===this.m_PCSHorizon&&(this.m_PCSHorizon=m)}updatePannableExtent(){const t=this.m_peCoordSys.getType();if(t===pe.PE_TYPE_PROJCS){const m=this.m_peCoordSys,u=this.getPCSInfo().getCentralMeridian(),g=m.getGeogcs();g||(0,F.c)("");const d=[u+1/g.getUnit().getUnitFactor()*Math.PI,0];Hs.geogToProj(m,1,d);const y=d[0],C=m.getParameters()[pe.PE_PARM_X0].getValue(),S=this.getPCSHorizon(),b=R.J.constructEmpty();S.queryEnvelope(b);const A=Math.abs(y-C);this.m_pannableExtent.setCoords({xmin:-1*A+C,ymin:b.ymin,xmax:A+C,ymax:b.ymax})}else if(t===pe.PE_TYPE_GEOGCS){const m=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtent.setCoords({xmin:-m,ymin:-m/2,xmax:m,ymax:m/2})}else(0,F.c)("")}updatePannableExtentGCS(){const t=this.m_peCoordSys.getType();if(t===pe.PE_TYPE_PROJCS){const u=this.m_centralMeridian,g=this.m_peCoordSys.getGeogcs();g||(0,F.c)("");const d=1/g.getUnit().getUnitFactor()*Math.PI,y=this.getGCSHorizon(),C=R.J.constructEmpty();y.queryEnvelope(C),this.m_pannableExtentGCS.setCoords({xmin:u-d,ymin:C.ymin,xmax:u+d,ymax:C.ymax})}else if(t===pe.PE_TYPE_GEOGCS){const m=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtentGCS.setCoords({xmin:-m,ymin:-m/2,xmax:m,ymax:m/2})}else(0,F.c)("")}updateDomain(){if(1===this.m_csType){const t=400*this.getOneDegreeGCSUnit();this.m_domain=R.J.construct(-t,-t,t,t)}else{(0,F.g)(2===this.m_csType);const t=zs.generate(this.m_peCoordSys,zs.PE_PCSINFO_OPTION_DOMAIN);t||(0,F.c)("generate pcs info failed");const m=new R.J(t.getDomainMinx(),t.getDomainMiny(),t.getDomainMaxx(),t.getDomainMaxy());this.m_domain.isEmpty()&&this.m_domain.setCoords({env2D:m})}}updatePoles(){if(this.m_peCoordSys.getType()===pe.PE_TYPE_PROJCS){const t=90*this.getOneDegreeGCSUnit(),m=[[0,t],[0,-t]];Hs.geogToProj(this.m_peCoordSys,2,m);const u=this.getPCSInfo().getNorthPoleLocation()!==zs.PE_POLE_OUTSIDE_BOUNDARY,g=this.getPCSInfo().getSouthPoleLocation()!==zs.PE_POLE_OUTSIDE_BOUNDARY;this.m_polesUpdated||(u&&this.m_northPole.setCoords(m[0][0],m[0][1]),g&&this.m_southPole.setCoords(m[1][0],m[1][1]),this.m_polesUpdated=1)}else this.m_polesUpdated=1}updateGeogToProjFactors(){if(this.m_peCoordSys.getType()===pe.PE_TYPE_PROJCS){const t=this.getOneDegreeGCSUnit(),m=this.m_pPCSInfoNoDomain.getCentralMeridian(),u=[0,0,0,0];u[0]=m,u[1]=0,u[2]=m+t,u[3]=0;const g=Hs.geogToProj(this.m_peCoordSys,2,u);(0,F.g)(2===g);const y=u[0];0===this.m_geogToProjFactorsUpdated&&(this.m_geogToProjFactor=(u[2]-u[0])/t,this.m_geogToProjOffset=y,this.m_geogToProjFactorsUpdated=1)}else this.m_geogToProjFactorsUpdated=1}getOneMeterPCSUnit(){return this.m_oneMeterPCS}getOneDegreeGCSUnit(){return this.m_oneDegreeGCS}getGcsUnitFactor(){return this.m_gcsUnitFactor}getUnitsPerMillimeter(){return this.m_oneMillimeter}getGCSSplitLines(){return this.m_bIsPannable?null:(this.m_GCSHorizon||this.updateGCSHorizon(),this.m_GCSSplitLines)}getGCSHorizon(){return this.m_bIsPannable?this.getGCSHorizonPannable():(null!==this.m_GCSHorizon||this.updateGCSHorizon(),this.m_GCSHorizon)}getGCSHorisonIsInclusive(){return this.m_bIsPannable||this.getGCSHorizon(),this.m_bGCSHorisonIsInclusive}getPCSHorizon(){return this.m_bIsPannable?this.getPCSHorizonPannable():(null!==this.m_PCSHorizon||this.updatePCSHorizon(),this.m_PCSHorizon)}getPole(t){return this.m_bIsPannable||0!==this.m_polesUpdated||this.updatePoles(),t?this.m_southPole:this.m_northPole}getGeogToProjFactors(){return 0===this.m_geogToProjFactorsUpdated&&this.updateGeogToProjFactors(),(0,Y.n)(this.m_geogToProjFactor,this.m_geogToProjOffset)}getDomainXY(){if(this.m_bIsPannable)return this.m_domain.clone();let t=!1;return t=this.m_domain.isEmpty(),t&&this.updateDomain(),this.m_domain.clone()}getPrimeMeridian(){return this.m_primeMeridian}getLatestID(){return this.m_WKID}getOldID(){let t=this.m_oldWKID;if(t<0){if(t=0,this.m_WKID>0){const m=[0],u=[0];(function Nc(P,t,m,u){return t<=0?(m[0]=0,u[0]=0,!1):(m[0]=t,u[0]=t,!0)})(this.m_peCoordSys.getType(),this.m_WKID,m,u)||(0,F.c)("query_code_change"),t=m[0]}this.m_oldWKID=t}return t}isCustomWkid(){return!1}isPannable(){return this.m_bIsPannable}getPannableExtent(){return this.m_pannableExtent.clone()}getPannableExtentGCS(){return this.m_pannableExtentGCS.clone()}getAreaOfUse(){return null!==this.m_areaOfUse?this.m_areaOfUse:this.updateAreaOfUse()}getVcsCode(){return 0}saveMemory(){}getCSType(){return this.m_csType}getUnit(){return this.m_unit}setCached(){this.m_bCached=!0}getCached(){return this.m_bCached}static equal(t,m){return!1}static equal_for_projection(t,m){return!1}}class sc{constructor(t,m=!0){this.m_oneMeter=0,this.m_WKID=-1,this.m_oldWKID=-1,this.m_canonicalWkt="not yet implemented",this.m_model=0,this.m_unit=new Tn,this.m_cached=!1}setCached(t=!0){this.m_cached=t}getCached(){return this.m_cached}getOneMeterUnit(){return 0}getLatestID(){return this.m_WKID}getOldID(){let t=this.m_oldWKID;return t<0&&(t=0,this.m_WKID>0&&(t=this.m_WKID),this.m_oldWKID=t),t}getModel(){return 0}isCustomWkid(){return!1}getVerticalUnit(){return this.m_unit}static equal(t,m){return!1}static equal_for_projection(t,m){return!1}}function Nu(P,t,m,u){return function nc(P,t,m,u,g){return Bi()||(0,F.r)("cannot create projection transformation"),t.hasVCS()&&m.hasVCS()?function rc(P,t,m,u){return(0,F.g)(0),{}}():function oc(P,t,m,u){P&&t||(0,F.t)("!inputSR || !outputSR");const g=P.getLatestID(),d=t.getLatestID();if(3857===g&&4326===d){if(P.m_bDefaultDescriptor&&t.m_bDefaultDescriptor)return Gu()}else if(4326===g&&3857===d&&P.m_bDefaultDescriptor&&t.m_bDefaultDescriptor)return function _c(){return cu||(cu=Gu().getInverse()),cu}();const y=R.J.constructEmpty();y.setCoords({env2D:m});const C=P.getCoordinateSystemType(),S=t.getCoordinateSystemType();if(0===C||0===S)return Sm(P,t);if(u){const X=u.find(0,P.getGCS(),t.getGCS());if(X)return Sm(P,t,X)}const b=P.getGCS().getLatestID(),A=t.getGCS().getLatestID();if(b>0&&b===A)return Sm(P,t);const T=new uc(P,t,m);{const X=function cc(P){if(lu.has(P.getHashCode()))return lu.get(P.getHashCode())}(T);if(X)return X}const M=Au(0,P,t,y,1,!0);return function gc(P,t){return lu.set(P.getHashCode(),t),t}(T,Sm(P,t,M.length?M[0]:void 0))}(t,m,u,g)}(0,P,t,m,u)}function kr(P,t,m,u){return su(!0,P,t,m,u)}function su(P,t,m,u,g,d){return Bi()||(0,F.r)("cannot create projection transformation"),new au(P?2:1,t,m,u,g,d)}function Au(P,t,m,u,g,d=!1){if(t&&m||(0,F.t)(""),Bi()||(0,F.r)("cannot obtain geotransformation list"),1===P&&t.hasVCS()&&m.hasVCS())return(0,F.b)("hv xform not impl"),[];{const y=Qu(t,m,u,g,d),C=[];for(const S of y)C.push(S);return C}}function iu(){return{centralMeridianOfOutputGCS:Number.NaN,densificationStep:Number.NaN,clipWithInputHorizon:!0,clipWithOutputHorizon:!0,legacyHorizonClipping:!1,normalizeResultGeometry:!1,equals(P){return(0,Y.a3)(this.centralMeridianOfOutputGCS,P.centralMeridianOfOutputGCS)&&(0,Y.a3)(this.densificationStep,P.densificationStep)&&this.clipWithInputHorizon===P.clipWithInputHorizon&&this.clipWithOutputHorizon===P.clipWithOutputHorizon&&this.legacyHorizonClipping===P.legacyHorizonClipping&&this.normalizeResultGeometry===P.normalizeResultGeometry}}}function Sm(P,t,m,u,g){return new au(1,P,t,m,u,g)}function nu(){return{flagsMask:0,setFlag(P,t){t?this.flagsMask|=P:this.flagsMask&=~P},hasFlag(P){return!!(this.flagsMask&P)}}}function ru(){return{m_extendedParams:iu(),m_extendedParamsInternal:nu()}}function ou(){return ru()}let au=class tc{constructor(t,m,u,g,d,y){let C,S;this.m_datumTran=null,this.m_bIdentity=!0,this.m_bIdentityGeogToGeog=!0,this.m_bVertical=!1,this.m_bNormalize=!1,m&&u||(0,F.t)("!inputSR || !outputSR"),g&&0===g.getType()&&(g.m_bReadOnly=!0),this.m_bNormalize=!1,1!==t&&(C=m.getVCS(),S=u.getVCS(),this.m_bVertical=null!=C&&null!=S),this.m_inputSR=m,this.m_outputSR=u,this.m_bIdentity=!1,this.m_bIdentityGeogToGeog=!1,(0,F.g)(!this.m_params),d&&(this.m_params=ru(),this.m_params.m_extendedParams=d),y&&(this.m_params||(this.m_params=ru()),this.m_params.m_extendedParamsInternal=y);let b=!1;const A=null!=g,T=m.getCoordinateSystemType(),M=u.getCoordinateSystemType();if(u.isPannable()&&0!==T&&d){const H=d.centralMeridianOfOutputGCS;if(!Number.isNaN(H)&&u.isPannable()){const U=u.getPannableExtent(),Z=U.getCenterX();if(Z!==H){const st=Math.ceil(U.width());H+st!==Z+st&&(b=!0)}}}const X=d&&d.normalizeResultGeometry;if(m.equals(u))return this.m_bIdentity=!b,this.m_bIdentityGeogToGeog=!0,void this.updateProjector();const k=!A&&m.equalForProjection(u,this.m_bVertical);this.m_bIdentity=k&&!b,this.m_bIdentity?this.m_bIdentityGeogToGeog=!0:0!==T&&0!==M&&(X&&this.m_outputSR.isPannable()&&(this.m_bNormalize=X),this.m_datumTran=g||null,this.m_bIdentityGeogToGeog=(!this.m_datumTran||0===this.m_datumTran.count())&&this.m_inputSR.getGCS().equalForProjection(this.m_outputSR.getGCS(),this.m_bVertical)),this.updateProjector()}getInputSR(){return this.m_inputSR}getOutputSR(){return this.m_outputSR}getDatumTransformation(){return this.m_datumTran}getInverse(){const t=new tc(1,this.m_outputSR,this.m_inputSR,this.m_datumTran?.createInverse());return t.m_bIdentity=this.m_bIdentity,t.m_bVertical=this.m_bVertical,t.m_bIdentityGeogToGeog=this.m_bIdentityGeogToGeog,t.updateProjector(),t}isIdentity(){return this.m_bIdentity}getExtendedParams(){return this.m_params?this.m_params.m_extendedParams:ou().m_extendedParams}equals(t){return(0,F.g)(0),!1}isVertical(){return this.m_bVertical}isMatchingTransformation(t,m){return(0,F.g)(0),!1}getGeographicTransformations(){return this.m_datumTran}getExtendedParamsImpl(){return this.m_params?this.m_params.m_extendedParams:ou().m_extendedParams}getExtendedParamsInternal(){return this.m_params?this.m_params.m_extendedParamsInternal:ou().m_extendedParamsInternal}isIdentityGeogToGeog(){return this.m_bIdentityGeogToGeog}normalizeOutput(){return this.m_bNormalize}updateProjector(){this.m_projector=new ql(this)}};const hu=new Map,Va=new Map,mu=new Map;function vm(P){let t=P.getCode();if(t>0)return pu(t)||du(ws.coordsys(t));const m=P.getName();if(Va.has(m)){const u=Va.get(m);if(u&&u.deref()){const g=u.deref();if(g.m_peCoordSys.isEqual(P))return g}}return t=ws.getCode(P),du(t>0?ws.coordsys(t):P)}class uc{constructor(t,m,u){this.m_hashCode=-1,t&&(this.m_inputSR=t,this.m_outputSR=m,this.m_env=u.clone(),this.m_hashCode=this.m_inputSR.getHashCode(),this.m_hashCode=(0,Y.aq)(this.m_hashCode,this.m_outputSR.getHashCode()),this.m_env.isEmpty()||(this.m_hashCode=(0,Y.aq)(this.m_hashCode,(0,Y.at)(this.m_env.xmin)),this.m_hashCode=(0,Y.aq)(this.m_hashCode,(0,Y.at)(this.m_env.xmax)),this.m_hashCode=(0,Y.aq)(this.m_hashCode,(0,Y.at)(this.m_env.ymin)),this.m_hashCode=(0,Y.aq)(this.m_hashCode,(0,Y.at)(this.m_env.ymax))))}getHashCode(){return this.m_hashCode}equals(t){return!(this.m_inputSR&&!t.m_inputSR||!this.m_inputSR&&t.m_inputSR)&&this.m_env.equals(t.m_env)&&this.m_inputSR.equals(t.m_inputSR)&&this.m_outputSR.equals(t.m_outputSR)}clear(){this.m_inputSR=void 0,this.m_outputSR=void 0,this.m_hashCode=-1,this.m_env=void 0}}const lu=new Map;let uu,cu,gu;function Gu(){return uu||(uu=kr(Fm(),Mm())),uu}const _u=new Map;function du(P){const t=wo(P),m=P.getCode();if(m>0){const C=pu(m);if(C)return C}const u=P.getName();let g=Va.get(u);if(g){const C=g.deref();if(C&&C.m_peCoordSys.isEqual(P))return C}const d=new eu(t.release());if(m>0)return d.setCached(),hu.set(m,new WeakRef(d)),Va.set(u,new WeakRef(d)),d;const y=Da(P,0,!1);if(g=mu.get(y),g){const C=g.deref();if(C)return C}return d.setCached(),mu.set(y,new WeakRef(d)),d}function pu(P){const t=hu.get(P);if(t)return t.deref()}class Tn extends hs{constructor(t){return void 0===t?(super(),this.m_wkid=9001,void(this.m_peUnit=null)):"number"==typeof t?(super(),this.m_factor=t,void(this.m_wkid=0)):(super(t),void(t||(this.m_factor=1,this.m_wkid=9001,this.m_peUnit=function dc(){return gu||(gu=ws.unit(9001)),gu}())))}getUnitType(){return 0}convertFromMeters(t){return t/this.getUnitToBaseFactor()}convertToMeters(t){return t*this.getUnitToBaseFactor()}}const Pc=["0","1","2","3","4","5","6","7","8","9","b","c","d","e","f","g","h","j","k","m","n","p","q","r","s","t","u","v","w","x","y","z"];function Fu(P,t,m,u,g){(0,F.g)(u>>5<g.length);let d=t,y=m;for(let C=u;C>=0;C-=2){const b=.5*(y+d);P>=b?(g[C>>5]|=1<<(31&C),d=b):y=b}}let bm=new Set;const fu=2147483645n,Im=9007199254740990n,xu="operation is not supported for unknown coordinate systems";var Mu;function Lr(){return{majorSemiAxis:0,e2:0,minorSemiAxis:0,flattening:0,isSphere(){return 0===this.e2}}}function qu(P){!function Dc(P){sr=P,(0,F.g)(sr)}(P)}function Bi(){return!!ws}function Pu(){return!!sr}function wm(){return!!ws||!!sr}function Dm(P,t,m){return(0,F.g)(wm()),Vm(P,void 0===t?0:t,0,!1)}function yu(P,t){(0,F.g)(wm());const m=new Nn;let u;return Bi()?(u=function mc(P){const t=wo(ws.fromString(pe.PE_TYPE_COORDSYS,P));return t.get()||(0,F.z)(P),vm(t.release())}(P),m.setHorzProj_(u),m.m_vertcs=null,m.m_userWKID=u.getLatestID()):(u=Ym(P),m.m_unit=u.isPCS?new Tn(u.metersOrRadiansPerUnit):new Yt(u.metersOrRadiansPerUnit)),qm(m.m_precisionDescriptor,u,null,1),m.m_bDefaultDescriptor=!0,m.m_userWKT=P,m.calculateHashCode(),m.initDbgName(),m}function Ya(P,t,m,u,g=!0){let d=null;return t&&(d=function va(P,t=!0){return(0,F.g)(0),{}}(0,g)),function Sc(P,t,m,u,g){P||(0,F.t)("!PE_coord_sys");const d=new Nn;let y;return y=g?vm(P):new eu(P,!1),qm(d.m_precisionDescriptor,y,t,u),d.m_bDefaultDescriptor=!0,d.setHorzProj_(y),d.m_vertcs=t,d.m_userWKID=y.getLatestID(),d.calculateHashCode(),d.initDbgName(),d}(P,d,0,u,g)}function Eu(P,t,m=!1){3===P.getCoordinateSystemType()&&(0,F.t)("image spatial reference cannot be altered");const u=new Nn,g=P;return u.m_peCoordSysVal=g.m_peCoordSysVal,u.m_vertcs=g.m_vertcs,u.m_unit=g.m_unit,u.m_precisionDescriptor.assign(t),u.m_localZToXYFactor=g.m_localZToXYFactor,(Number.isNaN(u.m_precisionDescriptor.m_falseX)||Number.isNaN(u.m_precisionDescriptor.m_falseY))&&(u.m_precisionDescriptor.m_falseX=g.m_precisionDescriptor.m_falseX,u.m_precisionDescriptor.m_falseY=g.m_precisionDescriptor.m_falseY),u.m_precisionDescriptor.snapPrecision(),u.m_precisionDescriptor.fixTolerance(),u.m_userWKID=g.m_userWKID,u.m_bDefaultDescriptor=!!u.m_precisionDescriptor.equals(g.m_precisionDescriptor)&&g.m_bDefaultDescriptor,m&&(u.m_bDefaultDescriptor=!0),u.calculateHashCode(),u.initDbgName(),u}function Vu(P,t,m){void 0===t&&(t=1),(t<=0||!Number.isFinite(t))&&(0,F.t)(""),P||1===t||(0,F.t)("null Unit has to have z_to_xy_factor equal to 1");const u=new Nn;u.m_unit=P;const g=P||new Tn(9001);return zu(u.m_precisionDescriptor,g,null,1),u.m_bDefaultDescriptor=!0,Number.isNaN(u.m_precisionDescriptor.m_falseX)&&(0,F.t)("NAN false X/Y are not allowed here"),u.m_localZToXYFactor=t,u.calculateHashCode(),u.initDbgName(),u}function Yu(P,t){return P.snapGeometry(t)}function Tm(P){const t=P.getCoordinateSystemType();return 1===t?P:(3===t&&(0,F.g)(0),P.getGCS())}function Xu(P){return(0,F.g)(wm()),Pu()?function Ac(P){return(0,F.g)(Pu()),!!sr(P).isPCS||function Gc(P){return ws&&(0,F.m)("pe has been loaded. no-pe methods should not be used at this point."),er||Wu(),er.has(P)}(P)}(P):function fc(P){if(_u.has(P))return _u.get(P);{const t=function pc(P){return null!==wo(ws.coordsys(P)).get()}(P);return _u.set(P,t),t}}(P)}function Ru(P){if(Bi())return null!==wo(ws.fromString(pe.PE_TYPE_COORDSYS,P)).get();try{return Ym(P),!0}catch{}return!1}let Su;function ku(){return Su||(Su=(()=>{const P=Math.trunc(Math.random()*(0,Y.i)()),t=Date.now();return`|abba_000|${P.toString(16)}|${t.toString(16)}|`})()),Su}!function(P){P[P.utmDefault=0]="utmDefault",P[P.utmNorthSouth=1]="utmNorthSouth"}(Mu||(Mu={}));let vc=0;function Lu(P=""){let t=`${ku()}${vc++}`;return""!==P&&(t+=`|${P}`),t}function Bu(P){return P.startsWith(ku())}let Nm,Am,Gm,Nn=class ka{destroy(){(function lc(P){Va.delete(P.m_peCoordSys.getName()),mu.delete(Da(P.m_peCoordSys,0,!1))})(this.m_peCoordSysVal),1===this.getCoordinateSystemType()||2===this.getCoordinateSystemType()?this.getPECoordSys().destroy():(0,F.c)("SpatialReference.destroy")}constructor(){this.m_vertcs=null,this.m_peCoordSysVal=null,this.m_userWKID=0,this.m_userWKT=null,this.m_geogSpatialReference=null,this.m_srToGcs=null,this.m_gcsToSr=null,this.m_defaultPrecisionSR=null,this.m_localZToXYFactor=-1,this.m_precisionDescriptor=new _i,this.m_hashCode=0,this.m_bDefaultDescriptor=!1,bu(this.m_precisionDescriptor),bm&&bm.add(new WeakRef(this))}attachToPe(){(this.m_userWKID>0?Dm(this.m_userWKID):yu(this.m_userWKT)).copyTo(this,!1)}copyTo(t,m=!0){(m||t.m_bDefaultDescriptor)&&(t.m_bDefaultDescriptor=this.m_bDefaultDescriptor,t.m_precisionDescriptor.assign(this.m_precisionDescriptor)),t.m_defaultPrecisionSR=null,t.m_gcsToSr=this.m_gcsToSr,t.m_geogSpatialReference=this.m_geogSpatialReference,t.m_hashCode=this.m_hashCode,t.m_localZToXYFactor=this.m_localZToXYFactor,t.m_peCoordSysVal=this.m_peCoordSysVal,t.m_srToGcs=this.m_srToGcs,t.m_userWKID=this.m_userWKID,t.m_userWKT=this.m_userWKT,t.m_vertcs=this.m_vertcs,t.m_unit=this.m_unit}getHashCode(){return this.m_hashCode}getHashCodeHorizontal(){let t=0;return t=this.m_peCoordSysVal?this.m_peCoordSysVal.getHashCode():this.m_unit?this.m_unit.getHashCode():305419891,t}updateTransform(t){if(1===this.getCoordinateSystemType())return kr(this,this,null);let m=t?this.m_srToGcs:this.m_gcsToSr;if(m)return m;const u=this.getGCS();m=t?kr(this,u,null):kr(u,this,null);const d=m;return(t?this.m_srToGcs:this.m_gcsToSr)||(t?this.m_srToGcs=d:this.m_gcsToSr=d,m)}getHashCodeVertical(){return this.m_vertcs?this.m_vertcs.getHashCode():0}calculateHashCode(){let t=this.getHashCodeHorizontal();const m=this.getHashCodeVertical(),u=this.m_precisionDescriptor.getHashCode();t=(0,Y.aq)(t,m),this.m_hashCode=(0,Y.aq)(t,u)}initDbgName(){}setHorzProj_(t){this.m_peCoordSysVal=t,this.m_unit=this.m_peCoordSysVal.getUnit()}getTolerance(t=0){return this.m_precisionDescriptor.getTolerance(t)}getResolution(t=0){return this.m_precisionDescriptor.getResolution(t)}getPECoordSys(){return this.m_peCoordSysVal?this.m_peCoordSysVal.m_peCoordSys:null}getPCSInfo(){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSInfo()}getCentralMeridian(){return this.throwIfNotGCSOrPCS(),1===this.getCoordinateSystemType()?0:this.getPCSInfo().getCentralMeridian()}getCoordinateSystemType(){const t=this.getPECoordSys();if(t)switch(t.getType()){case pe.PE_TYPE_GEOGCS:return 1;case pe.PE_TYPE_PROJCS:return 2;default:return 0}else{if((this.m_userWKID>0||this.m_userWKT)&&this.m_unit instanceof Tn)return 2;if(this.m_unit instanceof Yt)return 1}return 0}getID(){return this.m_userWKID}getLatestID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getLatestID():this.m_userWKID}getOldID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getOldID():this.m_userWKID}getVerticalID(){return(0,F.b)("vcs not implemented"),0}getLatestVerticalID(){return this.m_vertcs?this.m_vertcs.getLatestID():0}getOldVerticalID(){return(0,F.b)("vcs not implemented"),0}getPEVerticalCoordSys(){return null}getPole(t){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPole(t)}getText(){const t=this.getPECoordSys();return t?Jn(t):this.m_userWKT??""}getTextExtended(t){const m=this.getPECoordSys();return m?this.getPEVerticalCoordSys()?function Jl(P,t,m,u){return(0,F.g)(0),""}(0,0,this.getPEVerticalCoordSys()):Jn(m,t):this.m_userWKT??""}getText2(t=-1){const m=this.getPECoordSys();return m?function Ta(P,t){(t>1||t<-1)&&(0,F.t)("verbosity");let m=pe.PE_STR_FMT_WKT2;return-1!==t&&(m|=0===t?pe.PE_STR_AUTH_TOP:pe.PE_STR_AUTH_ALL),P.toString(m)}(m,t):this.m_userWKT??""}getUnit(){return this.m_unit}getUnitsPerMillimeter(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getUnitsPerMillimeter():this.m_unit instanceof Tn?.001/this.m_unit.getUnitToBaseFactor():this.m_unit instanceof Yt?.001/(Ym(this.m_userWKT??this.m_userWKID).semiMajor*this.m_unit.getUnitToBaseFactor()):((0,F.m)("sr object not in valid state"),0)}getAuthorityName(){return this.getPECoordSys()?function Zn(P){return(0,F.g)(0),""}():""}getVerticalUnit(){return(0,F.b)("vcs not implemented"),{}}getVCS(){return this.m_vertcs}hasVCS(){return!1}getGCSHorisonIsInclusive(){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorisonIsInclusive()}getGCSHorizon(){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorizon()}getGCS(){const t=this.getCoordinateSystemType();if(0===t)(0,F.m)(xu);else{if(1===t)return this;3===t&&(0,F.m)("image cs not supported")}if(this.m_geogSpatialReference)return this.m_geogSpatialReference;let m;if(this===Fm()||this===vu())m=Mm();else{(0,F.g)(this.m_peCoordSysVal);const u=this.m_peCoordSysVal.m_peCoordSys.getGeogcs();u||(0,F.c)(""),m=Ya(u,this.m_vertcs,0,this.m_precisionDescriptor.getPrecision(),this.m_peCoordSysVal.getCached())}return this.m_geogSpatialReference?m=this.m_geogSpatialReference:this.m_geogSpatialReference=m,m}getGCSSplitLines(){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSSplitLines()}toGCS(t,m){if(0===t.length)return 0;t.length>m.length&&(0,F.t)("coordsSrc.size() > coordsDst.size()");const u=this.getCoordinateSystemType();if(0===u&&(0,F.m)(xu),1===u)return(0,Y.au)(m,t,t.length),t.length;(0,F.g)(this.m_peCoordSysVal);const g=this.getSRToGCSTransform();return(new Ji).transform(g,t,t.length,m)}toGeohash(t,m=8){const u=t.clone();u.scale(9102===this.getGCS().getUnit().getID()?1:this.getGCS().getUnit().getUnitToBaseFactor()/Math.PI*180),u.x<-180?(u.x=(0,Y.o)(u.x,360),u.x<-180&&(u.x+=360)):u.x>180&&(u.x=(0,Y.o)(u.x,360),u.x>180&&(u.x-=360)),u.y>90&&(u.y=90),u.y<-90&&(u.y=-90);const g=5*m,d=new Uint32Array(4);return Fu(u.x,-180,180,g-1,d),Fu(u.y,-90,90,g-2,d),function yc(P,t,m){const u=(0,Y.d)(t,"R");let g=0,d=0;for(let y=0;y<t;y++){let C=P[g]>>d&31;if(d+=5,d>31){const b=37-d;C&=(1<<b)-1,d-=32,g++,C|=(P[g]&(1<<d)-1)<<b}u[t-1-y]=Pc[C]}return m>t?u.push(..."0".repeat(m-t)):m<t&&(u.length=m),u.join("")}(d,m,m)}isPannable(){const t=this.getCoordinateSystemType();return 0!==t&&3!==t&&((0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.isPannable())}getPannableExtent(){return this.isPannable()||(0,F.t)("!is_pannable"),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtent()}getPannableExtentInGCS(){return this.isPannable()||(0,F.t)("!is_pannable"),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtentGCS()}throwIfNotGCSOrPCS(){const t=this.getCoordinateSystemType();1!==t&&2!==t&&(0,F.t)("Not a GCS or PCS")}getDomainXY(){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getDomainXY()}getFullWorldExtent(){return this.throwIfNotGCSOrPCS(),this.isPannable()?this.getPannableExtent():this.getDomainXY()}queryPrecisionDescriptor(t){if(t.assign(this.m_precisionDescriptor),Number.isNaN(t.m_falseX))if(Bi()||(0,F.r)("cannot query precision descriptor"),(0,F.g)(null!==this.m_peCoordSysVal),2!==this.m_precisionDescriptor.m_precision){const m=this.m_peCoordSysVal.getDomainXY();t.m_falseX=m.xmin,t.m_falseY=m.ymin}else t.m_falseX=-Number.MAX_VALUE,t.m_falseY=-Number.MAX_VALUE}queryPrecisionDescriptorWithoutFalseXY(t){t.assign(this.m_precisionDescriptor),t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}queryDefaultPrecisionDescriptorWithoutFalseXY(t){if(this.m_bDefaultDescriptor)t.assign(this.m_precisionDescriptor);else{const m=this.getCoordinateSystemType();0===m?zu(t,this.m_unit,this.m_vertcs,this.m_precisionDescriptor.getPrecision()):3===m?(0,F.b)("image cs"):qm(t,this.m_peCoordSysVal,this.m_vertcs,this.m_precisionDescriptor.getPrecision())}t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}horizontalEqual(t){return function vo(P,t){return P===t||null!==P&&null!==t&&P.m_csType===t.m_csType&&(0===P.m_WKID&&0===t.m_WKID?P.m_hashCode===t.m_hashCode&&P.m_canonicalWkt===t.m_canonicalWkt:P.m_WKID===t.m_WKID)}(this.m_peCoordSysVal,t.m_peCoordSysVal)}verticalEqual(t){return null!==this.m_vertcs==(null!==t.m_vertcs)&&(!this.m_vertcs||this.m_vertcs.equals(t.m_vertcs))}equals(t){const m=t;if(this===m)return!0;if(!this.horizontalEqual(m)||!this.verticalEqual(m)||!m.m_peCoordSysVal&&((0,F.g)(!this.m_peCoordSysVal),null!==this.m_unit!=(null!==m.m_unit)||this.m_unit&&!this.m_unit.equals(m.m_unit)||this.m_localZToXYFactor!==m.m_localZToXYFactor))return!1;if(!this.m_bDefaultDescriptor||!m.m_bDefaultDescriptor){if(this.m_peCoordSysVal){if(!this.m_precisionDescriptor.equalsWithoutFalseXY(m.m_precisionDescriptor))return!1;(0,F.g)(m.m_peCoordSysVal);let u=this.m_precisionDescriptor.m_falseX,g=this.m_precisionDescriptor.m_falseY;if(Number.isNaN(u)){const C=this.m_peCoordSysVal.getDomainXY();u=C.xmin,g=C.ymin}let d=m.m_precisionDescriptor.m_falseX,y=m.m_precisionDescriptor.m_falseY;if(Number.isNaN(d)){const C=m.m_peCoordSysVal.getDomainXY();d=C.xmin,y=C.ymin}return u===d&&g===y}return this.m_precisionDescriptor.equals(m.m_precisionDescriptor)}return!0}equalForProjection(t,m){if(this===t)return!0;const u=this.getCoordinateSystemType(),g=t.getCoordinateSystemType();if(0===u||0===g)return 0===u&&0===g?(!m||this.getZToXYFactor()===t.getZToXYFactor())&&(!this.getUnit()||!t.getUnit()||this.getUnit().equals(t.getUnit())):3!==u&&3!==g&&(null===this.getUnit()||null===t.getUnit()||(!m||this.getZToXYFactor()===t.getZToXYFactor())&&this.getUnit().equals(t.getUnit()));if(u!==g)return!1;if(3===u)return this.equals(t);if(function ec(P,t){return P===t||null!==P&&null!==t&&P.m_csType===t.m_csType&&(0===P.m_WKID&&0===t.m_WKID?1===P.m_csType?P.m_peCoordSys.isEqual(t.m_peCoordSys):P.m_peCoordSys===t.m_peCoordSys:P.m_WKID===t.m_WKID)}(this.m_peCoordSysVal,t.m_peCoordSysVal)){if(!m)return!0;if(null!==this.m_vertcs==(null!==t.m_vertcs))return!this.m_vertcs||this.m_vertcs.equalForProjection(t.m_vertcs)}return!1}equalHorizontal(t){return this.horizontalEqual(t)}equalVertical(t){return(0,F.g)(0),!1}equalVerticalVCS(t){return(0,F.g)(0),!1}convergenceAngle(t){return(0,F.g)(0),0}getPeCoordsysCopy(){if(this.m_peCoordSysVal){const t=this.m_peCoordSysVal.m_peCoordSys;return t||(0,F.c)("cannot clone coord sys"),t}return null}getPeVertcsCopy(){return(0,F.g)(0),0}throwIfLocal(){0===this.getCoordinateSystemType()&&(0,F.t)(xu)}getPrimeMeridian(){return this.throwIfLocal(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPrimeMeridian()}getSRToGCSTransform(){return this.updateTransform(!0)}getGCSToSRTransform(){return this.updateTransform(!1)}getOneMeter(){return 1e3*this.getUnitsPerMillimeter()}getOneMeterPCSUnit(){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneMeterPCSUnit()}getDefaultPrecisionSR(){if(this.m_bDefaultDescriptor)return this;if(null===this.m_defaultPrecisionSR){const t=new _i;this.queryDefaultPrecisionDescriptorWithoutFalseXY(t),this.m_defaultPrecisionSR=Eu(this,t,!0)}return this.m_defaultPrecisionSR}getPCSHorizon(){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSHorizon()}getHorzUnitFactor(){return this.m_unit?this.m_unit.getUnitToBaseFactor():1}querySpheroidData(t){this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal);const m=this.getGCS().getPECoordSys().getDatum().getSpheroid(),u=m.getFlattening();!function Ec(P,t,m){P.majorSemiAxis=t,P.minorSemiAxis=t*(1-m),P.e2=m*(2-m),P.flattening=m}(t,m.getAxis(),u)}getAreaOfUse(){0===this.getCoordinateSystemType()&&(0,F.m)(""),(0,F.g)(this.m_peCoordSysVal);const t=this.m_peCoordSysVal.getAreaOfUse();return null===t?new ue:new ue({geom:t.clone(),sr:Dm(4326)})}getZToXYFactor(){return 1}isCustomWkid(){return!1}getOneDegreeGCSUnit(){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneDegreeGCSUnit()}getGcsUnitFactor(){return this.throwIfNotGCSOrPCS(),(0,F.g)(this.m_peCoordSysVal),this.m_peCoordSysVal.getGcsUnitFactor()}snapGeometry(t){if(t.isEmpty()||2===this.m_precisionDescriptor.getPrecision())return!1;const m=t.getGeometryType();if((0,F.i)(m))return this.snapMultiVertex_(t);if(m===F.G.enumPoint)return this.snapPoint_(t);if(m===F.G.enumEnvelope)return this.snapEnvelope_(t);if((0,F.f)(m))return this.snapSegment_(t);if(m===F.G.enumGeometryCollection){const u=t;let g=!1;for(let d=0,y=u.getGeometryCount();d<y;++d)g=this.snapGeometry(u.getGeometry(d))||g;return g}(0,F.c)("what else?")}snapMultiVertex_(t){if((0,F.g)(!t.isEmpty()),(0,F.g)(2!==this.m_precisionDescriptor.getPrecision()),(0,F.h)(t.getGeometryType())){const d=t;if(d.hasNonLinearSegments())return this.snapGeometryWithCurves_(d)}const m=t.getImpl(),u=m.getDescription();let g=!1;for(let d=0,y=u.getAttributeCount();d<y;d++){const C=u.getSemantics(d),S=m.getAttributeStreamRef(C);g=this.snapAttributes(C,S,0,m.getPointCount())||g}return g&&m.notifyModifiedFlags(2001),g}snapPoint_(t){return!1}snapEnvelope_(t){return!1}snapSegment_(t){(0,F.g)(!t.isEmpty()),(0,F.g)(2!==this.m_precisionDescriptor.getPrecision());const m=new _i;this.queryPrecisionDescriptor(m);const u=t.getStartXY(),g=new Y.P;g.x=bo(u.x,m.getFalseX(),m.getGridUnitsXY()),g.y=bo(u.y,m.getFalseY(),m.getGridUnitsXY());let d=!g.equals(u);const y=t.getEndXY(),C=new Y.P;C.x=bo(y.x,m.getFalseX(),m.getGridUnitsXY()),C.y=bo(y.y,m.getFalseY(),m.getGridUnitsXY()),d||=!C.equals(y),d&&t.changeEndPoints2D(g,C);const S=(A,T,M)=>{let X=!1;{const k=t.getStartAttributeAsDbl(A,0),H=bo(k,T,M),U=!(0,Y.a3)(H,k);X||=U,U&&t.setStartAttribute(A,0,H)}{const k=t.getEndAttributeAsDbl(A,0),H=bo(k,T,M),U=!(0,Y.a3)(H,k);X||=U,U&&t.setEndAttribute(A,0,H)}return X};let b=d?1:0;return t.hasAttribute(1)&&(b|=S(1,m.getFalseZ(),m.getGridUnitsZ())?1:0),t.hasAttribute(2)&&(b|=S(2,m.getFalseM(),m.getGridUnitsM())?1:0),!!b}snapGeometryWithCurves_(t){(0,F.g)(!t.isEmpty()),(0,F.g)(2!==this.m_precisionDescriptor.getPrecision());const m=t.createInstance(),u=new c.S;let g=0;for(let d=0,y=t.getPathCount();d<y;++d){const C=t.getSegmentCountPath(d);if(0===C){if(m.addPath(t,d,!0),1===m.getPathSize(d)){const b=new dt.P;m.getPointByVal(m.getPointCount()-1,b),g|=this.snapGeometry(b)?1:0,m.setPointByVal(m.getPointCount()-1,b)}continue}const S=t.isClosedPath(d);for(let b=0,A=S?C-1:C;b<A;++b)t.getSegmentFromPath(d,b,u,!1),g|=this.snapGeometry(u.get())?1:0,m.addSegment(u.get(),0===b);S&&(t.getSegmentFromPath(d,C-1,u,!1),g|=this.snapGeometry(u.get())?1:0,1===C?m.addPathFromClosedSegment(u.get(),!1):m.closeLastPathWithSegment(u.get()))}return g&&m.copyTo(t),!!g}snapAttributes(t,m,u,g){let d=!1;const y=new _i;if(this.queryPrecisionDescriptor(y),0===t){const C=m;for(let S=u;S<g;S++){const b=C.read(2*S),A=ka.s_SnapValue(b,y.getFalseX(),y.getGridUnitsXY()),T=C.read(2*S+1),M=ka.s_SnapValue(T,y.getFalseY(),y.getGridUnitsXY());d=d||A!==b||M!==T,d&&(C.write(2*S,A),C.write(2*S+1,M))}}else if(1===t){const C=m;for(let S=u;S<g;S++){const b=C.read(S),A=ka.s_SnapValue(b,y.getFalseZ(),y.getGridUnitsZ());d=d||!(0,Y.a3)(A,b),d&&C.write(S,A)}}else if(2===t){const C=m;for(let S=u;S<g;S++){const b=C.read(S),A=ka.s_SnapValue(b,y.getFalseM(),y.getGridUnitsM());d=d||!(0,Y.a3)(A,b),d&&C.write(S,A)}}return d}static s_SnapValue(t,m,u){return(0,Y.av)((t-m)*u)/u+m}};class _i{constructor(){const t=Im,m=1e-4,u=.001,g=m*Number(t)*.5;this.m_precision=1,this.m_falseX=-g,this.m_falseY=-g,this.m_unitsXY=Number(t)/(2*g),this.m_falseM=-1e5,this.m_unitsM=1/m,this.m_falseZ=-1e5,this.m_unitsZ=1/m,this.m_toleranceXY=u,this.m_toleranceM=u,this.m_toleranceZ=u}getHashCode(){let t=7777,m=7777;return m=(0,Y.aq)(m,this.m_falseM),m=(0,Y.aq)(m,this.m_unitsM),t=(0,Y.aq)(t,this.m_unitsXY),m=(0,Y.aq)(m,this.m_toleranceXY),t=(0,Y.aq)(t,this.m_falseZ),m=(0,Y.aq)(m,this.m_toleranceZ),t=(0,Y.aq)(t,this.m_unitsZ),m=(0,Y.aq)(m,this.m_toleranceM),t=(0,Y.aq)(t,this.m_precision),(0,Y.aq)(t,m)}clone(){const t=new _i;return t.m_falseX=this.m_falseX,t.m_falseY=this.m_falseY,t.m_unitsXY=this.m_unitsXY,t.m_falseZ=this.m_falseZ,t.m_unitsZ=this.m_unitsZ,t.m_falseM=this.m_falseM,t.m_unitsM=this.m_unitsM,t.m_toleranceXY=this.m_toleranceXY,t.m_toleranceZ=this.m_toleranceZ,t.m_toleranceM=this.m_toleranceM,t.m_precision=this.m_precision,t}assign(t){return this.m_falseX=t.m_falseX,this.m_falseY=t.m_falseY,this.m_unitsXY=t.m_unitsXY,this.m_falseZ=t.m_falseZ,this.m_unitsZ=t.m_unitsZ,this.m_falseM=t.m_falseM,this.m_unitsM=t.m_unitsM,this.m_toleranceXY=t.m_toleranceXY,this.m_toleranceZ=t.m_toleranceZ,this.m_toleranceM=t.m_toleranceM,this.m_precision=t.m_precision,this}initialize2D(t,m){}getTolerance(t){switch(t){case 0:return this.m_toleranceXY;case 1:return this.m_toleranceZ;case 2:return this.m_toleranceM;default:return 0}}getResolution(t){if(2===this.m_precision)return 0;switch(t){case 0:return 1/this.m_unitsXY;case 1:return 1/this.m_unitsZ;case 2:return 1/this.m_unitsM;default:return 0}}getFalseX(){return this.m_falseX}getFalseY(){return this.m_falseY}getFalseZ(){return this.m_falseZ}getFalseM(){return this.m_falseM}getGridUnitsXY(){return this.m_unitsXY}getGridUnitsZ(){return this.m_unitsZ}getGridUnitsM(){return this.m_unitsM}getPrecision(){return this.m_precision}static getLimit32(){return 2147483645}static getLimit64(){return 9007199254740990n}static getLimitFloat(){return 0}getXYGridRange(){const t=new R.J;switch(this.m_precision){case 0:{const m=_i.getLimit32()/this.getGridUnitsXY();t.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+m,ymax:this.getFalseY()+m})}break;case 1:{const m=Number(_i.getLimit64())/this.getGridUnitsXY();t.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+m,ymax:this.getFalseY()+m})}break;case 2:t.setCoords({xmin:-Number.MAX_VALUE,ymin:-Number.MAX_VALUE,xmax:Number.MAX_VALUE,ymax:Number.MAX_VALUE});break;default:t.setEmpty(),(0,F.c)("")}return t}getZGridRange(){const t=new Y.E;switch(this.m_precision){case 0:{const m=_i.getLimit32()/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+m)}break;case 1:{const m=Number(_i.getLimit64())/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+m)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),(0,F.c)("")}return t}getMGridRange(){const t=new Y.E;switch(this.m_precision){case 0:{const m=_i.getLimit32()/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+m)}break;case 1:{const m=Number(_i.getLimit64())/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+m)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),(0,F.c)("")}return t}setTolerance(t,m){switch(m<0&&(0,F.t)("tol < 0"),Number.isFinite(m)||(0,F.t)("tol is not finite"),t){case 0:this.m_toleranceXY=m;break;case 1:this.m_toleranceZ=m;break;case 2:this.m_toleranceM=m;break;default:(0,F.t)("cannot set tolerance for this attribute")}}setGridParams(t,m,u){Number.isFinite(t)&&Number.isFinite(m)&&Number.isFinite(u)||(0,F.t)("grid params are not finite"),u<1&&(0,F.t)("grid units cannot be smaller than 1.0"),this.m_falseX=t,this.m_falseY=m,this.m_unitsXY=u}setZParams(t,m){Number.isFinite(t)&&Number.isFinite(m)||(0,F.t)("grid params are not finite"),m<1&&(0,F.t)("grid units cannot be smaller than 1.0"),this.m_falseZ=t,this.m_unitsZ=m}setMParams(t,m){Number.isFinite(t)&&Number.isFinite(m)||(0,F.t)("grid params are not finite"),m<1&&(0,F.t)("grid units cannot be smaller than 1.0"),this.m_falseM=t,this.m_unitsM=m}setPrecision(t){}equals(t){return this===t||(0,Y.a3)(this.m_falseX,t.m_falseX)&&(0,Y.a3)(this.m_falseY,t.m_falseY)&&this.equalsWithoutFalseXY(t)}snapPrecision(){if(2===this.m_precision)return;const t=(u,g,d,y)=>{if(!Number.isFinite(g)||!Number.isFinite(d))return d;if(d<1)return 1;if(!y)return d;const C=Number(u)/d;return Math.trunc((g+C-g)*d)>u&&(d=u/(g+C-g)),Math.max(1,d)},m=Number(0===this.m_precision?fu:Im);this.m_unitsXY=t(m,this.m_falseX,this.m_unitsXY,!0),this.m_unitsXY=t(m,this.m_falseY,this.m_unitsXY,!0),this.m_unitsZ=t(m,this.m_falseZ,this.m_unitsZ,!1),this.m_unitsM=t(m,this.m_falseM,this.m_unitsM,!1)}verifyPrecision(){if(2===this.m_precision)return!0;const t=(u,g,d,y)=>{if(d<1||!Number.isFinite(g)||!Number.isFinite(d))return!1;if(!y)return!0;const C=Number(u)/d;return!(BigInt((g+C-g)*d)>u)},m=0===this.m_precision?fu:Im;return!!(t(m,this.m_falseX,this.m_unitsXY,!0)&&t(m,this.m_falseY,this.m_unitsXY,!0)&&t(m,this.m_falseZ,this.m_unitsZ,!1)&&t(m,this.m_falseM,this.m_unitsM,!1))}fixTolerance(){2!==this.m_precision&&(this.m_toleranceXY=Math.max(2/this.m_unitsXY,this.m_toleranceXY),this.m_toleranceZ=Math.max(2/this.m_unitsZ,this.m_toleranceZ),this.m_toleranceM=Math.max(2/this.m_unitsM,this.m_toleranceM),(Number.isNaN(this.m_falseX)||Number.isNaN(this.m_falseY))&&(this.m_falseX=this.m_falseY=Number.NaN))}equalsWithoutFalseXY(t){return this===t||this.m_unitsXY===t.m_unitsXY&&this.m_falseZ===t.m_falseZ&&this.m_unitsZ===t.m_unitsZ&&this.m_falseM===t.m_falseM&&this.m_unitsM===t.m_unitsM&&this.m_toleranceXY===t.m_toleranceXY&&this.m_toleranceZ===t.m_toleranceZ&&this.m_toleranceM===t.m_toleranceM&&this.m_precision===t.m_precision}setBestXyDomainFromEnvelope(t,m){}setBestZDomainFromZRange(t,m,u){}setBestMDomainFromMRange(t,m,u){}}function Fm(){return(!Nm||Bi()&&null===Nm.getPECoordSys())&&(Nm=Vm(3857,0,0,!0)),Nm}function vu(){return(!Am||Bi()&&null===Am.getPECoordSys())&&(Am=Vm(102100,0,0,!0)),Am}function Mm(){return(!Gm||Bi()&&null===Gm.getPECoordSys())&&(Gm=Vm(4326,0,0,!0)),Gm}function bu(P){P.m_falseX=0,P.m_falseY=0,P.m_unitsXY=1,P.m_falseZ=0,P.m_unitsZ=1,P.m_falseM=0,P.m_unitsM=1,P.m_toleranceXY=100*(0,Y.N)(),P.m_toleranceZ=100*(0,Y.N)(),P.m_toleranceM=100*(0,Y.N)(),P.m_precision=2}function qm(P,t,m,u){const g=t instanceof eu;bu(P),P.m_precision=u,P.m_falseX=Number.NaN,P.m_falseY=Number.NaN;const d=1e-4,y=.001,C=g?t.m_csType:t.isPCS?2:1;if(1===C){const A=(0===u?5.555555555555555e-7:1e-9)*(g?t.getOneDegreeGCSUnit():Math.PI/t.metersOrRadiansPerUnit/180);P.m_unitsXY=1/A}else if(2===C){const A=(0===u?y:d)*(g?t.getOneMeterPCSUnit():1/t.metersOrRadiansPerUnit);P.m_unitsXY=1/A}else(0,F.t)("unrecognized cs type");P.m_falseM=-1e5,P.m_unitsM=1/(0===u?y:d),P.m_unitsM=Math.max(1,P.m_unitsM),P.m_unitsXY=Math.max(1,P.m_unitsXY);let S=0,b=0;0!==u&&1!==u||(S=2/P.m_unitsXY,b=2/P.m_unitsM),P.m_toleranceXY=Math.max(S,g?t.getUnitsPerMillimeter():2===C?.001/t.metersOrRadiansPerUnit:.001/(t.semiMajor*t.metersOrRadiansPerUnit)),P.m_toleranceM=Math.max(y,b),Hu(P,m)}function Hu(P,t){if(P.m_falseZ=-1e5,t){const d=(0===P.m_precision?.001:1e-4)*t.getOneMeter();P.m_unitsZ=1/d}else P.m_unitsZ=1/(0===P.m_precision?.001:1e-4);P.m_unitsZ=Math.max(1,P.m_unitsZ);let g=0;0!==P.m_precision&&1!==P.m_precision||(g=2/P.m_unitsZ),P.m_toleranceZ=Math.max(t?.001*t.getOneMeter():.001,g)}function zu(P,t,m,u){bu(P),P.m_precision=u;const g=0===u?fu:Im,d=1e-4,y=.001;let C=1,S=1,b=.001;t&&(S=t.getUnitToBaseFactor()),t&&1===t.getUnitType()?(C=400*Math.PI/180,b=8.983152841195215e-9*Math.PI/180/S):(C=(0===u?y:d)*Number(g)*.5,b=y/S),C/=S,P.m_falseX=-C,P.m_falseY=-C,P.m_unitsXY=Number(g)/(2*C),P.m_falseM=-1e5,P.m_unitsM=1/(0===u?y:d),P.m_unitsM=Math.max(1,P.m_unitsM),P.snapPrecision();let A=0,T=0;0!==P.m_precision&&1!==P.m_precision||(T=2/P.m_unitsM,A=2/P.m_unitsXY),P.m_toleranceXY=Math.max(A,b),P.m_toleranceM=Math.max(y,T),Hu(P,m)}function Vm(P,t,m,u){if(!u&&t<=0){if(3857===P)return Fm();if(102100===P)return vu();if(4326===P)return Mm()}const g=new Nn;let d,y=null;return Bi()?(d=function ac(P){P<=0&&(0,F.y)(P);{const u=pu(P);if(u)return u}const t=wo(ws.coordsys(P));t.get()||(0,F.y)(P);const m=du(t.release());return m.getLatestID()!==P&&hu.set(P,new WeakRef(m)),m}(P),t>0?y=null:t=0,g.setHorzProj_(d),g.m_vertcs=y):(d=Ym(P),g.m_unit=d.isPCS?new Tn(d.metersOrRadiansPerUnit):new Yt(d.metersOrRadiansPerUnit)),qm(g.m_precisionDescriptor,d,y,1),g.m_bDefaultDescriptor=!0,g.m_userWKID=P,g.calculateHashCode(),g.initDbgName(),g}function bo(P,t,m){return(0,Y.av)((P-t)*m)/m+t}let er=null;const Uu=3552713678800501e-30;function es(P,t){return function bc(P,t,m){return P===t||Math.abs(P-t)<=m*(1+(Math.abs(P)+Math.abs(t))/2)}(P,t,Uu)}let js,ws,pe,Hs,Iu,zs,Io,Ou,Si,Xa,wu;function wo(P){return{_this:P,get(){return this._this},reset(t){this._this=t},release(){const t=this._this;return this._this=null,t}}}let sr=null;function Ym(P){(0,F.g)(sr);const t=sr(P);return t.semiMajor=t.isPCS?Number.NaN:function Mc(P){if(ws&&(0,F.m)("pe has been loaded. no-pe methods should not be used at this point."),"string"==typeof P){const t=P.match(Fc);t&&2===t.length||(0,F.t)("bad gcs wkt");const m=Number.parseFloat(t[1]);return Number.isFinite(m)||(0,F.t)("bad gcs wkt"),m}return er||Wu(),er.has(P)||(0,F.m)("gcs wkid not found"),er.get(P)}(P),t}const Fc=/(?:ELLIPSOID|SPHEROID)\["(?:\w|[-()])+",(\d+\.\d+)/;function Wu(){er=new Map;for(const P in As){const t=Number.parseFloat(P),m=As[P];if(Array.isArray(m))for(const u of m)er.set(u,t);else er.set(m,t)}!function Ve(){for(const P in As)delete As[P]}()}function ju(P,t){return new Xm(P,t)}const Ju=(0,Y.ar)(0),Zu=(0,Y.ar)(1);let Xm=class Tu{constructor(t,m){if(t instanceof Tu)return this.m_geogTranWrapper=t.m_geogTranWrapper,this.m_bInverted=m?!t.m_bInverted:t.m_bInverted,void(this.m_hashCode=(0,Y.aq)(this.m_geogTranWrapper.getHashCode(),this.m_bInverted?Zu:Ju));this.m_geogTranWrapper=new xo(t),this.m_bInverted=m,this.m_hashCode=(0,Y.aq)(this.m_geogTranWrapper.getHashCode(),this.m_bInverted?Zu:Ju)}getID(){return this.m_geogTranWrapper.getLatestId()}getLatestID(){return this.m_geogTranWrapper.getLatestId()}getText(){return this.m_geogTranWrapper.getText()}getTextExtended(t){if(!this.m_geogTranWrapper.getGeogtran())return"";if(-1===t)return this.m_geogTranWrapper.getGeogtran().toString();{const m=0===t?pe.PE_STR_AUTH_TOP:pe.PE_STR_AUTH_ALL;return this.m_geogTranWrapper.getGeogtran().toString(m)}}getText2(t=-1){let m=pe.PE_STR_FMT_WKT2;return-1!==t&&(m|=0===t?pe.PE_STR_AUTH_TOP:pe.PE_STR_AUTH_ALL),this.m_geogTranWrapper.getGeogtran().toString(m)}getName(){return this.m_geogTranWrapper&&this.m_geogTranWrapper.getGeogtran()?this.m_geogTranWrapper.getGeogtran().getName():""}getInputSpatialReference(){return this.m_bInverted?this.m_geogTranWrapper.getOutputSr(!1):this.m_geogTranWrapper.getInputSr(!1)}getOutputSpatialReference(){return this.m_bInverted?this.m_geogTranWrapper.getInputSr(!1):this.m_geogTranWrapper.getOutputSr(!1)}getInverse(){return new Tu(this,!0)}isInverted(){return this.m_bInverted}getHashCode(){return this.m_hashCode}GetPeGeogtran(){return this.m_geogTranWrapper.getGeogtran()}equals(t){const m=t;return m===this||this.m_bInverted===m.m_bInverted&&(this.GetPeGeogtran()===m.GetPeGeogtran()||this.getID()===m.getID()&&!(0===this.getID()&&!this.GetPeGeogtran().isEqual(m.GetPeGeogtran())))}referencesMissingData(){return!!this.m_geogTranWrapper&&!this.m_geogTranWrapper.isUsable()}getWrapper(){return this.m_geogTranWrapper}};function Qu(P,t,m,u,g){const d=P.getGCS(),y=t.getGCS(),C=d.getPECoordSys(),S=y.getPECoordSys();let b=null;if(!m.isEmpty()){const X=m.clone();if(!X.isEmpty()&&2===P.getCoordinateSystemType()){let k=new dt.E({env2D:X});const H=kr(P,d,null);k=(new Ji).execute(k,H,null),k.queryEnvelope(X)}if(!X.isEmpty()){const k=C.getPrimem().getLongitude(),H=C.getUnit().getUnitFactor();b=new wu(X.xmin,X.ymin,X.xmax,X.ymax,k,H)}}let A=u;A>=(0,Y.i)()&&(A=0);const T=[];let M=Io.PE_GTLIST_OPTS_COMMON;g||(M&=~Io.PE_GTLIST_OPTS_USABLE);for(let X=0;X<2;X++){T.length=0;const H=Io.getGTlist(C,S,2,M,b,A);let U=!1;if(H&&H.length>0)for(let Z=0,st=H.length;Z<st;Z++){const mt=Ku([H[Z]]);if((0,F.g)(mt),g&&mt.referencesMissingData())U=!0;else if(T.push(mt),u>0&&T.length===u)break}if(!U)break;0===A||(A=0)}return b&&b.destroy(),T}function Ku(P){(0,F.g)(null!==P);const t=new Du,m=P[0].getSteps();if(m){const u=P[0].getEntries();for(let g=0;g<m;g++){const d=0!==u[g].getDirection(),y=ju(u[g].getGeogtran(),d);t.add(y)}return t.create()}return null}let $u=class{constructor(P,t,m,u){this.m_bReadOnly=!0,this.m_name="",this.m_fastTrack=-1,this.m_bNameIsSet=!1,this.m_transforms=P,t&&(this.m_name=t,this.m_bNameIsSet=!0),this.m_inputSr=m,this.m_outputSr=u}getType(){return 0}getName(){if(this.m_bNameIsSet)return this.m_name;if(0===this.m_transforms.length)return"";let P="";for(const t of this.m_transforms)P.length>0&&(P+=" + "),t.isInverted()&&(P+="~"),P+=t.getName();return P}count(){return this.m_transforms.length}createInverse(){return this.getInverse()}getHashCode(){let P=1973;for(let t=0;t<this.m_transforms.length;t++)P=(0,Y.aq)(P,this.m_transforms[t].getHashCode());return P}equals(P){return(0,F.g)(0),!1}referencesMissingData(){if(0===this.m_transforms.length)return!1;for(const P of this.m_transforms)if(P.referencesMissingData())return!0;return!1}isMatchingTransformation(P,t){return(0,F.g)(0),!1}validateTransformation(P,t){return(0,F.g)(0),!1}nameIsSet(){return(0,F.g)(0),!1}getInputSpatialReference(){return this.m_inputSr}getOutputSpatialReference(){return this.m_outputSr}getStep(P){return(P<0||P>this.count())&&(0,F.n)(""),this.m_transforms[P]}getInverse(){const P=new Du;return P.addSteps(this,!0),P.setInputSpatialReference(this.m_outputSr),P.setOutputSpatialReference(this.m_inputSr),P.create()}transform(P,t,m){if(0===this.count())return;let u=this.m_inputSr,g=this.m_outputSr;if(P&&(g=(0,Y.b)(u,u=g)),0===this.m_transforms.length)return void vn(u,null,g,null,t,null,m);let d=this.m_fastTrack;if(1===d)return void(0,c.I)(P,this.m_transforms,T=>{!function qr(P,t,m,u,g){const d=P.getVerttran(),y=P.getGeogtran();if(g>0){P.prepareOrThrow();const C=t?pe.PE_TRANSFORM_2_TO_1:pe.PE_TRANSFORM_1_TO_2;d?at():pt(y,g,m,u,C)}}(T.getWrapper(),P!==T.isInverted(),t,null,m)});const y=ki();-1===d&&y.initFromGcsAndVcs(u,null);const C=ki();let S=P?this.m_transforms.length-1:0;const b=P?-1:1;for(let T=0,M=this.m_transforms.length;T<M;T++,S+=b){if(0===T){const k=this.m_transforms[S];Wn(u.getPECoordSys(),null,k.getWrapper(),P!==k.isInverted(),t,null,m,C),-1===d&&(y.equals(C)||(d=0)),y.assign(C)}else{const k=this.m_transforms[S-b],H=this.m_transforms[S];zl(y,k.getWrapper(),P!==k.isInverted(),H.getWrapper(),P!==H.isInverted(),t,null,m,C),-1===d&&(y.equals(C)||(d=0)),y.assign(C)}const X=this.m_transforms[S];wa(y,X.getWrapper(),P!==X.isInverted(),t,null,m,C),y.assign(C)}const A=this.m_transforms[S-b];(function Ia(P,t,m,u,g,d,y,C){const S=ki();S.assign(m?t.m_inputUnitParams:t.m_outputUnitParams),S.processUnitParams(P);let A=null;u&&(A=u.getPECoordSys());const T=ki();T.initFromGcsAndVcsPe(A,null),T.processUnitParams(S),S.processUnitParams(T),C>0&&Sn(S,T,d,y,C)})(y,A.getWrapper(),P!==A.isInverted(),g,0,t,null,m),-1===d&&(C.initFromGcsAndVcs(g,null),y.equals(C)||(d=0)),this.m_fastTrack=0===d?0:1}};class Du{constructor(){this.m_transforms=[],this.m_inputGCS=null,this.m_outputGCS=null,this.m_name="",this.m_bNameIsSet=!1}getInputSpatialReference(){return null!==this.m_inputGCS?this.m_inputGCS:this.count()>0?this.m_transforms[0].getInputSpatialReference():null}setInputSpatialReference(t){this.m_inputGCS=t?t.getGCS():null}getOutputSpatialReference(){return null!==this.m_outputGCS?this.m_outputGCS:this.count()>0?this.m_transforms.at(-1).getOutputSpatialReference():null}setOutputSpatialReference(t){this.m_outputGCS=t?t.getGCS():null}getName(){if(this.m_bNameIsSet)return this.m_name;if(0===this.m_transforms.length)return"";let t="";for(const m of this.m_transforms)t.length>0&&(t+=" + "),m.isInverted()&&(t+="~"),t+=m.getName();return t}count(){return this.m_transforms.length}getStep(t){return(t<0||t>this.count())&&(0,F.n)(""),this.m_transforms[t]}setStep(t,m){(0,F.g)(0)}add(t){this.m_transforms.push(t)}addSteps(t,m){if(m)for(let u=t.count()-1;u>=0;--u)this.add(t.getStep(u).getInverse());else for(let u=0;u<t.count();++u)this.add(t.getStep(u))}clear(){this.m_transforms=[],this.m_name="",this.m_bNameIsSet=!1,this.m_inputGCS=null,this.m_outputGCS=null}remove(t){(0,F.g)(0)}create(){const t=this.getInputSpatialReference(),m=this.getOutputSpatialReference(),u=new $u(this.m_transforms,this.m_bNameIsSet?this.m_name:null,t,m);return u.m_bReadOnly=!0,this.clear(),u}}const Yc=Object.freeze(Object.defineProperty({__proto__:null,SpatialReference:Nn,SpatialReferencePrecisionDescriptor:_i,create:Dm,createFromWKT:yu,createImplFromPe:Ya,createLocal:Vu,createWithNewPrecision:Eu,createWithNewVCS:function Cu(P,t,m){return{}},getGCS:Tm,getTempName:Lu,hasNoPe:Pu,hasPe:Bi,injectNoPe:qu,injectPe:function Cc(P){if(ws)return;!function Tc(P){const t=P;ws=t.PeFactory,(0,F.g)(ws),wu=t.PeGCSExtent,(0,F.g)(wu),Si=t.PeLineType,(0,F.g)(Si),Xa=t.PeMath,(0,F.g)(Xa),js=t.PeDouble,(0,F.g)(js),pe=t.PeDefs,(0,F.g)(pe),Hs=t.PeCSTransformations,(0,F.g)(Hs),Iu=t.PeGTTransformations,(0,F.g)(Iu),zs=t.PePCSInfo,(0,F.g)(zs),Io=t.PeGTlistExtended,(0,F.g)(Io),ws.initialize(),Ou=t.PeGTlistExtendedEntry,(0,F.g)(Ou),pe.PE_TYPE_ANGUNIT=512,pe.PE_STR_AUTH_ALL=2,zs.PE_POLE_LINE_STRAIGHT=2,zs.PE_POLE_LINE_CURVED=3,pe.PE_PARM_LAM0=2,pe.PE_PARM_PHI0=6,pe.PE_PRJ_AZIMUTHAL_EQUIDISTANT=43032,pe.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA=43033,pe.PE_PRJ_ALBERS=43007,pe.PE_PRJ_CYLINDRICAL_EQAREA=43034,pe.PE_TYPE_VERTCS=8,pe.PE_LINETYPE_GEODESIC=0,pe.PE_LINETYPE_LOXODROME=1,pe.PE_LINETYPE_GREAT_ELLIPTIC=2,pe.PE_LINETYPE_NORMAL_SECTION=3,Io.PE_GTLIST_OPTS_USABLE=1,sr=null}(P);const t=bm;bm=null,t.forEach(m=>{const u=m.deref();u&&u.attachToPe()})},isInitialized:wm,isTempName:Bu,isValidWkid:Xu,isValidWkt:Ru,makeSpheroidData:Lr,snapGeometry:Yu,webMercator:Fm,webMercator102100:vu,wgs84:Mm},Symbol.toStringTag,{value:"Module"})),Xc=Object.freeze(Object.defineProperty({__proto__:null,OperatorProject:Ji},Symbol.toStringTag,{value:"Module"})),Rc=Object.freeze(Object.defineProperty({__proto__:null,CompositeGeographicTransformation:$u,CompositeGeographicTransformationEditor:Du,createImpl:Ku,queryGtListImpl:Qu},Symbol.toStringTag,{value:"Module"})),kc=Object.freeze(Object.defineProperty({__proto__:null,GeographicTransformation:Xm,create:function qc(P,t){const m=ws.geogtran(P);return m||(0,F.y)(P),new Xm(m,t)},createFromPe:ju,createFromWKT:function Vc(P,t){const m=ws.fromString(pe.PE_TYPE_GEOGTRAN,P);return m||(0,F.z)(P),new Xm(m,t)}},Symbol.toStringTag,{value:"Module"})),Lc=Object.freeze(Object.defineProperty({__proto__:null,ProjectionTransformation:au,create:function ic(P,t,m){return Nu(P,t,R.J.constructEmpty(),m)},createEx:kr,createFromAoi:Nu,createImplEx:su,makeExtendedParams:iu,makeExtendedParamsInternal:nu,queryTransformationList:Au},Symbol.toStringTag,{value:"Module"}))},95944:(Do,Ui,ze)=>{ze.d(Ui,{$:()=>ql,A:()=>qr,B:()=>cm,C:()=>Aa,D:()=>Ei,E:()=>Zn,F:()=>am,H:()=>Vs,I:()=>Se,J:()=>jh,K:()=>_a,L:()=>ke,M:()=>Ut,N:()=>go,O:()=>Ni,P:()=>Yi,Q:()=>as,R:()=>gm,S:()=>is,T:()=>qs,U:()=>Or,V:()=>Os,W:()=>Vt,X:()=>re,Y:()=>Ne,Z:()=>Ri,_:()=>Kn,a:()=>yi,a0:()=>$n,a1:()=>Jn,a2:()=>wn,a3:()=>Zh,a4:()=>Oe,a5:()=>Fs,a6:()=>qa,a7:()=>tu,a8:()=>Ta,b:()=>Jh,c:()=>mi,d:()=>$h,e:()=>Na,f:()=>Zl,g:()=>ir,i:()=>Ql,l:()=>Pi,n:()=>Mt,s:()=>ee,x:()=>ji,y:()=>fi,z:()=>wa});var R=ze(62257),F=ze(7085),c=ze(33165),dt=ze(87571),Y=ze(23558),vt=ze(1469);class Wt{constructor(){this.posStream=null,this.streams=null}get(n){return n>0?this.streams[n-1]:this.posStream}set(n,r){n>0?this.streams[n-1]=r:this.posStream=r}destroyAndSetSize(n){if(this.streams=null,n>1){this.streams=new Array(n-1);for(let r=0;r<n-1;++r)this.streams[r]=null}this.posStream=null}swap(n){[this.streams,n.streams]=[n.streams,this.streams],[this.posStream,n.posStream]=[n.posStream,this.posStream]}empty(){return null===this.posStream&&null===this.streams}}function Se(f,n,r){if(f)for(let l=n.length-1;l>=0;--l)r(n[l]);else n.forEach(r)}function ee(f,n){let r=(0,c.A)(f);const l=n.length/(0,c.i)();for(let _=0;_<n.length;++_){const x=Math.trunc(r*l);r=(0,c.A)(r);const E=Math.trunc(r*l),v=n[x];n[x]=n[E],n[E]=v}}var Yt=F.V;const se="can not assign an empty point to a vertex";class Jt{constructor(n){if(this.m_accelerators=null,void 0!==n&&n.move)this.m_description=n.move.m_description,n.move.m_description=(0,F.j)(),this.m_vertexAttributes=n.move.m_vertexAttributes,n.move.m_vertexAttributes=new Wt,this.m_envelopeData=n.move.m_envelopeData,n.move.m_envelopeData=new F.k,this.m_pointCount=n.move.m_pointCount,this.m_reservedPointCount=n.move.m_reservedPointCount,this.m_flags=n.move.m_flags,this.m_bFillRule=n.move.m_bFillRule,this.m_bPathStarted=n.move.m_bPathStarted,this.m_bPolygon=n.move.m_bPolygon,this.m_simpleTolerance=n.move.m_simpleTolerance;else{const r=void 0!==n&&n.vd?n.vd:(0,F.j)();this.m_description=r,this.m_vertexAttributes=new Wt,this.m_envelopeData=new F.k,this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_flags=4063,this.m_bFillRule=this.m_bPathStarted=this.m_bPolygon=!1,this.m_simpleTolerance=0,void 0!==n&&n.copy&&n.copy.copyTo(this)}}equalsBase(n,r){if(!(0,R.i)(n.getGeometryType()))return!1;const l=n;if(this===l)return!0;if(!this.m_description.equals(l.getDescription())||this.isEmptyImpl()!==l.isEmptyImpl())return!1;if(this.isEmptyImpl())return!0;const _=this.getPointCount();if(_!==l.getPointCount())return!1;for(let x=0;x<this.m_description.getAttributeCount();x++){const E=this.m_description.getSemantics(x),v=this.getAttributeStreamRef(E),I=l.getAttributeStreamRef(E),D=Yt.getComponentCount(E);if(!v.equals(I,0,_*D,r))return!1}if(r){if(!this.equalsImplTol(n,r))return!1}else if(!this.equalsImpl(n))return!1;return!0}transformAttribute(n,r,l,_,x){this.addAttribute(n),this.isEmpty()||0===l&&1===_||(function Rt(f,n,r,l,_){(n<0||r<0||l<1||n+l*(r-1)+1>f.size())&&(0,R.t)("Index out of bound");for(let x=n,E=n+l*(r-1)+1;x<E;x+=l)f.writeAsDbl(x,_(f.readAsDbl(x)))}(this.getAttributeStreamRef(n),r,this.getPointCount(),Yt.getComponentCount(n),(0,F.v)(l,_,x)),this.notifyModified())}getDescription(){return this.m_description}assignVertexDescription(n){this.m_description!==n&&this.assignVertexDescriptionImpl(n)}mergeVertexDescriptionImpl(n){const r=this.getDescription(),l=(0,F.l)(r,n);this.assignVertexDescription(l)}mergeVertexDescription(n){this.m_description!==n&&(this.m_description.hasAttributesFrom(n)||this.mergeVertexDescriptionImpl(n))}hasAttribute(n){return this.m_description.hasAttribute(n)}addAttribute(n){if(this.m_description.hasAttribute(n))return;const r=(0,F.m)(this.m_description,n);this.assignVertexDescription(r)}dropAttribute(n){if(!this.m_description.hasAttribute(n))return;const r=(0,F.r)(this.m_description,n);this.assignVertexDescription(r)}dropAllAttributes(){const n=(0,F.j)();n!==this.m_description&&this.assignVertexDescription(n)}getAttributeStreamRef(n){this.throwIfEmpty(),this.m_description.hasAttribute(n)||(0,R.t)("AttributeStream : Geometry does not have the attribute");const r=this.m_description.getAttributeIndex(n);return this.m_vertexAttributes.get(r)}setAttributeStreamRef(n,r){r||(0,R.t)("stream"),r&&Yt.getPersistence(n)!==r.getPersistence()&&(0,R.t)(""),this.addAttribute(n);const l=this.m_description.getAttributeIndex(n);this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_vertexAttributes.set(l,r),this.notifyModifiedFlags(2001)}notifyModifiedFlags(n){65535===n&&(this.m_reservedPointCount=-1,this.notifyModifiedAllImpl()),this.setDirtyFlagProtected(n,!0),this.clearAccelerators(),32&n&&this.verifyAllStreamsAfterSizeChange()}notifyModified(){this.notifyModifiedFlags(2001)}getPointCount(){return this.m_pointCount}getPointByVal(n,r){const l=r;l.assignVertexDescription(this.m_description);for(let _=0;_<this.m_description.getAttributeCount();_++){const x=this.m_description.getSemantics(_);for(let E=0,v=Yt.getComponentCount(x);E<v;E++){const I=this.m_vertexAttributes.get(_).readAsDbl(v*n+E);l.setAttributeBasic(x,E,I)}}}setPointByVal(n,r){const l=r;l.isEmpty()&&(0,R.t)(se);const _=l.getDescription();_!==this.m_description&&this.mergeVertexDescription(_);const x=this.m_vertexAttributes.get(0);x.write(2*n,l.getX()),x.write(2*n+1,l.getY());for(let E=1,v=this.m_description.getAttributeCount();E<v;E++){const I=this.m_description.getSemantics(E),D=Yt.getComponentCount(I);for(let G=0;G<D;G++){const q=l.getAttributeAsDbl(I,G);this.m_vertexAttributes.get(E).writeAsDbl(n*D+G,q)}}this.notifyModifiedFlags(2001)}setPointByValFromArray(n,r,l,_){(0,R.g)(0)}getPointByValAsArray(n,r,l,_){(0,R.g)(0)}isEmpty(){return this.isEmptyImpl()}isEmptyImpl(){return 0===this.m_pointCount}getAttributeAsDbl(n,r,l){const _=Yt.getComponentCount(n);l>=_&&(0,R.n)("");const x=this.m_description.getAttributeIndex(n);return x>=0?this.m_vertexAttributes.get(x).readAsDbl(r*_+l):Yt.getDefaultValue(n)}queryAttributeAsDbl(n,r,l,_){const x=Yt.getComponentCount(n);_<x&&(0,R.n)("");const E=this.m_description.getAttributeIndex(n);if(E>=0){const v=r*x,I=this.m_vertexAttributes.get(E);for(let D=0;D<x;D++)l[D]=I.readAsDbl(v+D)}else{const v=Yt.getDefaultValue(n);for(let I=0;I<x;I++)l[I]=v}}getAttributeAsInt(n,r,l){return Math.trunc(this.getAttributeAsDbl(n,r,l))}queryAttributeAsInt(n,r,l,_){(0,R.g)(0)}setAttribute(n,r,l,_){const x=Yt.getComponentCount(n);l>=x&&(0,R.n)(""),this.addAttribute(n);const E=this.m_description.getAttributeIndex(n);this.notifyModifiedFlags(2001),this.m_vertexAttributes.get(E).writeAsDbl(r*x+l,_)}setAttributeFromArray(n,r,l,_){(r<0||r>=this.m_pointCount)&&(0,R.n)("");const x=Yt.getComponentCount(n);_!==x&&(0,R.n)(""),this.addAttribute(n);const E=this.m_description.getAttributeIndex(n);this.notifyModifiedFlags(2001);const v=this.m_vertexAttributes.get(E);for(let I=0;I<x;++I)v.writeAsDbl(r*x+I,l[I])}getXY(n){return this.m_vertexAttributes.get(0).readPoint2D(2*n)}queryXY(n,r){return this.m_vertexAttributes.get(0).queryPoint2D(2*n,r)}setXY(n,r){this.m_vertexAttributes.get(0).writePoint2D(2*n,r),this.notifyModifiedFlags(2001)}setXYCoords(n,r,l){const _=this.m_vertexAttributes.get(0);_.write(2*n,r),_.write(2*n+1,l),this.notifyModifiedFlags(2001)}getXYZ(n){const r=this.m_vertexAttributes.get(0),l=F.h.getNAN();return l.x=r.read(2*n),l.y=r.read(2*n+1),l.z=this.m_description.hasAttribute(1)?this.m_vertexAttributes.get(1).read(n):Yt.getDefaultValue(1),l}setXYZ(n,r){this.addAttribute(1),this.notifyModifiedFlags(2001);const l=this.m_vertexAttributes.get(0);l.write(2*n,r.x),l.write(2*n+1,r.y),this.m_vertexAttributes.get(1).write(n,r.z)}queryEnvelope(n){n instanceof dt.J||n instanceof F.n?this.updateEnvelope(n):(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,n))}queryLooseEnvelope(n){this.updateLooseEnvelope(n)}queryInterval(n,r){const l=c.E.constructEmpty();return this.isEmptyImpl()||(this.updateAllDirtyIntervals(!0),this.m_envelopeData.queryInterval(this.m_description,n,r,l)),l}setAttributeBasic(n,r,l){this.setAttributeImpl(n,r,l)}setAttributeImpl(n,r,l){if(this.addAttribute(n),this.isEmpty())return;let _=!1;const x=Yt.getComponentCount(n),E=this.getAttributeStreamRef(n),v=Number.isNaN(l);if(1===E.getPersistence()){const I=E;for(let D=r,G=this.m_pointCount*x;D<G;D+=x){const q=I.read(D);(v||q===l)&&Number.isNaN(q)||(I.write(D,l),_=!0)}}else for(let I=r,D=this.m_pointCount*x;I<D;I+=x)E.readAsDbl(I)!==l&&(E.writeAsDbl(I,l),_=!0);_&&this.notifyModifiedFlags(2001)}replaceNaNs(n,r){if(this.addAttribute(n),this.isEmpty())return;let l=!1;const _=Yt.getComponentCount(n),x=this.getAttributeStreamRef(n);for(let E=0;E<_;E++)if(1===x.getPersistence()){const v=x;for(let I=0,D=this.m_pointCount*_;I<D;I++){const G=v.read(I);Number.isNaN(G)&&(v.write(I,r),l=!0)}}else for(let v=0,I=this.m_pointCount*_;v<I;v++){const D=x.readAsDbl(v);Number.isNaN(D)&&(x.writeAsDbl(v,r),l=!0)}l&&this.notifyModifiedFlags(2001)}calculateLength3D(n){return(0,R.g)(0),0}setEnvelopeForImport(n){this.m_description.equals(n.getDescription())||(0,R.t)(""),this.m_envelopeData=new F.k({moveEnv:n}),this.setDirtyFlagProtected(192,!1)}copyTo(n){n.getGeometryType()!==this.getGeometryType()&&(0,R.t)(""),this!==n&&this.copyToUnchecked(n,!1)}queryCoordinates(n,r,l,_){let x=_<0?this.m_pointCount:_;if(x=Math.min(x,l+r),(l<0||x<l||this.m_pointCount>0&&l>=this.m_pointCount)&&(0,R.t)(""),0===this.m_pointCount)return x;const E=this.getAttributeStreamRef(0);for(let v=2*l,I=2*x,D=0;v<I;v+=2,D++)E.queryPoint2D(v,n[D]);return x}queryCoordinates3D(n,r,l,_){let x=_<0?this.m_pointCount:_;if(x=Math.min(x,l+r),(l<0||x<l||this.m_pointCount>0&&l>=this.m_pointCount)&&(0,R.t)(""),0===this.m_pointCount)return x;const E=this.getAttributeStreamRef(0);let v=null;const I=Yt.getDefaultValue(1),D=this.m_description.hasAttribute(1);D&&(v=this.getAttributeStreamRef(1));let G=0;for(let q=l;q<x;q++,G++)n[G].x=E.read(2*q),n[G].y=E.read(2*q+1),n[G].z=D?v.read(q):I;return x}clearAndSetDirtyFlagProtected(n,r){let l=0;const _=n&~r;l=this.m_flags,(l&(r|_))!==r&&(this.m_flags=l&~_|r)}getIsSimple(n,r){r[0]=0;let l=-1;const _=this.m_flags,x=this.m_simpleTolerance;return 1&_||(l=(14&_)>>1,r[0]=x,x<n&&(l=-1)),l}setIsSimple(n,r,l=!1){if(2===n?(0,R.g)(this.getGeometryType()===R.G.enumPolyline):1===n?(0,R.g)(this.getGeometryType()===R.G.enumMultiPoint||this.getGeometryType()===R.G.enumPolyline):3===n&&(0,R.g)(this.getGeometryType()===R.G.enumPolygon),-1===n)this.setDirtyFlagProtected(17,!0);else{let _=n<<1;l||(_|=16),this.clearAndSetDirtyFlagProtected(31,_),this.m_simpleTolerance!==r&&(this.m_simpleTolerance=r)}}attributeStreamIsAllocated(n){this.throwIfEmpty();const r=this.m_description.getAttributeIndex(n);return r>=0&&null!==this.m_vertexAttributes.get(r)}capacity(){return-1===this.m_reservedPointCount&&0===this.m_pointCount?0:this.m_reservedPointCount}getDescriptionImpl(){return this.m_description}copyToUnchecked(n,r=!1){r&&this.hasDirtyFlag(32)&&(0,R.s)("Cannot do shallow clone on unprepared geometry");const l=n,_=this.getGeometryType(),x=l.getGeometryType();(0,R.g)(_===x||_===R.G.enumPolygon&&x===R.G.enumPolyline,"failure in copyToUnchcked"),l.clearAccelerators(),l.m_description=this.m_description,l.m_vertexAttributes.destroyAndSetSize(0),l.m_envelopeData.releaseAttributes();const E=this.m_description.getAttributeCount(),v=new Wt;if(!this.m_vertexAttributes.empty()){v.destroyAndSetSize(E);for(let I=0;I<E;I++)if(this.m_vertexAttributes.get(I))if(r)v.set(I,this.m_vertexAttributes.get(I));else{const D=Yt.getComponentCount(this.m_description.getSemantics(I));v.set(I,this.m_vertexAttributes.get(I).restrictedClone(this.getPointCount()*D))}}if(this.m_envelopeData.copyToIfNotNull(this.m_description,l.m_envelopeData),l.m_flags=this.m_flags,l.m_simpleTolerance=this.m_simpleTolerance,_!==x){const I=[Number.NaN];l.getIsSimple(0,I)>=3?l.setIsSimple(1,I[0]):l.setIsSimple(-1,0)}l.m_vertexAttributes.swap(v),v.destroyAndSetSize(0),l.m_pointCount=this.m_pointCount,l.hasDirtyFlag(32)?((0,R.g)(!r),l.m_reservedPointCount=-1):l.m_reservedPointCount=l.m_pointCount;try{this.copyToImpl(l,r)}catch(I){throw l.setEmpty(),I}l.verifyAllStreamsAfterSizeChange()}buildRasterizedGeometryAccelerator(n,r){return!1}getAccelerators(){return this.m_accelerators}clearAccelerators(){this.m_accelerators&&this.m_accelerators.release(),this.m_accelerators=null}ensureUniqueAccelerators(){if(this.m_accelerators&&!this.m_accelerators.uniqueUse()){const n=this.m_accelerators.clone();this.m_accelerators.release(),this.m_accelerators=n}}interpolateTwoVertices(n,r,l,_){(n<0||n>=this.m_pointCount)&&(0,R.n)(""),(r<0||r>=this.m_pointCount)&&(0,R.n)(""),_.assignVertexDescription(this.m_description);const x=(0,c.d)(Yt.maxComponentCount(),Number.NaN),E=(0,c.d)(Yt.maxComponentCount(),Number.NaN),v=(0,F.o)();let I=0;for(let D=0;D<this.m_description.getAttributeCount();D++){const G=this.m_description.getSemantics(D),q=Yt.getInterpolation(G),B=Yt.getComponentCount(G),z=Yt.getDefaultValue(G);this.queryAttributeAsDbl(G,n,x,B),this.queryAttributeAsDbl(G,r,E,B),(0,R.g)(I+B<=F.O),(0,c.B)(q,x,E,v,I,B,l,z),I+=B}!function Ve(f,n,r){const l=f.getDescription().getTotalComponentCount();f.setX(n[0]),f.setY(n[1]),(0,c.a)(f.getAttributeArray(),n,0,2,l-2)}(_,v)}getShortestDistance(n,r){return c.P.distance(this.getXY(n),this.getXY(r))}getShortestSqrDistance(n,r){return c.P.sqrDistance(this.getXY(n),this.getXY(r))}resizeImpl(n){n<0&&(0,R.t)(),(n=Math.ceil(n))!==this.m_pointCount&&(this.m_pointCount=n,this.notifyModifiedFlags(this.m_pointCount<=this.m_reservedPointCount?2001:4095))}assignVertexDescriptionImpl(n){if(!this.m_vertexAttributes.empty()){const r=(0,F.p)();(0,F.q)(n,this.m_description,r);const l=new Wt;l.destroyAndSetSize(n.getAttributeCount());for(let _=0;_<n.getAttributeCount();_++){const x=r[_];-1!==x?l.set(_,this.m_vertexAttributes.get(x)):this.m_reservedPointCount=-1}l.swap(this.m_vertexAttributes)}this.m_description=n,this.m_envelopeData.releaseAttributes(),this.notifyModifiedFlags(4095)}hasDirtyFlag(n){return!!(this.m_flags&n)}setDirtyFlagProtected(n,r){r?this.m_flags|=n:this.m_flags&=~n}notifyModifiedAllImpl(){}verifyAllStreamsAfterSizeChange(){this.hasDirtyFlag(32)&&this.verifyAllStreamsAfterSizeChangeImpl()}verifyAllStreamsAfterSizeChangeImpl(){if(this.hasDirtyFlag(32)){if(this.m_reservedPointCount<this.m_pointCount){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_reservedPointCount=Number.MAX_SAFE_INTEGER;let n=0;n=this.m_pointCount<4?3:this.m_pointCount<=128?2*this.m_pointCount:Math.trunc((4*this.m_pointCount+2)/3);for(let r=0;r<this.m_description.getAttributeCount();r++){const l=this.m_description.getSemantics(r);let _=0;if(null!==this.m_vertexAttributes.get(r)){const x=Yt.getComponentCount(l);_=this.m_vertexAttributes.get(r).size()/x,_<this.m_pointCount&&(this.m_vertexAttributes.get(r).resize(n*x,Yt.getDefaultValue(l)),_=n)}else this.m_vertexAttributes.set(r,(0,F.t)(l,n)),_=n;_<this.m_reservedPointCount&&(this.m_reservedPointCount=_)}}this.verifyStreamsAfterSizeChangeExtraImpl(),this.setDirtyFlagProtected(32,!1)}}verifyStreamsAfterSizeChangeExtraImpl(){}updateAllDirtyIntervals(n){if(this.hasDirtyFlag(n?192:128)){if(this.isEmpty())return this.hasDirtyFlag(192)&&this.m_envelopeData.setEmpty(this.m_description),void this.setDirtyFlagProtected(192,!1);const r=this.updateXYImpl(n),l=new F.E({vd:this.m_description});l.setEnvelope(r);for(let _=1;_<this.m_description.getAttributeCount();_++){const x=this.m_description.getSemantics(_),E=Yt.getComponentCount(x),v=this.m_vertexAttributes.get(_);for(let I=0;I<E;I++){const D=new c.E;D.setEmpty();for(let G=0;G<this.m_pointCount;G++){const q=v.readAsDbl(G*E+I);D.mergeCoordinate(q)}l.setIntervalEnvelope(x,I,D)}}this.hasDirtyFlag(n?192:128)&&(this.m_envelopeData=new F.k({moveEnv:l}),this.clearDirtyIntervalsFlag(n))}}updateXYImpl(n){const r=dt.J.constructEmpty(),l=this.m_vertexAttributes.get(0);return r.mergePointsInterleaved(l,0,this.m_pointCount),r}updateEnvelope3D(n){(0,R.g)(0)}updateLooseEnvelope(n){this.updateAllDirtyIntervals(!1),n instanceof dt.J?n.assign(this.m_envelopeData.m_envelope2D):this.m_envelopeData.queryEnvelope3D(this.m_description,n)}updateEnvelope(n){this.updateAllDirtyIntervals(!0),n.assign(this.m_envelopeData.m_envelope2D)}setEmptyImpl(){this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_vertexAttributes.destroyAndSetSize(0),this.notifyModifiedFlags(4095)}clearDirtyIntervalsFlag(n){this.setDirtyFlagProtected(192,!1)}reserveImpl(n,r){if(n<0&&(0,R.t)(""),0===n)return;let l=n=Math.ceil(n);if(this.m_reservedPointCount<l){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),r?(null===this.m_vertexAttributes.get(0)&&this.m_vertexAttributes.set(0,(0,F.u)(0,0)),this.m_vertexAttributes.get(0).resizeRounded(2*l),l=this.m_vertexAttributes.get(0).size()>>1):null===this.m_vertexAttributes.get(0)?this.m_vertexAttributes.set(0,(0,F.u)(0,l)):this.m_vertexAttributes.get(0).resize(2*l);for(let _=1;_<this.m_description.getAttributeCount();_++){const x=this.m_description.getSemantics(_),E=Yt.getComponentCount(x);null!==this.m_vertexAttributes.get(_)?this.m_vertexAttributes.get(_).resize(l*E):this.m_vertexAttributes.set(_,(0,F.u)(x,l))}this.reserveImplImpl(l,r),this.m_reservedPointCount=l}}reserveRounded(n){n<0&&(0,R.t)(),n=Math.ceil(n),this.reserveImpl(n,!0)}reserveImplImpl(n,r){}throwIfEmpty(){this.isEmptyImpl()&&(0,R.u)("")}}class Ut extends Jt{constructor(n){super(n),n&&(n.points?this.addPoints2D(n.points,n.pointsSize,0,-1):n.point&&this.add(n.point))}assignCopy(n){return n.copyTo(this),this}assignMove(n){return n.copyTo(this),n.setEmpty(),this}insertPoint2D(n,r){n>this.getPointCount()&&(0,R.t)("invalid point index"),n<0&&(n=this.getPointCount());const l=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let _=0,x=this.m_description.getAttributeCount();_<x;_++){const E=this.m_description.getSemantics(_),v=F.V.getComponentCount(E);if(0===E)this.m_vertexAttributes.get(_).insert(v*n,r,v*l);else{const I=F.V.getDefaultValue(E);this.m_vertexAttributes.get(_).insertRange(v*n,I,v,v*l)}}this.notifyModifiedFlags(2001)}insertPoint(n,r){r.isEmpty()&&(0,R.t)(se),n<0&&(n=this.getPointCount()),this.mergeVertexDescription(r.getDescription());const l=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let _=0,x=this.m_description.getAttributeCount();_<x;_++){const E=this.m_description.getSemantics(_),v=F.V.getComponentCount(E);if(r.hasAttribute(E))this.m_vertexAttributes.get(_).insertAttributes(v*n,r,E,v*l);else{const I=F.V.getDefaultValue(E);this.m_vertexAttributes.get(_).insertRange(v*n,I,v,v*l)}}this.notifyModifiedFlags(2001)}insertPoints(n,r,l){if((n>this.getPointCount()||l<0)&&(0,R.n)(""),n<0&&(n=this.getPointCount()),0===l)return;const _=r[0].getDescription();this.mergeVertexDescription(_);const x=this.m_pointCount;this.resizeNoInit(this.m_pointCount+l);for(let E=0,v=this.m_description.getAttributeCount();E<v;E++){const I=this.m_description.getSemantics(E),D=F.V.getComponentCount(I);if(this.m_vertexAttributes.get(E))if(_.hasAttribute(I))this.m_vertexAttributes.get(E).insertAttributesFromPoints(n*D,r,l,I,x*D);else{const G=F.V.getDefaultValue(I);this.m_vertexAttributes.get(E).insertRange(D*n,G,D*l,D*x)}}this.notifyModifiedFlags(2001)}insertPoints2D(n,r,l){if((n>this.getPointCount()||l<0)&&(0,R.t)("invalid point index"),n<0&&(n=this.getPointCount()),0===l)return;const _=this.m_pointCount;this.resizeNoInit(this.m_pointCount+l);for(let x=0,E=this.m_description.getAttributeCount();x<E;x++){const v=this.m_description.getSemantics(x),I=F.V.getComponentCount(v);if(this.m_vertexAttributes.get(x))if(0===v)this.m_vertexAttributes.get(x).insertRangeFromPoints(I*n,r,0,l,!0,I*_);else{const D=F.V.getDefaultValue(v);this.m_vertexAttributes.get(x).insertRange(I*n,D,I,I*_)}}this.notifyModifiedFlags(2001)}removePoints(n,r){if((n<0||r<0||n+r>this.getPointCount())&&(0,R.n)("remove_points"),0!==r){for(let l=0,_=this.m_description.getAttributeCount();l<_;l++)if(this.m_vertexAttributes.get(l)){const x=this.m_description.getSemantics(l),E=F.V.getComponentCount(x);this.m_vertexAttributes.get(l).eraseRange(E*n,E*r,E*this.m_pointCount)}this.m_pointCount-=r,this.m_reservedPointCount>0&&(this.m_reservedPointCount-=r),this.notifyModifiedFlags(2001)}}removePoint(n){for(let r=0,l=this.m_description.getAttributeCount();r<l;r++)if(this.m_vertexAttributes.get(r)){const _=this.m_description.getSemantics(r),x=F.V.getComponentCount(_);this.m_vertexAttributes.get(r).eraseRange(x*n,x,x*this.m_pointCount)}this.m_pointCount--,this.m_reservedPointCount>0&&this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}calculateEnvelope2D(){return this.updateXYImpl(!0)}resizeNoInit(n){this.resizeImpl(n)}resizeAndInitNonPositionAttributes(n){const r=this.m_pointCount;if(this.resizeImpl(n),this.m_pointCount>r)for(let l=1,_=this.m_description.getAttributeCount();l<_;l++){const x=this.m_description.getSemantics(l),E=F.V.getDefaultValue(x),v=F.V.getComponentCount(x);this.m_vertexAttributes.get(l).insertRange(v*r,E,v*(this.m_pointCount-r),v*r)}}queryCoordinates3D(n,r,l,_){let x=_<0?this.m_pointCount:_;if(x=Math.min(x,l+r),(l<0||x<l||this.m_pointCount>0&&l>=this.m_pointCount)&&(0,R.t)(""),0===this.m_pointCount)return x;const E=this.getAttributeStreamRef(0);let v=null;const I=F.V.getDefaultValue(1),D=this.m_description.hasAttribute(1);D&&(v=this.getAttributeStreamRef(1));let G=0;for(let q=l;q<x;q++,G++)n[G].x=E.read(2*q),n[G].y=E.read(2*q+1),n[G].z=D?v.read(q):I;return x}queryAttributeAsInt(n,r,l,_){(0,R.g)(0)}add(n){n.isEmpty()&&(0,R.t)(se),this.resizeAndInitNonPositionAttributes(this.m_pointCount+1),this.setPointByVal(this.m_pointCount-1,n)}addXY(n,r){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const l=new c.P(n,r);this.setXY(this.m_pointCount-1,l)}addXYZ(n,r,l){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const _=new F.h;_.setCoords(n,r,l),this.setXYZ(this.m_pointCount-1,_)}addPoint2D(n){this.addXY(n.x,n.y)}addPoint3D(n){this.addXYZ(n.x,n.y,n.z)}addPoints(n,r,l){this===n&&(0,R.t)("Multi_point_impl.add");const _=l<0?n.getPointCount():l;if((r<0||r>n.getPointCount()||_<r)&&(0,R.t)(""),r===_)return;const x=n.getDescription();this.mergeVertexDescription(x);const E=_-r,v=this.m_pointCount;this.resizeNoInit(this.m_pointCount+E);for(let I=0,D=this.m_description.getAttributeCount();I<D;I++){const G=this.m_description.getSemantics(I),q=F.V.getComponentCount(G),B=this.getAttributeStreamRef(G);if(x.hasAttribute(G)){const z=n.getAttributeStreamRef(G);B.insertRangeFromStream(v*q,z,r*q,E*q,!0,1,v*q)}else{const z=F.V.getDefaultValue(G);B.insertRange(v*q,z,E*q,v*q)}}}addPoints2D(n,r,l,_){let x=r;const E=_<0?x:_;if((x<0||l<0||l>x||E<l)&&(0,R.t)(""),l===E)return;x=E-l;const v=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+x);const I=this.getAttributeStreamRef(0);for(let D=0;D<x;++D)I.writePoint2D(2*(v+D),n[l+D]);this.notifyModifiedFlags(2001)}addPoints3D(n,r,l,_){let x=r;const E=_<0?x:_;if((x<0||l<0||l>x||E<l)&&(0,R.t)(""),this.addAttribute(1),l===E)return;x=E-l;const v=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+x);const I=this.getAttributeStreamRef(0),D=new c.P;for(let q=0;q<x;q++)D.x=n[l+q].x,D.y=n[l+q].y,I.writePoint2D(2*(v+q),D);const G=this.getAttributeStreamRef(1);for(let q=0;q<x;q++)G.write(v+q,n[l+q].z);this.notifyModifiedFlags(2001)}getGeometryType(){return R.G.enumMultiPoint}getDimension(){return 0}createInstance(){return new Ut({vd:this.getDescription()})}setEmpty(){this.setEmptyImpl()}applyTransformation(n){if(this.isEmpty()||n.isIdentity())return;const r=this.m_vertexAttributes.get(0);1===n.m_TransformationType?r.applyTransformation(n,0,this.m_pointCount):(0,R.b)("3d xform not impl"),this.notifyModifiedFlags(2001)}calculateArea2D(){return 0}calculateLength2D(){return 0}calculateLength3D(n){return 0}equals(n,r){return n.getGeometryType()===R.G.enumMultiPoint&&this.equalsBase(n,r)}queryEnvelope(n){4===n.m_EnvelopeType?(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,n)):2===n.m_EnvelopeType?this.updateEnvelope(n):(0,R.b)("")}getImpl(){return this}getBoundary(){return null}reserve(n){this.reserveImpl(n)}clone(){const n=this.createInstance();return this.copyTo(n),n}swap(n){(0,R.g)(0)}buildQuadTreeAccelerator(n){return!1}getHashCodeImpl(){return(0,R.g)(0),0}equalsImpl(n){return!0}equalsImplTol(n,r){return!0}copyToImpl(n,r){}}Ut.type=R.G.enumMultiPoint;class jt{constructor(){this.m_EnvelopeType=5,this.envAabb=dt.J.constructEmpty(),this.envRot=dt.J.constructEmpty()}static constructEmpty(){return new jt}width(){return this.envAabb.width()}height(){return this.envAabb.height()}maxDim(){return Math.max(this.width(),this.height())}setEmpty(){this.envAabb.setEmpty(),this.envRot.setEmpty()}setCoords(n){this.envAabb.setCoords(n),this.envRot.setCoords({x:de(n),y:me(n)})}setFromPoints(n,r){this.setEmpty(),this.mergePoints(n,r)}mergeNe(n){this.envAabb.mergeNe(n),this.envRot.mergeNeCoords(de(n),me(n))}mergePoints(n,r){this.envAabb.mergePoints(n,r);for(let l=0;l<r;){if(!this.envRot.isEmpty()){for(let _=l;_<r;_++){const x=de(n[_]),E=me(n[_]);this.envRot.mergeNeCoords(x,E)}break}{const _=de(n[l]),x=me(n[l]);this.envRot.setCoords({x:_,y:x}),l++}}}isIntersectingPoint2D(n){return!(!this.envAabb.contains(n)||!this.envRot.containsCoords(de(n),me(n)))}isIntersectingW(n){return this.envAabb.isIntersecting(n.envAabb)&&this.envRot.isIntersecting(n.envRot)}containsW(n){return!(!this.envAabb.containsEnvelope(n.envAabb)||!this.envRot.containsEnvelope(n.envRot))}containsPoint2D(n){return this.isIntersectingPoint2D(n)}intersectW(n){const r=this.envAabb.intersect(n.envAabb),l=this.envRot.intersect(n.envRot);return r&&!l&&this.envAabb.setEmpty(),l&&!r&&this.envRot.setEmpty(),r&&l}inflate(n){this.envAabb.inflateCoords(n,n);const r=n*(0,c.D)();this.envRot.inflateCoords(r,r),r<0&&jt.st_reduceEmpty(this)}static st_reduceEmpty(n){const r=n.envAabb.isEmpty(),l=n.envRot.isEmpty();r&&!l?n.envRot.setEmpty():l&&!r&&n.envAabb.setEmpty()}}function de(f){return f.x-f.y}function me(f){return f.x+f.y}class Vt{constructor(){this.x=c.F.getNAN(),this.y=c.F.getNAN()}static getNAN(){return new Vt}static constructPoint2D(n){const r=new Vt;return r.x.set(n.x),r.y.set(n.y),r}static constructCoords(n,r){const l=new Vt;return l.x.set(n),l.y.set(r),l}static constructCoordsE(n,r){const l=new Vt;return l.setCoordsE(n,r),l}get 0(){return this.x.clone()}set 0(n){this.x.setE(n)}get 1(){return this.y.clone()}set 1(n){this.y.setE(n)}clone(){return(new Vt).setE(this)}scaleThis(n){return this.x.mulThisE(n),this.y.mulThisE(n),this}setCoords(n,r){return this.x.set(n),this.y.set(r),this}setCoordsE(n,r){return this.x.setE(n),this.y.setE(r),this}set(n){return this.x.set(n.x),this.y.set(n.y),this}setE(n){return this.x.setE(n.x),this.y.setE(n.y),this}setWithEps(n,r){return this.x.setWithEps(n.x,r),this.y.setWithEps(n.y,r),this}getUnitVector(){const n=this.clone();return n.normalize(),n}sqrLength(){return this.x.sqr().addE(this.y.sqr())}length(){return this.sqrLength().sqrt()}mulE(n){const r=new Vt;return r.setCoordsE(this.x.mulE(n),this.y.mulE(n)),r}mul(n){const r=new Vt;return r.setCoordsE(this.x.mul(n),this.y.mul(n)),r}mulThis(n){return this.x.mulThis(n),this.y.mulThis(n),this}mulThisE(n){return this.x.mulThisE(n),this.y.mulThisE(n),this}divE(n){return this.clone().divThisE(n)}divThisE(n){return this.x.divThisE(n),this.y.divThisE(n),this}normalize(){const n=this.length();0===n.value()?(this.x=c.G.clone(),this.y=c.H.clone()):(this.x.divThisE(n),this.y.divThisE(n))}addE(n){return this.clone().addThisE(n)}addThisE(n){return this.x.addThisE(n.x),this.y.addThisE(n.y),this}subE(n){return this.clone().subThisE(n)}subThisE(n){return this.x.subThisE(n.x),this.y.subThisE(n.y),this}static distance(n,r){return n.subE(r).length()}negateThis(){return this.x.negateThis(),this.y.negateThis(),this}eq(n){return this.x.eq(n.x)&&this.y.eq(n.y)}isZero(){return this.x.isZero()&&this.y.isZero()}isTrueZero(){return!this.x.value()&&!this.y.value()}rotateDirect(n,r){const l=this.x.mulE(n).subThisE(this.y.mulE(r)),_=this.x.mulE(r).addThisE(this.y.mulE(n));return this.x.setE(l),this.y.setE(_),this}rotateReverse(n,r){const l=this.x.mulE(n).addThisE(this.y.mulE(r)),_=this.x.negate().mulThisE(r).addThisE(this.y.mulE(n));return this.x.setE(l),this.y.setE(_),this}dotProduct(n){return this.x.mulE(n.x).addE(this.y.mulE(n.y))}crossProduct(n){return this.x.mulE(n.y).subE(this.y.mulE(n.x))}value(){return c.P.construct(this.x.value(),this.y.value())}}class xe{constructor(){this.a11=new c.F(1),this.a12=new c.F(0),this.a21=new c.F(0),this.a22=new c.F(1)}clone(){const n=new xe;return n.a11.setE(this.a11),n.a12.setE(this.a12),n.a21.setE(this.a21),n.a22.setE(this.a22),n}assign(n){return this.a11.setE(n.a11),this.a12.setE(n.a12),this.a21.setE(n.a21),this.a22.setE(n.a22),this}mulThis(n){const r=this.a11.mulE(n.a11).addThisE(this.a12.mulE(n.a21)),l=this.a11.mulE(n.a12).addThisE(this.a12.mulE(n.a22)),_=this.a21.mulE(n.a11).addThisE(this.a22.mulE(n.a21)),x=this.a21.mulE(n.a12).addThisE(this.a22.mulE(n.a22));return this.a11=r,this.a12=l,this.a21=_,this.a22=x,this}mulLeftThis(n){const r=n.clone();return this.assign(r.mulThis(this)),this}det(){return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21))}invertThis(){const n=this.det();if(0!==n.value()){const r=this.a22.divE(n),l=this.a12.negate().divThisE(n),_=this.a21.negate().divThisE(n),x=this.a11.divE(n);this.a11=r,this.a12=l,this.a21=_,this.a22=x}else this.setZero();return!n.isZero()}transposeThis(){return this.a21=(0,c.b)(this.a12,this.a12=this.a21),this}eigenSymmetric(n,r){const l=this.a12.clone();l.addThisE(this.a21),l.mulThisByPower2(.5);let _=new c.F(1),x=new c.F(0);if(l.isZero())n[0].setE(this.a11),n[1].setE(this.a22);else{const E=new c.F(1);if(this.a11.ne(this.a22)){const v=this.a11.subE(this.a22).divE(l);v.mulThisByPower2(.5);const I=v.sqr();E.setE(v),E.absThis(),E.subThisE(I.add(1).sqrtThis()),v.gt(c.H)&&E.negateThis();const D=E.sqr().addThis(1).sqrtThis().invThis();x=E.mulE(D),_.setE(D);const G=E.mulE(l);n[0]=this.a11.addE(G),n[1]=this.a22.subE(G)}else _=new c.F(1/Math.sqrt(2)),x=_.clone(),n[0]=this.a11.addE(l),n[1]=this.a22.subE(l)}r[0].x=_.toDouble(),r[0].y=x.toDouble(),r[1].x=x.negate().toDouble(),r[1].y=_.toDouble(),Math.abs(n[0].toDouble())>Math.abs(n[1].toDouble())&&(n[1]=(0,c.b)(n[0],n[0]=n[1]),r[1]=(0,c.b)(r[0],r[0]=r[1]))}setZero(){this.a11.set(0),this.a21.set(0),this.a12.set(0),this.a22.set(0)}}var $t=F.V;function _e(f,n){const r=f.getStartXY();if(r.equals(n.getStartXY())||r.equals(n.getEndXY()))return!0;const l=f.getEndXY();return!!l.equals(n.getStartXY())||!!l.equals(n.getEndXY())}function Te(f,n){let r=f.calculateLowerLength2D();return!(r>n)&&(!!f.isLine()||(r=f.calculateUpperLength2D(),r<=n||0!==n&&f.calculateLength2D()<=n))}function Pe(f,n){const r=f.getEndXY().sub(f.getStartXY()).length(),l=f.calculateUpperLength2D()-r<=n[0];return n[0]*=.1,l}function ve(f,n,r,l,_,x,E,v){let I=f.calculateUpperLength2D(),D=n.calculateUpperLength2D(),G=f,q=n,B=!1;I>D&&(q=(0,c.b)(G,G=q),l=(0,c.b)(r,r=l),D=(0,c.b)(I,I=D),B=!0);const z=0===r;{E[0]=z?1:0;const at=G.getCoord2D(E[0]);v[0]=q.getClosestCoordinate(at,!1);const pt=q.getCoord2D(v[0]);if(c.P.distance(at,pt)<=_){const gt=[.5,.75,.25,.1,.9];let yt=!0;for(let ft=0;ft<gt.length;ft++)if(at.assign(G.getCoord2D(gt[ft])),!q.isCloserThanDistance(at,new c.E(0,1),_)){yt=!1;break}if(yt)return B&&(v[0]=(0,c.b)(E[0],E[0]=v[0])),1}}if(I<=3*_)return 0;let L=(0,c.c)(Math.max(_/I,.1),0,.5),j=.01*_,Q=0,et=0,K=L,rt=-1,ot=0,nt=1/32;for(let at=0;;at++){(0,R.g)(at<4095);const pt=z?L:1-L,gt=G.getCoord2D(pt),yt=q.getClosestCoordinate(gt,!1);if(yt===l)return ot;const ft=q.getCoord2D(yt),bt=c.P.distance(gt,ft);if(0===at&&(rt=bt),bt<=j?(nt=.5,et=bt,Q=L):(K=L,rt=bt),Math.abs(et-rt)>.1*j&&K-Q>1e-16)L=(0,c.q)(Q,K,nt);else{if(E[ot]=pt,v[ot]=yt,B&&(v[ot]=(0,c.b)(E[ot],E[ot]=v[ot])),1===x||1===ot)return 1===ot&&E[0]>E[1]&&(E[1]=(0,c.b)(E[0],E[0]=E[1]),v[1]=(0,c.b)(v[0],v[0]=v[1])),ot+1;ot++,Q=K,et=rt,K=.8,rt=-1,L=.8,nt=1/32,j=10*_,at=0}}}function Ie(f,n,r,l,_,x,E,v,I){if((0,c.J)(r,0,1)&&(0,c.J)(l,0,1)&&0===c.P.distance(f.getCoord2D(r),n.getCoord2D(l))){const G=new Vt,q=(0,c.N)();if(f.queryDerivative(new c.F(r,q),G),G.isTrueZero()){const Q=1===r?-1e-12:1e-12;f.queryDerivative(new c.F(r,q).add(Q),G)}1===r&&G.negateThis();const B=new Vt;if(n.queryDerivative(new c.F(l,q),B),B.isTrueZero()){const Q=1===r?-1e-12:1e-12;n.queryDerivative(new c.F(l,q).add(Q),B)}1===l&&B.negateThis(),G.isZero()||G.normalize(),B.isZero()||B.normalize();const z=G.dotProduct(B),L=G.crossProduct(B);L.scaleError(3);const j=()=>{{const Q=f.calculateUpperLength2D(),et=n.calculateUpperLength2D();return Math.min(.01*_/Math.min(Q,et),1e-10)}};if(z.ge(c.H)&&(L.isZero()||Math.abs(L.value())<j()))return ve(f,n,r,l,_,x,E,v)}return 0}function Le(f,n){f.m_XStart=n.x,f.m_YStart=n.y}function Be(f,n,r){f.m_XStart=n,f.m_YStart=r}function Re(f,n){f.m_XEnd=n.x,f.m_YEnd=n.y}function we(f,n,r){f.m_XEnd=n,f.m_YEnd=r}function Ss(f,n){const r=new F.h;return n?(r.x=f.m_XEnd,r.y=f.m_YEnd):(r.x=f.m_XStart,r.y=f.m_YStart),r.z=function Ze(f,n){return f.m_description.hasZ()?f.m_attributes[n*(f.m_description.getTotalComponentCount()-2)]:$t.getDefaultValue(1)}(f,n),r}function Qe(f,n,r){f.m_description.hasZ()||f.addAttribute(1),n?f.m_XEnd===r.x&&f.m_YEnd===r.y||(f.m_XEnd=r.x,f.m_YEnd=r.y,f.endPointModified()):f.m_XStart===r.x&&f.m_YStart===r.y||(f.m_XStart=r.x,f.m_YStart=r.y,f.endPointModified()),f.m_attributes[(f.m_description.getTotalComponentCount()-2)*n]=r.z}function fe(f,n,r){r.assignVertexDescription(f.m_description),r.setXYCoords(0===n?f.m_XStart:f.m_XEnd,0===n?f.m_YStart:f.m_YEnd);for(let x=1;x<f.m_description.getAttributeCount();x++){const E=f.m_description.getSemantics(x);for(let v=0,I=$t.getComponentCount(E);v<I;v++){const D=ye(f,n,E,v);r.setAttributeBasic(E,v,D)}}}function os(f,n,r){r.isEmpty()&&(0,R.u)(""),function ms(f,n,r){n?f.m_XEnd===r.x&&f.m_YEnd===r.y||(f.m_XEnd=r.x,f.m_YEnd=r.y,f.endPointModified()):f.m_XStart===r.x&&f.m_YStart===r.y||(f.m_XStart=r.x,f.m_YStart=r.y,f.endPointModified())}(f,n,r.getXY());const l=r.getDescription();l!==f.m_description&&f.mergeVertexDescription(l);for(let _=1,x=l.getAttributeCount();_<x;_++){const E=l.getSemantics(_),v=$t.getComponentCount(E);for(let I=0;I<v;I++)gs(f,n,E,I,r.getAttributeAsDbl(E,I))}}function ye(f,n,r,l){if((n<0||n>1)&&(0,R.n)(""),0===r)return(l<0||l>=2)&&(0,R.n)(""),0===n?0===l?f.m_XStart:f.m_YStart:0===l?f.m_XEnd:f.m_YEnd;const _=$t.getComponentCount(r);(l<0||l>=_)&&(0,R.n)("");const x=f.m_description.getAttributeIndex(r);return x>=0?f.m_attributes[n*(f.m_description.getTotalComponentCount()-2)+f.m_description.getPointAttributeOffset(x)-2+l]:$t.getDefaultValue(r)}function gs(f,n,r,l,_){if((n<0||n>1)&&(0,R.n)(""),0===r)return 0===n?0===l?f.m_XStart=_:1===l?f.m_YStart=_:(0,R.n)(""):1===n?0===l?f.m_XEnd=_:1===l?f.m_YEnd=_:(0,R.n)(""):(0,R.n)(""),void f.endPointModified();const x=$t.getComponentCount(r);(l<0||l>=x)&&(0,R.n)("");let E=f.m_description.getAttributeIndex(r);E<0&&(f.addAttribute(r),E=f.m_description.getAttributeIndex(r)),f.m_attributes[n*(f.m_description.getTotalComponentCount()-2)+f.m_description.getPointAttributeOffset(E)-2+l]=_}function Ts(f,n){if(f===n)return;n.isEmpty()&&(0,R.u)("");const r=n.getDescription();r!==f.m_description&&f.mergeVertexDescription(r);for(let l=1,_=r.getAttributeCount();l<_;l++){const x=r.getSemantics(l),E=$t.getComponentCount(x);for(let v=0;v<E;v++){let I=ye(n,0,x,v);gs(f,0,x,v,I),I=ye(n,1,x,v),gs(f,1,x,v,I)}}}function re(f){return f.absNorm()*(0,c.g)()}function qe(f,n){return Math.max(f.absNorm(),n.absNorm())*(0,c.g)()}function Ps(f,n,r){const l=new jt;f.queryEnvelopeW(c.E.unit(),l);const _=new jt;return n.queryEnvelopeW(c.E.unit(),_),_.inflate(r),!l.isIntersectingW(_)}function ds(f,n,r){const l=(0,c.L)(f,r),_=(0,c.L)(n,r);l.sort((x,E)=>x.compare(E)),_.sort((x,E)=>x.compare(E));for(let x=0;x<3;x++){if(l[x].compare(_[x])<0)return-1;if(0!==l[x].compare(_[x]))return 1}return 0}var fs=F.V;let qs=(()=>{class f{constructor(r){if(r.copy)this.m_XStart=r.copy.m_XStart,this.m_YStart=r.copy.m_YStart,this.m_XEnd=r.copy.m_XEnd,this.m_YEnd=r.copy.m_YEnd,this.m_description=r.copy.m_description,this.m_attributes=null,this.m_description&&this.m_description.getTotalComponentCount()-2&&(this.m_attributes=r.copy.m_attributes.slice());else{if(r.move)return this.m_description=r.move.m_description,r.move.m_description=null,this.m_attributes=r.move.m_attributes,r.move.m_attributes=null,this.m_XStart=r.move.m_XStart,this.m_YStart=r.move.m_YStart,this.m_XEnd=r.move.m_XEnd,void(this.m_YEnd=r.move.m_YEnd);if(void 0!==r.XStart)return this.m_XStart=r.XStart,this.m_YStart=r.YStart,this.m_XEnd=r.XEnd,this.m_YEnd=r.YEnd,this.m_attributes=null,this.m_description=r.vd?r.vd:(0,F.j)(),void(r.vd&&this.setDefaultAttributeValues());if(void 0!==r.ZStart)return this.m_XStart=r.XStart,this.m_YStart=r.YStart,this.m_XEnd=r.XEnd,this.m_YEnd=r.YEnd,this.m_description=r.vd?r.vd:(0,F.w)(),void(r.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=r.ZStart,this.m_attributes[this.m_description.getTotalComponentCount()-2]=r.ZEnd):this.m_attributes=[r.ZStart,r.ZEnd]);if(r.start)return this.m_XStart=r.start.x,this.m_YStart=r.start.y,this.m_XEnd=r.end.x,this.m_YEnd=r.end.y,this.m_attributes=null,void(this.m_description=(0,F.j)());if(r.start3D)return this.m_XStart=r.start3D.x,this.m_YStart=r.start3D.y,this.m_XEnd=r.end3D.x,this.m_YEnd=r.end3D.y,this.m_description=r.vd?r.vd:(0,F.w)(),void(r.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=r.start3D.z,this.m_attributes[this.m_description.getTotalComponentCount()-2]=r.end3D.z):this.m_attributes=[r.start3D.z,r.end3D.z]);(0,R.c)("bad constructor params"),this.m_XStart=this.m_YStart=this.m_XEnd=this.m_YEnd=Number.NaN}}setDefaultAttributeValues(){const r=this.m_description.getTotalComponentCount()-2;r>0&&(null===this.m_attributes&&(this.m_attributes=(0,c.d)(2*r,Number.NaN)),(0,c.a)(this.m_attributes,this.m_description.getDefaultPointAttributes(),0,2,r),(0,c.a)(this.m_attributes,this.m_description.getDefaultPointAttributes(),r,2,r))}absNormXYZ(r){return(0,R.b)("not implemented"),0}snapControlPoints3D(){return(0,R.b)("not implemented"),!1}setCoordsForIntersector3D(r,l,_){(0,R.b)("not implemented")}transformAttribute(r,l,_,x,E){(0,R.b)("")}mergeVertexDescriptionImpl(r){const l=this.getDescription(),_=(0,F.l)(l,r);this.assignVertexDescription(_)}changeEndPoints(r,l){const _=r.getXY(),x=l.getXY();this.changeEndPoints2D(_,x);let E=r.getDescription();E!==this.getDescription()&&this.mergeVertexDescription(E),E=l.getDescription(),E!==this.getDescription()&&this.mergeVertexDescription(E);for(let v=1,I=E.getAttributeCount();v<I;v++){const D=E.getSemantics(v),G=fs.getComponentCount(D);for(let q=0;q<G;q++)gs(this,0,D,q,r.getAttributeAsDbl(D,q)),gs(this,1,D,q,l.getAttributeAsDbl(D,q))}}getStartXY(){return new c.P(this.m_XStart,this.m_YStart)}setStartXY(r){this.m_XStart=r.x,this.m_YStart=r.y,this.endPointModified()}setStartXYCoords(r,l){this.m_XStart=r,this.m_YStart=l,this.endPointModified()}getStartXYZ(){return Ss(this,0)}setStartXYZ(r){Qe(this,0,r)}setStartXYZCoords(r,l,_){Qe(this,0,F.h.construct(r,l,_))}queryStart(r){fe(this,0,r)}setStart(r){os(this,0,r)}setStart2D(r){this.setStartXY(r)}getStartAttributeAsDbl(r,l){return ye(this,0,r,l)}getStartAttributeAsInt(r,l){return(0,R.g)(0),0}setStartAttribute(r,l,_){gs(this,0,r,l,_)}setStartAttributesFromPoint(r,l){const _=r.getDescription();for(let x=l&&_.hasZ()?2:1,E=_.getAttributeCount();x<E;++x){const v=_.getSemantics(x),I=fs.getComponentCount(v);for(let D=0;D<I;++D){const G=r.getAttributeAsDbl(v,D);this.setStartAttribute(v,D,G)}}}setEndAttributesFromPoint(r,l){const _=r.getDescription();for(let x=l&&_.hasZ()?2:1,E=_.getAttributeCount();x<E;++x){const v=_.getSemantics(x),I=fs.getComponentCount(v);for(let D=0;D<I;++D){const G=r.getAttributeAsDbl(v,D);this.setEndAttribute(v,D,G)}}}getStartX(){return this.m_XStart}getStartY(){return this.m_YStart}getStartZ(){return(0,R.g)(0),0}getEndX(){return this.m_XEnd}getEndY(){return this.m_YEnd}getEndZ(){return(0,R.g)(0),0}getEndXY(){return new c.P(this.m_XEnd,this.m_YEnd)}setEndXY(r){this.m_XEnd=r.x,this.m_YEnd=r.y,this.endPointModified()}setEndXYCoords(r,l){this.m_XEnd=r,this.m_YEnd=l,this.endPointModified()}getEndXYZ(){return Ss(this,1)}setEndXYZ(r){Qe(this,1,r)}setEndXYZCoords(r,l,_){Qe(this,1,F.h.construct(r,l,_))}queryEnd(r){fe(this,1,r)}setEnd(r){os(this,1,r)}setEnd2D(r){this.setEndXY(r)}getEndAttributeAsDbl(r,l){return ye(this,1,r,l)}getEndAttributeAsInt(r,l){return(0,R.g)(0),Math.trunc(0)}setEndAttribute(r,l,_){gs(this,1,r,l,_)}getDimension(){return 1}copyTo(r){if(this===r)return;r.getGeometryType()!==this.getGeometryType()&&(0,R.t)("");const l=r;l.assignVertexDescription(this.m_description),l.m_attributes&&(0,c.a)(l.m_attributes,this.m_attributes,0,0,2*(this.m_description.getTotalComponentCount()-2)),l.m_XStart=this.m_XStart,l.m_YStart=this.m_YStart,l.m_XEnd=this.m_XEnd,l.m_YEnd=this.m_YEnd,this.copyToImpl(l)}isEmpty(){return this.isEmptyImpl()}isClosed(){return this.m_XStart===this.m_XEnd&&this.m_YStart===this.m_YEnd}setEmpty(){}calculateArea2D(){return 0}queryInterval(r,l){const _=c.E.constructEmpty();return _.vmin=ye(this,0,r,l),_.vmax=_.vmin,_.mergeNeCoordinate(ye(this,1,r,l)),_}calculateLength3D(r){return(0,R.g)(0),0}getCoord3D(r){return(0,R.g)(0),{}}getCoord2D(r){const l=c.P.getNAN();return this.queryCoord2D(r,l),l}queryCoord3D(r,l){(0,R.g)(0)}getCoordZ(r){return(0,R.g)(0),0}queryCoord(r,l){l.assignVertexDescription(this.m_description),l.setXY(this.getCoord2D(r));for(let _=1,x=this.m_description.getAttributeCount();_<x;_++){const E=this.m_description.getSemantics(_),v=fs.getComponentCount(E);for(let I=0;I<v;I++){const D=this.getAttributeAsDbl(r,E,I);l.setAttributeBasic(E,I,D)}}}isCloserThanDistance(r,l,_){const x=dt.J.constructEmpty();if(this.queryLooseEnvelopeOnInterval(l,x),x.distance(r)>_)return!1;const E=this.getClosestCoordinateOnInterval(r,l,_);return!Number.isNaN(E)&&c.P.distance(r,this.getCoord2D(E))<=_}isMonotoneQuickAndDirty(){return!1}isTrue3D(){return!1}getReversed(){const r=this.clone();return r.reverse(),r}reverse(){this.m_XEnd=(0,c.b)(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=(0,c.b)(this.m_YStart,this.m_YStart=this.m_YEnd),this.reverseImpl();for(let r=1,l=this.m_description.getAttributeCount();r<l;r++){const _=this.m_description.getSemantics(r);for(let x=0,E=fs.getComponentCount(_);x<E;x++){const v=ye(this,0,_,x);gs(this,0,_,x,ye(this,1,_,x)),gs(this,1,_,x,v)}}return this.afterCompletedModification(),this}isEmptyImpl(){return!1}isCircular(){return!1}distance(r,l,_,x){if(!l&&this.isIntersecting(r,0,!1)){if(null!==_||null!==x){const G=(0,c.d)(9,Number.NaN),q=(0,c.d)(9,Number.NaN),B=this.intersect(r,null,G,q,0);(0,R.g)(B<=9),0===B&&(0,R.c)(""),null!==_&&(_[0]=G[0]),null!==x&&(x[0]=q[0])}return 0}let E,v=Number.MAX_VALUE,I=-1,D=v;return E=this.getStartXY(),I=r.getClosestCoordinate(E,!1),E.subThis(r.getCoord2D(I)),D=E.length(),D<v&&(v=D,null!==x&&(x[0]=I),null!==_&&(_[0]=0)),E=this.getEndXY(),I=r.getClosestCoordinate(E,!1),E.subThis(r.getCoord2D(I)),D=E.length(),D<v&&(v=D,null!==x&&(x[0]=I),null!==_&&(_[0]=1)),E=r.getStartXY(),I=this.getClosestCoordinate(E,!1),E.subThis(this.getCoord2D(I)),D=E.length(),D<v&&(v=D,null!==_&&(_[0]=I),null!==x&&(x[0]=0)),E=r.getEndXY(),I=this.getClosestCoordinate(E,!1),E.subThis(this.getCoord2D(I)),D=E.length(),D<v&&(v=D,null!==_&&(_[0]=I),null!==x&&(x[0]=1)),v}calculateSubLengthFromStart(r){return this.tToLength(r)}calculateSubLength(r,l){return l===r?0:this.tToLength(l)-this.tToLength(r)}static recalculateParentT(r,l,_){return(0,c.q)(r,l,_)}moveTo(r){const l=this.isClosed(),_=new Y.T;_.setShift(r.sub(this.getStartXY())),this.applyTransformation(_),this.changeEndPoints2D(r,l?r:this.getEndXY())}moveTo3D(r){(0,R.g)(0)}getDescription(){return this.m_description}assignVertexDescription(r){!function ks(f,n){const r=(0,F.p)();(0,F.q)(n,f.m_description,r);let l=null;const _=n.getTotalComponentCount()-2,x=f.m_description?f.m_description.getTotalComponentCount()-2:0;if(_>0&&(l=(0,c.d)(2*_,Number.NaN),(0,c.a)(l,n.getDefaultPointAttributes(),0,2,_),(0,c.a)(l,n.getDefaultPointAttributes(),_,2,_),null!==f.m_description))for(let E=1;E<n.getAttributeCount();E++){const v=r[E];if(-1!==v){const I=f.m_description.getPointAttributeOffset(v)-2,D=n.getPointAttributeOffset(E)-2,G=$t.getComponentCount(n.getSemantics(E));for(let q=0;q<G;++q)l[D]=f.m_attributes[I],l[_+D]=f.m_attributes[x+I]}}f.m_attributes=l,f.m_description=n}(this,r)}mergeVertexDescription(r){this.m_description!==r&&(this.m_description.hasAttributesFrom(r)||this.mergeVertexDescriptionImpl(r))}hasAttribute(r){return this.m_description.hasAttribute(r)}addAttribute(r){if(this.m_description.hasAttribute(r))return;const l=(0,F.m)(this.m_description,r);this.assignVertexDescription(l)}dropAttribute(r){if(!this.m_description.hasAttribute(r))return;const l=(0,F.r)(this.m_description,r);this.assignVertexDescription(l)}dropAllAttributes(){const r=(0,F.j)();r!==this.m_description&&this.assignVertexDescription(r)}swap(r){if(this===r)return;r.getGeometryType()!==this.getGeometryType()&&(0,R.t)("wrong geometry type");const l=r;l.m_description=(0,c.b)(this.m_description,this.m_description=l.m_description),l.m_XStart=(0,c.b)(this.m_XStart,this.m_XStart=l.m_XStart),l.m_YStart=(0,c.b)(this.m_YStart,this.m_YStart=l.m_YStart),l.m_XEnd=(0,c.b)(this.m_XEnd,this.m_XEnd=l.m_XEnd),l.m_YEnd=(0,c.b)(this.m_YEnd,this.m_YEnd=l.m_YEnd),l.m_attributes=(0,c.b)(this.m_attributes,this.m_attributes=l.m_attributes),this.swapImpl(l)}equals(r,l){if(this.getGeometryType()!==r.getGeometryType())return!1;const _=void 0===l;_&&(l=0);const x=r;if(this===x)return!0;if(this.m_description!==x.m_description||Math.abs(this.m_XStart-x.m_XStart)>l||Math.abs(this.m_XEnd-x.m_XEnd)>l||Math.abs(this.m_YStart-x.m_YStart)>l||Math.abs(this.m_YEnd-x.m_YEnd)>l)return!1;for(let E=0,v=2*(this.m_description.getTotalComponentCount()-2);E<v;E++)if(!(0,c.I)(this.m_attributes[E],x.m_attributes[E],l))return!1;return _?this.equalsImpl(x):this.equalsImplTol(x,l)}getImpl(){return this}setAttributeBasic(r,l,_){if(this.addAttribute(r),0===r&&this.isCurve()){(l<0||l>1)&&(0,R.t)("");const x=new Y.T;x.setShiftCoords(0===l?_:0,1===l?_:0),0===l?x.xx=0:x.yy=0,this.applyTransformation(x)}else this.setStartAttribute(r,l,_),this.setEndAttribute(r,l,_)}replaceNaNs(r,l){if(this.addAttribute(r),this.isEmpty())return;const _=fs.getComponentCount(r);for(let x=0;x<_;x++){const E=this.getStartAttributeAsDbl(r,x);Number.isNaN(E)&&this.setStartAttribute(r,x,l);const v=this.getEndAttributeAsDbl(r,x);Number.isNaN(v)&&this.setEndAttribute(r,x,l)}}}return f.s_maxMonotonicPartParams=8,f})();class bi extends vt.G{constructor(n,r){super(),this.m_index=-1,this.gc=n,this.dim=r}next(){for(;;){if(this.m_index>=this.gc.getGeometryCount()||(this.m_index++,this.m_index===this.gc.getGeometryCount()))return null;const n=this.gc.getGeometry(this.m_index);if(-1===this.dim||1<<n.getDimension()&this.dim)return n}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class li{constructor(n){this.m_geoms=[],this.m_description=(0,F.j)(),n&&(n.vd?this.m_description=n.vd:n.copy?n.copy.copyTo(this):(0,R.t)("constructor argument not recognized"))}getGeometryCount(){return this.m_geoms.length}reserve(n){}addGeometry(n){if(n.getGeometryType()===R.G.enumGeometryCollection){const r=n;for(let l=0,_=r.getGeometryCount();l<_;l++)this.addGeometry(r.getGeometry(l))}else this.m_geoms.push(n.clone()),this.mergeVertexDescription(n.getDescription())}addCursor(n){for(let r=n.next();null!==r;r=n.next())this.addGeometry(r)}getGeometry(n){return(n<0||n>=this.m_geoms.length)&&(0,R.t)("Geometry_collection.get_geometry"),this.m_geoms[n]}modifiedElementIndex(n){this.mergeVertexDescription(this.getGeometry(n).getDescription())}modifiedElement(n){this.mergeVertexDescription(n.getDescription())}getGeometryType(){return R.G.enumGeometryCollection}getDimension(){let n=0;for(const r of this.m_geoms)n=Math.max(n,r.getDimension());return n}getDescription(){return this.m_description}assignVertexDescription(n){this.m_description!==n&&this.assignVertexDescriptionImpl(n)}assignVertexDescriptionImpl(n){for(const r of this.m_geoms)r.assignVertexDescription(n);this.m_description=n}mergeVertexDescription(n){this.m_description!==n&&(this.m_description.hasAttributesFrom(n)||this.mergeVertexDescriptionImpl(n))}hasAttribute(n){return this.m_description.hasAttribute(n)}addAttribute(n){if(this.m_description.hasAttribute(n))return;const r=(0,F.m)(this.m_description,n);this.assignVertexDescription(r)}dropAttribute(n){if(!this.m_description.hasAttribute(n))return;const r=(0,F.r)(this.m_description,n);this.assignVertexDescription(r)}dropAllAttributes(){const n=(0,F.j)();n!==this.m_description&&this.assignVertexDescription(n)}queryInterval(n,r){let l=new c.E;const _=new c.E;_.setEmpty();for(const x of this.m_geoms)l=x.queryInterval(n,r),_.merge(l);return _}queryEnvelope(n){if(4===n.m_EnvelopeType){const r=new F.E;n.setEmpty(),n.assignVertexDescription(this.m_description);for(const l of this.m_geoms)l.queryEnvelope(r),n.merge(r)}else if(2===n.m_EnvelopeType){const r=new dt.J;n.setEmpty();for(const l of this.m_geoms)l.queryEnvelope(r),n.mergeEnvelope2D(r)}(0,R.b)("3d envelope case not implemented")}queryLooseEnvelope(n){if(2===n.m_EnvelopeType){const r=new dt.J;n.setEmpty();for(const l of this.m_geoms)l.queryLooseEnvelope(r),n.mergeEnvelope2D(r)}(0,R.b)("3d not impl")}isEmpty(){return 0===this.m_geoms.length}setEmpty(){this.m_geoms.length=0}applyTransformation(n){if(1===n.m_TransformationType)for(const r of this.m_geoms)r.applyTransformation(n);(0,R.b)("3d xform not impl")}transformAttribute(n,r,l,_,x){for(const E of this.m_geoms)E.transformAttribute(n,r,l,_,x)}createInstance(){return new li({vd:this.getDescription()})}copyTo(n){n.getGeometryType()!==R.G.enumGeometryCollection&&(0,R.t)("");const r=n;if(r!==this){r.m_geoms.length=0,r.assignVertexDescription(this.m_description);for(const l of this.m_geoms)r.m_geoms.push(l.clone())}}calculateArea2D(){const n=new c.K(0);for(const r of this.m_geoms)n.pe(r.calculateArea2D());return n.getResult()}calculateLength2D(){const n=new c.K(0);for(const r of this.m_geoms)n.pe(r.calculateLength2D());return n.getResult()}calculateLength3D(n){return(0,R.g)(0),0}getBoundary(){const n=this.createInstance(),r=n;for(const l of this.m_geoms){const _=l.getBoundary();_&&r.m_geoms.push(_)}return n}clone(){return new li({copy:this})}equals(n,r){if(n===this)return!0;if(n.getGeometryType()!==R.G.enumGeometryCollection)return!1;const l=n;if(this.m_description!==l.m_description||this.m_geoms.length!==l.m_geoms.length)return!1;for(let _=0;_<this.m_geoms.length;++_)if(!this.m_geoms[_].equals(l.m_geoms[_],r))return!1;return!0}swap(n){n.getGeometryType()!==R.G.enumGeometryCollection&&(0,R.t)(""),n!==this&&(this.m_geoms=(0,c.b)(n.m_geoms,n.m_geoms=this.m_geoms))}setAttributeBasic(n,r,l){for(const _ of this.m_geoms)_.setAttributeBasic(n,r,l)}replaceNaNs(n,r){for(const l of this.m_geoms)l.replaceNaNs(n,r)}getImpl(){return this}mergeVertexDescriptionImpl(n){const r=this.getDescription(),l=(0,F.l)(r,n);this.assignVertexDescription(l)}}function ir(f,n=-1){return new bi(f,n)}li.type=R.G.enumGeometryCollection;class Ls extends qs{constructor(n){super(n)}}class To extends Ls{isTrue3D(){return!0}constructor(n){super(n)}}function Us(f,n,r){nr(n,f.getStartXY(),f.getEndXY(),r)}function nr(f,n,r,l){(0,c.Z)(n,r,f,l)}function Is(f,n){return(0,c.q)(f.m_XStart,f.m_XEnd,n)}function Ii(f,n){return(0,c.q)(f.m_YStart,f.m_YEnd,n)}function or(f,n,r){n.value()<=.5?(0,c.a1)(2,Vt.constructPoint2D(f.getStartXY()),Vt.constructPoint2D(f.getEndXY()),n,r):(0,c.a2)(2,Vt.constructPoint2D(f.getStartXY()),Vt.constructPoint2D(f.getEndXY()),n,r)}function Hr(f,n,r){f.m_XStart=n.x,f.m_YStart=n.y,f.m_XEnd=r.x,f.m_YEnd=r.y,f.afterCompletedModification()}function Oe(f){if(f.m_YEnd<f.m_YStart||f.m_YEnd===f.m_YStart&&f.m_XEnd<f.m_XStart){f.m_XEnd=(0,c.b)(f.m_XStart,f.m_XStart=f.m_XEnd),f.m_YEnd=(0,c.b)(f.m_YStart,f.m_YStart=f.m_YEnd);for(let n=0,r=f.m_description.getTotalComponentCount()-2;n<r;n++)f.m_attributes[n+r]=(0,c.b)(f.m_attributes[n],f.m_attributes[n]=f.m_attributes[n+r])}}function Oi(f,n,r,l){let _=0;if((f.m_XStart===n.m_XStart&&f.m_YStart===n.m_YStart||f.m_XStart===n.m_XEnd&&f.m_YStart===n.m_YEnd)&&(_++,!l))return 1;if(f.m_XEnd===n.m_XStart&&f.m_YEnd===n.m_YStart||f.m_XEnd===n.m_XEnd&&f.m_YEnd===n.m_YEnd){if(_++,2===_)return 2;if(!l)return 1}return n.isIntersectingPoint(f.getStartXY(),r,!0)||n.isIntersectingPoint(f.getEndXY(),r,!0)||f.isIntersectingPoint(n.getStartXY(),r,!0)||f.isIntersectingPoint(n.getEndXY(),r,!0)?4:l&&_?0:function ar(f,n){const r=rn(f,n.m_XStart,n.m_YStart),l=rn(f,n.m_XEnd,n.m_YEnd);if(r<0&&l<0||r>0&&l>0)return!1;const _=rn(n,f.m_XStart,f.m_YStart),x=rn(n,f.m_XEnd,f.m_YEnd);return!(_<0&&x<0||_>0&&x>0)&&(mr(f)>mr(n)?hr(f,n):hr(n,f))}(f,n)?4:0}function Gn(f,n,r,l,_,x,E,v){null!==l&&(0,c.w)(l,2,Number.NaN),null!==_&&(0,c.w)(_,2,Number.NaN),null!==r&&(0,c.ab)(r,c.P,2);const I=function zr(f,n,r,l,_,x,E,v,I){const D=Qi(f,n.getStartXY(),E,!1),G=Qi(f,n.getEndXY(),E,!1),q=Qi(n,f.getStartXY(),E,!1),B=Qi(n,f.getEndXY(),E,!1);let z=0,L=0;if(!Number.isNaN(D)){let Q=!1;v&&(0,c.J)(D,0,1)&&f.getCoord2D(D).isEqualPoint2D(n.getStartXY())&&(z++,Q=!0),Q||(_&&(_[L]=D),x&&(x[L]=0),l&&l[L].setCoords(n.m_XStart,n.m_YStart),L++)}if(!Number.isNaN(G)){let Q=!1;v&&(0,c.J)(G,0,1)&&f.getCoord2D(G).isEqualPoint2D(n.getEndXY())&&(z++,Q=!0),Q||(r>L&&(_&&(_[L]=G),x&&(x[L]=1),l&&l[L].setCoords(n.m_XEnd,n.m_YEnd)),L++)}if(2!==L&&!Number.isNaN(q)&&!(0===D&&0===q||0===G&&1===q)){let Q=!1;v&&(0,c.J)(q,0,1)&&n.getCoord2D(q).isEqualPoint2D(f.getStartXY())&&(z++,Q=!0),Q||(r>L&&(_&&(_[L]=0),x&&(x[L]=q),l&&l[L].setCoords(f.m_XStart,f.m_YStart)),L++)}if(2!==L&&!Number.isNaN(B)&&!(1===D&&0===B||1===G&&1===B)){let Q=!1;v&&(0,c.J)(B,0,1)&&n.getCoord2D(B).isEqualPoint2D(f.getEndXY())&&(z++,Q=!0),Q||(r>L&&(_&&(_[L]=1),x&&(x[L]=B),l&&l[L].setCoords(n.m_XEnd,n.m_YEnd)),L++)}if(L>0)return I&&(x=(0,c.b)(_,_=x)),2===L&&r>=2&&_&&_[0]>_[1]&&(_[1]=(0,c.b)(_[0],_[0]=_[1]),x&&(x[1]=(0,c.b)(x[0],x[0]=x[1])),l&&(l[1]=(0,c.b)(l[0],l[0]=l[1]))),L;if(z>0)return 0;const j=function No(f,n,r){const l=f.m_XEnd-f.m_XStart,_=f.m_YEnd-f.m_YStart,x=n.m_XEnd-n.m_XStart,E=n.m_YEnd-n.m_YStart,v=x*_-l*E;if(0===v)return c.P.getNAN();const I=4*(0,c.N)()*(Math.abs(x*_)+Math.abs(l*E)),D=n.m_XStart-f.m_XStart,G=n.m_YStart-f.m_YStart,q=x*G-D*E,B=4*(0,c.N)()*(Math.abs(x*G)+Math.abs(D*E)),z=q/v,L=Math.abs(v),j=(B*L+I*Math.abs(q))/(v*v)+(0,c.N)()*Math.abs(z);if(z<-j||z>1+j)return c.P.getNAN();const Q=l*G-D*_,et=Q/v,K=(4*(0,c.N)()*(Math.abs(l*G)+Math.abs(D*_))*L+I*Math.abs(Q))/(v*v)+(0,c.N)()*Math.abs(et);if(et<-K||et>1+K)return c.P.getNAN();let rt=(0,c.c)(z,0,1),ot=(0,c.c)(et,0,1);const nt=c.P.getNAN();Us(f,rt,nt);const at=c.P.getNAN();if(Us(n,ot,at),!r||c.P.distance(nt,at)>r){const pt=c.P.getNAN();(0,c.Z)(nt,at,.5,pt),rt=f.getClosestCoordinate(pt,!1),ot=n.getClosestCoordinate(pt,!1);const gt=c.P.getNAN();Us(f,rt,gt);const yt=c.P.getNAN();Us(n,ot,yt),gt.subThis(yt);const ft=gt.length(),bt=(f.absNorm()+n.absNorm())*(0,c.g)();if(ft>Math.max(r,bt))return c.P.getNAN()}return new c.P(rt,ot)}(f,n,E);return Number.isNaN(j.x)?0:(l&&(l[0]=f.getCoord2D(j.x)),_&&(_[0]=j.x),x&&(x[0]=j.y),1)}(f,n,2,r,l,_,x,E,v);return l&&(l.length=I),_&&(_.length=I),r&&(r.length=I),I}function Qi(f,n,r,l){const _=c.P.getNAN(),x=c.P.getNAN();let E=!1;f.m_YEnd<f.m_YStart||f.m_YEnd===f.m_YStart&&f.m_XEnd<f.m_XStart?(_.setCoords(f.m_XEnd,f.m_YEnd),x.setCoords(f.m_XStart,f.m_YStart),E=!0):(_.setCoords(f.m_XStart,f.m_YStart),x.setCoords(f.m_XEnd,f.m_YEnd));const v=E?1:0,I=E?0:1,D=c.P.getNAN();D.setSub(n,_);let G=D.length(),q=3*G*(0,c.N)();if(G<=Math.max(r,q))return l&&0===G?Number.NaN:v;if(D.setSub(n,x),G=D.length(),q=3*G*(0,c.N)(),G<=Math.max(r,q))return l&&0===G?Number.NaN:I;D.setCoords(x.x-_.x,x.y-_.y);const B=D.length();if(B>0){const z=1/B;D.scale(z);const L=c.P.getNAN();L.setSub(n,_);const j=L.dotProduct(D),Q=8*L.dotProductAbs(D)*(0,c.N)();D.leftPerpendicularThis();const et=L.dotProduct(D),K=8*L.dotProductAbs(D)*(0,c.N)(),rt=Math.max(r,Q);if(j<-rt||j>B+rt)return Number.NaN;const ot=Math.max(r,K);if(Math.abs(et)<=ot){let nt=j*z;nt=(0,c.c)(nt,0,1);const at=c.P.getNAN();if(nr(nt,_,x,at),c.P.distance(at,n)<=r){if(nt<.5){if(c.P.distance(at,_)<=r&&c.P.distance(n,_)<=r)return v}else if(c.P.distance(at,x)<=r&&c.P.distance(n,x)<=r)return I;return E?1-nt:nt}}}return Number.NaN}function rn(f,n,r){const l=c.P.getNAN();l.setCoords(n,r),l.subThis(f.getStartXY());const _=c.P.getNAN();_.setSub(f.getEndXY(),f.getStartXY());const x=_.crossProduct(l),E=4*(0,c.N)()*(Math.abs(_.x*l.y)+Math.abs(_.y*l.x));return x>E?-1:x<-E?1:0}function Ur(f,n,r,l){const _=l?f.m_XStart:f.m_XEnd,x=l?f.m_YStart:f.m_YEnd,E=c.P.getNAN();return E.x=n.getEndX()-_,E.y=n.getEndY()-x,!(r.dotProduct(E)>3*(0,c.N)()*r.dotProductAbs(E))||(E.x=n.getStartX()-_,E.y=n.getStartY()-x,r.dotProduct(E)<=3*(0,c.N)()*r.dotProductAbs(E))}function hr(f,n){const r=c.P.getNAN();return r.x=f.m_XEnd-f.m_XStart,r.y=f.m_YEnd-f.m_YStart,!!Ur(f,n,r,!1)&&(r.negateThis(),!!Ur(f,n,r,!0))}function mr(f){const n=f.m_XStart-f.m_XEnd,r=f.m_YStart-f.m_YEnd;return n*n+r*r}class Fn{constructor(n){if(this.m_segFlagStream=null,this.m_xyStream=null,this.m_bCirculator=!1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_parent=n.parent,this.m_buffer=new this.m_parent.m_segmentBufferCTor,this.m_description=n.parent.getDescription(),this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),void 0!==n.pointIndex){(n.pointIndex<0||n.pointIndex>=n.parent.getPointCount())&&(0,R.n)("");const r=n.parent.getPathIndexFromPointIndex(n.pointIndex);this.m_currentPathIndex=r,this.m_nextPathIndex=r+1,this.m_nextSegmentIndex=n.pointIndex-n.parent.getPathStart(r),this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex)}else if(void 0!==n.pathIndex){(n.pathIndex<0||n.pathIndex>=n.parent.getPathCount()||n.segmentIndex<0)&&(0,R.n)("");const r=n.parent.isClosedPath(n.pathIndex)?0:1;n.segmentIndex>=n.parent.getPathSize(n.pathIndex)-r&&(0,R.n)(""),this.m_nextSegmentIndex=n.segmentIndex,this.m_currentPathIndex=n.pathIndex,this.m_nextPathIndex=this.m_nextSegmentIndex+1,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex)}this.prepare(),this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1,this.m_bStripAttributes=!1,this.m_prevPathIndex=-1,this.m_prevSegmentIndex=-1,this.m_bNeedsUpdate=!1,this.m_currentPathIndex>-1&&(this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex))}stripAttributes(){this.m_bStripAttributes=!0}prepare(){this.m_bCirculator=!1,this.m_parent.isEmptyImpl()?(this.m_segFlagStream=null,this.m_xyStream=null):(this.m_segFlagStream=this.m_parent.getSegmentFlagsStreamRef(),this.m_xyStream=this.m_parent.getAttributeStreamRef(0))}nextPath(){return this.m_currentPathIndex=this.m_nextPathIndex,!(this.m_currentPathIndex>=this.m_parent.getPathCount()||(this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.m_nextPathIndex++,0))}previousPath(){return 0!==this.m_nextPathIndex&&(this.m_nextPathIndex--,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),this.m_currentPathIndex=this.m_nextPathIndex,this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.resetToLastSegment(),!0)}getSegmentCount(n){return this.m_parent.isEmptyImpl()?0:this.m_parent.getSegmentCountPath(n)}resetToFirstPath(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}resetToLastPath(){this.m_nextPathIndex=this.m_parent.getPathCount(),this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1}resetToPath(n){(n<0||n>this.m_parent.getPathCount())&&(0,R.n)(""),this.m_nextPathIndex=n,this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}isLastPath(){return this.m_currentPathIndex===this.m_parent.getPathCount()-1}isFirstSegmentInPath(){return 0===this.m_currentSegmentIndex}isLastSegmentInPath(){return this.m_currentSegmentIndex===this.m_segmentCount-1}resetToFirstSegment(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0}resetToLastSegment(){this.m_nextSegmentIndex=this.m_segmentCount,this.m_currentSegmentIndex=-1}resetTo(n){this.m_parent!==n.m_parent&&(0,R.m)(""),this.m_currentSegmentIndex=n.m_currentSegmentIndex,this.m_nextSegmentIndex=n.m_nextSegmentIndex,this.m_currentPathIndex=n.m_currentPathIndex,this.m_nextPathIndex=n.m_nextPathIndex,this.m_segmentCount=n.m_segmentCount,this.m_bCirculator=n.m_bCirculator,this.m_pathBegin=n.m_pathBegin,this.m_bCurrentPathClosed=n.m_bCurrentPathClosed,this.m_bStripAttributes=n.m_bStripAttributes,this.m_description=n.m_description}resetToVertex(n,r){if(this.m_currentPathIndex>=0&&this.m_currentPathIndex<this.m_parent.getPathCount()){const _=this.getPathBegin();if(n>=_&&n<this.m_parent.getPathEnd(this.m_currentPathIndex))return this.m_currentSegmentIndex=-1,void(this.m_nextSegmentIndex=n-_)}let l;l=r>=0&&r<this.m_parent.getPathCount()&&n>=this.m_parent.getPathStart(r)&&n<this.m_parent.getPathEnd(r)?r:this.m_parent.getPathIndexFromPointIndex(n),this.m_nextPathIndex=l+1,this.m_currentPathIndex=l,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=n-this.m_parent.getPathStart(l),this.m_segmentCount=this.getSegmentCount(l),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex)}hasNextSegment(){return this.m_nextSegmentIndex<this.m_segmentCount}hasPreviousSegment(){return this.m_nextSegmentIndex>0}nextSegment(){return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&(0,R.n)("Segment_iterator_impl::next_segment"),this.m_nextSegmentIndex++),this.m_buffer.get()}previousSegment(){return this.m_bCirculator?this.m_nextSegmentIndex=(this.m_segmentCount+this.m_nextSegmentIndex-1)%this.m_segmentCount:(0===this.m_nextSegmentIndex&&(0,R.n)(""),this.m_nextSegmentIndex--),this.m_nextSegmentIndex!==this.m_currentSegmentIndex&&this.updateSegment(),this.m_buffer.get()}nextCurve(){if(!this.m_parent.hasNonLinearSegments())return this.resetToLastSegment(),null;let n=0;for(;;){if(this.m_nextSegmentIndex===this.m_segmentCount||n===this.m_segmentCount)return null;const r=this.getPathBegin()+this.m_nextSegmentIndex;if(1!=(31&this.m_segFlagStream.read(r))){this.updateSegment();break}this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:this.m_nextSegmentIndex++,n++}return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&(0,R.n)(""),this.m_nextSegmentIndex++),this.m_buffer.get()}getPathBegin(){return this.m_pathBegin}getPathIndex(){return this.m_currentPathIndex}getStartPointIndex(){return this.getPathBegin()+this.m_currentSegmentIndex}getEndPointIndex(){return this.isClosingSegment()?this.getPathBegin():this.getStartPointIndex()+1}updateSegment(){(this.m_nextSegmentIndex<0||this.m_nextSegmentIndex>=this.m_segmentCount||this.m_currentPathIndex<0)&&(0,R.n)(""),this.m_currentSegmentIndex=this.m_nextSegmentIndex,this.m_parent.getSegmentFromPath(this.m_currentPathIndex,this.m_currentSegmentIndex,this.m_buffer,this.m_bStripAttributes)}isClosingSegment(){return this.m_bCurrentPathClosed&&this.m_currentSegmentIndex===this.m_segmentCount-1}isCurve(){return null!==this.m_segFlagStream&&1!=(31&this.m_segFlagStream.read(this.m_currentSegmentIndex))}isPathClosed(){return this.m_bCurrentPathClosed}setCirculator(n){this.m_bCirculator=n}getImpl(){return this}}class pn{constructor(n){this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null,this.m_refCount=1,n&&n.copyTo(this)}getRasterizedGeometry(){return this.m_rasterizedGeometry}copyTo(n){n!==this&&((0,R.g)(n.uniqueUse()),n.m_quadTree=this.m_quadTree,n.m_quadTreeForPaths=this.m_quadTreeForPaths,n.m_rasterizedGeometry=this.m_rasterizedGeometry)}clone(){const n=new pn;return this.copyTo(n),n}uniqueUse(){return 1===this.m_refCount}addRef(){++this.m_refCount}release(){0==--this.m_refCount&&(this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null)}setRasterizedGeometry(n){(0,R.g)(this.uniqueUse())}setQuadTree(n){(0,R.g)(this.uniqueUse()),this.m_quadTree=n}setQuadTreeForPaths(n){(0,R.g)(this.uniqueUse()),this.m_quadTreeForPaths=n}getQuadTree(){return this.m_quadTree}getQuadTreeForPaths(){return this.m_quadTreeForPaths}}function Or(f){return!(f.isEmpty()||f.getGeometryType()!==R.G.enumPolyline&&f.getGeometryType()!==R.G.enumPolygon||f.getPointCount()<20)}function Os(f){return!(f.isEmpty()||f.getGeometryType()!==R.G.enumPolyline&&f.getGeometryType()!==R.G.enumPolygon||f.getPointCount()<20)}function Ao(f,n){return f.readPoint2D(n+4)}function lr(f){const n=f.getGeometryType();return n===R.G.enumEllipticArc?10:n===R.G.enumBezier?4:n===R.G.enumRationalBezier2?5:n===R.G.enumBezier2?2:void(0,R.c)("")}function Vs(f){const n=31&f;return 4===n?10:2===n?4:8===n?5:16===n?2:0}function wi(f,n,r,l){const _=4*(0,c.N)()*(Math.abs(n.vmin)+Math.abs(n.vmax)),x=(0,c.N)();if(1===f.getMaxDerivative()){(0,R.g)(r>0);const G=Go(f,0,n,(0,c.N)(),_);return l[0]=G.root,G.cRoots}let E,v=[];const I=new c.E(n.vmin-_,n.vmax+_);v.push(new c.P(I.vmin,I.vmax));let D=0;for(let G=f.getMaxDerivative()-1;G>=0;G--){E=v,v=[];for(let q=0,B=E.length;q<B;q++){if(E[q][0]<E[q][1]){let z,L,j;if(G===f.getMaxDerivative()-1?({root:z,funcAtRoot:L,cRoots:j}=Go(f,G,c.E.construct(E[q][0],E[q][1]),x,.5*_)):({root:z,funcAtRoot:L,cRoots:j}=Gt(f,G,c.E.construct(E[q][0],E[q][1]),0,.5*_)),1===j){if(0===G)D<r&&(E[q][0]<=n.vmin&&E[q][1]>=n.vmin&&z!==n.vmin&&0===f.getValue(0,n.vmin)&&(z=n.vmin),E[q][0]<=n.vmax&&E[q][1]>=n.vmax&&z!==n.vmax&&0===f.getValue(0,n.vmax)&&(z=n.vmax),l[D]=n.snapClip(z),D>0?l[D]-l[D-1]>_&&D++:D++);else{const Q=c.P.getNAN();Q[0]=E[q][0],Q[1]=z,v.push(Q);const et=c.P.getNAN();et[0]=z,et[1]=E[q][1],v.push(et)}continue}}v.push(E[q])}}return D}function Ns(f,n,r,l,_,x){const E=(0,c.m)(c.F,2),v=it(new c.F(f),new c.F(n),new c.F(r),l,_,E);return x[0]=E[0].value(),x[1]=E[1].value(),v}function Ks(f,n,r,l,_,x,E){const v=(0,c.m)(c.F,3),I=lt(new c.F(f),new c.F(n),new c.F(r),new c.F(l),_,x,v);return E[0]=v[0].value(),E[1]=v[1].value(),E[2]=v[2].value(),I}function Di(f,n,r,l,_,x,E,v){return function Mn(f,n,r,l,_,x,E,v){const I=(0,c.d)(r*r,Number.NaN);I.fill(0),(0,c.a)(v,l,0,0,r);const D=(0,c.d)(r,Number.NaN),G=(0,c.d)(r,Number.NaN),q=(0,c.d)(r,Number.NaN);let B=f(v,r,n);let L=0;for(L=0;L<100;L++){const j=B;for(let rt=0;rt<r;++rt)G[rt]=v[rt];if(L%r==0){I.fill(0);for(let rt=0;rt<r;rt++)I[rt*r+rt]=1}let Q=0,et=0;for(let rt=0;rt<r;++rt){for(let at=0;at<r;++at)D[at]=I[rt*r+at];const ot=B;B=w(f,n,v,D,_,x,r);const nt=ot-B;nt>Q&&(et=rt,Q=nt)}for(let rt=0;rt<r;rt++)D[rt]=v[rt]-G[rt],q[rt]=v[rt]+(v[rt]-G[rt]);const K=f(q,r,n);if(K<j&&2*(j-2*B+K)*(0,c.s)(j-B-Q)<(0,c.s)(j-K)*Q){B=w(f,n,v,D,_,x,r);for(let rt=0;rt<r;++rt)I[et*r+rt]=I[(r-1)*r+rt],I[(r-1)*r+rt]=D[rt]}if(j<=B)return f(v,r,n)}return B}(f,n,r,l,_,x,0,v)}function Go(f,n,r,l,_){const x={root:0,funcAtRoot:0,cRoots:0};let E=r.vmin,v=r.vmax,I=0,D=Number.MAX_VALUE,G=f.getValue(n,E),q=f.getValue(n,v),B=0,z=0,L=0;if(G>=0&&q>=0||G<=0&&q<=0)return Math.abs(G)<Math.abs(q)?(x.funcAtRoot=G,x.root=E,x.cRoots=0===G?1:0,x):(x.funcAtRoot=q,x.root=v,x.cRoots=0===q?1:0,x);Math.abs(G)<Math.abs(q)&&(v=(0,c.b)(E,E=v),q=(0,c.b)(G,G=q)),I=E,B=G;let j=!0,Q=0;for(;0!==q&&Math.abs(E-v)>l*Math.abs(v)+_;Q++){let et=Q>64;if(!et){z=G!==B&&q!==B?E*q*B/((G-q)*(G-B))+v*G*B/((q-G)*(q-B))+I*G*q/((B-G)*(B-q)):v-q*(v-E)/(q-G);const K=(3*E+v)/4;if(et=!(z>K&&z<v||z>v&&z<K),!et){const rt=l*Math.abs(v)+_;if(j){const ot=Math.abs(v-I);et=Math.abs(z-v)>=.5*ot||ot<rt}else{const ot=Math.abs(I-D);et=Math.abs(z-v)>=.5*ot||ot<rt}}}if(et?(z=(E+v)/2,j=!0):j=!1,L=f.getValue(n,z),0===L)return x.root=z,x.funcAtRoot=L,x.cRoots=1,x;if(!et){const K=E-z,rt=z-v;if(Math.abs(K)>10*Math.abs(rt)){let ot=v+3*rt;for(let nt=0;nt<2;nt++){const at=f.getValue(n,ot);(0,c.e)(G)*(0,c.e)(at)>0?(E=ot,G=at):ot=(0,c.q)(E,v,.75)}}else if(Math.abs(rt)>10*Math.abs(K)){let ot=E-3*K;for(let nt=0;nt<2;++nt){const at=f.getValue(n,ot);(0,c.e)(q)*(0,c.e)(at)>0?(v=ot,q=at):ot=(0,c.q)(E,v,.25)}}}D=I,I=v,B=q,(0,c.e)(G)*(0,c.e)(L)<0?(v=z,q=L):(E=z,G=L),Math.abs(G)<Math.abs(q)&&(v=(0,c.b)(E,E=v),q=(0,c.b)(G,G=q)),128===Q&&(0,R.c)("Root_finder iterations exceeded")}return x.root=v,x.funcAtRoot=q,x.cRoots=1,x}function Gt(f,n,r,l,_){const x={root:0,funcAtRoot:0,cRoots:0};let E=r.vmin,v=f.getValue(n,E),I=r.vmax,D=f.getValue(n,I);if(v>=0&&D>=0||v<=0&&D<=0)return Math.abs(v)<Math.abs(D)?(x.funcAtRoot=v,x.root=E,x.cRoots=0===v?1:0,x):(x.funcAtRoot=D,x.root=I,x.cRoots=0===D?1:0,x);D<0&&(D=(0,c.b)(v,v=D),I=(0,c.b)(E,E=I));let G=.5*(E+I),q=Math.abs(I-E),B=q,z=f.getValue(n,G),L=f.getValue(n+1,G),et=4,rt=1,ot=0,nt=0,at=1,gt=0;for(;++gt<100;){let yt;gt>32||0===L||2===at&&ot>1||1===at&&et<4?(at=1,rt>1&&rt--):(at=2,nt>1&&Math.abs(2*z)>Math.abs(q*L)&&rt++),q=B;let ft=!1;if(1===at)do{if(nt>2){const Nt=16*Math.abs(q);if(.5*Math.abs(E-I)>Nt){const Ft=Math.min(E,I),Ot=Math.max(E,I);if(G===Ft){yt=G,G=Ft+Nt,B=G-yt;break}if(G===Ot){yt=G,G=Ot-Nt,B=G-yt;break}}}B=.5*(I-E),yt=G,G=E+B,ft=E===G||I===G}while(0);else for(;;){B=rt*z/L,yt=G,G-=B,ft=G===yt;const Nt=Math.min(E,I),Ft=Math.max(E,I);if(G<Nt){if(rt>1){G=yt,rt--;continue}B=yt-Nt,G=Nt}else if(G>Ft){if(rt>1){G=yt,rt--;continue}B=yt-Ft,G=Ft}break}if(ft||Math.abs(B)<_){yt!==G&&(z=f.getValue(n,G));break}z=f.getValue(n,G),L=f.getValue(n+1,G);const bt=E,Dt=I;z<0?(v=z,E=G):(D=z,I=G),2===at&&(E===bt&&I===Dt||nt>1&&Math.abs(B)>=.5001*Math.abs(q))?ot++:ot=0,1===at?(et++,nt=0):(et=0,nt++)}return 100===gt&&(0,R.c)("Root_finder iterations exceeded"),x.root=G,x.funcAtRoot=z,x.cRoots=1,x}function w(f,n,r,l,_,x,E){const v=l.slice(0,E);let I=0;for(let et=0;et<E;et++)I+=l[et]*l[et];if(I=Math.sqrt(I),I>0)for(let et=0;et<E;et++)v[et]/=I;let D=Number.NEGATIVE_INFINITY,G=Number.POSITIVE_INFINITY;{const et=(0,c.d)(E,0);for(let K=0;K<E;K++)et[K]=K;et.sort((K,rt)=>{const ot=Math.abs(v[K]),nt=Math.abs(v[rt]);return ot<nt?-1:ot>nt?1:0});for(let K=0;K<E;K++){const rt=et[K];if(0===v[rt])continue;let ot=(_[rt]-r[rt])/v[rt],nt=(x[rt]-r[rt])/v[rt];nt<ot&&(nt=(0,c.b)(ot,ot=nt)),ot>D&&(D=ot),nt<G&&(G=nt)}}let q=0;const B=(Math.abs(D)+Math.abs(G))*(0,c.N)()*100,z=(0,c.d)(E,Number.NaN),L=v.slice();function j(et,K){for(let rt=0,ot=E;rt<ot;rt++)z[rt]=r[rt]+et*L[rt];return f(z,E,n)}B>0&&(q=function Ti(f,n,r,l,_,x){return function V(f,n,r,l,_,x){const E=(0,c.an)();let v=l,I=f(v,n),D=r,G=_,q=f(D,n),B=f(G,n);I>q&&(I=q,v=D),I>B&&(I=B,v=G);let z=D,L=G,j=q,Q=B;j>Q&&(j=(0,c.b)(Q,Q=j),L=(0,c.b)(z,z=L));let et=v-z,K=z-L;const rt=.5*Math.min(x,G-D),ot=2*rt;let at,pt=0;for(at=0;at<100&&!(G-D<=ot);++at){const gt=D+.5*(G-D);let yt=pt>0;if(!yt&&Math.abs(K)<=rt&&(yt=!0,pt=3),!yt){const Dt=v-z,Nt=v-L,Ft=Dt*(I-Q);let Ot=Nt*(I-j),Qt=Nt*Ot-Dt*Ft;Ot=2*(Ot-Ft),Ot>0&&(Qt=-Qt),Ot=Math.abs(Ot),0===Ot||Math.abs(Qt)>=Math.abs(Ot*K/2)||Qt<=Ot*(D-v)||Qt>=Ot*(G-v)?(yt=!0,pt=3):(K=et,et=Qt/Ot)}yt&&(K=v>=gt?D-v:G-v,et=E*K,pt--);let ft=v+et;ft<D+rt?ft=D+rt:ft>G-rt&&(ft=G-rt);const bt=f(ft,n);bt<I?(ft>=v?(D=v,q=I):(G=v,B=I),L=z,z=v,v=ft,Q=j,j=I,I=bt):(ft<v?(D=ft,q=bt):(G=ft,B=bt),bt<=j||z===v?(L=z,z=ft,Q=j,j=bt):(bt<=Q||L===v||L===z)&&(L=ft,Q=bt))}return v}(f,n,r,l,_,x)}(j,null,D,0,G,B));const Q=j(q);for(let et=0,K=E;et<K;et++)r[et]=(0,c.c)(z[et],_[et],x[et]);return Q}function W(f,n,r,l){return f.isZero()?n.isZero()?-1:0:(l.setE(n.clone().negateThis().divThisE(f)),r.containsCoordinate(l.value())?1:0)}function it(f,n,r,l,_,x){if(0===f.value())return _?(x[0].set(1),l.containsCoordinate(x[0].value())?1:0):W(n,r,l,x[0]);if(_){let z=2;return x[0].set(1),x[1].setE(r).divThisE(f),x[1].eq(x[0])&&(x[1].set(1),z=1),l.containsCoordinate(x[1].value())||(z=1),l.containsCoordinate(x[0].value())||(z--,x[0].setE(x[1])),2===z&&x[0].value()>x[1].value()&&(x[1]=(0,c.b)(x[0],x[0]=x[1])),z}const E=n.clone().sqrThis().subThisE(f.clone().mulThisE(r).mulThisE(c.ac));if(E.lt(c.H))return 0;const v=new c.F(n.value()>=0?1:-1),I=E.clone().sqrtThis(),D=new c.F(-.5).mulThisE(n.clone().addThisE(v.clone().mulThisE(I)));let G=0;x[0].setE(D.divE(f));const q=new c.F(x[0].value()),B=new c.F(f.value()).mulE(q).addE(new c.F(n.value()).mulE(q).addE(new c.F(r.value())));return B.isZero()||he(x[0],f,n,r,x[0]),l.containsCoordinate(x[0].value())&&G++,0!==I.value()&&0!==D.value()&&(x[G].assign(r.divE(D)),q.set(x[G].value()),B.assign(new c.F(f.value()).mulE(q).addE(new c.F(n.value()).mulE(q).addE(new c.F(r.value())))),B.isZero()||he(x[G],f,n,r,x[G]),l.containsCoordinate(x[G].value())&&G++,2===G&&x[0].value()>x[1].value()&&(x[1]=(0,c.b)(x[0],x[0]=x[1]))),G}function lt(f,n,r,l,_,x,E){if(0===f.value())return it(n,r,l,_,x,E);if(x){let v=1;E[0].set(1);const I=E.slice(v),D=it(f,n.addE(f),l.negate(),_,!1,I);if(D>0){v+=D;for(let q=1;q<v;q++)E[q].eq(c.G)&&(E[v-1]=(0,c.b)(E[q],E[q]=E[v-1]),v--)}const G=E.slice(0,v);G.sort((q,B)=>q.value()<B.value()?-1:q.value()>B.value()?1:0);for(let q=0;q<v;++q)E[q]=G[q];return v}return function Ye(f,n,r,l,_,x){const E=(0,c.m)(c.F,3);let v=0;const I=n.negate().divThisE(f.clone().mulThis(3));_.containsCoordinate(I.value())&&(E[0].setE(I),v=1);const D=(0,c.m)(c.F,2),G=it(f.mul(3),n.mul(2),r,_,!1,D);if(G<0)return l.isZero()?-1:0;for(let j=0;j<G;j++)_.containsCoordinate(D[j].value())&&E[v++].setE(D[j]);(0,c.C)(E,0,v,(j,Q)=>j.value()<Q.value()?-1:j.value()>Q.value()?1:0);const q=(0,c.m)(c.F,5);q[0].set(_.vmin);for(let j=0;j<v;j++)q[1+j].setE(E[j]);q[1+v].set(_.vmax);const B=v+2;let z=1,L=0;{const j=q[0].clone();if(f.clone().mulThisE(j).addThisE(n).mulThisE(j).addThisE(r).mulThisE(j).addThisE(l).isZero()){const Q=Ct(f,n,r,l);j.setError(Q.estimateError(j.value())),x[L]=j,L++,z++}}for(let j=z;j<B;j++){const Q=q[j].clone(),et=f.clone().mulThisE(Q).addThisE(n).mulThisE(Q).addThisE(r).mulThisE(Q).addThisE(l).isZero();if(et||!q[j].eq(q[j-1])){if(et||te(q[j-1].value(),q[j].value(),q[j-1].clone().addThisE(q[j]).divThisByPower2(2),f,n,r,l,Q)){if(L>0&&Q.eq(x[L-1]))continue;if(L>=3&&(0,R.c)("cubic_polynomial_solver_too_many_roots"),et){const K=Ct(f,n,r,l);Q.setError(K.estimateError(Q.value()))}x[L]=Q,L++}if(q[j].value()===_.vmax)break;et&&j++}}return L}(f,n,r,l,_,E)}function xt(f,n,r,l,_,x){return(x<n||n<0)&&(0,R.t)("nth_degree_real_roots"),function Ys(f,n,r,l,_,x){const E=new It(f,n,r,(0,c.N)());let v=0;if(2===E.truePower)v=it(f[2],f[1],f[0],r,l,_);else if(1===E.truePower)v=W(f[1],f[0],r,_[0]);else{if(0===E.truePower)return f[0].value()?0:-1;{const I=[];I.length=n,v=wi(E,r,n,I);for(let D=0;D<v;D++)_[D].set(I[D])}}for(let I=0;I<v;I++)_[I].setError(E.getError(_[I].value()));return v}(f,n,r,l,_)}function Ct(f,n,r,l){return{coef0:f.clone(),coef1:n.clone(),coef2:r.clone(),coef3:l.clone(),calcF(_){return this.coef0.clone().mulThis(_).addThisE(this.coef1).mulThis(_).addThisE(this.coef2).mulThis(_).addThisE(this.coef3)},calcDF(_){return this.coef0.clone().mulThis(3).mulThis(_).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(_).addThisE(this.coef2)},estimateError(_){const x=Math.abs(_),E=((this.coef0.eps()*x+this.coef1.eps())*x+this.coef2.eps())*x+this.coef3.eps()+this.calcF(_).eps(),v=this.coef0.clone().mulThis(_).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(_).addThisE(this.coef2);if(v.isZero()){const I=this.coef0.clone().mulThis(_).mulThis(6).addThisE(this.coef1.clone().mulThis(2));if(I.isZero()){const D=this.coef0.clone().mulThis(6);return Math.pow(6*E/Math.abs(D.value()),1/3)}return Math.sqrt(2*E/Math.abs(I.value()))}return E/Math.abs(v.value())}}}class It{updateCoefs(n){if(this.lastDeriv1===n)return this.curCoefs=this.derivCoefs1,void(this.lastUsed=1);if(this.lastDeriv2===n)return this.curCoefs=this.derivCoefs2,void(this.lastUsed=2);let r;1===this.lastUsed?(r=this.derivCoefs2,this.lastDeriv2=n,this.lastUsed=2):(r=this.derivCoefs1,this.lastDeriv1=n,this.lastUsed=1),r.length=0;for(let l=0,_=this.truePower-n;l<=_;++l){r.push(this.coefs[l+n].clone());let x=l+n,E=x--;for(let v=1;v<n;v++)E*=x--;r[l].mulThis(E)}this.curCoefs=r}constructor(n,r,l,_){this.derivCoefs1=[],this.derivCoefs2=[],this.lastDeriv1=-1,this.lastDeriv2=-1,this.lastUsed=-1,this.curCoefs=null,this.coefs=n,this.power=r,this.truePower=0;for(let x=r;x>=1;x--)if(0!==this.coefs[x].value()){this.truePower=x;break}}getMaxDerivative(){return this.truePower+1}getValue(n,r){let l=this.coefs;0===n?l=this.coefs:(this.updateCoefs(n),l=this.curCoefs);const _=new c.K(0);let x=1;for(let E=0,v=this.truePower-n;E<=v;++E)_.pe(x*l[E].value()),x*=r;return _.getResult()}getError(n){const r=Math.abs(n),l=new c.K(0),_=new c.F(1),x=new c.F(0);for(let v=0,I=this.power;v<=I;++v)x.addThisE(this.coefs[v].mulE(_)),l.pe(_.value()*this.coefs[v].eps()),_.mulThis(r);l.pe(x.eps());let E=1;for(let v=1;v<=this.truePower;++v){E*=v,this.updateCoefs(v);const I=new c.F(1),D=new c.F(0);for(let G=0,q=this.truePower-v;G<=q;++G)D.addThisE(this.curCoefs[G].mulE(I)),I.mulThis(n);if(!D.isZero())return Math.pow(E*l.getResult()/Math.abs(D.value()),1/v)}return 0}}function Lt(f,n,r,l,_,x){let E=f,v=n,I=v-E;if(!x){let z=l.calcF(f).value(),L=l.calcF(n).value();if((z>0||z>L)&&(v=(0,c.b)(E,E=v),L=(0,c.b)(z,z=L)),z>=0||L<=0)return!1}let D,G=!1,q=r,B=0;for(;B<100;B++){const z=l.calcF(q);if(D=l.calcDF(q),D.isZero())return!1;if(!z.value()||B>3&&z.isZero()){G=!0;break}x||(z.value()<0?E=q:v=q);const L=z.value()/D.value(),j=q-L;x||(j>=E&&j<=v||j>=v&&j<=E)&&Math.abs(L)<=.5*I?(q=j,I=Math.abs(L)):(I=Math.abs(.5*(v-E)),q=.5*(E+v))}return!!G&&(_.set(q,l.estimateError(q)),!0)}function te(f,n,r,l,_,x,E,v){return Lt(f,n,r.value(),Ct(l,_,x,E),v,!1)}class le{constructor(n,r,l){this.coefs=(0,c.m)(c.F,3),this.coefs[0].setE(n),this.coefs[1].setE(r),this.coefs[2].setE(l)}calcF(n){const r=new c.F(n);return this.coefs[0].mulE(r).addE(this.coefs[1]).mulE(r).addE(this.coefs[2])}calcDF(n){const r=new c.F(n);return c.F.st_mulByPower2(this.coefs[0],2).mulE(r).addE(this.coefs[1])}estimateError(n){const r=Math.abs(n),l=(this.coefs[0].eps()*r+this.coefs[1].eps())*r+this.coefs[2].eps()+this.calcF(n).eps(),_=new c.F(2).mulE(this.coefs[0]).mul(n).addE(this.coefs[1]);if(_.isZero()){const x=this.coefs[0].value();return Math.sqrt(l/Math.abs(x))}return l/Math.abs(_.value())}}function he(f,n,r,l,_){return Lt(0,0,f.value(),new le(n,r,l),_,!0)}var Je=F.V;class ns extends Ls{constructor(n){void 0===n||(0,c.O)(n,"vd")?(super({vd:n?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new c.P(0,0)):n.from?(super({XStart:n.from.x,YStart:n.from.y,XEnd:n.to.x,YEnd:n.to.y,...n.vd}),this.m_cp=n.cp.clone()):n.points?(super({XStart:n.points[0].x,YStart:n.points[0].y,XEnd:n.points[2].x,YEnd:n.points[2].y,...n.vd}),this.m_cp=n.points[1].clone()):n.copy?(super(n),this.m_cp=n.copy.m_cp.clone()):(0,R.c)("unexpected constructor args")}getBoundary(){return mi(this)}assignCopy(n){return this!==n&&n.copyTo(this),this}construct(n,r,l){this.setStartXY(n),this.m_cp.assign(r),this.setEndXY(l),no(this)}constructPoints(n){this.setStartXY(n[0]),this.m_cp.assign(n[1]),this.setEndXY(n[2]),no(this)}getGeometryType(){return R.G.enumBezier2}queryEnvelope(n){if(2!==n.m_EnvelopeType)(0,R.b)("env type not impl");else{if(n.setCoords(this.getStartXY()),n.mergeNe(this.getEndXY()),n.contains(this.m_cp))return;const r=Ih(this);if(null!==r){const l=new c.P;for(const _ of r.specialPoints)this.queryCoord2D(_,l),n.mergeNe(l)}else{const l=[];Ch(this,l);const _=new c.P;for(const x of l)this.queryCoord2D(x,_),n.mergeNe(_)}}}applyTransformation(n){if(1===n.m_TransformationType){const r=(0,c.m)(c.P,3);return this.queryControlPoints(r),n.transformPoints2D(r,3,r),this.setStartXY(r[0]),this.m_cp.assign(r[1]),this.setEndXY(r[2]),void this.afterCompletedModification()}(0,R.g)(0)}createInstance(){return new ns({vd:this.m_description})}calculateLength2D(){return yr(this,1,!1)}calculateLowerLength2D(){return c.P.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return c.P.distance(this.getStartXY(),this.m_cp)+c.P.distance(this.getEndXY(),this.m_cp)}queryCoord2D(n,r){this.queryCoord2DExtended(n,r,!1)}queryCoord2DExtended(n,r,l){const _=(0,c.m)(c.P,3);this.queryControlPoints(_),ni(_,n,r,l)}queryCoord2DE(n,r){!function Ln(f,n,r){const l=(0,c.m)(c.P,3);f.queryControlPoints(l),function ll(f,n,r){if(n.value()<=.5){const l=Vt.constructPoint2D(f[1]),_=new Vt;(0,c.a1)(2,Vt.constructPoint2D(f[0]),l,n,_);const x=new Vt;(0,c.a1)(2,l,Vt.constructPoint2D(f[2]),n,x);const E=new Vt;(0,c.a1)(2,_,x,n,E),r.setE(E)}else{const l=Vt.constructPoint2D(f[1]),_=new Vt;(0,c.a2)(2,Vt.constructPoint2D(f[0]),l,n,_);const x=new Vt;(0,c.a2)(2,l,Vt.constructPoint2D(f[2]),n,x);const E=new Vt;(0,c.a2)(2,_,x,n,E),r.setE(E)}}(l,n,r)}(this,n,r)}getCoordX(n){if(n<0||n>1){const r=new c.P;return this.queryCoord2DExtended(n,r,!0),r.x}if(n<=.5){const r=(0,c.Q)(this.getStartX(),this.m_cp.x,n),l=(0,c.Q)(this.m_cp.x,this.getEndX(),n);return(0,c.Q)(r,l,n)}{const r=(0,c.R)(this.getStartX(),this.m_cp.x,n),l=(0,c.R)(this.m_cp.x,this.getEndX(),n);return(0,c.R)(r,l,n)}}getCoordY(n){if(n<0||n>1){const r=new c.P;return this.queryCoord2DExtended(n,r,!0),r.y}if(n<=.5){const r=(0,c.Q)(this.getStartX(),this.m_cp.x,n),l=(0,c.Q)(this.m_cp.x,this.getEndX(),n);return(0,c.Q)(r,l,n)}{const r=(0,c.R)(this.getStartY(),this.m_cp.y,n),l=(0,c.R)(this.m_cp.y,this.getEndY(),n);return(0,c.R)(r,l,n)}}cut(n,r,l){const _=new is;return this.queryCut(n,r,_,l),_.releaseSegment()}queryCut(n,r,l,_){const x=l.createQuadraticBezier();if(this.cutBezierIgnoreAttributes(n,r,x),_)return;x.assignVertexDescription(this.m_description);const E=this.m_description.getAttributeCount();if(E>1){for(let v=1;v<E;v++){const I=this.m_description.getSemantics(v),D=Je.getComponentCount(I);for(let G=0;G<D;G++){const q=this.getAttributeAsDbl(n,I,G);x.setStartAttribute(I,G,q)}}for(let v=1;v<E;v++){const I=this.m_description.getSemantics(v),D=Je.getComponentCount(I);for(let G=0;G<D;G++){const q=this.getAttributeAsDbl(r,I,G);x.setEndAttribute(I,G,q)}}}}queryDerivative(n,r){!function ul(f,n,r){const l=(0,c.m)(c.P,4);f.queryControlPoints(l),function Gh(f,n,r){n.value()<0&&n.set(0,n.eps()),n.value()>1&&n.set(1,n.eps()),r.setE(function en(f,n,r){{const l=Vt.constructPoint2D(f[1]).subE(Vt.constructPoint2D(f[0])),_=new c.F(1).subE(r),x=Vt.constructPoint2D(f[2]).subE(Vt.constructPoint2D(f[1])),E=l.mulE(_).addE(x.mulE(r));return E.mulThisE(new c.F(2)),E}}(f,0,n))}(l,n,r)}(this,n,r)}cutBezierIgnoreAttributes(n,r,l){if((n<0||r>1||n>r)&&(0,R.t)("Quadratic_bezier.cut_bezier_ignore_attributes"),0===n&&1===r)return l.setStartXY(this.getStartXY()),l.m_cp.assign(this.m_cp),void l.setEndXY(this.getEndXY());const _=(0,c.m)(c.P,3);this.queryControlPoints(_),Rn(_,n,r,_),l.constructPoints(_)}splitBezierIgnoreAttributes(n,r,l){(0,R.g)(0)}getAttributeAsDbl(n,r,l){if(0===r)return 0===l?this.getCoordX(n):this.getCoordY(n);const _=this.calculateLength2D(),x=_>0?this.tToLength(n)/_:0,E=Je.getInterpolation(r),v=this.getStartAttributeAsDbl(r,l),I=this.getEndAttributeAsDbl(r,l);return(0,c.T)(E,v,I,x,Je.getDefaultValue(r))}getClosestCoordinate(n,r){return ys(this,n,c.E.unit(),r)}getClosestCoordinateOnInterval(n,r,l=-1){return ys(this,n,r,!1)}getYMonotonicParts(n,r){return this.getMonotonicParts(n,r)}getMonotonicParts(n,r){n.length<2&&(0,R.t)("");const l=ro(this);let _=0;if(2===l.specialPointsCount())return 0;(0,R.g)(n.length>=l.specialPointsCount()-1);for(let x=1,E=l.specialPointsCount();x<E;++x)this.queryCut(l.specialPoints[x-1],l.specialPoints[x],n[_],r),_++;for(let x=0;x<_;++x)wr(n[x].get());return _}intersectionWithAxis2D(n,r,l,_){const x=(0,c.m)(c.F,3),E=(0,c.m)(c.F,2),v=new c.E(0,1);let I=0;if(n){if(x[0]=new c.F(this.getStartY()).sub(r),x[1]=new c.F(this.m_cp.y).subE(new c.F(this.getStartY())).mulThisByPower2(2),x[2]=new c.F(this.getStartY()).add(this.getEndY()).subE(new c.F(this.m_cp.y).mulThisByPower2(2)),I=it(x[2],x[1],x[0],v,!1,E),l)for(let D=0;D<I;D++)l[D]=this.getCoordX(E[D].value())}else if(x[0]=new c.F(this.getStartX()).sub(r),x[1]=new c.F(this.m_cp.x).subE(new c.F(this.getStartX())).mulThisByPower2(2),x[2]=new c.F(this.getStartX()).add(this.getEndX()).subE(new c.F(this.m_cp.x).mulThisByPower2(2)),I=it(x[2],x[1],x[0],v,!1,E),l)for(let D=0;D<I;D++)l[D]=this.getCoordY(E[D].value());if(_)for(let D=0;D<I;D++)_[D]=E[D].value();else l&&(0,c.U)(l,I);return I}intersectionOfYMonotonicWithAxisX(n,r){if(this.m_YStart===this.m_YEnd)return n===this.m_YStart?r:Number.NaN;if(n===this.m_YStart)return this.m_XStart;if(n===this.m_YEnd)return this.m_XEnd;const l=[0,0],_=this.intersectionWithAxis2D(!0,n,l,null);return(0,R.g)(2!==_),-1===_?r:l[0]}isCurve(){return!0}isLine(){return!1}isDegenerate(n){return Te(this,n)}isDegenerate3D(n,r){return(0,R.g)(0),!1}queryLooseEnvelope(n){if(2===n.m_EnvelopeType)return n.setCoords(this.getStartXY()),n.mergeNe(this.m_cp),void n.mergeNe(this.getEndXY());(0,R.g)(0)}clone(n){const r=this.createInstance();return this.copyTo(r),r}queryInterval(n,r){if(0===n){const l=new dt.J;this.queryEnvelope(l);const _=new c.E;return 0===r?l.queryIntervalX(_):l.queryIntervalY(_),_}return super.queryInterval(n,r)}queryLooseEnvelopeOnInterval(n,r){const l=(0,c.m)(c.P,4);this.queryControlPoints(l),Rn(l,n.vmin,n.vmax,l),r.setFromPoints(l,4)}changeEndPoints2D(n,r){if(n.isEqual(this.m_XStart,this.m_YStart)&&r.isEqual(this.m_XEnd,this.m_YEnd))return;const l=this.m_cp.isEqual(this.m_XStart,this.m_YStart),_=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(n),this.setEndXY(r),l?this.m_cp.setCoordsPoint2D(n):_&&this.m_cp.setCoordsPoint2D(r),this.normalizeAfterEndpointChange()}tToLength(n){return yr(this,n,!0)}lengthToT(n){return function ol(f,n,r){const l=yr(f,1,!1);if(n<=0)return n;if(n>=l)return n-l+1;const _=[0];return 1!==wi(new il(f,n),c.E.unit(),1,_)&&(0,R.c)(""),_[0]}(this,n)}calculateWeightedAreaCentroid2D(n){const r=(0,c.m)(c.P,3);!function hl(f,n,r=!1){const l=(0,c.m)(c.P,3);f.queryControlPoints(l),Zo(l,n,r)}(this,r);const l=r[2],_=r[1],x=new c.P,E=l.y*_.x-l.x*_.y;x.x=-(4*l.x+5*_.x)*E/60,x.y=-(4*l.y+5*_.y)*E/60;const v=bh(this);return x.x+=(r[0].x-n.x)*v,x.y+=(r[0].y-n.y)*v,x}calculateWeightedCentroid2D(){const n=new c.P;return this.isDegenerate(0)?(n.setCoords(0,0),n):function vr(f){const n=c.P.distance(f.getStartXY(),f.getEndXY()),r=f.calculateUpperLength2D();return r-n<=8*Number.EPSILON*r}(this)?(n.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),n):(n.assign(function Dh(f,n,r){void 0===r&&(r=n,n=0);const l=new c.P;if(n<0||r>1)return l.setNAN(),l;if(n>r&&(0,R.t)("calculate_sub_weighted_centroid"),n===r||f.isDegenerate(0))return l.setCoords(0,0),l;const _=ro(f),x=re(f),E=Math.min(x/f.calculateUpperLength2D(),1e-7);let v=n,I=0;for(let D=1,G=_.specialPointsCount();D<G;D++)if(n<_.specialPoints[D]){I=D-1;break}l.setCoords(0,0);for(let D=I+1,G=_.specialPointsCount();D<G;D++){const q=Math.min(_.specialPoints[D],r),B=nl(f,v,q,E,x);if(l.addThis(B),v=q,r<=_.specialPoints[D])break}return l.add(f.getStartXY().mul(f.calculateLength2D()))}(this,1)),n)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(n){this.m_cp.setCoordsPoint2D(n),this.afterCompletedModification()}queryControlPoints(n){n[0].assign(this.getStartXY()),n[1].assign(this.m_cp),n[2].assign(this.getEndXY())}setControlPoints(n){for(let r=0;r<3;r++)n[r].isNAN()&&(0,R.t)("NaN control points in bezier are not supported");this.m_XStart=n[0].x,this.m_YStart=n[0].y,this.m_cp.setCoordsPoint2D(n[1]),this.m_XEnd=n[2].x,this.m_YEnd=n[2].y,this.afterCompletedModification()}getTangent(n){const r=(0,c.c)(n,0,1);let l=Er(this,1,r);return l.isZero()&&(l=Er(this,2,r),1===r&&l.negateThis()),l}getDerivative(n){return Er(this,1,(0,c.c)(n,0,1))}getCurvature(n){const r=Er(this,1,n),l=Er(this,2,n),_=r.sqrLength();return 0===_?Number.NaN:(r.divThis(Math.sqrt(_)),r.crossProduct(l)/_)}isIntersecting(n,r,l){return 0!==Kn(!1,this,n,r,l)}isIntersectingPoint(n,r,l){if(l&&(n.isEqualPoint2D(this.getStartXY())||n.isEqualPoint2D(this.getEndXY())))return!1;const _=new dt.J;if(this.queryLooseEnvelope(_),_.inflateCoords(r,r),!_.contains(n))return!1;const x=this.getClosestCoordinate(n,!1),E=new c.P;return this.queryCoord2D(x,E),c.P.distance(E,n)<=r}isIntersectingPoint3D(n,r,l,_,x=1){return(0,R.g)(0),!1}isMonotoneQuickAndDirty(){return!1}getMonotonicPartParams(n,r){const l=ro(this),_=l.specialPointsCount();if(!r)return l.specialPointsCount();n<_&&(0,R.t)("");for(let x=0;x<_;x++)r[x]=l.specialPoints[x];return _}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){(0,c.b)(this.m_XStart,this.m_XStart=this.m_XEnd),(0,c.b)(this.m_YStart,this.m_YStart=this.m_YEnd);for(let n=0,r=this.m_description.getTotalComponentCount()-2;n<r;n++)this.m_attributes[n+r]=(0,c.b)(this.m_attributes[n],this.m_attributes[n]=this.m_attributes[n+r]);this.m_cachedValues=null}}isDegenerateToLineHelper(n){const r=[n];if(!Pe(this,r))return!1;const l=this.getEndXY().sub(this.getStartXY()),_=l.length(),x=this.getControlPoint1();return x.sub(this.getStartXY()),!(Math.abs(x.crossProduct(l))/_>r[0])}copyIgnoreAttributes(n){const r=(0,c.m)(c.P,3);this.queryControlPoints(r),n.setControlPoints(r)}calculateArea2DHelper(){return bh(this)}absNorm(){return function al(f){return f.getStartXY().norm(1)+f.getEndXY().norm(1)+f.m_cp.norm(1)}(this)}queryEnvelopeW(n,r){const l=(0,c.m)(c.P,3);this.queryControlPoints(l),Ir(l,n,r)}setSegmentFromCoords(n,r){this.construct(n[0],this.getControlPoint1(),n[r-1])}snapControlPoints(n){return function Fh(f,n){const r=(0,c.m)(c.P,3);f.queryControlPoints(r);const l=c.P.sqrDistance(r[1],r[0]),_=c.P.sqrDistance(r[1],r[2]);let x=r[0].clone(),E=l;l>_&&(x=r[2].clone(),E=_);let v=!1;return E<=n&&0!==E&&(v=!0,f.setControlPoint1(x)),v}(this,n)}writeInBufferStream(n,r){const l=new Float64Array(2);return l[0]=this.m_cp.x,l[1]=this.m_cp.y,n.writeRangeFromArray(r,l.length,l,!0,1),r+l.length}readFromBufferStream(n,r){const l=new Float64Array(2);n.queryRange(r,l.length,l,!0,1),this.m_cp.x=l[0],this.m_cp.y=l[1],this.m_cachedValues=null}needsSnapControlPoints(n){return function gl(f,n){if(!n)return!1;const r=(0,c.m)(c.P,3);f.queryControlPoints(r);const l=c.P.sqrDistance(r[1],r[0]),_=c.P.sqrDistance(r[1],r[2]);r[0].clone();let x=l;return l>_&&(r[2].clone(),x=_),x<=n&&0!==x}(this,n)}calculateSpecialPointsForCracking(n,r){return 0}ensureXYMonotone(){return wr(this)}setCoordsForIntersector(n,r,l){!function Th(f,n,r,l){if(n.isEqual(f.m_XStart,f.m_YStart)&&r.isEqual(f.m_XEnd,f.m_YEnd))return;const _=!!l&&f.isMonotoneQuickAndDirty(),x=new Y.T,E=(0,c.m)(c.P,3);E[0].setCoords(f.m_XStart,f.m_YStart),E[2].setCoords(f.m_XEnd,f.m_YEnd);const v=new c.P;v.setSub(E[2],E[0]),v.leftPerpendicularThis(),E[1].setAdd(E[0],v);const I=(0,c.m)(c.P,3);I[0].setCoordsPoint2D(n),I[2].setCoordsPoint2D(r),v.setSub(I[2],I[0]),v.leftPerpendicularThis(),I[1].setAdd(I[0],v),x.setFromTwoTriangles(E,I)?x.transformInPlace(f.m_cp):(0,c.Z)(n,r,.5,f.m_cp),f.changeEndPoints2D(n,r),_&&wr(f)}(this,n,r,l)}copyToImpl(n){const r=n;r.m_cp.setCoordsPoint2D(this.m_cp),Uo(r,Ih(this))}reverseImpl(){}equalsImplTol(n,r){return!!this.m_cp.isEqualPoint2D(n.m_cp,r)}equalsImpl(n){return!!this.m_cp.equals(n.m_cp)}swapImpl(n){const r=n;r.m_cp=(0,c.b)(this.m_cp,this.m_cp=r.m_cp),function rl(f,n){n.m_cachedValues=(0,c.b)(f.m_cachedValues,f.m_cachedValues=n.m_cachedValues)}(this,r)}afterCompletedModification(){no(this)}intersect(n,r,l,_,x){return $n(!1,this,n,r,l,_,x)}intersectPoint(n,r,l){return function br(f,n,r,l,_,x){const E=new jt;if(function wh(f,n,r){const l=(0,c.m)(c.P,3);f.queryControlPoints(l),Ir(l,n,r)}(f,c.E.unit(),E),E.inflate(_),!E.isIntersectingPoint2D(n))return 0;const v=new c.P,I=ys(f,n,c.E.unit(),!1);return f.queryCoord2D(I,v),c.P.distance(v,n)<=_?(l&&(l[0]=I),1):0}(this,n,0,r,l)}endPointModified(){no(this)}clearEndPointModified(){}}ns.type=R.G.enumBezier2;var _s=F.V;class as extends Ls{constructor(n){return void 0===n||(0,c.O)(n,"vd")?(super({vd:n?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new c.P(0,0),void(this.m_weights=[1,0,1])):(n.fromPoint&&n.weight?n={fromPoint:n.fromPoint,controlPoint1:n.controlPoint1,toPoint:n.toPoint,weight0:1,weight1:n.weight,weight2:1}:n.points&&n.weight?n={fromPoint:n.points[0],controlPoint1:n.points[1],toPoint:n.points[2],weight0:1,weight1:n.weight,weight2:1}:n.points&&n.weights&&(n={fromPoint:n.points[0],controlPoint1:n.points[1],toPoint:n.points[2],weight0:n.weights[0],weight1:n.weights[1],weight2:n.weights[2]}),n.fromPoint&&n.weight0?(super({start:n.fromPoint,end:n.toPoint}),(n.weight0<=0||n.weight1<0||n.weight2<=0)&&(0,R.t)("weights"),this.m_cp=n.controlPoint1.clone(),void(this.m_weights=[n.weight0,n.weight1,n.weight2])):n.copy?(super(n),this.m_cp=n.copy.m_cp.clone(),void(this.m_weights=n.copy.m_weights.slice())):n.move?(super(n),this.m_cp=n.move.m_cp.clone(),void(this.m_weights=n.move.m_weights.slice())):void(0,R.b)("unexpected constructor param"))}getBoundary(){return mi(this)}assignMove(n){return this}assignCopy(n){return n.copyTo(this),this}construct(n,r,l,_){this.dropAllAttributes(),this.setCpsAndWeights(n,r,l,1,_,1),gr(this)}constructWeights(n,r,l,_,x,E){this.dropAllAttributes(),this.setCpsAndWeights(n,r,l,_,x,E),gr(this)}constructArray(n,r){this.construct(n[0],n[1],n[2],r)}constructArrayWeights(n,r){this.dropAllAttributes(),this.setCpsAndWeightsArray(n,r),gr(this)}convertToStandardForm(){}getStandardFormWeight(){return this.m_weights[1]/Math.sqrt(this.m_weights[0]*this.m_weights[2])}getGeometryType(){return R.G.enumRationalBezier2}queryEnvelope(n){if(n instanceof dt.J){if(n.setCoords(this.getStartXY()),n.mergeNe(this.getEndXY()),n.contains(this.m_cp))return;const r=uh(this);if(null!==r){const l=new c.P;for(const _ of r.specialPoints)this.queryCoord2D(_,l),n.mergeNe(l)}else{const l=[],_=(0,c.m)(c.P,3);this.queryControlPoints(_),Fi(_,this.m_weights,l);const x=new c.P;for(const E of l)this.queryCoord2D(E,x),n.mergeNe(x)}}}applyTransformation(n){if(n instanceof Y.T){const r=(0,c.m)(c.P,3);return this.queryControlPoints(r),n.transformPoints2D(r,3,r),this.setStartXY(r[0]),this.m_cp.assign(r[1]),this.setEndXY(r[2]),void this.afterCompletedModification()}}createInstance(){return new as({vd:this.m_description})}calculateLength2D(){return Xe(this,1,!1)}calculateLowerLength2D(){return c.P.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return this.m_weights[1]>0?c.P.distance(this.getStartXY(),this.m_cp)+c.P.distance(this.getEndXY(),this.m_cp):c.P.distance(this.getStartXY(),this.getEndXY())}queryCoord2D(n,r){return this.queryCoord2DExtension(n,r,!0)}queryCoord2DE(n,r){!function tl(f,n,r){const l=(0,c.m)(c.P,3);f.queryControlPoints(l);const _=[0,0,0];f.queryWeights(_),function el(f,n,r,l){if(0===r.value())return void l.setE(f[0]);if(1===r.value())return void l.setE(f[2]);const _=[f[0].x.mulE(n[0]),f[1].x.mulE(n[1]),f[2].x.mulE(n[2])],x=[f[0].y.mulE(n[0]),f[1].y.mulE(n[1]),f[2].y.mulE(n[2])],E=[n[0].clone(),n[1].clone(),n[2].clone()],v=new c.F,I=new c.F,D=new c.F;if(r.value()<=.5){const q=(0,c._)(_[0],_[1],r),B=(0,c._)(_[1],_[2],r);v.setE((0,c._)(q,B,r));const z=(0,c._)(x[0],x[1],r),L=(0,c._)(x[1],x[2],r);I.setE((0,c._)(z,L,r));const j=(0,c._)(E[0],E[1],r),Q=(0,c._)(E[1],E[2],r);D.setE((0,c._)(j,Q,r))}else{const q=(0,c.$)(_[0],_[1],r),B=(0,c.$)(_[1],_[2],r);v.setE((0,c.$)(q,B,r));const z=(0,c.$)(x[0],x[1],r),L=(0,c.$)(x[1],x[2],r);I.setE((0,c.$)(z,L,r));const j=(0,c.$)(E[0],E[1],r),Q=(0,c.$)(E[1],E[2],r);D.setE((0,c.$)(j,Q,r))}v.divThisE(D),I.divThisE(D);const G=new c.P(v.value(),I.value());so([f[0].value(),f[1].value(),f[2].value()],G),l.x.set(G.x,v.eps()),l.y.set(G.y,I.eps())}([Vt.constructPoint2D(l[0]),Vt.constructPoint2D(l[1]),Vt.constructPoint2D(l[2])],[new c.F(_[0]),new c.F(_[1]),new c.F(_[2])],n,r)}(this,n,r)}queryCoord2DExtension(n,r,l){if(l){if(n<0)return void Us(new ke({start:this.getStartXY(),end:this.getStartXY().add(this.getTangent(0).getUnitVector())}),n,r);if(n>1)return void Us(new ke({start:this.getEndXY(),end:this.getEndXY().add(this.getTangent(1).getUnitVector())}),n-1,r)}const _=(0,c.m)(c.P,3);this.queryControlPoints(_),ps(_,this.m_weights,n,r)}getCoordX(n){const r=new c.P;return this.queryCoord2DExtension(n,r,!0),r.x}getCoordY(n){const r=new c.P;return this.queryCoord2DExtension(n,r,!0),r.y}cut(n,r,l){const _=new is;return this.queryCut(n,r,_,l),_.releaseSegment()}queryCut(n,r,l,_){const x=l.createQuadraticRationalBezier();if(this.cutBezierIgnoreAttributes(n,r,x),_)return;x.assignVertexDescription(this.m_description);const E=this.m_description.getAttributeCount();if(E>1){for(let v=1;v<E;v++){const I=this.m_description.getSemantics(v),D=_s.getComponentCount(I);for(let G=0;G<D;G++){const q=this.getAttributeAsDbl(n,I,G);x.setStartAttribute(I,G,q)}}for(let v=1;v<E;v++){const I=this.m_description.getSemantics(v),D=_s.getComponentCount(I);for(let G=0;G<D;G++){const q=this.getAttributeAsDbl(r,I,G);x.setEndAttribute(I,G,q)}}}}queryDerivative(n,r){!function rh(f,n,r){const l=(0,c.m)(c.P,3);f.queryControlPoints(l);const _=(0,c.d)(3,Number.NaN);f.queryWeights(_),function zm(f,n,r,l){r.value()<0&&r.set(0,r.eps()),r.value()>1&&r.set(1,r.eps());const _=(0,c.m)(Vt,4);(function ih(f,n,r,l,_){const x=[Vt.constructPoint2D(f[0]),Vt.constructPoint2D(f[1]),Vt.constructPoint2D(f[2])];x[2].subThisE(x[0]),x[1].subThisE(x[0]),x[0].setCoords(0,0),function nh(f,n,r,l,_){(0,R.g)(r>0);const x=[f[0].clone(),f[1].clone(),f[2].clone()];if(!x[0].isZero()){for(let z=1;z<3;++z)x[z].subThisE(x[0]);x[0]=Vt.constructCoords(0,0)}const E=Xo(x,n,0,l),v=function Hm(f,n,r){if(r.toDouble()<=.5){const l=(0,c._)(f[0],f[1],r),_=(0,c._)(f[1],f[2],r);return(0,c._)(l,_,r)}{const l=(0,c.$)(f[0],f[1],r),_=(0,c.$)(f[1],f[2],r);return(0,c.$)(l,_,r)}}(n,0,l),I=E.divE(v);_[0].setE(I);const D=[n[1].mulE(n[0]),n[2].mulE(n[0]).mul(.5),n[1].mulE(n[2])],G=Xo([f[1].subE(f[0]),f[2].subE(f[0]),f[2].subE(f[1])],D,0,l).mul(2),q=v.sqr(),B=G.divE(q);_[1].setE(B)}(x,[new c.F(n[0]),new c.F(n[1]),new c.F(n[2])],r,l,_)})(f,n,1,r,_),l.setE(_[1])}(l,_,n,r)}(this,n,r)}cutBezierIgnoreAttributes(n,r,l){(n<0||r>1||n>r)&&(0,R.t)("Quadratic_rational_bezier.cut_bezier_ignore_attributes");const _=(0,c.m)(c.P,3);this.queryControlPoints(_);const x=[0,0,0];$i(_,this.m_weights,n,r,_,x),l.setControlPointsAndWeights(_,x)}splitBezierIgnoreAttributes(n,r,l){}getAttributeAsDbl(n,r,l){if(0===r)return 0===l?this.getCoordX(n):this.getCoordY(n);const _=this.calculateLength2D(),x=_>0?this.tToLength(n)/_:0,E=_s.getInterpolation(r),v=this.getStartAttributeAsDbl(r,l),I=this.getEndAttributeAsDbl(r,l);return(0,c.T)(E,v,I,x,_s.getDefaultValue(r))}getClosestCoordinate(n,r){return Qr(this,n,c.E.unit(),r,-1)}getClosestCoordinateOnInterval(n,r,l=-1){return Qr(this,n,0,!1,l)}getYMonotonicParts(n,r){return this.getMonotonicParts(n,r)}getMonotonicParts(n,r){n.length<2&&(0,R.t)("");const l=_r(this);let _=0;if(2===l.specialPointsCount())return 0;(0,R.g)(n.length>=l.specialPointsCount()-1);for(let x=1,E=l.specialPointsCount();x<E;++x)this.queryCut(l.specialPoints[x-1],l.specialPoints[x],n[_],r),_++;for(let x=0;x<_;++x)$r(n[x].get());return _}intersectionWithAxis2D(n,r,l,_){l&&(l.length=9),_&&(_.length=9);const x=new Array(3),E=(0,c.m)(c.F,2),v=new c.E(0,1);let I=0;const D=(0,c.m)(c.P,3);if(this.queryControlPoints(D),n){if(x[0]=new c.F(D[0].y).sub(r).mul(this.m_weights[0]),x[1]=new c.F(D[1].y).sub(r).mul(this.m_weights[1]),x[2]=x[0].subE(x[1].mul(2)).addE(new c.F(D[2].y).sub(r).mul(this.m_weights[2])),x[1]=x[1].subE(x[0]).mulThisByPower2(2),I=it(x[2],x[1],x[0],v,!1,E),l)for(let G=0;G<I;G++)l[G]=this.getCoordX(E[G].value())}else if(x[0]=new c.F(D[0].x).sub(r).mul(this.m_weights[0]),x[1]=new c.F(D[1].x).sub(r).mul(this.m_weights[1]),x[2]=x[0].subE(x[1].mul(2)).addE(new c.F(D[2].x).sub(r).mul(this.m_weights[2])),x[1]=x[1].subE(x[0]).mulThisByPower2(2),I=it(x[2],x[1],x[0],v,!1,E),l)for(let G=0;G<I;G++)l[G]=this.getCoordY(E[G].value());if(_)for(let G=0;G<I;G++)_[G]=E[G].value();else l&&(0,c.C)(l,0,I,c.X);return I}intersectionOfYMonotonicWithAxisX(n,r){if(this.m_YStart===this.m_YEnd)return n===this.m_YStart?r:Number.NaN;if(n===this.m_YStart)return this.m_XStart;if(n===this.m_YEnd)return this.m_XEnd;const l=[Number.NaN,Number.NaN],_=this.intersectionWithAxis2D(!0,n,l,null);return(0,R.g)(2!==_),-1===_?r:l[0]}isCurve(){return!0}isDegenerate(n){return Te(this,n)}isDegenerate3D(n,r){return!1}queryLooseEnvelope(n){if(n instanceof dt.J)return n.setCoords({pt:this.getStartXY()}),n.mergeNe(this.m_cp),void n.mergeNe(this.getEndXY())}clone(n){const r=this.createInstance();return this.copyTo(r),r}queryInterval(n,r){if(0===n){const l=dt.J.constructEmpty();this.queryEnvelope(l);const _=c.E.constructEmpty();return 0===r?l.queryIntervalX(_):l.queryIntervalY(_),_}return super.queryInterval(n,r)}queryLooseEnvelopeOnInterval(n,r){const l=(0,c.m)(c.P,3);this.queryControlPoints(l),$i(l,this.m_weights,n.vmin,n.vmax,l,[0,0,0]),r.setFromPoints(l,3)}changeEndPoints2D(n,r){if(n.isEqual(this.m_XStart,this.m_YStart)&&r.isEqual(this.m_XEnd,this.m_YEnd))return;const l=this.m_cp.isEqual(this.m_XStart,this.m_YStart),_=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(n),this.setEndXY(r),l?this.m_cp.setCoordsPoint2D(n):_&&this.m_cp.setCoordsPoint2D(r),this.normalizeAfterEndpointChange()}tToLength(n){return Xe(this,n,!0)}lengthToT(n){return function ah(f,n,r){const l=Xe(f,1,!1);if(n<=0)return n;if(n>=l)return n-l+1;const _=[0];return 1!==wi(new oh(f,n),c.E.unit(),1,_)&&(0,R.c)(""),_[0]}(this,n)}calculateWeightedAreaCentroid2D(n){const r=function mh(f){const n=(0,c.m)(c.P,3),r=[0,0,0];return f.queryControlPoints(n),f.queryWeights(r),function Om(f,n){const r=Ni(n);if(1===r){const x=(0,c.m)(c.P,3);Zo(f,x);const E=x[2].clone(),v=x[1].clone(),I=new c.P,D=E.y*v.x-E.x*v.y;return I.x=-(4*E.x+5*v.x)*D/60,I.y=-(4*E.y+5*v.y)*D/60,I}if(0===r)return new c.P(0,0);(0,R.g)(r>0);const l=f[1].sub(f[0]),_=f[2].sub(f[0]);if(r<1){const x=Math.sqrt(1-r),E=Math.sqrt(1+r),v=(l.y*_.x-l.x*_.y)*r/Math.pow(x*E,5)/12,I=Math.atan2(x,E),D=r*x*E,G=r*r,q=l.mul(2*(2+G)),B=_.mul(2*G-5),z=q.add(B).mul(D),L=_.sub(l.mul(2*G)).mul(6*I);return z.add(L).mul(v)}{const x=Math.sqrt(r-1),E=Math.sqrt(r+1),v=(l.y*_.x-l.x*_.y)*r/Math.pow(x*E,5)/12,I=Math.atanh(x/E),D=r*x*E,G=r*r,q=l.mul(4).sub(_.mul(5)),B=l.add(_).mul(2*G),z=q.add(B).mul(D),L=_.sub(l.mul(2*G)).mul(6*I);return z.add(L).mul(v)}}(n,r)}(this),l=hh(this);return r.x+=(this.getStartX()-n.x)*l,r.y+=(this.getStartY()-n.y)*l,r}calculateWeightedCentroid2D(){const n=new c.P;return this.isDegenerate(0)?(n.setCoords(0,0),n):function lh(f){if(0===f.m_weights[1])return!0;const n=c.P.distance(f.getStartXY(),f.getEndXY()),r=f.calculateUpperLength2D();return r-n<=8*Number.EPSILON*r}(this)?(n.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),n):(n.assign(function Zm(f,n,r){void 0===r&&(r=n,n=0);const l=new c.P;if(n<0||r>1)return l.setNAN(),l;if(n>r&&(0,R.t)("calculate_sub_weighted_centroid"),n===r||f.isDegenerate(0))return l.setCoords(0,0),l;const _=_r(f),x=Ro(f),E=x/f.calculateUpperLength2D();let v=n,I=0;for(let D=1,G=_.specialPointsCount();D<G;D++)if(n<_.specialPoints[D]){I=D-1;break}l.setCoords(0,0);for(let D=I+1,G=_.specialPointsCount();D<G;D++){const q=Math.min(_.specialPoints[D],r),B=Ki(f,v,q,E,x);if(l.addThis(B),v=q,r<=_.specialPoints[D])break}return l.add(f.getStartXY().mul(f.calculateLength2D()))}(this,1)),n)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(n){this.m_cp.setCoordsPoint2D(n),this.afterCompletedModification()}queryWeights(n){for(let r=0;r<3;++r)n[r]=this.m_weights[r]}setWeights(n){}queryControlPoints(n){n[0].assign(this.getStartXY()),n[1].assign(this.m_cp),n[2].assign(this.getEndXY())}setControlPointsAndWeights(n,r){this.setCpsAndWeightsArray(n,r),this.afterCompletedModification()}getTangent(n){const r=(0,c.m)(c.P,3);return this.queryControlPoints(r),Zr(r,this.m_weights,n)}getDerivative(n){const r=(0,c.c)(n,0,1),l=(0,c.m)(c.P,4);return fn(this,1,r,l),l[1]}getCurvature(n){const r=(0,c.m)(c.P,4);fn(this,2,n,r);const l=r[1].sqrLength();return 0===l?Number.NaN:(r[1].divThis(Math.sqrt(l)),r[1].crossProduct(r[2])/l)}isIntersecting(n,r,l){return!1}isIntersectingPoint(n,r,l){return!1}isIntersectingPoint3D(n,r,l,_,x=1){return!1}isMonotoneQuickAndDirty(){const n=(0,c.m)(c.P,3);return this.queryControlPoints(n),Kr(n)}getMonotonicPartParams(n,r){const l=_r(this),_=l.specialPointsCount();if(!r)return l.specialPointsCount();n<_&&(0,R.t)("");for(let x=0;x<_;x++)r[x]=l.specialPoints[x];return _}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=(0,c.b)(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=(0,c.b)(this.m_YStart,this.m_YStart=this.m_YEnd),this.m_weights[2]=(0,c.b)(this.m_weights[0],this.m_weights[0]=this.m_weights[2]);for(let n=0,r=this.m_description.getTotalComponentCount()-2;n<r;n++)this.m_attributes[n+r]=(0,c.b)(this.m_attributes[n],this.m_attributes[n]=this.m_attributes[n+r]);this.m_cachedValues=null}}isLine(){return!1}isDegenerateToLineHelper(n){const r=[n];return!!Pe(this,r)&&function Qm(f,n){const r=f.getEndXY().sub(f.getStartXY()),l=r.length(),_=f.getControlPoint1();return _.subThis(f.getStartXY()),!(Math.abs(_.crossProduct(r))/l>n)}(this,r[0])}copyIgnoreAttributes(n){const r=(0,c.m)(c.P,3);this.queryControlPoints(r);const l=[0,0,0];this.queryWeights(l),n.setControlPointsAndWeights(r,l)}calculateArea2DHelper(){return hh(this)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)+this.m_cp.norm(1)}absNormXYZ(n){return(0,R.g)(0),0}queryEnvelopeW(n,r){gh(this,n,r)}setSegmentFromCoords(n,r){const l=[0,0,0];this.queryWeights(l),this.constructWeights(n[0],this.getControlPoint1(),n[r-1],l[0],l[1],l[2])}writeInBufferStream(n,r){const l=new Float64Array(5);return l[0]=this.m_cp.x,l[1]=this.m_cp.y,l[2]=this.m_weights[0],l[3]=this.m_weights[1],l[4]=this.m_weights[2],n.writeRangeFromArray(r,l.length,l,!0,1),r+l.length}readFromBufferStream(n,r){const l=new Float64Array(5);n.queryRange(r,l.length,l,!0,1),this.m_cp.x=l[0],this.m_cp.y=l[1],this.m_weights[0]=l[2],this.m_weights[1]=l[3],this.m_weights[2]=l[4],this.m_cachedValues=null}snapControlPoints(n){const r=(0,c.m)(c.P,3);this.queryControlPoints(r);const l=c.P.sqrDistance(r[1],r[0]),_=c.P.sqrDistance(r[1],r[2]);let x=r[0].clone(),E=l;l>_&&(x=r[2].clone(),E=_);let v=!1;return E<=n&&0!==E&&(v=!0,this.setControlPoint1(x)),v}needsSnapControlPoints(n){if(!n)return!1;const r=(0,c.m)(c.P,3);this.queryControlPoints(r);const l=c.P.sqrDistance(r[1],r[0]),_=c.P.sqrDistance(r[1],r[2]);r[0].clone();let x=l;return l>_&&(r[2].clone(),x=_),x<=n&&0!==x}calculateSpecialPointsForCracking(n,r){return 0}ensureXYMonotone(){return $r(this)}setCoordsForIntersector(n,r,l){!function ph(f,n,r,l){if(n.isEqual(f.m_XStart,f.m_YStart)&&r.isEqual(f.m_XEnd,f.m_YEnd))return;const _=!!l&&f.isMonotoneQuickAndDirty(),x=new Y.T,E=(0,c.m)(c.P,3);E[0].setCoords(f.m_XStart,f.m_YStart),E[2].setCoords(f.m_XEnd,f.m_YEnd);const v=new c.P;v.setSub(E[2],E[0]),v.leftPerpendicularThis(),E[1].setAdd(E[0],v);const I=(0,c.m)(c.P,3);I[0].setCoordsPoint2D(n),I[2].setCoordsPoint2D(r),v.setSub(I[2],I[0]),v.leftPerpendicularThis(),I[1].setAdd(I[0],v),x.setFromTwoTriangles(E,I)?x.transformInPlace(f.m_cp):(0,c.Z)(n,r,.5,f.m_cp),f.changeEndPoints2D(n,r),_&&$r(f)}(this,n,r,l)}copyToImpl(n){const r=n;r.m_cp.setCoordsPoint2D(this.m_cp),r.m_weights[0]=this.m_weights[0],r.m_weights[1]=this.m_weights[1],r.m_weights[2]=this.m_weights[2],ch(r,uh(this))}reverseImpl(){this.m_weights[2]=(0,c.b)(this.m_weights[0],this.m_weights[0]=this.m_weights[2])}equalsImpl(n){const r=n;if(!this.m_cp.equals(r.m_cp))return!1;for(let l=0;l<3;l++)if(this.m_weights[l]!==r.m_weights[l])return!1;return!0}equalsImplTol(n,r){const l=n;if(!this.m_cp.isEqualPoint2D(l.m_cp,r))return!1;const _=(0,c.m)(c.P,3);this.queryControlPoints(_);const x=(0,c.m)(c.P,3);l.queryControlPoints(x);const E=[l.m_weights[0],l.m_weights[1],l.m_weights[2]];for(let v=0;v<3;v++){const I=new F.h;I.setCoordsPoint2DZ(_[v].mul(this.m_weights[v]),this.m_weights[v]);const D=new F.h;if(D.setCoordsPoint2DZ(x[v].mul(E[v]),E[v]),!I.isEqual(D,r))return!1}return!0}swapImpl(n){const r=n;r.m_cp=(0,c.b)(this.m_cp,this.m_cp=r.m_cp),r.m_weights=(0,c.b)(this.m_weights,this.m_weights=r.m_weights),function eh(f,n){n.m_cachedValues=(0,c.b)(f.m_cachedValues,f.m_cachedValues=n.m_cachedValues)}(this,r)}afterCompletedModification(){gr(this)}intersect(n,r,l,_,x){return $n(!1,this,n,r,l,_,x)}intersectPoint(n,r,l){return function Jm(f,n,r,l,_){const x=new jt;if(gh(f,c.E.unit(),x),x.inflate(l),!x.isIntersectingPoint2D(n))return 0;const E=_r(f);let v=0;const I=[];let D=E.specialPoints[0];for(let G=1,q=E.specialPoints.length;G<q;++G){const B=E.specialPoints[G],z=th(f,n,D,B);if(0===I.length)I.push(z);else if(z.t===z.tmin)(0,R.g)(I.at(-1).d<=z.d),I.at(-1).tmax=z.tmax;else if(I.at(-1).t===I.at(-1).tmax){(0,R.g)(I.at(-1).d>=z.d);const L=I.at(-1).tmin;I[I.length-1]=z,I.at(-1).tmin=L}else I.push(z);D=B}for(const G of I)G.d<=l&&(r&&(r[v]=G.t),v++);return v}(this,n,r,l)}endPointModified(){gr(this)}clearEndPointModified(){}setCpsAndWeights(n,r,l,_,x,E){(_<=0||E<=0||x<0)&&(0,R.t)("weights"),(n.isNAN()||r.isNAN()||l.isNAN())&&(0,R.t)("NAN control points in bezier are not supported"),this.setStartXY(n),this.m_cp.assign(r),this.m_weights[0]=_,this.m_weights[1]=x,this.m_weights[2]=E,this.setEndXY(l)}setCpsAndWeightsArray(n,r){this.setCpsAndWeights(n[0],n[1],n[2],r[0],r[1],r[2])}}as.type=R.G.enumRationalBezier2;class Ne{static constructPoint2D(n){return new Ne(c.M.constructDouble(n.x),c.M.constructDouble(n.y))}constructor(n,r){if(void 0===n)return this.x=(new c.M).setNAN(),void(this.y=(new c.M).setNAN());this.x=n.clone(),this.y=r.clone()}assignPoint2D(n){return this.x.setDouble(n.x),this.y.setDouble(n.y),this}setCoords(n,r){return this.x.setThis(n),this.y.setThis(r),this}asPoint2D(){return new c.P(this.x.value(),this.y.value())}crossProduct(n){return this.x.mul(n.y).sub(this.y.mul(n.x))}leftPerpendicularThis(){const n=this.x.clone();this.x=this.y.clone().negate(),this.y=n}clone(){return new Ne(this.x,this.y)}dotProduct(n){return this.x.mul(n.x).add(this.y.mul(n.y))}add(n){return new Ne(this.x.add(n.x),this.y.add(n.y))}sub(n){return new Ne(this.x.sub(n.x),this.y.sub(n.y))}sqrLength(){return this.x.sqr().addThis(this.y.sqr())}mulThis(n){return this.x.mulThis(n),this.y.mulThis(n),this}mul(n){return this.clone().mulThis(n)}}class ls{constructor(n){return n.coefsT?(this.m_zeroCtor=n.zeroCtor,this.m_elements=n.coefsT.map(r=>r.clone()),(0,R.g)(this.m_elements.length===n.power+1),void this.updatePower()):n.coef0?(this.m_zeroCtor=n.zeroCtor,void(this.m_elements=[n.coef0.clone()])):n.copy?(this.m_zeroCtor=n.copy.m_zeroCtor,void(this.m_elements=n.copy.m_elements.map(r=>r.clone()))):(this.m_zeroCtor=n.zeroCtor,void(this.m_elements=[new this.m_zeroCtor]))}construct(n,r){return this.m_elements=n.map(l=>l.clone()),this.updatePower(),this}construct0(n){return this.m_elements.length=0,this.m_elements.push(n.clone()),this.updatePower(),this}assignCopy(n){return this.m_elements=n.m_elements.map(r=>r.clone()),this.updatePower(),this}assignMove(n){return this.m_elements=n.m_elements,n.m_elements=[],this.updatePower(),this}power(){return this.m_elements.length-1}addElement(n){this.m_elements.push(n.clone())}fmSubThis(n,r){return(0,R.g)(0),this}addThis(n){const r=Math.min(this.power(),n.power());for(let _=0;_<=r;++_)this.m_elements[_].addThis(n.m_elements[_]);const l=n.power();this.m_elements.length=Math.max(this.power(),n.power())+1;for(let _=r+1;_<=l;++_)this.m_elements[_]=n.m_elements[_];return this.updatePower(),this}add0(n){return this.m_elements[0].addThis(n),this.updatePower(),this}addNumber0(n){return(0,R.g)(0),this}sub(n){const r=Math.min(this.power(),n.power());for(let _=0;_<=r;++_)this.m_elements[_].subThis(n.m_elements[_]);const l=n.power();this.m_elements.length=Math.max(this.power(),n.power())+1;for(let _=r+1;_<=l;++_)this.m_elements[_]=n.m_elements[_].clone(),this.m_elements[_].negateThis();return this.updatePower(),this}sub0(n){return(0,R.g)(0),this}subNumber0(n){return(0,R.g)(0),this}subShifted(n,r){const l=this.power(),_=n.power()+r,x=Math.min(this.power(),_);let E=0;for(let v=r;v<=x;++v)this.m_elements[v].subThis(n.m_elements[E]),E++;if(_<=l)return this.updatePower(),this;this.m_elements.length=_+1;for(let v=l+1;v<this.m_elements.length;++v)this.m_elements[v]=new this.m_zeroCtor;for(let v=x+1;v<=_;++v)this.m_elements[v].subThis(n.m_elements[E++]);return this.updatePower(),this}subShiftedWithCoef(n,r,l){const _=this.power(),x=n.power()+l,E=Math.min(this.power(),x);let v=0;for(let I=l;I<=E;++I)this.m_elements[I].fmSubThis(n.m_elements[v],r),v++;if(x<=_)return this.updatePower(),this;this.m_elements.length=x+1;for(let I=_+1;I<this.m_elements.length;++I)this.m_elements[I]=new this.m_zeroCtor;for(let I=E+1;I<=x;++I)this.m_elements[I].fmSubThis(n.m_elements[v++],r);return this.updatePower(),this}mulThis(n){if(this.constructor===n.constructor){const r=n,l=[];for(let _=0,x=this.power();_<=x;_++)for(let E=0,v=r.power();E<=v;E++){const I=this.m_elements[_].clone();I.mulThis(r.m_elements[E]),_+E<l.length?l[_+E].addThis(I):l.push(I)}this.m_elements=l}else for(let r=0,l=this.power();r<=l;r++)this.m_elements[r].mulThis(n);return this.updatePower(),this}mulElementThis(n){for(let r=0,l=this.power();r<=l;r++)this.m_elements[r].mulThis(n);return this.updatePower(),this}mulNumber0(n){return(0,R.g)(0),this}mulBigint0(n){return(0,R.g)(0),this}mulBigIntThis(n){return(0,R.g)(0),this}mulInt320(n){return(0,R.g)(0),this}div0(n){return(0,R.g)(0),this}absThis(){return(0,R.g)(0),this}div(n,r,l){if(this.power()<n.power())return l.assignCopy(this),void r.setZero();l.setZero(),r.setZero();const _=n.getElement(n.power()),x=this.clone();let E=x.power();const v=x.power()-n.power();let I=v;for(r.m_elements=(0,c.m)(r.m_zeroCtor,v+1);;){if(E<n.power()){l.assignMove(x);break}if(E===x.power()){const D=x.getElement(x.power());D.divThis(_),x.subShiftedWithCoef(n,D,x.power()-n.power()),r.m_elements[I]=D.clone()}I--,E--}l.updatePower(),r.updatePower()}divThis(n){return(0,R.g)(0),this}subThis(n){const r=Math.min(this.power(),n.power());for(let _=0;_<=r;++_)this.m_elements[_].subThis(n.m_elements[_]);const l=n.power();this.m_elements.length=Math.max(this.power(),n.power())+1;for(let _=r+1;_<=l;++_)this.m_elements[_]=n.m_elements[_].clone(),this.m_elements[_].negateThis();return this.updatePower(),this}sub0This(n){return this.m_elements[0].subThis(n),this.updatePower(),this}subFrom(n,r){(0,R.g)(0)}isZero(){return 0===this.power()&&this.m_elements[0].isZero()}negateThis(){for(let n=this.m_elements.length-1;n>=0;n--)this.m_elements[n].negateThis();return this}getElement(n){return this.m_elements[n].clone()}setElement(n,r){return this.m_elements[n]=r.clone(),this}evaluate(n){const r=this.power(),l=this.m_elements[r].clone();for(let _=r-1;_>=0;--_)l.mulThis(n),l.addThis(this.m_elements[_]);return l}equals(n){if(this===n)return!0;if(this.power()!==n.power())return!1;for(let r=this.m_elements.length-1;r>=0;r--)if(!this.m_elements[r].equals(n.m_elements[r]))return!1;return!0}updatePower(){for(let n=this.m_elements.length-1;n>0&&this.m_elements[n].isZero();n--)this.m_elements.pop();return this}setZero(){return this.m_elements.length=1,this.m_elements[0]=new this.m_zeroCtor,this.updatePower(),this}derivative(n){if(this.power()<n)return this.clone().setZero();if(0===n)return this.clone();const r=new this.constructor({coefsT:this.m_elements.slice(n),power:this.power()-n});for(let l=n,_=this.power();l<=_;l++){let x=BigInt(l);for(let E=l-1,v=l-n;E>v;--E)x*=BigInt(E);r.m_elements[l-n].mulBigIntThis(x)}return r.updatePower(),r}derivative1This(){if(this.m_elements.length>1){this.m_elements=this.m_elements.slice(1);for(let n=1,r=this.power();n<=r;n++)this.m_elements[n].mulThis(c.M.constructInt32(n+1))}else this.m_elements.length=0,this.m_elements.push(new this.m_zeroCtor);return this}limitPrecisionThis(n){for(let r=this.power();r>=0;--r)this.m_elements[r].limitPrecisionThis(n);return this.updatePower(),this}hiBitIndex(){return this.m_elements.reduce((n,r)=>{const l=r.hiBitIndex();return n<l?l:n},0)}shiftRight(n){return this.m_elements.splice(0,n),this.updatePower(),this}static evaluateCoefs(n,r,l){const _=n.power();l.construct0(n.getElement(0).evaluate(r));for(let x=1;x<=_;++x)l.addElement(n.getElement(x).evaluate(r));l.updatePower()}}class Ae extends ls{constructor(n){super(void 0===n?{zeroCtor:c.M}:{...n,zeroCtor:c.M})}clone(){return new Ae({copy:this})}absEvaluate(n){const r=this.power(),l=this.m_elements[r].clone();l.absThis();const _=n.clone();_.absThis();for(let x=r-1;x>=0;--x)l.mulThis(_),l.addThis(this.m_elements[x].abs());return l}}class Xs extends ls{constructor(n){super(void 0===n?{zeroCtor:Ae}:{...n,zeroCtor:Ae})}clone(){return new Xs({copy:this})}constructFromMPValues(n,r){this.m_elements.length=0;for(let l=0;l<=r;++l)this.m_elements.push(new Ae({coef0:n[l]}));return this.updatePower(),this}}function ui(f,n,r,l,_,x,E,v,I,D,G,q,B,z,L,j,Q,et=!1){const K=function La(){return{polypoly1:new Xs,polypoly2:new Xs,polyX2:new Ae,polyY2:new Ae,polyX2Deriv:new Ae,polyY2Deriv:new Ae,polypolyX1:new Xs,polypolyY1:new Xs,polypolyX1Deriv:new Xs,polypolyY1Deriv:new Xs,lazyPolypolyD1:new Xs,lazyPolypolyD1Deriv:new Xs,lazyPolyD2:new Ae,lazyPolyD2Deriv:null,polypoly11:new Xs,polypoly12:new Xs,tempPp:new Xs,tempPp1:new Xs,tempPp2:new Xs,tempP:new Ae,tempP1:new Ae,tempP2:new Ae}}();K.polyX2.construct(E,v),K.polyY2.construct(I,D),K.polypolyX1.constructFromMPValues(f,n),K.polypolyY1.constructFromMPValues(r,l),K.polypoly11.assignCopy(K.polypolyX1),K.polypoly12.assignCopy(K.polypolyY1),G&&(K.lazyPolyD2.construct(G,q),K.polypoly11.mulElementThis(K.lazyPolyD2),K.polypoly12.mulElementThis(K.lazyPolyD2)),_?(K.lazyPolypolyD1.constructFromMPValues(_,x),K.lazyPolypolyD1Deriv=new Xs({copy:K.lazyPolypolyD1}),K.lazyPolypolyD1Deriv.derivative1This(),K.tempPp.assignCopy(K.lazyPolypolyD1),K.tempPp.mulElementThis(K.polyX2),K.polypoly11.subThis(K.tempPp),K.tempPp.assignCopy(K.lazyPolypolyD1),K.tempPp.mulElementThis(K.polyY2),K.polypoly12.subThis(K.tempPp)):(K.polypoly11.sub0This(K.polyX2),K.polypoly12.sub0This(K.polyY2)),K.polypolyX1Deriv.assignCopy(K.polypolyX1),K.polypolyX1Deriv.derivative1This(),K.polypolyY1Deriv.assignCopy(K.polypolyY1),K.polypolyY1Deriv.derivative1This(),_&&(K.polypolyX1Deriv.mulThis(K.lazyPolypolyD1),K.tempPp2.assignCopy(K.lazyPolypolyD1Deriv),K.tempPp2.mulThis(K.polypolyX1),K.polypolyX1Deriv.subThis(K.tempPp2),K.polypolyY1Deriv.mulThis(K.lazyPolypolyD1),K.tempPp2.assignCopy(K.lazyPolypolyD1Deriv),K.tempPp2.mulThis(K.polypolyY1),K.polypolyY1Deriv.subThis(K.tempPp2)),K.polyX2Deriv.assignCopy(K.polyX2),K.polyX2Deriv.derivative1This(),K.polyY2Deriv.assignCopy(K.polyY2),K.polyY2Deriv.derivative1This(),G&&((0,R.g)(null===K.lazyPolyD2Deriv),K.lazyPolyD2Deriv=new Ae({copy:K.lazyPolyD2}),K.lazyPolyD2Deriv.derivative1This(),K.polyX2Deriv.mulThis(K.lazyPolyD2),K.tempP1.assignCopy(K.lazyPolyD2Deriv),K.tempP1.mulThis(K.polyX2),K.polyX2Deriv.subThis(K.tempP1),K.polyY2Deriv.mulThis(K.lazyPolyD2),K.tempP1.assignCopy(K.lazyPolyD2Deriv),K.tempP1.mulThis(K.polyY2),K.polyY2Deriv.subThis(K.tempP1)),K.polypoly1.assignCopy(K.polypoly11),K.polypoly1.mulElementThis(K.polyX2Deriv),K.tempPp.assignCopy(K.polypoly12),K.tempPp.mulElementThis(K.polyY2Deriv),K.polypoly1.addThis(K.tempPp),K.polypoly2.assignCopy(K.polypolyX1Deriv),K.polypoly2.mulElementThis(K.polyY2Deriv),K.tempPp.assignCopy(K.polypolyY1Deriv),K.tempPp.mulElementThis(K.polyX2Deriv),K.polypoly2.subThis(K.tempPp);let rt=[];const ot=[];Q||(Q=[]),j||(j=[]),Wr(K.polypoly11,K.polypoly12,K.tempP);let nt=57,at=.25*Number.EPSILON;const pt=[];let gt=on(K.tempP,0,L,at,nt,pt);if(gt<0)return-1;for(let Dt=0;Dt<gt;Dt++){Ae.evaluateCoefs(K.polypoly11,c.M.constructDouble(pt[Dt]),K.tempP1);const Nt=[];let Ft=on(K.tempP1,0,z,at,nt,Nt);if(0!==Ft)if(Ae.evaluateCoefs(K.polypoly12,c.M.constructDouble(pt[Dt]),K.tempP2),Ft<0){Ft=on(K.tempP2,0,z,at,nt,Nt),Ft<0&&(0,R.c)("mp_curve_proximity");for(let Ot=0;Ot<Ft;Ot++)ot.push((0,c.n)(Nt[Ot],pt[Dt]))}else{const Ot=K.tempP2.absEvaluate(c.ae);Ot.mulThis(c.M.constructDouble(1e-12));for(let Qt=0;Qt<Ft;Qt++){const Kt=K.tempP2.evaluate(c.M.constructDouble(Nt[Qt]));Kt.absThis(),Kt.lt(Ot)&&ot.push((0,c.n)(Nt[Qt],pt[Dt]))}}}gt=ot.length,Wr(K.polypoly1,K.polypoly2,K.tempP),nt=57,at=.25*Number.EPSILON;const yt=[];let ft=on(K.tempP,0,L,at,nt,yt);ft<0&&(ft=0);for(let Dt=0;Dt<ft;Dt++){Ae.evaluateCoefs(K.polypoly1,c.M.constructDouble(yt[Dt]),K.tempP1);const Nt=[];let Ft=on(K.tempP1,0,z,at,nt,Nt);if(0!==Ft)if(Ae.evaluateCoefs(K.polypoly2,c.M.constructDouble(yt[Dt]),K.tempP2),Ft<0){if(Ft=on(K.tempP2,0,z,at,nt,Nt),Ft<0)continue;for(let Ot=0;Ot<Ft;Ot++)rt.push((0,c.n)(Nt[Ot],yt[Dt]))}else{const Ot=K.tempP2.absEvaluate(c.ae);Ot.mulThis(c.M.constructDouble(1e-12));for(let Qt=0;Qt<Ft;Qt++){const Kt=K.tempP2.evaluate(c.M.constructDouble(Nt[Qt]));Kt.absThis(),Kt.lt(Ot)&&rt.push((0,c.n)(Nt[Qt],yt[Dt]))}}}if(ft=rt.length,0===gt&&0===ft)return 0;rt=rt.concat(ot),rt.sort((Dt,Nt)=>et?(0,c.X)(Dt.second,Nt.second):(0,c.X)(Dt.first,Nt.first));const bt=(0,c.u)(rt,(Dt,Nt)=>Dt.first===Nt.first&&Dt.second===Nt.second);rt=rt.slice(0,bt),j.length=0,Q.length=0;for(const Dt of rt)j.push(Dt.first),Q.push(Dt.second);return(0,R.g)(j.length===Q.length),Q.length}function Fo(f,n,r,l,_,x,E,v,I,D,G){const q=function pi(){return{polyIntersect:new Ae,polyX1:new Ae,polyY1:new Ae,polyX1Deriv:new Ae,polyY1Deriv:new Ae,lazyPolyD1:new Ae,lazyPolyD1Deriv:new Ae,tempP:new Ae,tempP1:new Ae,tempP2:new Ae,polypoly1Proximity:new Xs,polypoly2Proximity:new Xs}}();q.polyX1.construct(f,n),q.polyY1.construct(r,l),q.polyX1Deriv.assignCopy(q.polyX1),q.polyX1Deriv.derivative1This(),q.polyY1Deriv.assignCopy(q.polyY1),q.polyY1Deriv.derivative1This(),q.polyIntersect.assignCopy(q.polyX1),q.polyIntersect.mulThis(q.polyX1),q.polyIntersect.mulElementThis(E[0]),q.tempP.assignCopy(q.polyY1),q.tempP.mulThis(q.polyY1),q.tempP.mulElementThis(E[1]),q.polyIntersect.addThis(q.tempP),_?(q.lazyPolyD1.construct(_,x),q.tempP.assignCopy(q.lazyPolyD1),q.tempP.mulThis(q.lazyPolyD1),q.tempP.mulElementThis(E[2]),q.polyIntersect.addThis(q.tempP)):q.polyIntersect.add0(E[2]);{const ot=E[0].clone(),nt=ot.clone();nt.sqrThis();const at=E[1].clone(),pt=at.clone();pt.sqrThis();const gt=E[2].clone(),yt=ot.clone();yt.subThis(at),q.polyX1.construct(f,n),q.polyX1Deriv.assignCopy(q.polyX1),q.polyX1Deriv.derivative1This(),q.polyY1.construct(r,l),q.polyY1Deriv.assignCopy(q.polyY1),q.polyY1Deriv.derivative1This(),q.tempP.assignCopy(q.polyX1),q.tempP.mulThis(q.polyX1),q.tempP.mulElementThis(pt),q.tempP.mulElementThis(gt),q.polypoly1Proximity.construct0(q.tempP),q.tempP.assignCopy(q.polyX1),q.tempP.mulThis(at.mul(yt).mul(gt).ldexpThis(1)),q.polypoly1Proximity.addElement(q.tempP),q.tempP.assignCopy(q.polyX1),q.tempP.mulThis(q.polyX1),q.tempP.mulElementThis(ot.mul(pt)),q.tempP1.assignCopy(q.polyY1),q.tempP1.mulThis(q.polyY1),q.tempP1.mulElementThis(nt.mul(at)),q.tempP.addThis(q.tempP1),q.tempP.add0(yt.mul(yt).mul(gt)),q.polypoly1Proximity.addElement(q.tempP),q.tempP.assignCopy(q.polyX1),q.tempP.mulElementThis(yt.mul(ot).mul(at).ldexpThis(1)),q.polypoly1Proximity.addElement(q.tempP),q.tempP.construct0(ot.mul(yt).mul(yt)),q.polypoly1Proximity.addElement(q.tempP),q.polypoly1Proximity.updatePower(),q.tempP.construct0(c.ad),q.polypoly2Proximity.construct0(q.tempP),q.tempP.assignCopy(q.polyX1),q.tempP.mulThis(q.polyX1Deriv),q.tempP1.assignCopy(q.polyY1),q.tempP1.mulThis(q.polyY1Deriv),q.tempP.addThis(q.tempP1),q.tempP.mulElementThis(ot.mul(at)),q.polypoly2Proximity.addElement(q.tempP),q.tempP.assignCopy(q.polyX1Deriv),q.tempP.mulElementThis(yt.mul(ot)),q.polypoly2Proximity.addElement(q.tempP),q.polypoly2Proximity.updatePower()}const B=[],z=[];G||(G=[]);let L=2*q.polyIntersect.power()+58;const j=.5*Number.EPSILON,Q=on(q.polyIntersect,0,I,j,L,z);if(Q<0)return-1;Wr(q.polypoly1Proximity,q.polypoly2Proximity,q.tempP),L=2*q.tempP.power()+58;let et=on(q.tempP,0,I,j,L,B);if(et<0&&(et=0),0===Q&&0===et)return 0;const K=B.concat(z);G.length=K.length,(0,c.a)(G,K,0,0,K.length),(0,c.v)(G);const rt=(0,c.u)(G,(ot,nt)=>0===(0,c.X)(ot,nt));return G.length=rt,G.length}function Ba(f,n,r,l){return f.isZero()?n.isZero()?-1:0:(l.setThis(n),l.negateThis(),l.divThis(f),r.isEmpty()||r.containsCoordinate(l.value())?1:0)}function qn(f,n,r,l,_,x,E){if(f.isZero())return x?(E[0].setInt32(1),_.containsCoordinate(1)?1:0):Ba(n,r,_,E[0]);if(x){let z=2;return E[0].setInt32(1),r.equals(f)?(E[1].setInt32(1),z=1):E[1].setThis(r.div(f)),_.containsCoordinate(E[1].value())||(z=1),_.containsCoordinate(E[0].value())||(z--,E[0].setThis(E[1])),2===z&&E[0].value()>E[1].value()&&(E[1]=(0,c.b)(E[0],E[0]=E[1])),z}const v=n.clone();v.sqrThis();const I=f.clone();if(I.mulThis(r).ldexpThis(2).negateThis().addThis(v),I.LZ())return 0;const D=l+2,G=c.M.sqrt(I,D),q=G.clone();n.LZ()&&q.negateThis(),q.addThis(n).limitPrecisionThis(D).ldexpThis(-1).negateThis();let B=0;return E[0].setThis(q).divThis(c.M.constructAssign(f,D)).limitPrecisionThis(l),(_.isEmpty()||_.containsCoordinate(E[0].value()))&&B++,G.isZero()||q.isZero()||(E[B].setThis(r).divThis(q).limitPrecisionThis(l),(_.isEmpty()||_.containsCoordinate(E[B].value()))&&B++,2===B&&E[0].gt(E[1])&&(E[1]=(0,c.b)(E[0],E[0]=E[1]))),B}function ur(f,n,r,l,_,x,E,v){if(f.isZero())return qn(n,r,l,_,x,E,v);const I=(bt,Dt)=>{if(bt>0){let Nt=Dt+bt;for(let Ft=1;Ft<Nt;Ft++)v[Ft].equals(v[0])&&(v[Nt-1]=(0,c.b)(v[Ft],v[Ft]=v[Nt-1]),Nt--);Dt=Nt}return(0,c.C)(v,0,Dt,(Nt,Ft)=>Nt.compare(Ft)),Dt};if(l.isZero()){let bt=0;return x.containsCoordinate(0)&&(v[0].setInt32(0),bt=1),I(qn(f,n,r,_,x,E,v.slice(1)),bt)}if(E){let bt=0;x.containsCoordinate(1)&&(v[0].setInt32(1),bt=1);const Dt=n.add(f),Nt=l.negate(),Ft=f.add(Dt).add(Nt).isZero();return I(qn(f,Dt,Nt,_,x,Ft,v.slice(bt)),bt)}const D=new c.M,G=new c.M,q=new c.M,B=n.clone();if(B.isZero())G.setThis(r),G.divThis(f),q.setThis(l),G.divThis(f);else{B.divThis(f).divDoubleThis(3).negateThis();const bt=n.clone();bt.sqrThis();const Dt=f.clone();Dt.sqrThis(),G.setThis(f),G.mulThis(r).mulDoubleThis(3).subThis(bt).divThis(Dt).divDoubleThis(3),q.setThis(bt),q.mulThis(n),q.ldexpThis(1),D.setThis(f),D.mulThis(n).mulThis(r).mulDoubleThis(9),q.subThis(D),D.setThis(Dt),D.mulThis(l).mulDoubleThis(27),q.addThis(D),q.divThis(Dt).divThis(f).divDoubleThis(27)}if(G.isZero()){const bt=q.clone();return bt.negateThis(),bt.isZero()?(v[0].setThis(B),cr(x,_,v,1)):(v[0].setThis(c.M.cubicRoot(q,_).add(B)),cr(x,_,v,1))}const z=q.clone();if(z.sqrThis().ldexpThis(-2),D.setThis(G.clone()),D.sqrThis().mulThis(G).divDoubleThis(27),z.addThis(D),z.isZero())return v[0].setThis(q),v[0].mulDoubleThis(3).divThis(G),v[1].setThis(v[0]),v[1].negateThis(),v[1].ldexpThis(-1),v[0].addThis(B),v[1].addThis(B),cr(x,_,v,2);if(z.GZ())return z.setThis(c.M.sqrt(z,_+8)),D.setThis(q),D.ldexpThis(-1).negateThis(),D.addThis(z),v[0].setThis(c.M.cubicRoot(D,_+8)),D.setThis(q),D.ldexpThis(-1).negateThis(),D.subThis(z),v[0].addThis(c.M.cubicRoot(D,_+8)),v[0].addThis(B),cr(x,_,v,1);D.setThis(G),D.divDoubleThis(3).negateThis(),(0,R.g)(D.GEZ());const L=c.M.sqrt(D,_+8),j=L.clone();j.negateThis(),j.addThis(B),L.addThis(B);const Q=c.M.constructDouble(x.isEmpty()?-Number.MAX_VALUE:x.vmin),et=c.M.constructDouble(x.isEmpty()?Number.MAX_VALUE:x.vmax),K=new Ae({zeroCtor:c.M});K.construct0(l),K.addElement(r),K.addElement(n),K.addElement(f);const rt=new Ae({copy:K});rt.derivative1This();let ot=0;const nt=(0,c.m)(c.M,4);nt[ot++].setThis(Q),j.gt(Q)&&j.lt(et)&&nt[ot++].setThis(j),L.gt(Q)&&L.lt(et)&&nt[ot++].setThis(L),nt[ot++].setThis(et);const at=3*_;let pt=52,gt=Number.EPSILON;for(;pt<at;)2*pt<=at?(gt*=gt,pt*=2):(gt*=Number.EPSILON,pt+=52);pt+=2;let yt=0,ft=!1;for(let bt=1;bt<ot;bt++)if(jr(K,rt,nt[bt-1],nt[bt],gt,pt,v[0])){yt=1,ft=bt+1<ot;break}if(!yt)return 0;if(ft){const bt=new Ae({zeroCtor:c.M,coef0:v[0]});bt.negateThis(),bt.addElement(c.ae);const Dt=new Ae({zeroCtor:c.M}),Nt=new Ae({zeroCtor:c.M});K.div(bt,Dt,Nt),(0,R.g)(2===Dt.power()),(0,R.g)(0===Nt.power());const Ft=qn(Dt.getElement(2),Dt.getElement(1),Dt.getElement(0),_,x,!1,v.slice(1));(0,R.g)(Ft>=0&&Ft<=2),yt+=Ft}return cr(x,_,v,yt)}function Mo(f,n,r,l,_,x,E,v,I){if(f.isZero())return ur(n,r,l,_,x,E,v,I);const D=(j,Q)=>{if(j>0){let et=Q+j;for(let K=1;K<et;K++)I[K].equals(I[0])&&(I[et-1]=(0,c.b)(I[K],I[K]=I[et-1]),et--);Q=et}return(0,c.C)(I,0,Q,(et,K)=>et.compare(K)),Q};if(_.isZero()){let j=0;return E.containsCoordinate(0)&&(I[0].setInt32(0),j=1),D(ur(f,n,r,l,x,E,v,I.slice(j)),j)}const G=new Ae({zeroCtor:c.M,coef0:_});if(G.addElement(l),G.addElement(r),G.addElement(n),G.addElement(f),v){let j=0;E.containsCoordinate(1)&&(I[0].setInt32(1),j=1);const Q=new Ae({zeroCtor:c.M,coef0:c.M.constructInt32(-1)});Q.addElement(c.M.constructInt32(1));const et=new Ae({zeroCtor:c.M}),K=new Ae({zeroCtor:c.M});return G.div(Q,et,K),D(ur(3===et.power()?et.getElement(3):c.ad.clone(),et.power()>=2?et.getElement(2):c.ad.clone(),et.power()>=1?et.getElement(1):c.ad.clone(),et.getElement(0),x,E,et.evaluate(c.ae).isZero(),I.slice(j)),j)}if(G.getElement(0).isZero()){let j=0;for(E.containsCoordinate(0)&&(j=1,I[0].setDouble(0));G.getElement(0).isZero()&&G.power()>0;)G.shiftRight(1);const Q=ur(3===G.power()?G.getElement(3):c.ad.clone(),G.power()>=2?G.getElement(2):c.ad.clone(),G.power()>=1?G.getElement(1):c.ad.clone(),G.getElement(0),x,E,!1,I.slice(j));return Q>0&&(j+=Q),(0,c.C)(I,0,j,(et,K)=>et.compare(K)),j}let q=52,B=Number.EPSILON;for(;q<x;)2*q<=x?(B*=B,q*=2):(B*=Number.EPSILON,q+=52);q+=2;const z=Ua(G),L=c.M.constructDouble(Math.max(Math.abs(E.vmax),Math.abs(E.vmin)));return B=(z.lt(L)?z:L).mul(c.M.constructDouble(B)).toDouble(),Bs(G,E,B,q,v,0,I,4)}function Ha(f,n){let r=f,l=n;l.power()>r.power()&&(l=(0,c.b)(r,r=l));const _=r.power()-l.power(),x=new Ae({copy:r.getElement(r.power())});r.mulThis(l.getElement(l.power()));for(let E=0,v=r.power();E<v;E++)if(E>=_){const I=new Ae({copy:l.getElement(E-_)});I.mulThis(x);const D=r.getElement(E).sub(I);r.setElement(E,D)}r.setElement(r.power(),r.getElement(r.power()).setZero()),r.updatePower(),qo(r)}function qo(f){let n=0;for(;n<f.power()&&f.getElement(n).isZero();)n++;return n>0&&(f.shiftRight(n),!0)}function Wr(f,n,r){const l=f.clone(),_=n.clone();for(qo(l),qo(_);0!==l.power()||0!==_.power();)Ha(l,_);r.assignMove(l.getElement(0))}function on(f,n,r,l,_,x){x.length=0;const E=f.power(),v=(0,c.m)(c.M,2*E+4),I=function km(f,n,r,l,_,x,E){if(0===f.power())return f.isZero()?-1:0;const v=f.evaluate(c.M.constructInt32(1)).isZero();if(1===f.power()){const I=Ba(f.getElement(1),f.getElement(0),n,x.at(0));return x[0].limitPrecisionThis(l),1!==I?0:(x[0].limitPrecisionThis(l),1)}return 2===f.power()?qn(f.getElement(2),f.getElement(1),f.getElement(0),l,n,v,x):3===f.power()?ur(f.getElement(3),f.getElement(2),f.getElement(1),f.getElement(0),l,n,v,x):4===f.power()?Mo(f.getElement(4),f.getElement(3),f.getElement(2),f.getElement(1),f.getElement(0),l,n,v,x):Bs(f,n,r,l,v,0,x,E)}(f,r||c.E.unit(),l,_,0,v,v.length);if(I>0){x.length=0;for(let D=0;D<I;D++){const G=v[D].value();D>0&&G<=x.at(-1)||x.push(G)}return x.length}return I}function Vo(f,n,r){if((0,R.g)(r>=1),0===f.power())return f.isZero()?-1:0;const l=f.getElement(0);return l.negateThis(),l.divThis(f.getElement(1)),n[0].setThis(l),1}function za(f,n,r,l){if(f.power()<2)return Vo(f,r,l);(0,R.g)(l>=1);let _=f.getElement(1);_.mulThis(f.getElement(1));const x=f.getElement(0);if(x.mulThis(f.getElement(2)),x.ldexpThis(2),_.subThis(x),_.LZ())return 0;if(_.isZero()){const D=f.getElement(1);return D.negateThis(),D.divThis(f.getElement(2)),D.ldexpThis(-1),D.limitPrecisionThis(n),r[0].setThis(D),1}(0,R.g)(l>=2),_=c.M.sqrt(_,n+8);const E=f.getElement(1);E.negateThis();const v=E.clone();v.subThis(_),v.divThis(f.getElement(2)),v.ldexpThis(-1),v.limitPrecisionThis(n);const I=E.clone();return I.addThis(_),I.divThis(f.getElement(2)),I.ldexpThis(-1),I.limitPrecisionThis(n),v.lt(I)?(r[0].setThis(v),r[1].setThis(I)):(r[1].setThis(v),r[0].setThis(I)),2}function jr(f,n,r,l,_,x,E){let v=r.clone(),I=l.clone();v.limitPrecisionThis(x),I.limitPrecisionThis(x);let D=f.evaluate(v);D.limitPrecisionThis(x+2);let G=f.evaluate(I);if(G.limitPrecisionThis(x+2),D.GEZ()&&G.GEZ()||D.LEZ()&&G.LEZ())return D.absLessAbs(G)?(E=v,D.isZero()):(E=I,G.isZero());const q=G.LZ();q&&(G=(0,c.b)(D,D=G),I=(0,c.b)(v,v=I));const B=q?I:v,z=q?v:I,L=v.add(I).ldexpThis(-1);L.limitPrecisionThis(x);const j=I.sub(v);j.limitPrecisionThis(x),j.absThis();const Q=j.clone();let et=f.evaluate(L),K=n.evaluate(L);const rt=new Ae({copy:f}),ot=new Ae({copy:n});{const Ce=Math.max(f.hiBitIndex(),n.hiBitIndex()),ie=c.ae.clone();ie.ldexpThis(-(x+2));for(let ne=64;ne<Ce;){rt.limitPrecisionThis(ne),ot.limitPrecisionThis(ne);const De=rt.evaluate(L),We=ot.evaluate(L),Li=De.sub(et),Ms=We.sub(K);if(Li.divThis(et).absThis().lt(ie)&&(K.isZero()||Ms.divThis(K).absThis().lt(ie)))break;rt.assignCopy(f),ot.assignCopy(n),ne=Math.min(ne+64,Ce)}et.limitPrecisionThis(x+2),K.limitPrecisionThis(x+2)}let pt=4,yt=1,ft=0,bt=0,Dt=1;const Ft=c.M.constructDouble(.25*_),Ot=c.M.constructDouble(.5001);let Qt=0;for(;++Qt<300;){if(Qt>32&&ft>0||K.isZero()||2===Dt&&ft>1||1===Dt&&pt<4)Dt=1,yt>1&&yt--;else if(Dt=2,bt>1){const We=j.mul(K);We.absThis(),We.ldexpThis(-3),We.absLessAbs(et)&&yt++}j.setThis(Q);const Ce=new c.M;let ie=!1;if(1===Dt)do{if(bt>2){const We=j.clone();if(We.absThis(),We.ldexpThis(4),z.sub(B).ldexpThis(-1).gt(We)){if(L.equals(B)){Ce.setThis(L),L.setThis(B.add(We)),L.limitPrecisionThis(x),Q.setThis(L.sub(Ce));break}if(L.equals(z)){Ce.setThis(L),L.setThis(z.sub(We)),L.limitPrecisionThis(x),Q.setThis(L.sub(Ce));break}}}Q.setThis(I.sub(v)),Q.ldexpThis(-1),Q.limitPrecisionThis(x),Ce.setThis(L),L.setThis(v.add(Q)),L.limitPrecisionThis(x),L.lt(B)?L.setThis(B):L.gt(z)&&L.setThis(z),ie=v.equals(L)||I.equals(L)}while(0);else for(;;){if(Q.setThis(et.div(K)),Q.limitPrecisionThis(x),1!==yt&&Q.mulDoubleThis(yt),Ce.setThis(L),L.subThis(Q),L.limitPrecisionThis(x),ie=L.equals(Ce),L.lt(B)){if(yt>1){L.setThis(Ce),yt--;continue}Q.setThis(Ce.sub(B)),L.setThis(B)}else if(L.gt(z)){if(yt>1){L.setThis(Ce),yt--;continue}Q.setThis(Ce.sub(z)),L.setThis(z)}break}if(ie||Q.absLessAbs(Ft)){Ce.equals(L)||(et=rt.evaluate(L),et.limitPrecisionThis(x+2));break}et=rt.evaluate(L),et.limitPrecisionThis(x+2),K=ot.evaluate(L),K.limitPrecisionThis(x+2);const ne=v.clone(),De=I.clone();et.LZ()?(D.setThis(et),v.setThis(L)):(G.setThis(et),I.setThis(L)),2===Dt&&(v.equals(ne)&&I.equals(De)||bt>1&&!Q.absLessAbs(Ot.mul(j)))?ft++:ft=0,1===Dt?(pt++,bt=0):(pt=0,bt++)}return Qt>=300&&(0,R.c)("Root_finder iterations exceeded"),E.setThis(L),!0}function Lm(f,n,r,l,_){const x=f.evaluate(r);if(x.isZero())return!0;const E=c.M.constructDouble(.5*l),v=r.clone();v.subThis(E);const I=f.evaluate(v),D=r.clone();D.addThis(E);const G=f.evaluate(D);if(I.LZ()&&G.GZ()||I.GZ()&&G.LZ()||(x.GZ()?I.LEZ()||G.LEZ():I.GEZ()||G.GEZ()))return!0;const q=I.LEZ()&&G.LEZ(),B=I.GEZ()&&G.GEZ();let z=!1;return q?x.gt(I)&&x.gt(G)&&(z=!0):B&&x.lt(I)&&x.lt(G)&&(z=!0),!!z&&x.absThis().lt(c.M.constructDouble(1e-17))}function Bs(f,n,r,l,_,x,E,v){(0,R.g)(r>0),(0,R.g)(v>=f.power());const I=E,D=[];let G=[];const q=new Ae({zeroCtor:f.m_zeroCtor}),B=new Ae({zeroCtor:f.m_zeroCtor}),z=new Ae({zeroCtor:f.m_zeroCtor}),L=c.M.constructDouble(r),j=c.M.constructDouble(n.vmin),Q=c.M.constructDouble(n.vmax),et=j.sub(L),K=Q.add(L),rt=Ua(f),ot=rt.clone();if(ot.negateThis(),et.lt(ot))et.setThis(ot.sub(L));else if(et.gt(rt))return 0;if(K.gt(rt))K.setThis(rt.add(L));else if(K.lt(ot))return 0;let nt=f,at=null;if(_){const Ot=new Ae({coef0:c.M.constructInt32(-1)});Ot.addElement(c.ae),at=new Ae,nt=at;const Qt=new Ae,Kt=new Ae;for(f.div(Ot,Qt,Kt),at.assignCopy(Qt);nt.evaluate(c.ae).isZero();)nt.div(Ot,Qt,Kt),at.assignCopy(Qt)}let pt=!1;if(nt.power()>0&&nt.getElement(0).isZero())for(pt=!0,at||(at=new Ae({copy:nt}),nt=at);nt.getElement(0).isZero();)at.shiftRight(1);let gt=l+2*nt.power()+2,yt=r/Math.pow(2,nt.power()+2),ft=gt;if(c.ad.gt(et)&&c.ad.lt(K))for(let Ot=0,Qt=nt.power();Ot<Qt;Ot++)if(nt.getElement(Ot).isZero()){D.push(c.ad.clone());break}for(let Ot=nt.power()-1;Ot>0;Ot--)if(yt*=2,gt-=2,ft-=2,nt.power()-Ot!=1)if(nt.power()-Ot!=2){B.assignMove(z),z.assignMove(nt.derivative(Ot-1));let Qt=[];for(let Kt=0,Ce=G.length;Kt<Ce;++Kt)if(G[Kt].first.lte(G[Kt].second)){const ie=new c.M;if(jr(B,q,G[Kt].first,G[Kt].second,yt,gt,ie)){D.push(ie);let ne=ie.sub(L);ne.limitPrecisionThis(ft),Qt.push((0,c.n)(G[Kt].first,ne)),ne=ie.add(L),ne.limitPrecisionThis(ft),Qt.push((0,c.n)(ne,G[Kt].second))}else Qt.push(G[Kt])}G=Qt,Qt=[],q.assignMove(B)}else{B.assignMove(nt.derivative(Ot));const Qt=za(B,gt,I,v);(0,R.g)(Qt>=0&&Qt<=2);for(let Kt=0;Kt<Qt;Kt++)I[Kt].gt(et)&&I[Kt].lt(K)&&!I[Kt].isZero()&&D.push(I[Kt].clone());if(D.length>1&&D.sort((Kt,Ce)=>Kt.compare(Ce)),D.length>0){let Kt=D[0].sub(L);Kt.limitPrecisionThis(ft),G.push((0,c.n)(et.clone(),Kt));let Ce=1===D.length?K.clone():D[1].sub(L);Kt=D[0].add(L),Kt.limitPrecisionThis(ft),Ce.limitPrecisionThis(ft),G.push((0,c.n)(Kt,Ce)),D.length>1&&(Ce=2===D.length?K.clone():D[2].sub(L),Ce.limitPrecisionThis(ft),Kt=D[1].add(L),Kt.limitPrecisionThis(ft),G.push((0,c.n)(Kt,Ce)),D.length>2&&(Kt=D[2].add(L),Kt.limitPrecisionThis(ft),G.push((0,c.n)(Kt,K.clone()))))}else G.push((0,c.n)(et.clone(),K.clone()));q.assignCopy(B),z.assignMove(nt.derivative(Ot-1))}else B.assignMove(nt.derivative(Ot)),1===Vo(B,I,v)&&(I[0].gt(et)&&I[0].lt(K)&&!I[0].isZero()&&D.push(I[0].clone()),q.assignMove(B),z.assignMove(nt.derivative(Ot-1)));D.sort((Ot,Qt)=>Ot.compare(Qt)),0===G.length&&(q.assignMove(nt.derivative(nt.power())),q.isZero()||G.push((0,c.n)(et.clone(),K.clone())));let bt=0,Dt=0,Nt=0;const Ft=new c.M;for(;;){if(Dt<G.length){if(G[Dt].first.gt(G[Dt].second)){Dt++;continue}let Ot=!1;if(Nt<D.length&&D[Nt].lt(G[Dt].first)&&(Ot=!0),!Ot){jr(nt,q,G[Dt].first,G[Dt].second,r,l,Ft)&&(Ft.lt(j)?I[bt++].setThis(j):Ft.gt(Q)?I[bt++].setThis(Q):I[bt++].setThis(Ft)),Dt++;continue}}if(!(Nt<D.length))break;0!==Nt&&D[Nt-1].equals(D[Nt])||Lm(nt,0,D[Nt],r)&&(Ft.setThis(D[Nt]),Ft.lt(j)?Ft.setThis(j):Ft.gt(Q)&&Ft.setThis(Q),0!==bt&&I[bt].equals(Ft)||I[bt++].setThis(Ft)),Nt++}return pt&&c.ad.gt(et)&&c.ad.lt(K)&&(I[bt++].setThis(c.ad),(0,c.C)(I,0,bt,(Ot,Qt)=>Ot.compare(Qt))),_&&c.ae.gt(et)&&c.ae.lt(K)&&(I[bt++].setThis(c.ae),(0,c.C)(I,0,bt,(Ot,Qt)=>Ot.compare(Qt))),bt}function Ua(f){const n=f.getElement(f.power());n.limitPrecisionThis(53);const r=c.ad.clone();for(let l=0,_=f.power();l<_;l++){const x=f.getElement(l);x.limitPrecisionThis(53),x.divThis(n).absThis(),x.gt(r)&&r.setThis(x)}return r.addThis(c.ae),r.mulThis(c.M.constructDouble(1+100*Number.EPSILON)),r}function cr(f,n,r,l){let _=l;if(!f.isEmpty()){_=0;for(let x=0;x<l;++x)f.containsCoordinate(r[x].value())&&(_!==x&&r[_].setThis(r[x]),_++)}_>1&&(r[0].gt(r[1])&&(r[1]=(0,c.b)(r[0],r[0]=r[1])),_>2&&(r[0].gt(r[2])&&(r[2]=(0,c.b)(r[0],r[0]=r[2])),r[1].gt(r[2])&&(r[2]=(0,c.b)(r[1],r[1]=r[2]))));for(let x=0;x<_;++x)r[x].limitPrecisionThis(n);return _}const Oa=[[.33998104358485626,.6521451548625461],[.8611363115940526,.34785484513745385]],Wa=[[.1834346424956498,.362683783378362],[.525532409916329,.31370664587788727],[.7966664774136267,.22238103445337448],[.9602898564975363,.10122853629037626]],ja=[[.09501250983763744,.1894506104550685],[.2816035507792589,.18260341504492358],[.45801677765722737,.16915651939500254],[.6178762444026438,.14959598881657674],[.755404408355003,.12462897125553388],[.8656312023878318,.09515851168249279],[.9445750230732326,.062253523938647894],[.9894009349916499,.027152459411754096]],Ja=[[.04830766568773832,.0965400885147278],[.1444719615827965,.09563872007927486],[.23928736225213706,.09384439908080457],[.33186860228212767,.09117387869576389],[.42135127613063533,.08765209300440381],[.5068999089322294,.08331192422694675],[.5877157572407623,.07819389578707031],[.6630442669302152,.0723457941088485],[.7321821187402897,.06582222277636185],[.7944837959679424,.058684093478535544],[.84936761373257,.050998059262376175],[.8963211557660521,.04283589802222668],[.9349060759377397,.03427386291302143],[.9647622555875064,.02539206530926206],[.9856115115452684,.01627439473090567],[.9972638618494816,.007018610009470096]],Za=[[.024350292663424433,.048690957009139724],[.07299312178779904,.04857546744150343],[.12146281929612056,.048344762234802954],[.16964442042399283,.04799938859645831],[.21742364374000708,.04754016571483031],[.2646871622087674,.04696818281621002],[.31132287199021097,.046284796581314416],[.3572201583376681,.04549162792741814],[.4022701579639916,.044590558163756566],[.4463660172534641,.04358372452932345],[.48940314570705296,.04247351512365359],[.5312794640198946,.04126256324262353],[.571895646202634,.03995374113272034],[.6111553551723933,.038550153178615626],[.6489654712546573,.03705512854024005],[.6852363130542333,.035472213256882386],[.7198818501716109,.033805161837141606],[.7528199072605319,.03205792835485155],[.7839723589433414,.030234657072402478],[.8132653151227975,.028339672614259483],[.8406292962525803,.02637746971505466],[.8659993981540928,.024352702568710874],[.8893154459951141,.022270173808383253],[.9105221370785028,.02013482315353021],[.9295691721319396,.017951715775697343],[.9464113748584028,.015726030476024718],[.9610087996520538,.013463047896718643],[.973326827789911,.011168139460131128],[.983336253884626,.008846759826363947],[.9910133714767443,.006504457968978363],[.9963401167719553,.004147033260562468],[.9993050417357722,.001783280721696433]],Qa=[[.012223698960615764,.024446180196262518],[.03666379096873349,.024431569097850044],[.06108196960413957,.02440235563384958],[.08546364050451549,.024358557264690626],[.10979423112764375,.024300200167971867],[.13405919946118777,.02422731922281525],[.15824404271422493,.024139957989019287],[.18233430598533718,.024038168681024052],[.2063155909020792,.023922012136703457],[.23017356422666,.023791557781003402],[.2538939664226943,.023646883584447616],[.2774626201779044,.02348807601653591],[.3008654388776772,.02331522999406276],[.32408843502441337,.023128448824387027],[.3471177285976355,.022927844143686846],[.369939555349859,.02271353585023646],[.39254027503326744,.022485652032744968],[.414906379552275,.022244328893799764],[.43702450103710416,.02198971066846049],[.4588814198335522,.021721949538052076],[.48046407240417205,.02144120553920846],[.5017595591361445,.02114764646822135],[.5227551520511755,.02084144778075115],[.5434383024128103,.02052279248696007],[.5637966482266181,.020191871042130043],[.5838180216287631,.01984888123283086],[.6034904561585486,.019494028058706602],[.6228021939105849,.019127523609950944],[.6417416925623075,.01874958694054471],[.660297632272646,.01836044393733134],[.6784589224477192,.017960327185008687],[.6962147083695144,.017549475827117706],[.7135543776835874,.01712813542311138],[.7304675667419088,.016696557801589205],[.746944166797062,.016255000909785187],[.7629743300440948,.015803728659399347],[.7785484755064119,.015343010768865144],[.7936572947621933,.014873122602147314],[.8082917575079137,.014394345004166847],[.8224431169556439,.013906964132951985],[.8361029150609068,.013411271288616333],[.8492629875779689,.012907562739267348],[.8619154689395485,.012396139543950923],[.8740527969580318,.01187730737274028],[.8856677173453972,.011351376324080417],[.8967532880491582,.010818660739503076],[.9073028834017568,.010279479015832158],[.9173101980809605,.009734153415006806],[.9267692508789478,.009183009871660874],[.9356743882779164,.00862637779861675],[.9440202878302202,.008064589890486059],[.9518019613412644,.0074979819256347285],[.9590147578536999,.006926892566898814],[.9656543664319652,.006351663161707189],[.9717168187471366,.005772637542865698],[.9771984914639074,.00519016183267633],[.9820961084357185,.004604584256702955],[.9864067427245862,.004016254983738642],[.9901278184917344,.0034255260409102157],[.9932571129002129,.0028327514714579912],[.9957927585349812,.0022382884309626186],[.997733248625514,.0016425030186690294],[.9990774599773758,.0010458126793403489],[.9998248879471319,.00044938096029209035]];function Wi(f,n,r,l){const _=.5*(l-r),x=r+_,E=new c.K(0);for(let v=0,I=Math.trunc(f/2);v<I;++v){let D,G;switch(f){case 4:D=Oa[v][0],G=Oa[v][1];break;case 8:D=Wa[v][0],G=Wa[v][1];break;case 16:D=ja[v][0],G=ja[v][1];break;case 32:D=Ja[v][0],G=Ja[v][1];break;case 64:D=Za[v][0],G=Za[v][1];break;case 128:D=Qa[v][0],G=Qa[v][1];break;default:throw new Error("Quadrature_integral: invalid n")}const q=(0,c.aj)(-.5,D,x),B=(0,c.aj)(_,D,x);E.pe(n(q)*G),E.pe(n(B)*G)}return E.getResult()*_}function ji(f,n,r,l,_,x){return function $a(f,n,r,l,_,x){if(r<n&&(0,R.t)("xTo < xFrom"),r===n)return 0;const E=[0];let v=Number.MAX_VALUE;const I=[Number.MAX_VALUE];let D=0;const q=(0,c.d)(33,Number.NaN),B=(0,c.d)(33,Number.NaN),z=[0];q[0]=1;let L=0,j=0;for(let Q=0;Q<32;Q++){if(D=Gi(n,r,l,0===Q,D,z),B[Q]=D,Q+1>=f){Ka(Q+1-f,f,q,B,0,E,I)||(0,R.c)("polynomial_interpolation");const et=_*Math.abs(E[0])+x,K=Math.abs(v-E[0]);if(K<=et&&Math.abs(I[0])<=et){if(L++,L>1&&(K<=.1*j||0===j||L>2))return E[0]}else L=0;j=K,v=E[0]}B[Q+1]=B[Q],q[Q+1]=.25*q[Q]}return E[0]}(f,n,r,x,l,_)}function Gi(f,n,r,l,_,x){let E=_;if(l)return x[0]=1,E=.5*(n-f)*(r(f)+r(n)),E;const v=x[0],I=(n-f)/v,D=f,G=new c.K(0);for(let q=1;q<=x[0];++q)G.add(r(D+(q-.5)*I));return E=.5*(E+(n-f)*G.getResult()/v),x[0]*=2,E}function Ka(f,n,r,l,_,x,E){let v=0,I=Math.abs(_-r[f]);const D=(0,c.d)(n,Number.NaN),G=(0,c.d)(n,Number.NaN);for(let L=0;L<n;++L){const j=Math.abs(_-r[f+L]);j<I&&(v=L,I=j),D[L]=l[f+L],G[L]=l[f+L]}let q=0,B=0,z=0;x[0]=l[f+v],v--;for(let L=1;L<n;L++){for(let j=0;j<n-L;j++){if(B=r[f+j]-_,z=r[f+j+L]-_,q=B-z,0===q)return!1;const Q=(D[j+1]-G[j])/q;D[j]=B*Q,G[j]=z*Q}2*(v+1)<n-L?E[0]=D[v+1]:(E[0]=G[v],v--),x[0]+=E[0]}return!0}class Vn{constructor(){this.length=Number.NaN,this.area=Number.NaN,this.centroidX=Number.NaN,this.centroidY=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}function $s(f,n,r,l,_,x,E,v){for(;;){const I=c.P.distance(n[0],n[2]),D=c.P.distance(n[0],n[1])+c.P.distance(n[1],n[2]);if(D-I<=_+l*D)return f+(0,c.q)(I,D,.5);const G=(0,c.m)(c.P,4),q=pt=>(Yn(n,r,1,pt,G),G[1].length());if(0===E&&v<8){(0,R.g)(v<8);let pt=q(0),gt=q(1);x[0]+=2,pt>gt&&(gt=(0,c.b)(pt,pt=gt),n[2]=(0,c.b)(n[0],n[0]=n[2]),r[2]=(0,c.b)(r[0],r[0]=r[2]));let yt=pt/(pt+gt),ft=1,bt=D;for(;yt<1/32&&bt>=_+l*bt;){ft/=4;const Dt=q(ft);x[0]++,yt=pt/(Dt+pt);const Nt=new c.P;if(ps(n,r,.5*ft,Nt),bt=c.P.distance(Nt,n[0]),bt<=_){const Ft=new c.P;ps(n,r,ft,Ft),bt+=c.P.distance(Ft,Nt)}}if(1!==ft){const Dt=(0,c.m)(c.P,3),Nt=[0,0,0];_h(n,r,ft,n,r,Dt,Nt),f=$s(f,Dt,Nt,l,_,x,0,v+1),E++,v++;continue}}let B=!1;const z=8;x[0]+=z;const L=Wi(z,q,0,1),j=16;x[0]+=j;const Q=Wi(j,q,0,1);if(B=Math.abs(L-Q)>_+l*D,!B)return f+Q;if(E<8&&v<9){const pt=(0,c.m)(c.P,3),gt=[0,0,0];_h(n,r,.5,n,r,pt,gt),f=$s(f,pt,gt,l,_,x,E+1,v+1),E++,v++;continue}const et=32;x[0]+=et;const K=Wi(et,q,0,1);if(B=Math.abs(Q-K)>_+l*D,!B)return f+K;const rt=64;x[0]+=rt;const ot=Wi(rt,q,0,1);if(B=Math.abs(K-ot)>_+l*D,!B)return f+ot;const nt=128;x[0]+=nt;const at=Wi(nt,q,0,1);return B=Math.abs(ot-at)>_+l*D,f+at}}function Yo(f,n,r,l,_){if(r===n)return 0;const x=(0,c.m)(c.P,3),E=[0,0,0];f.queryControlPoints(x),f.queryWeights(E);const v=[0,0,0],I=(0,c.m)(c.P,3);return $i(x,E,n,r,I,v),$s(0,I,v,l,_,[0],0,0)}let Bm=class{constructor(f,n,r){this.controlPoints=(0,c.L)(f,3),this.weights=[0,0,0],(0,c.a)(this.weights,n,0,0,3),this.point=r.clone()}getMaxDerivative(){return 3}getValue(f,n){if(0===f){const r=new c.P;ps(this.controlPoints,this.weights,n,r);const l=(0,c.m)(c.P,4);return Yn(this.controlPoints,this.weights,1,n,l),2*r.sub(this.point).dotProduct(l[1])}if(1===f){const r=new c.P;ps(this.controlPoints,this.weights,n,r);const l=(0,c.m)(c.P,4);return Yn(this.controlPoints,this.weights,2,n,l),2*(r.sub(this.point).dotProduct(l[2])+l[1].dotProduct(l[1]))}if(2===f){const r=new c.P;ps(this.controlPoints,this.weights,n,r);const l=(0,c.m)(c.P,4);return Yn(this.controlPoints,this.weights,3,n,l),2*(r.sub(this.point).dotProduct(l[3])+3*l[1].dotProduct(l[2]))}return 0}getError(f){return(0,R.g)(0),0}};function th(f,n,r,l){const _=function jm(f,n,r,l,_){return{tmin:f,tmax:n,t:r,d:l,pt:_.clone()}}(0,0,0,0,c.P.getNAN()),x=(0,c.d)(18,Number.NaN),E=(0,c.m)(c.P,3);f.queryControlPoints(E),E[2].subThis(n),E[1].subThis(n),E[0].subThis(n);const v=[0,0,0];f.queryWeights(v);const I=[1,Ni(v),1],D=Pr(v,r),G=Pr(v,l),q=wi(new Bm(E,I,new c.P(0,0)),c.E.construct(D,G),18,x);ps(E,I,D,_.pt),_.t=D,_.d=c.P.distance(_.pt,new c.P(0,0));const B=new c.P;ps(E,I,G,B);const z=c.P.distance(B,new c.P(0,0));z<_.d&&(_.d=z,_.t=G,_.pt.assign(B));for(let L=0;L<q;L++){ps(E,I,x[L],B);const j=c.P.distance(B,new c.P(0,0));j<_.d&&(_.d=j,_.t=Xn(v,x[L]),_.pt.assign(B))}return _}function Ki(f,n,r,l,_){let x=!0;const E=(0,c.m)(c.P,4),v=ji(5,n,r,l,_,D=>(fn(f,1,D,E),(x?f.getCoordX(D)-f.getStartX():f.getCoordY(D)-f.getStartY())*E[1].length()));x=!1;const I=ji(5,n,r,l,_,D=>(fn(f,1,D,E),(x?f.getCoordX(D)-f.getStartX():f.getCoordY(D)-f.getStartY())*E[1].length()));return new c.P(v,I)}function gr(f){f.m_cachedValues=null}function _r(f){if(f.m_cachedValues)return f.m_cachedValues;const n=new Vn,r=(0,c.m)(c.P,3);f.queryControlPoints(r);const l=[0,0,0];return f.queryWeights(l),Fi(r,l,n.specialPoints),ch(f,n),n}function Fi(f,n,r){if(0===n[1])return r.length=0,r.push(0),void r.push(1);const l=(0,c.m)(c.F,8);l[0].set(0);let _=1;{const x=new c.F(f[1].x).subThis(f[0].x).mulThis(n[1]).mulThis(n[0]),E=new c.F(f[2].x).subThis(f[0].x).mulThis(n[2]).mulThis(n[0]),v=x.subE(E).addThisE(new c.F(f[2].x).subThis(f[1].x).mulThis(n[2]).mulThis(n[1]));E.subThisE(x.mul(2));const I=(0,c.m)(c.F,2);let D=it(v,E,x,new c.E(0,1),!1,I);D<0&&(D=0);for(let G=0;G<D;G++)(0,c.J)(I[G].value(),0,1)||(l[_]=I[G],_++)}{const x=new c.F(f[1].y).subThis(f[0].y).mulThis(n[1]).mulThis(n[0]),E=new c.F(f[2].y).subThis(f[0].y).mulThis(n[2]).mulThis(n[0]),v=x.subE(E).addThisE(new c.F(f[2].y).subThis(f[1].y).mulThis(n[2]).mulThis(n[1]));E.subThisE(x.mul(2));const I=(0,c.m)(c.F,2);let D=it(v,E,x,new c.E(0,1),!1,I);D<0&&(D=0);for(let G=0;G<D;G++)(0,c.J)(I[G].value(),0,1)||(l[_]=I[G],_++)}if(l[_].set(1),_++,_>2){(0,c.C)(l,0,_,(I,D)=>(0,c.X)(I.value(),D.value()));let x=0,E=l[0].value(),v=1;for(let I=1;I<_;I++)l[I].eq(l[I-1])?(E+=l[I].value(),v++):(v>1&&(E/=v,l[x].set(E)),x++,l[x]=l[I],E=l[I].value(),v=1);x++,_=x}l[0].set(0),l[_-1].set(1),r.length=_;for(let x=0;x<_;x++)r[x]=l[x].value()}function Xe(f,n,r){if(r){if(n<0)return n;if(n>1)return n-1+Xe(f,1,!1)}if(f.isDegenerate(0))return 0;const l=1===n,_=_r(f);if(l&&!Number.isNaN(_.length))return _.length;const x=Ro(f),E=x/f.calculateUpperLength2D();let v=0,I=0;for(let D=1,G=_.specialPointsCount();D<G;D++){const q=_.specialPoints[D];if(v+=Yo(f,I,Math.min(n,q),E,x),n<=q)break;I=q}return l&&(_.length=v),v}function fn(f,n,r,l){const _=(0,c.m)(c.P,3);f.queryControlPoints(_);const x=[0,0,0];f.queryWeights(x),Yn(_,x,n,r,l)}function Yn(f,n,r,l,_){const x=[f[0],f[1],f[2]],E=[n[0],n[1],n[2]],v=(0,c.m)(c.P,4);!function sh(f,n,r,l,_){(0,R.g)(r>0);const x=[f[0].clone(),f[1].clone(),f[2].clone()];if(!x[0].isZero()){for(let rt=1;rt<3;++rt)x[rt].subThis(x[0]);x[0].setCoords(0,0)}const E=dr(x,n,0,l),v=Jr(n,0,l),I=E.divide(v);if(_[0].assign(I),0===r)return;const D=[n[1]*n[0],n[2]*n[0]*.5,n[1]*n[2]],G=[f[1].sub(f[0]),f[2].sub(f[0]),f[2].sub(f[1])],q=v*v,B=dr(G,D,0,l).mul(2).divide(q);if(_[1].assign(B),1===r)return;const z=Jr(n,1,l),L=2*v*z,j=dr(G,D,1,l).mul(2).sub(B.mul(L)).divide(q);if(_[2].assign(j),2===r)return;const Q=dr(G,D,2,l).mul(2),et=2*(z*z+v*Jr(n,2,l)),K=Q.sub(j.mul(L).mul(2)).sub(B.mul(et)).divide(q);_[3].assign(K),3!==r&&(0,R.c)("")}(x,E,r,l,v);for(let I=0;I<=r;I++)_[I].setCoords(v[I].x,v[I].y)}function dr(f,n,r,l){if(0===r){if(l<=.5){const _=new c.P;(0,c.V)(2,f[0].mul(n[0]),f[1].mul(n[1]),l,_);const x=new c.P;(0,c.V)(2,f[1].mul(n[1]),f[2].mul(n[2]),l,x);const E=new c.P;return(0,c.V)(2,_,x,l,E),E}{const _=new c.P;(0,c.W)(2,f[0].mul(n[0]),f[1].mul(n[1]),l,_);const x=new c.P;(0,c.W)(2,f[1].mul(n[1]),f[2].mul(n[2]),l,x);const E=new c.P;return(0,c.W)(2,_,x,l,E),E}}if(1===r){const _=f[1].mul(n[1]),x=_.sub(f[0].mul(n[0])).mul(1-l).add(f[2].mul(n[2]).sub(_).mul(l));return x.mulThis(2),x}if(2===r){const _=f[1].mul(n[1]),x=f[2].mul(n[2]).sub(_).sub(_.sub(f[0].mul(n[0])));return x.mulThis(2),x}(0,R.c)("")}function Xo(f,n,r,l){if(l.toDouble()<=.5){const _=new Vt;(0,c.a1)(2,f[0].mulE(n[0]),f[1].mulE(n[1]),l,_);const x=new Vt;(0,c.a1)(2,f[1].mulE(n[1]),f[2].mulE(n[2]),l,x);const E=new Vt;return(0,c.a1)(2,_,x,l,E),E}{const _=new Vt;(0,c.a2)(2,f[0].mulE(n[0]),f[1].mulE(n[1]),l,_);const x=new Vt;(0,c.a2)(2,f[1].mulE(n[1]),f[2].mulE(n[2]),l,x);const E=new Vt;return(0,c.a2)(2,_,x,l,E),E}}function Jr(f,n,r){if(0===n){const l=(0,c.q)(f[0],f[1],r),_=(0,c.q)(f[1],f[2],r);return(0,c.q)(l,_,r)}return 1===n?2*((1-r)*(f[1]-f[0])+(f[2]-f[1])*r):2===n?2*(f[2]-f[1]-(f[1]-f[0])):void(0,R.c)("")}function Zr(f,n,r){const l=(0,c.c)(r,0,1),_=(0,c.m)(c.P,4);if(Yn(f,n,3,l,_),_[1].isZero()){if(_[2].isZero())return _[3];{const x=_[2].clone();return 1===l&&x.negateThis(),x}}return _[1]}let oh=class{constructor(f,n){this.len=0,this.b=f,this.len=n}getMaxDerivative(){return 1}getValue(f,n){return 0===f?this.len-Xe(this.b,n,!1):0}getError(f){return(0,R.g)(0),0}};function hh(f){const n=(0,c.m)(c.P,3),r=[0,0,0];return f.queryControlPoints(n),f.queryWeights(r),function Um(f,n){const r=Ni(n);if(1===r)return Sr(f);if(0===r)return 0;const l=[new c.P(0,0),f[1].sub(f[0]),f[2].sub(f[0])],_=l[1].crossProduct(l[2]);if(r<1){(0,R.g)(r>0);const x=1-r;let E;if(x<.01)E=-1/3+x*(2/15+x*(3/35+x*(16/315+x*(20/693+x*(16/1001+x*(56/6435))))));else{const v=x*(1+r),I=Math.atan2(Math.sqrt(x),Math.sqrt(1+r));E=r*(.5*r-(0,c.ak)(v)*I)/v}return _*E}{const x=(r-1)*(r+1);return.25*r/Math.pow(x,1.5)*(-2*r*Math.sqrt(x)*_-4*l[1].y*l[2].x*Math.atanh(Math.sqrt((r-1)/(r+1)))-l[1].x*l[2].y*Math.log(2*r*(r-Math.sqrt(x))-1))}}(n,r)}function Ro(f){return function Wm(f){return 256*(0,c.N)()*f}(f.calculateUpperLength2D())}function uh(f){return f.m_cachedValues}function ch(f,n){f.m_cachedValues=n}function Qr(f,n,r,l,_){const x=(0,c.m)(c.P,3);f.queryControlPoints(x);const E=[0,0,0];f.queryWeights(E);const v=[0];return 1===ko(x,E,n,c.E.unit(),l,_,1,v)?v[0]:Number.NaN}function ko(f,n,r,l,_,x,E,v){(0,R.w)(c.E.unit().contains(l)&&E>0,""),(x<0||Number.isNaN(x))&&(x=Number.MAX_VALUE);const I=new Array(3);for(let ie=0;ie<3;++ie)I[ie]=f[ie].sub(r);const D=Ni(n),G=Ne.constructPoint2D(I[0]),q=Ne.constructPoint2D(I[1]),B=Ne.constructPoint2D(I[2]),z=c.M.constructDouble(D),L=z.clone();L.ldexpThis(1);const j=G.dotProduct(q.sub(G)).mul(z),Q=z.mul(z.addDouble(2)),et=B.sub(q.mul(Q.ldexp(1))),K=q.sqrLength().mul(z.mul(z).ldexp(1)).add(G.sqrLength().mul(z.ldexp(2).subDouble(1))).add(G.dotProduct(et)),rt=B.sub(q.mul(L)).add(G.mul(L.subDouble(1))),ot=q.mul(z).sub(G).dotProduct(rt).mulDouble(3),nt=q.dotProduct(B).mul(z.subDouble(3).mul(z)).ldexp(1),at=q.sqrLength().mul(z.mul(z).ldexp(2)),pt=G.sqrLength().mul(z.ldexp(2).subDouble(3)),gt=G.dotProduct(B.sub(q.mul(z.mulDouble(3).subDouble(1)).mul(z))).ldexp(1),yt=B.sqrLength().addThis(nt).addThis(at).addThis(pt).addThis(gt),ft=G.add(B).sub(q.mul(L)),bt=z.subDouble(1),Dt=B.sub(G).dotProduct(ft).mul(bt),Nt=new c.P(0,0),Ft=[];let Ot=new c.P;ps(I,n,l.vmin,Ot);let Qt=c.P.distance(Ot,Nt);if(Qt<=x&&Ft.push(new c.P(l.vmin,Qt)),l.vmin!==l.vmax&&(ps(I,n,l.vmax,Ot),Qt=c.P.distance(Ot,Nt),Qt<=x&&Ft.push(new c.P(l.vmax,Qt))),l.width()>0){const ie=I[2].isZero(),ne=(0,c.m)(c.M,4),De=Mo(Dt,yt,ot,K,j,58,l,ie,ne);for(let We=0;We<De;We++){if(!l.containsExclusiveCoordinate(ne[We].toDouble()))continue;let Li=ne[We].toDouble();Li=Xn(n,Li);const Ms=new c.P;ps(I,n,Li,Ms),Qt=c.P.distance(Ms,Nt),Qt<=x&&Ft.push(new c.P(Li,Qt))}}if(_){(0,R.g)(l.equals(c.E.unit()));{ps(I,n,-1,Ot,!0);const ie=new c.P;ps(I,n,0,ie);const ne=new ke({start:Ot,end:ie}),De=ne.getClosestCoordinate(Nt,!0);De<1&&(Ot=ne.getCoord2D(De),Qt=c.P.distance(Ot,Nt),Qt<=x&&Ft.push(new c.P(De-1,Qt)))}{ps(I,n,2,Ot,!0);const ie=new c.P;ps(I,n,l.vmax,ie);const ne=new ke({start:ie,end:Ot}),De=ne.getClosestCoordinate(Nt,!0);De>0&&(Ot=ne.getCoord2D(De),Qt=c.P.distance(Ot,Nt),Qt<=x&&Ft.push(new c.P(1+De,Qt)))}}if(!Ft.length)return 0;Ft.sort((ie,ne)=>ie.compare(ne));let Kt=0;if(v[Kt++]=Ft[0].x,Kt<E){const ie=(0,F.x)(I,4,!1).total(),ne=Ft[0].y;for(let De=1,We=Ft.length;De<We;De++)if(Ft[De].y>ne+ie){Ft.length=De;break}Ft.sort((De,We)=>(0,c.X)(De.x,We.x)),Kt=0,v[Kt++]=Ft[0].x;for(let De=1,We=Ft.length;De<We;De++)Ft[De].x!==v[Kt-1]&&Kt<E&&(v[Kt++]=Ft[De].x)}return Kt}function gh(f,n,r){const l=(0,c.m)(c.P,3);f.queryControlPoints(l);const _=[0,0,0];f.queryWeights(_),pr(l,_,n,r)}function pr(f,n,r,l){if(r.equalsRange(0,1))return void l.setFromPoints(f,3);const _=(0,c.m)(c.P,3);$i(f,n,r.vmin,r.vmax,_,[0,0,0]),l.setFromPoints(_,3)}function Kr(f){const n=(0,c.Y)(f[0].y,f[1].y),r=(0,c.Y)(f[1].y,f[2].y);if(n>=0&&r>=0||n<=0&&r<=0){const l=(0,c.Y)(f[0].x,f[1].x),_=(0,c.Y)(f[1].x,f[2].x);if(l>=0&&_>=0||l<=0&&_<=0)return!0}return!1}function $r(f){const n=(0,c.m)(c.P,3);f.queryControlPoints(n);const r=xn(n);return r&&(f.m_cp.setCoordsPoint2D(n[1]),f.afterCompletedModification()),r}function xn(f){let n=!1;for(let r=0;r<2;r++){const l=(0,c.Y)(f[0][r],f[2][r]);l>0?((0,c.Y)(f[0][r],f[1][r])<0&&(f[1][r]=f[0][r],n=!0),(0,c.Y)(f[1][r],f[2][r])<0&&(f[1][r]=f[2][r],n=!0)):l<0?((0,c.Y)(f[0][r],f[1][r])>0&&(f[1][r]=f[0][r],n=!0),(0,c.Y)(f[1][r],f[2][r])>0&&(f[1][r]=f[2][r],n=!0)):f[1][r]!==f[0][r]&&(f[1][r]=f[0][r],n=!0)}return n}function _h(f,n,r,l,_,x,E){(0,R.g)(r>=0&&r<=1&&l!==x&&_!==E),(0,R.g)(n[0]>0&&n[2]>0&&n[1]>=0);const v=[1,Ni(n),1],I=Pr(n,r),D=(0,c.L)(f,3),G=(0,c.m)(F.h,3);yh(D,v,G);const q=(0,c.m)(F.h,3),B=(0,c.m)(F.h,3);Ho(G,I,l?q:null,x?B:null),tn(n,r,_,E);const z=Kr(D);if(l){for(let L=0;L<3;++L)Bo(q[L],l[L]);io(D,l),z&&xn(l)}if(x){for(let L=0;L<3;++L)Bo(B[L],x[L]);io(D,x),z&&xn(x)}}function $i(f,n,r,l,_,x){if((0,R.g)(r>=0&&l<=1&&r<=l),r===l){const G=new c.P,q=Eh(f,n,r,G);return so(f,G),_[0].assign(G),_[1].assign(G),_[2].assign(G),x[0]=q,x[1]=q,void(x[2]=q)}if(0===r&&1===l)return _[0].assign(f[0]),_[1].assign(f[1]),_[2].assign(f[2]),x[0]=n[0],x[1]=n[1],void(x[2]=n[2]);const E=(0,c.m)(F.h,3);{const G=[1,Ni(n),1],q=Pr(n,r),B=Pr(n,l);yh(f,G,E),Ho(E,B,E,null),Ho(E,q>=B?1:q/B,null,E)}const v=[0,0,0];tn(n,l,v,null),tn(v,r/l,null,v);const I=Kr(f),D=(0,c.m)(c.P,3);Bo(E[1],D[1]),ps(f,n,r,D[0]),ps(f,n,l,D[2]),io(f,D);for(let G=0;G<3;++G)_[G].assign(D[G]),x[G]=v[G];I&&xn(_)}function dh(f,n,r){const l=Ni(n),_=[1,l,1],x=4*l/(3*(1+l));r[0].assign(f[0]),r[3].assign(f[2]),(0,c.Z)(f[0],f[1],x,r[1]),(0,c.Z)(f[2],f[1],x,r[2]),new fi({cp:r}),new as({points:f,weight:l});let E=0,v=.1,I=0;for(let D=0;D<9;D++,v+=.1){const G=new c.P;ps(f,_,v,G);const q=new c.P;$e(r,v,q);const B=c.P.sqrDistance(G,q);B>E&&(E=B,I=v)}{const D=new c.P;ps(f,_,I,D);const G=[0];us(r,D,c.E.unit(),!1,-1,1,G);const q=new c.P;return $e(r,G[0],q),E=c.P.sqrDistance(D,q),Math.sqrt(E)}}function fh(f,n,r,l,_){if(_){if(0!==Fs(n,r))return f?4:2}else if(_e(n,r))return 1;return 0!==an(f,n,r,null,null,null,l,void 0!==_&&_,!0,!1)?4:0}function xh(f,n,r,l,_){if(_){if(0!==Fs(n,r))return f?4:2}else if(_e(n,r))return 1;return 0!==to(f,n,r,null,null,null,l,_??!1,!0,!1)?4:0}function Ph(f,n,r,l,_){if(_){if(0!==Fs(n,r))return f?4:2}else if(_e(n,r))return 1;return 0!==Lo(f,n,r,null,null,null,l,_??!1,!0,!1)?4:0}function an(f,n,r,l,_,x,E,v,I,D){if(null!==_&&(_.length=0),null!==x&&(x.length=0),null!==l&&(l.length=0),r.isDegenerate(0)){const Ge=[0,0],ei=n.intersectPoint(r.getStartXY(),Ge,E);if(ei>0){if(null!==_)for(let vs=0;vs<ei;vs++)_.push(Ge[vs]);if(null!=x)for(let vs=0;vs<ei;vs++)x.push(0);if(null!=l)for(let vs=0;vs<ei;vs++){const vo=new c.P;n.queryCoord2D(Ge[vs],vo),l.push(vo)}}return ei}const G=qe(n,r);if(E=Math.max(E,G),n.isDegenerateToLineHelper(G)){const Ge=new ke({start:n.getStartXY(),end:n.getEndXY()}),ei=Gn(Ge,r,l,_,x,E,v,D);if(_)for(let vs=0;vs<ei;++vs){const vo=Ge.getCoord2D(_[vs]);_[vs]=n.getClosestCoordinate(vo,!1)}return ei}if(Ps(n,r,E))return 0;const q=(0,c.m)(c.P,3);n.queryControlPoints(q);const B=[0,0,0];n.queryWeights(B);const z=[1,Ni(B),1],L=r.getEndXY().sub(r.getStartXY()),j=L.clone();j.leftPerpendicularThis();const Q=q[0].clone(),et=q[1].clone(),K=q[2].clone(),rt=et.sub(Q),ot=K.sub(Q),nt=K.sub(et),at=z[0],pt=z[1],gt=z[2],yt=at*pt,ft=at*gt,bt=pt*gt,Dt=rt.dotProduct(j)*yt,Nt=ot.dotProduct(j)*ft;let Ft=Dt,Ot=Nt-2*Dt,Qt=nt.dotProduct(j)*bt+Nt-Nt;const Kt=(0,c.d)(13,Number.NaN),Ce=(0,c.d)(13,Number.NaN);let ie=Ns(Qt,Ot,Ft,c.E.unit(),!1,Kt);ie<0&&(Kt[0]=0,Kt[1]=1,ie=2);let ne=0;for(let Ge=0,ei=ne;Ge<ie;++Ge){const vs=new c.P;ps(q,z,Kt[Ge+ei],vs),Ce[ne]=r.getClosestCoordinate(vs,!1),c.P.distance(vs,r.getCoord2D(Ce[ne]))<=E&&(Kt[ne]=Kt[Ge+ei],ne++)}const De=(0,c.m)(c.P,3),We=(0,c.m)(c.P,3);if(n.queryControlPoints(We),We[0].subThis(r.getStartXY()),We[1].subThis(r.getStartXY()),We[2].subThis(r.getStartXY()),function $m(f,n,r,l=!1){const _=(0,c.m)(c.P,3);l?(_[0].setCoordsPoint2D(f[0]),_[1].setCoordsPoint2D(f[1]),_[1].subThis(_[0]),_[2].setCoordsPoint2D(f[2]),_[2].subThis(_[0]),_[0].setCoords(0,0)):(_[0].setCoordsPoint2D(f[0]),_[1].setCoordsPoint2D(f[1]),_[2].setCoordsPoint2D(f[2])),_[0].mulThis(n[0]),_[1].mulThis(n[1]),_[2].mulThis(n[2]),r[1].setCoords(_[1].x-_[0].x,_[1].y-_[0].y),r[2].setCoordsPoint2D(_[2].sub(_[1])),r[2].subThis(r[1]),r[1].x*=2,r[1].y*=2,r[0].setCoordsPoint2D(_[0])}(We,z,De,!1),Math.abs(L.x)>=Math.abs(L.y)){const Ge=L.y/L.x;Qt=De[2].y-De[2].x*Ge,Ot=De[1].y-De[1].x*Ge,Ft=De[0].y-De[0].x*Ge}else{const Ge=L.x/L.y;Qt=De[2].x-De[2].y*Ge,Ot=De[1].x-De[1].y*Ge,Ft=De[0].x-De[0].y*Ge}const Li=n.getEndXY().equals(r.getStartXY())||n.getEndXY().equals(r.getEndXY()),Ms=[0,0];ie=Ns(Qt,Ot,Ft,c.E.unit(),Li,Ms);for(let Ge=0,ei=ne;Ge<ie;++Ge){Kt[Ge+ei]=Ms[Ge];const vs=new c.P;ps(q,z,Kt[Ge+ei],vs),Ce[ne]=r.getClosestCoordinate(vs,!1),c.P.distance(vs,r.getCoord2D(Ce[ne]))<=E&&(Kt[ne]=Kt[Ge+ei],ne++)}(0,R.g)(ne<Kt.length+4);for(let Ge=0;Ge<ne;Ge++)Kt[Ge]=Xn(B,Kt[Ge]);ie=n.intersectPoint(r.getStartXY(),Ms,E);for(let Ge=0;Ge<ie;Ge++)Kt[ne]=Ms[Ge],Ce[ne++]=0;ie=n.intersectPoint(r.getEndXY(),Ms,E);for(let Ge=0;Ge<ie;Ge++)Kt[ne]=Ms[Ge],Ce[ne++]=1;ie=r.intersectPoint(n.getStartXY(),Ms,E);for(let Ge=0;Ge<ie;Ge++)Ce[ne]=Ms[Ge],Kt[ne++]=0;ie=r.intersectPoint(n.getEndXY(),Ms,E);for(let Ge=0;Ge<ie;Ge++)Ce[ne]=Ms[Ge],Kt[ne++]=1;return 0===ne?0:Ws(f,n,r,Kt,Ce,ne,l,_,x,E,v,0,D)}function to(f,n,r,l,_,x,E,v,I,D){if(ss(r))return an(f,n,new ke({start:r.getStartXY(),end:r.getEndXY()}),l,_,x,E,v,0,D);const G=qe(n,r);if(Ps(n,r,E=Math.max(E,G)))return 0;const q=[],B=[],z=(0,c.m)(c.P,4);{n.queryControlPoints(z);const j=(0,c.m)(c.P,4),Q=new Y.T;r.canonicToWorldTransformation(Q);const et=new Y.T;et.setInvert(Q),et.transformPoints2D(z,4,j);const K=(0,c.m)(c.M,3),rt=(0,c.m)(c.M,3),ot=(0,c.m)(c.M,3),nt=[0,0,0];n.queryWeights(nt),xr(j,nt,K,rt,ot);const at=(0,c.m)(c.M,3);at[0].setDouble(r.getSemiMinorAxis()),at[0].sqrThis(),at[1].setDouble(r.getSemiMajorAxis()),at[1].sqrThis(),at[2].setThis(at[0]),at[2].mulThis(at[1]),at[2].negateThis();const pt=Fo(K,2,rt,2,ot,2,at,0,c.E.unit(),c.E.unit(),q);if(pt>0){let gt=0;for(let yt=0;yt<pt;yt++){const ft=new c.P;n.queryCoord2D(q[yt],ft);const bt=r.getClosestCoordinate(ft,!1),Dt=new c.P;r.queryCoord2D(bt,Dt),c.P.distance(ft,Dt)<=E&&(q[gt]=q[yt],B.push(bt),gt++)}q.length=gt}}const L=[0,1];for(let j=0;j<2;j++){const Q=0===j?r.getStartXY():r.getEndXY(),et=Qr(n,Q,c.E.unit(),!1,-1),K=new c.P;n.queryCoord2D(et,K),c.P.distance(Q,K)<=E&&(q.push(et),B.push(L[j]))}for(let j=0;j<2;j++){const Q=[0,3];{const et=r.getClosestCoordinate(z[Q[j]],!1),K=new c.P;r.queryCoord2D(et,K),c.P.distance(z[Q[j]],K)<=E&&(q.push(L[j]),B.push(et))}}return Ws(f,n,r,q,B,q.length,l,_,x,E,v,0,D)}function fr(f,n,r,l,_,x,E,v,I,D){const G=(0,c.m)(c.P,3);n.queryControlPoints(G);const q=(0,c.m)(c.P,3);if(r.queryControlPoints(q),ds(G,q,3)<0)return fr(f,r,n,l,x,_,E,v,I,!D);const B=qe(n,r);if(n.isDegenerateToLineHelper(B)){const at=new ke({start:n.getStartXY(),end:n.getEndXY()}),pt=an(f,r,at,l,x,_,E,v,0,!D);if(_)for(let gt=0;gt<pt;++gt){const yt=at.getCoord2D(_[gt]);_[gt]=n.getClosestCoordinate(yt,!1)}return pt}if(r.isDegenerateToLineHelper(B)){const at=new ke({start:r.getStartXY(),end:r.getEndXY()}),pt=an(f,n,at,l,_,x,E,v,0,D);if(x)for(let gt=0;gt<pt;++gt){const yt=at.getCoord2D(x[gt]);x[gt]=r.getClosestCoordinate(yt,!1)}return pt}if(Ps(n,r,E=Math.max(E,B)))return 0;const z=(0,c.d)(3,Number.NaN);n.queryWeights(z);const L=(0,c.d)(3,Number.NaN);r.queryWeights(L);const j=[1,Ni(z),1],Q=[1,Ni(L),1],et=new c.E(0,1),K=new c.E(0,1);{const at=jt.constructEmpty();pr(G,j,new c.E(0,1),at);const pt=jt.constructEmpty();pr(q,Q,new c.E(0,1),pt);const gt=Math.max(at.maxDim(),pt.maxDim());if(at.inflate(3*E),pt.inflate(3*E),!at.intersectW(pt))return 0;if(at.maxDim()<.1*gt){if(eo(G,j,at,et),eo(q,Q,at,K),et.isEmpty()||K.isEmpty())return 0;$i(G,j,et.vmin,et.vmax,G,j),$i(q,Q,K.vmin,K.vmax,q,Q)}}const rt=tr(G,2,q,2,E);if(0===rt)return 0;const ot=[],nt=[];if(-1===rt){const at=(0,c.m)(c.M,3),pt=(0,c.m)(c.M,3),gt=(0,c.m)(c.M,3);xr(G,j,at,pt,gt);const yt=(0,c.m)(c.M,3),ft=(0,c.m)(c.M,3),bt=(0,c.m)(c.M,3);xr(q,Q,yt,ft,bt);const Dt=[],Nt=[],Ft=ui(at,2,pt,2,gt,2,yt,2,ft,2,bt,2,0,c.E.unit(),c.E.unit(),Dt,Nt);if(Ft>0)for(let Ot=0;Ot<Ft;Ot++){const Qt=new c.P;ps(q,Q,Nt[Ot],Qt);const Kt=new c.P;ps(G,j,Dt[Ot],Kt),c.P.distance(Kt,Qt)<=E&&(ot.push(Dt[Ot]),nt.push(Nt[Ot]))}}for(let at=0;at<2;at++){let pt,gt,yt;0===at?(pt=G,gt=q,yt=Q):(pt=q,gt=G,yt=j);for(let ft=0;ft<2;ft++){const bt=0===ft?0:pt.length-1,Dt=new c.P,Nt=[0],Ft=ko(gt,yt,pt[bt],c.E.unit(),!1,-1,1,Nt);(0,R.g)(1===Ft),ps(gt,yt,Nt[0],Dt),c.P.distance(pt[bt],Dt)<=E&&(0===at?(ot.push(0===bt?0:1),nt.push(Nt[0])):(nt.push(0===bt?0:1),ot.push(Nt[0])))}}if(0===ot.length)return 0;if(!et.equalsRange(0,1))for(let at=0;at<ot.length;++at)ot[at]=as.recalculateParentT(et.vmin,et.vmax,ot[at]);if(!K.equalsRange(0,1))for(let at=0;at<nt.length;++at)nt[at]=as.recalculateParentT(K.vmin,K.vmax,nt[at]);for(let at=0;at<ot.length;++at)ot[at]=Xn(z,ot[at]);for(let at=0;at<nt.length;++at)nt[at]=Xn(L,nt[at]);return Ws(f,n,r,ot,nt,ot.length,l,_,x,E,v,0,D)}function Lo(f,n,r,l,_,x,E,v,I,D){if(n.isLine())return kn(f,r,new ke({start:n.getStartXY(),end:n.getEndXY()}),l,x,_,E,v,I,!D);if(r.isLine())return an(f,n,new ke({start:r.getStartXY(),end:r.getEndXY()}),l,_,x,E,v,0,D);const G=qe(n,r);if(Ps(n,r,E=Math.max(E,G)))return 0;const q=(0,c.m)(c.P,3);n.queryControlPoints(q);const B=(0,c.m)(c.P,3);r.queryControlPoints(B);const z=tr(q,2,B,2,E);if(0===z)return 0;const L=[],j=[];if(-1===z){const Q=(0,c.m)(c.M,3),et=(0,c.m)(c.M,3),K=(0,c.m)(c.M,3),rt=[0,0,0];n.queryWeights(rt),xr(q,rt,Q,et,K);const ot=(0,c.m)(Ne,3);yn(B,ot);const nt=ui(Q,2,et,2,K,2,[ot[0].x,ot[1].x,ot[2].x],2,[ot[0].y,ot[1].y,ot[2].y],2,null,0,0,c.E.unit(),c.E.unit(),L,j);if(nt>0){let at=0;for(let pt=0;pt<nt;pt++){const gt=new c.P;r.queryCoord2D(j[pt],gt);const yt=new c.P;n.queryCoord2D(L[pt],yt),c.P.distance(yt,gt)<=E&&(L[at]=L[pt],j[at]=j[pt],at++)}L.length=at,j.length=at}}for(let Q=0;Q<2;Q++){let et;et=0===Q?q:B;for(let K=0;K<2;K++){const rt=0===K?0:et.length-1;let ot;const nt=new c.P;0===Q?(ot=ys(r,et[rt],c.E.unit(),!1),r.queryCoord2D(ot,nt)):(ot=Qr(n,et[rt],c.E.unit(),!1,-1),n.queryCoord2D(ot,nt)),c.P.distance(et[rt],nt)<=E&&(0===Q?(L.push(0===rt?0:1),j.push(ot)):(j.push(0===rt?0:1),L.push(ot)))}}return Ws(f,n,r,L,j,L.length,l,_,x,E,v,0,D)}function xr(f,n,r,l,_){const x=c.M.constructDouble(n[0]),E=c.M.constructDouble(n[1]),v=c.M.constructDouble(n[2]);r[0].setDouble(f[0].x),r[0].mulThis(x),r[1].setDouble(f[1].x),r[1].mulThis(E),r[2].setDouble(f[2].x),r[2].mulThis(v),r[2].subThis(r[1]),r[1].subThis(r[0]),r[2].subThis(r[1]),r[1].ldexpThis(1),l[0].setDouble(f[0].y),l[0].mulThis(x),l[1].setDouble(f[1].y),l[1].mulThis(E),l[2].setDouble(f[2].y),l[2].mulThis(v),l[2].subThis(l[1]),l[1].subThis(l[0]),l[2].subThis(l[1]),l[1].ldexpThis(1),_[0].setDouble(n[0]),_[1].setDouble(n[1]),_[2].setThis(_[1]),_[2].ldexpThis(1),_[2].negateThis(),_[2].addThis(_[0]),_[2].addDoubleThis(n[2]),_[1].subThis(_[0]),_[1].ldexpThis(1)}function yh(f,n,r){for(let l=0;l<3;++l)r[l].setCoordsPoint2DZ(f[l].mul(n[l]),n[l])}function Eh(f,n,r,l){if(0===r)return l.assign(f[0]),n[0];if(1===r)return l.assign(f[2]),n[2];const _=[f[0].x*n[0],f[1].x*n[1],f[2].x*n[2]],x=[f[0].y*n[0],f[1].y*n[1],f[2].y*n[2]],E=[n[0],n[1],n[2]],v=r;let I,D,G;if(r<=.5){const q=(0,c.Q)(_[0],_[1],v),B=(0,c.Q)(_[1],_[2],v);I=(0,c.q)(q,B,v);const z=(0,c.Q)(x[0],x[1],v),L=(0,c.Q)(x[1],x[2],v);D=(0,c.q)(z,L,v);const j=(0,c.Q)(E[0],E[1],v),Q=(0,c.Q)(E[1],E[2],v);G=(0,c.Q)(j,Q,v)}else{const q=(0,c.R)(_[0],_[1],v),B=(0,c.R)(_[1],_[2],v);I=(0,c.R)(q,B,v);const z=(0,c.R)(x[0],x[1],v),L=(0,c.R)(x[1],x[2],v);D=(0,c.R)(z,L,v);const j=(0,c.R)(E[0],E[1],v),Q=(0,c.R)(E[1],E[2],v);G=(0,c.R)(j,Q,v)}return I/=G,D/=G,l.setCoords(I,D),so(f,l),G}function Bo(f,n){return n.setCoords(f.x/f.z,f.y/f.z),f.z}function ps(f,n,r,l,_){if(_){if(r<0)return void Us(new ke({start:f[0],end:f[0].add(Zr(f,n,0).getUnitVector())}),r,l);if(r>1)return void Us(new ke({start:f[2],end:f[2].add(Zr(f,n,1).getUnitVector())}),r-1,l)}Eh(f,n,r,l)}function eo(f,n,r,l){l.setEmpty();const _=[];_.push(new c.E(0,1));const x=.5*Math.max(r.width(),r.height());for(;_.length;){const E=_.at(-1);_.pop();const v=new jt;if(pr(f,n,E,v),v.isIntersectingW(r)){const I=Math.max(v.width(),v.height());if(r.containsW(v)||I<=x||E.width()<1e-12)l.merge(E);else{const D=E.getCenter();_.push(c.E.construct(E.vmin,D)),_.push(c.E.construct(D,E.vmax))}}}}function Ni(f){return f[1]/Math.sqrt(f[0]*f[2])}function Xn(f,n){const r=Math.sqrt(f[2]/f[0]);return n/(0,c.q)(r,1,n)}function Pr(f,n){const r=Math.sqrt(f[0]/f[2]);return n/(0,c.q)(r,1,n)}function Ho(f,n,r,l){(0,R.g)(n>=0&&n<=1),(new F.h).setCoordsPoint3D(f[0]),(new F.h).setCoordsPoint3D(f[1]),(new F.h).setCoordsPoint3D(f[2]);const _=new F.h,x=new F.h,E=new F.h;(0,c.a0)(3,f[0],f[1],n,_),(0,c.a0)(3,f[1],f[2],n,x),(0,c.a0)(3,_,x,n,E);const v=f[2].clone();r&&(r[0].assign(f[0]),r[1].assign(_),r[2].assign(E)),l&&(l[0].assign(E),l[1].assign(x),l[2].assign(v))}function tn(f,n,r,l){const _=[f[0],f[1],f[2]];(0,R.g)(n>=0&&n<=1&&r!==l);const x=(0,c.q)(_[0],_[1],n),E=(0,c.q)(_[1],_[2],n),v=(0,c.q)(x,E,n);r&&(r[0]=_[0],r[1]=x,r[2]=v),l&&(l[0]=v,l[1]=E,l[2]=_[2])}function so(f,n){const r=c.E.constructEmpty();r.vmin=r.vmax=f[0].x,r.mergeNeCoordinate(f[1].x),r.mergeNeCoordinate(f[2].x),n.x=(0,c.c)(n.x,r.vmin,r.vmax),r.vmin=r.vmax=f[0].y,r.mergeNeCoordinate(f[1].y),r.mergeNeCoordinate(f[2].y),n.y=(0,c.c)(n.y,r.vmin,r.vmax)}function io(f,n){const r=new c.E;r.vmin=r.vmax=f[0].x,r.mergeNeCoordinate(f[1].x),r.mergeNeCoordinate(f[2].x),n[0].x=(0,c.c)(n[0].x,r.vmin,r.vmax),n[1].x=(0,c.c)(n[1].x,r.vmin,r.vmax),n[2].x=(0,c.c)(n[2].x,r.vmin,r.vmax),r.vmin=r.vmax=f[0].y,r.mergeNeCoordinate(f[1].y),r.mergeNeCoordinate(f[2].y),n[0].y=(0,c.c)(n[0].y,r.vmin,r.vmax),n[1].y=(0,c.c)(n[1].y,r.vmin,r.vmax),n[2].y=(0,c.c)(n[2].y,r.vmin,r.vmax)}class sl{constructor(){this.area=Number.NaN,this.centroid_x=Number.NaN,this.centroid_y=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}class il{constructor(n,r){this.b=n,this.len=r}getMaxDerivative(){return 1}getValue(n,r){return 0===n?this.len-yr(this.b,r,!1):0}getError(n){return(0,R.g)(0),0}}function nl(f,n,r,l,_){let x=!0;const E=(0,c.m)(c.P,3);f.queryControlPoints(E);let v=x?0:1,I=E[1][v]-E[0][v],D=E[2][v]-E[0][v];const G=ji(5,n,r,l,_,B=>{let z;if(B<=.5){const L=(0,c.Q)(0,I,B),j=(0,c.Q)(I,D,B);z=(0,c.Q)(L,j,B)}else{const L=(0,c.R)(0,I,B),j=(0,c.R)(I,D,B);z=(0,c.R)(L,j,B)}return z*Cr(E,1,B).length()});x=!1,v=x?0:1,I=E[1][v]-E[0][v],D=E[2][v]-E[0][v];const q=ji(5,n,r,l,_,B=>{let z;if(B<=.5){const L=(0,c.Q)(0,I,B),j=(0,c.Q)(I,D,B);z=(0,c.Q)(L,j,B)}else{const L=(0,c.R)(0,I,B),j=(0,c.R)(I,D,B);z=(0,c.R)(L,j,B)}return z*Cr(E,1,B).length()});return new c.P(G,q)}function no(f){f.m_cachedValues=null}function ro(f){if(f.m_cachedValues)return f.m_cachedValues;const n=new sl;return Ch(f,n.specialPoints),Uo(f,n),n}function Ch(f,n){const r=(0,c.m)(c.P,3);f.queryControlPoints(r);const l=(0,c.m)(c.F,8);l[0].set(0);let _=1;{const x=(0,c.m)(c.F,3);!function ml(f,n,r=!1){const _=new c.F(f[1][0]).subE(new c.F(f[0][0]));n[1]=_.mul(2),n[2]=new c.F(f[2][0]).subE(new c.F(f[1][0])).subE(_),n[0].set(r?0:f[0][0])}(r,x,!1);const E=(0,c.m)(c.F,2),v=new c.E(0,1);let I=W(x[2].mul(2),x[1],v,E[0]);I<0&&(I=0);for(let D=0;D<I;D++)(0,c.J)(E[D].value(),0,1)||(l[_]=E[D],_++)}{const x=(0,c.m)(c.F,3);!function Ah(f,n,r=!1){const _=new c.F(f[1][1]).subE(new c.F(f[0][1]));n[1]=_.mul(2),n[2]=new c.F(f[2][1]).subE(new c.F(f[1][1])).subE(_),n[0].set(r?0:f[0][1])}(r,x,!1);const E=(0,c.m)(c.F,2),v=new c.E(0,1);let I=W(x[2].mul(2),x[1],v,E[0]);I<0&&(I=0);for(let D=0;D<I;D++)(0,c.J)(E[D].value(),0,1)||(l[_]=E[D],_++)}if(l[_].set(1),_++,_>2){(0,c.C)(l,0,_,(I,D)=>I.value()-D.value());let x=0,E=l[0].value(),v=1;for(let I=1;I<_;I++)l[I].eq(l[I-1])?(E+=l[I].value(),v++):(v>1&&(E/=v,l[x].set(E)),x++,l[x]=l[I],E=l[I].value(),v=1);x++,_=x}l[0].set(0),l[_-1].set(1),n.length=_;for(let x=0;x<_;x++)n[x]=l[x].value()}function yr(f,n,r){const l=(0,c.m)(c.P,3);return f.queryControlPoints(l),Sh(l,n,r)}function Sh(f,n,r){if(r){if(n<0)return n;if(n>1)return n-1+Sh(f,1,!1)}if(1===n)return zo(f);const l=(0,c.m)(c.P,3);return Dr(f,n,l,null),zo(l)}function zo(f){if(f[0].equals(f[1]))return c.P.distance(f[2],f[0]);if(f[1].equals(f[2]))return c.P.distance(f[0],f[2]);const n=c.P.distance(f[0],f[1])+c.P.distance(f[2],f[1]),r=c.P.distance(f[0],f[2]);if(n-r<=n*Number.EPSILON)return r;const _=(0,c.m)(c.P,3);Zo(f,_,!0);const x=4*((0,c.s)(_[2].x)+(0,c.s)(_[2].y)),E=2*(_[2].x*_[1].x+_[2].y*_[1].y),v=(0,c.s)(_[1].x)+(0,c.s)(_[1].y);if(1e-14*(Math.abs(E)+Math.abs(v))>=Math.abs(x))return 1e-14*Math.abs(v)>=Math.abs(E)?1*Math.sqrt(v):2/(3*E)*(Math.pow(1*E+v,1.5)-Math.pow(v,1.5));const I=E/x,D=v/x,G=D-I*I,q=1+I;if(0===G)return I>=0&&q>=0||I<=0&&q<=0?Math.abs(.5*Math.sqrt(x)*(q*q-I*I)):.5*Math.sqrt(x)*(q*q+I*I);const B=Math.sqrt(G+q*q),z=Math.sqrt(D);return.5*Math.sqrt(x)*(q*B-I*z+G*Math.log(Math.abs((q+B)/(I+z))))}function vh(f,n){const r=(0,c.c)(n,0,1);let l=Cr(f,1,r);return l.isZero()&&(l=Cr(f,2,r)),l}function Er(f,n,r){const l=(0,c.m)(c.P,3);return f.queryControlPoints(l),Cr(l,n,r)}function Cr(f,n,r){if(1===n){const l=f[1].sub(f[0]).mul(1-r).add(f[2].sub(f[1]).mul(r));return l.mulThis(2),l}return 2===n?f[2].sub(f[1]).sub(f[1].sub(f[0]).mul(2)):c.P.construct(0,0)}function bh(f){const n=(0,c.m)(c.P,3);return f.queryControlPoints(n),Sr(n)}function Sr(f){return-f[1].sub(f[0]).crossProduct(f[2].sub(f[0]))/3}function Ih(f){return f.m_cachedValues}function Uo(f,n){f.m_cachedValues=n}function ys(f,n,r,l,_){(0,R.w)(c.E.unit().contains(r),"QuadraticBezierHelper::getClosestCoordinateSegment");const x=(0,c.m)(c.P,3);f.queryControlPoints(x);let E=Number.MAX_VALUE;const v=[0],I=Pn(x,n,v);if(r.containsCoordinate(v[0]))E=c.P.distance(n,I);else{v[0]=r.vmin,ni(x,v[0],I),E=c.P.distance(I,n);const D=new c.P;ni(x,r.vmax,D);const G=c.P.distance(D,n);E>G&&(I.setCoordsPoint2D(D),v[0]=r.vmax,E=G)}if(!l)return v[0];if(r.vmin<=0){const D=new c.P;f.queryCoord2DExtended(-1,D,!0);const G=new c.P;f.queryCoord2D(r.vmin,G);const q=new ke({start:D,end:G}),B=q.getClosestCoordinate(n,!0);if(B<1){const z=q.getCoord2D(B),L=c.P.distance(z,n);L<E&&(E=L,v[0]=B-1,I.assign(z))}}if(r.vmin>=1){const D=new c.P;f.queryCoord2DExtended(2,D,!0);const G=new c.P;f.queryCoord2D(r.vmax,G);const q=new ke({start:G,end:D}),B=q.getClosestCoordinate(n,!0);if(B>0){const z=q.getCoord2D(B),L=c.P.distance(z,n);L<E&&(E=L,v[0]=1+B,I.assign(z))}}return v[0]}function Pn(f,n,r){const l=f[2].sub(f[1]).sub(f[1].sub(f[0])),_=f[1].sub(f[0]),x=f[0].sub(n),E=x.dotProduct(_),v=x.dotProduct(l)+2*_.dotProduct(_),I=3*_.dotProduct(l),D=l.dotProduct(l),G=(0,c.d)(3,Number.NaN),q=Ks(D,I,v,E,c.E.unit(),!1,G),B=f[0].clone();let z=0,L=c.P.sqrDistance(f[0],n),j=c.P.sqrDistance(f[2],n);j<L&&(z=1,B.assign(f[2]),L=j);for(let Q=0;Q<q;Q++){const et=new c.P;ni(f,G[Q],et),j=c.P.sqrDistance(et,n),j<L&&(L=j,B.assign(et),z=G[Q])}return r&&(r[0]=z),B}function Ir(f,n,r){if(n.equalsRange(0,1))return void r.setFromPoints(f,3);const l=(0,c.m)(c.P,3);Rn(f,n.vmin,n.vmax,l),r.setFromPoints(l,3)}function oo(f,n,r){r.setEmpty();const l=[];l.push(new c.E(0,1));const _=.5*Math.max(n.width(),n.height());for(;l.length;){const x=l.at(-1);l.pop();const E=new jt;if(Ir(f,x,E),E.isIntersectingW(n)){const v=Math.max(E.width(),E.height());if(n.containsW(E)||v<=_||x.width()<1e-12)r.merge(x);else{const I=x.getCenter();l.push(c.E.construct(x.vmin,I)),l.push(c.E.construct(I,x.vmax))}}}}function wr(f){const n=(0,c.m)(c.P,3);f.queryControlPoints(n);const r=Mi(n);return r&&(f.m_cp.setCoordsPoint2D(n[1]),f.afterCompletedModification()),r}function Mi(f){let n=!1;for(let r=0;r<2;r++){const l=(0,c.Y)(f[0][r],f[2][r]);l>0?((0,c.Y)(f[0][r],f[1][r])<0&&(f[1][r]=f[0][r],n=!0),(0,c.Y)(f[1][r],f[2][r])<0&&(f[1][r]=f[2][r],n=!0)):l<0?((0,c.Y)(f[0][r],f[1][r])>0&&(f[1][r]=f[0][r],n=!0),(0,c.Y)(f[1][r],f[2][r])>0&&(f[1][r]=f[2][r],n=!0)):f[1][r]!==f[0][r]&&(f[1][r]=f[0][r],n=!0)}return n}function Dr(f,n,r,l){(new c.P).setCoordsPoint2D(f[0]),(new c.P).setCoordsPoint2D(f[1]),(new c.P).setCoordsPoint2D(f[2]);const _=new c.P,x=new c.P,E=new c.P;if((0,c.Z)(f[0],f[1],n,_),(0,c.Z)(f[1],f[2],n,x),(0,c.Z)(_,x,n,E),r&&(r[0].assign(f[0]),r[1].assign(_),r[2].assign(E)),l){const v=f[2];l[0].assign(E),l[1].assign(x),l[2].assign(v)}}function Rn(f,n,r,l){if(n===r){const x=new c.P;return ni(f,n,x),l[0]=x,l[1]=x,void(l[2]=x)}const _=(0,c.m)(c.P,3);Dr(f,r,_,null),Dr(_,n/r,null,_),ni(f,n,_[0]),ni(f,r,_[2]),l[0].setCoordsPoint2D(_[0]),l[1].setCoordsPoint2D(_[1]),l[2].setCoordsPoint2D(_[2])}function Oo(f,n,r,l,_){if(_){if(0!==Fs(n,r))return f?4:2}else if(_e(n,r))return 1;return 0!==kn(f,n,r,null,null,null,l,_??!1,!0,!1)?4:0}function Wo(f,n,r,l,_){if(_){if(0!==Fs(n,r))return f?4:2}else if(_e(n,r))return 1;return 0!==jo(f,n,r,null,null,null,l,_??!1,!0,!1)?4:0}function kn(f,n,r,l,_,x,E,v,I,D){if(null!=_&&(_.length=0),null!==x&&(x.length=0),null!==l&&(l.length=0),r.isDegenerate(0)){const ft=[0,0],bt=n.intersectPoint(r.getStartXY(),ft,E);if(bt>0){if(null!==_)for(let Dt=0;Dt<bt;Dt++)_.push(ft[Dt]);if(null!==x)for(let Dt=0;Dt<bt;Dt++)x.push(0);if(null!==l)for(let Dt=0;Dt<bt;Dt++){const Nt=new c.P;n.queryCoord2D(ft[Dt],Nt),l.push(Nt)}}return bt}const G=qe(n,r);if(E=Math.max(E,G),n.isDegenerateToLineHelper(G)){const ft=new ke({start:n.getStartXY(),end:n.getEndXY()}),bt=Gn(ft,r,l,_,x,E,v,D);if(_)for(let Dt=0;Dt<bt;++Dt){const Nt=ft.getCoord2D(_[Dt]);_[Dt]=n.getClosestCoordinate(Nt,!1)}return bt}if(Ps(n,r,E))return 0;const q=Ne.constructPoint2D(r.getStartXY()),B=Ne.constructPoint2D(r.getEndXY()).sub(q),z=B.clone();z.leftPerpendicularThis();const L=Ne.constructPoint2D(n.m_cp).sub(Ne.constructPoint2D(n.getStartXY())),j=Ne.constructPoint2D(n.getEndXY()).sub(Ne.constructPoint2D(n.m_cp));let Q=L.dotProduct(z).toDouble(),et=j.sub(L).dotProduct(z).toDouble();const K=(0,c.d)(12,Number.NaN),rt=(0,c.d)(12,Number.NaN);let ot=function ii(f,n,r,l){const _=new c.F,x=W(new c.F(f),new c.F(n),r,_);return l[0]=_.value(),x}(et,Q,c.E.unit(),K);ot<0&&(K[0]=0,K[1]=1,ot=2);let nt,at=0;for(let ft=0,bt=at;ft<ot;++ft){const Dt=n.getCoord2D(K[ft+bt]);rt[at]=r.getClosestCoordinate(Dt,!1),c.P.distance(Dt,r.getCoord2D(rt[at]))<=E&&(K[at]=K[ft+bt],at++)}const pt=(0,c.m)(c.P,3);n.queryControlPoints(pt);{const ft=(0,c.m)(Ne,3);if(yn(pt,ft,!1),ft[0]=ft[0].sub(q),B.x.abs().gte(B.y.abs())){const bt=B.y.div(B.x);et=ft[2].y.sub(ft[2].x.mul(bt)).toDouble(),Q=ft[1].y.sub(ft[1].x.mul(bt)).toDouble(),nt=ft[0].y.sub(ft[0].x.mul(bt)).toDouble()}else{const bt=B.x.div(B.y);et=ft[2].x.sub(ft[2].y.mul(bt)).toDouble(),Q=ft[1].x.sub(ft[1].y.mul(bt)).toDouble(),nt=ft[0].x.sub(ft[0].y.mul(bt)).toDouble()}}const gt=n.getEndXY().equals(r.getStartXY())||n.getEndXY().equals(r.getEndXY()),yt=[0,0];ot=Ns(et,Q,nt,c.E.unit(),gt,yt);for(let ft=0,bt=at;ft<ot;++ft){K[ft+bt]=yt[ft];const Dt=n.getCoord2D(K[ft+bt]);rt[at]=r.getClosestCoordinate(Dt,!1),c.P.distance(Dt,r.getCoord2D(rt[at]))<=E&&(K[at]=K[ft+bt],at++)}(0,R.g)(at<K.length+4),ot=n.intersectPoint(r.getStartXY(),yt,E);for(let ft=0;ft<ot;ft++)K[at]=yt[ft],rt[at++]=0;ot=n.intersectPoint(r.getEndXY(),yt,E);for(let ft=0;ft<ot;ft++)K[at]=yt[ft],rt[at++]=1;ot=r.intersectPoint(n.getStartXY(),yt,E);for(let ft=0;ft<ot;ft++)rt[at]=yt[ft],K[at++]=0;ot=r.intersectPoint(n.getEndXY(),yt,E);for(let ft=0;ft<ot;ft++)rt[at]=yt[ft],K[at++]=0;return 0===at?0:Ws(f,n,r,K,rt,at,l,_,x,E,v,0,D)}function jo(f,n,r,l,_,x,E,v,I,D){if(ss(r))return kn(f,n,new ke({start:r.getStartXY(),end:r.getEndXY()}),l,_,x,E,v,0,D);const G=qe(n,r);if(Ps(n,r,E=Math.max(E,G)))return 0;const q=[],B=[],z=(0,c.m)(c.P,3);{n.queryControlPoints(z);const j=(0,c.m)(c.P,3),Q=new Y.T;r.canonicToWorldTransformation(Q);const et=new Y.T;et.setInvert(Q),et.transformPoints2D(z,3,j);const K=(0,c.m)(Ne,3);yn(j,K);const rt=[K[0].x,K[1].x,K[2].x],ot=[K[0].y,K[1].y,K[2].y],nt=(0,c.m)(c.M,3);nt[0].setDouble(r.getSemiMinorAxis()),nt[0].sqrThis(),nt[1].setDouble(r.getSemiMajorAxis()),nt[1].sqrThis(),nt[2]=nt[0],nt[2].mul(nt[1]),nt[2].negate();const at=Fo(rt,2,ot,2,null,0,nt,0,c.E.unit(),c.E.unit(),q);if(at>0){let pt=0;for(let gt=0;gt<at;gt++){const yt=new c.P;n.queryCoord2D(q[gt],yt);const ft=r.getClosestCoordinate(yt,!1),bt=new c.P;r.queryCoord2D(ft,bt),c.P.distance(yt,bt)<=E&&(q[pt]=q[gt],B.push(ft),pt++)}q.length=pt}}const L=[0,1];for(let j=0;j<2;j++){const Q=0===j?r.getStartXY():r.getEndXY(),et=[0];Pn(z,Q,et);const K=new c.P;ni(z,et[0],K),c.P.distance(Q,K)<=E&&(q.push(et[0]),B.push(L[j]))}for(let j=0;j<2;j++){const Q=[0,2];{const et=r.getClosestCoordinate(z[Q[j]],!1),K=new c.P;r.queryCoord2D(et,K),c.P.distance(z[Q[j]],K)<=E&&(q.push(L[j]),B.push(et))}}return Ws(f,n,r,q,B,q.length,l,_,x,E,v,0,D)}function Jo(f,n,r,l,_,x,E,v,I,D){const G=(0,c.m)(c.P,3);n.queryControlPoints(G);const q=(0,c.m)(c.P,3);if(r.queryControlPoints(q),ds(G,q,3)<0)return Jo(f,r,n,l,x,_,E,v,I,!D);const B=qe(n,r);if(Ps(n,r,E=Math.max(E,B)))return 0;if(function _l(f,n,r,l,_,x,E,v,I){const D=(0,c.m)(c.P,3);f.queryControlPoints(D);const G=(0,c.m)(c.P,3);if(n.queryControlPoints(G),D[0].equals(G[0])){if(D[1].equals(G[1])&&D[2].equals(G[2]))return r&&(r.length=0,r.push(D[0]),r.push(D[2])),l&&(l.length=0,l.push(0),l.push(1)),_&&(_.length=0,_.push(0),_.push(1)),!0;if(!D[0].equals(G[2]))return!1}return!!(D[0].equals(G[2])&&D[1].equals(G[1])&&D[2].equals(G[0]))&&(l&&(l.length=0,l.push(0),l.push(1),I&&(l[1]=(0,c.b)(l[0],l[0]=l[1]))),_&&(_.length=0,_.push(1),_.push(0),I&&(_[1]=(0,c.b)(_[0],_[0]=_[1]))),r&&(r.length=0,r.push(D[0]),r.push(D[2]),I&&(r[1]=(0,c.b)(r[0],r[0]=r[1]))),!0)}(n,r,l,_,x,0,0,0,D))return 2;const z=new c.E(0,1),L=new c.E(0,1);{const K=new jt;Ir(G,c.E.unit(),K);const rt=new jt;Ir(q,c.E.unit(),rt);const ot=Math.max(K.maxDim(),rt.maxDim());if(K.inflate(3*E),rt.inflate(3*E),!K.intersectW(rt))return 0;if(K.maxDim()<.1*ot){if(oo(G,K,z),oo(q,K,L),z.isEmpty()||L.isEmpty())return 0;Rn(G,z.vmin,z.vmax,G),Rn(q,L.vmin,L.vmax,q)}}const j=tr(G,2,q,2,E);if(0===j)return 0;const Q=[],et=[];if(-1===j){const K=(0,c.m)(Ne,3);yn(G,K);const rt=[K[0].x,K[1].x,K[2].x],ot=[K[0].y,K[1].y,K[2].y],nt=(0,c.m)(Ne,3);yn(q,nt);const at=ui(rt,2,ot,2,null,0,[nt[0].x,nt[1].x,nt[2].x],2,[nt[0].y,nt[1].y,nt[2].y],2,null,0,0,c.E.unit(),c.E.unit(),Q,et,D);if(at>0){let pt=0;for(let gt=0;gt<at;gt++){const yt=new c.P,ft=new c.P;ni(q,et[gt],ft),ni(G,Q[gt],yt),c.P.distance(yt,ft)<=E&&(Q[pt]=Q[gt],et[pt]=et[gt],pt++)}Q.length=pt,et.length=pt}}for(let K=0;K<2;K++){const rt=0===K?G:q,ot=0===K?q:G;for(let nt=0;nt<2;nt++){const at=0===nt?0:2,pt=[0];Pn(ot,rt[at],pt);const gt=new c.P;ni(ot,pt[0],gt),c.P.distance(rt[at],gt)<=E&&(0===K?(Q.push(0===at?0:1),et.push(pt[0])):(et.push(0===at?0:1),Q.push(pt[0])))}}if(0===Q.length)return 0;if(!z.equalsRange(0,1))for(let K=0;K<Q.length;++K)Q[K]=ns.recalculateParentT(z.vmin,z.vmax,Q[K]);if(!L.equalsRange(0,1))for(let K=0;K<et.length;++K)et[K]=ns.recalculateParentT(L.vmin,L.vmax,et[K]);return Ws(f,n,r,Q,et,Q.length,l,_,x,E,v,0,D)}function Zo(f,n,r=!1){const l=f[1].sub(f[0]);n[1].assign(l.mul(2)),n[2].assign(f[2].sub(f[1]).sub(l)),r?n[0].setCoords(0,0):n[0].assign(f[0])}function yn(f,n,r=!1){const l=Ne.constructPoint2D(f[1]),_=l.sub(Ne.constructPoint2D(f[0]));n[1]=_.mul(c.M.constructInt32(2)),n[2]=Ne.constructPoint2D(f[2]).sub(l).sub(_),n[0]=r?new Ne(c.ad,c.ad):Ne.constructPoint2D(f[0])}function ni(f,n,r,l){if(l){if(n<0)return void Us(new ke({start:f[0],end:f[0].add(vh(f,0).getUnitVector())}),n,r);if(n>1)return void Us(new ke({start:f[2],end:f[2].add(vh(f,1).getUnitVector())}),n-1,r)}if(n<=.5){const _=f[1].clone(),x=new c.P;(0,c.V)(2,f[0],_,n,x);const E=new c.P;(0,c.V)(2,_,f[2],n,E);const v=new c.P;(0,c.V)(2,x,E,n,v),r.assign(v)}else{const _=f[1].clone(),x=new c.P;(0,c.W)(2,f[0],_,n,x);const E=new c.P;(0,c.W)(2,_,f[2],n,E);const v=new c.P;(0,c.W)(2,x,E,n,v),r.assign(v)}}var ao=F.V;class fi extends Ls{constructor(n){n&&n.cp?(super({start:n.cp[0],end:n.cp[3],vd:n.vd}),this.m_cp=(0,c.m)(c.P,2),this.m_cp[0].assign(n.cp[1]),this.m_cp[1].assign(n.cp[2])):void 0===n||(0,c.O)(n,"vd")?(super({vd:n?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=(0,c.m)(c.P,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)):n.from?(super({start:n.from,end:n.to,vd:n.vd}),this.m_cp=(0,c.m)(c.P,2),this.m_cp[0].assign(n.cp1),this.m_cp[1].assign(n.cp2)):(super({XStart:0,YStart:0,XEnd:0,YEnd:0,vd:n.vd}),(0,R.c)("unrecognized constructor params"),this.m_cp=(0,c.m)(c.P,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)),this.m_cachedValues=0}getBoundary(){return mi(this)}construct(n,r,l,_){this.m_XStart=n.x,this.m_YStart=n.y,this.m_XEnd=_.x,this.m_YEnd=_.y,this.m_cp[0].assign(r),this.m_cp[1].assign(l),this.afterCompletedModification()}constructPoints(n){this.m_XStart=n[0].x,this.m_YStart=n[0].y,this.m_XEnd=n[3].x,this.m_YEnd=n[3].y,this.m_cp[0].assign(n[1]),this.m_cp[1].assign(n[2]),this.afterCompletedModification()}constructFromQuadratic(n){const r=(0,c.m)(c.P,4);(function Qo(f,n){n[0].assign(f[0]),n[3].assign(f[2]),(0,c.Z)(f[0],f[1],2/3,n[1]),(0,c.Z)(f[1],f[2],1/3,n[2])})(n,r),this.constructPoints(r)}constructFromQuadraticSegment(n){this.dropAllAttributes(),this.assignVertexDescription(n.getDescription()),this.m_XStart=n.getStartX(),this.m_YStart=n.getStartY(),this.m_XEnd=n.getEndX(),this.m_YEnd=n.getEndY(),(0,c.a0)(2,n.getStartXY(),n.getControlPoint1(),2/3,this.m_cp[0]),(0,c.a0)(2,n.getControlPoint1(),n.getEndXY(),1/3,this.m_cp[1]),this.afterCompletedModification(),Ts(this,n)}getGeometryType(){return R.G.enumBezier}queryEnvelope(n){if(2!==n.m_EnvelopeType)return void(0,R.g)(0);if(n.setCoords(this.getStartXY()),n.mergeNe(this.getEndXY()),n.contains(this.m_cp[0])&&n.contains(this.m_cp[1]))return;const r=oi(this);if(null!==r){const v=new c.P;for(const I of r.specialPoints)this.queryCoord2D(I,v),n.mergeNe(v);return}const l=(0,c.m)(c.F,8),_=(0,c.m)(c.P,4);this.queryControlPoints(_);const x=ra(_,l),E=new c.P;for(let v=1;v<x-1;v++)this.queryCoord2D(l[v].value(),E),n.mergeNe(E)}applyTransformation(n){if(1===n.m_TransformationType){const r=(0,c.m)(c.P,4);return this.queryControlPoints(r),n.transformPoints2D(r,4,r),this.setStartXY(r[0]),this.m_cp[0].assign(r[1]),this.m_cp[1].assign(r[2]),this.setEndXY(r[3]),void xi(this)}(0,R.g)(0)}createInstance(){return new fi({vd:this.m_description})}calculateLength2D(){return Tr(this,1,!1)}calculateLowerLength2D(){return c.P.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return c.P.distance(this.getStartXY(),this.m_cp[0])+c.P.distance(this.m_cp[0],this.m_cp[1])+c.P.distance(this.getEndXY(),this.m_cp[1])}queryCoord2D(n,r){return this.queryCoord2DExtends(n,r,!0)}queryCoord2DExtends(n,r,l){const _=(0,c.m)(c.P,4);this.queryControlPoints(_),$e(_,n,r,l)}queryCoord2DE(n,r){!function Ko(f,n,r){const l=(0,c.m)(c.P,4);f.queryControlPoints(l),function Cl(f,n,r){if(n.value()<=.5){const l=new Vt;(0,c.a1)(2,Vt.constructPoint2D(f[0]),Vt.constructPoint2D(f[1]),n,l);const _=new Vt;(0,c.a1)(2,Vt.constructPoint2D(f[1]),Vt.constructPoint2D(f[2]),n,_);const x=new Vt;(0,c.a1)(2,Vt.constructPoint2D(f[2]),Vt.constructPoint2D(f[3]),n,x);const E=new Vt;(0,c.a1)(2,l,_,n,E);const v=new Vt;(0,c.a1)(2,_,x,n,v),(0,c.a1)(2,E,v,n,r)}else{const l=new Vt;(0,c.a2)(2,Vt.constructPoint2D(f[0]),Vt.constructPoint2D(f[1]),n,l);const _=new Vt;(0,c.a2)(2,Vt.constructPoint2D(f[1]),Vt.constructPoint2D(f[2]),n,_);const x=new Vt;(0,c.a2)(2,Vt.constructPoint2D(f[2]),Vt.constructPoint2D(f[3]),n,x);const E=new Vt;(0,c.a2)(2,l,_,n,E);const v=new Vt;(0,c.a2)(2,_,x,n,v),(0,c.a2)(2,E,v,n,r)}}(l,n,r)}(this,n,r)}getCoordX(n){if(n<0||n>1){const v=new c.P;return this.queryCoord2DExtends(n,v,!0),v.x}const r=(0,c.q)(this.getStartX(),this.m_cp[0].x,n),l=(0,c.q)(this.m_cp[0].x,this.m_cp[1].x,n),_=(0,c.q)(this.m_cp[1].x,this.getEndX(),n),x=(0,c.q)(r,l,n),E=(0,c.q)(l,_,n);return(0,c.q)(x,E,n)}getCoordY(n){if(n<0||n>1){const v=new c.P;return this.queryCoord2DExtends(n,v,!0),v.y}const r=(0,c.q)(this.getStartY(),this.m_cp[0].y,n),l=(0,c.q)(this.m_cp[0].y,this.m_cp[1].y,n),_=(0,c.q)(this.m_cp[1].y,this.getEndY(),n),x=(0,c.q)(r,l,n),E=(0,c.q)(l,_,n);return(0,c.q)(x,E,n)}cut(n,r,l){const _=new is;return this.queryCut(n,r,_,l),_.releaseSegment()}queryCut(n,r,l,_){const x=l.createCubicBezier();if(this.cutBezierIgnoreAttributes(n,r,x),_)return;x.assignVertexDescription(this.m_description);const E=this.m_description.getAttributeCount();if(E>1){for(let v=1;v<E;v++){const I=this.m_description.getSemantics(v),D=ao.getComponentCount(I);for(let G=0;G<D;G++){const q=this.getAttributeAsDbl(n,I,G);x.setStartAttribute(I,G,q)}}for(let v=1;v<E;v++){const I=this.m_description.getSemantics(v),D=ao.getComponentCount(I);for(let G=0;G<D;G++){const q=this.getAttributeAsDbl(r,I,G);x.setEndAttribute(I,G,q)}}}}queryDerivative(n,r){kh(this,n,r)}cutBezierIgnoreAttributes(n,r,l){(n<0||r>1||n>r)&&(0,R.t)("Cubic_bezier.cut_bezier_ignore_attributes");const _=(0,c.m)(c.P,4);this.queryControlPoints(_);const x=(0,c.m)(c.P,4);ln(_,n,r,x),l.setControlPoints(x)}splitBezierIgnoreAttributes(n,r,l){this===r&&this===l&&(0,R.t)("Cubic_bezier.split_bezier_ignore_attributes");const _=(0,c.m)(c.P,4);this.queryControlPoints(_);const x=(0,c.m)(c.P,4),E=(0,c.m)(c.P,4);mn(_,n,x,E),r&&r.setControlPoints(x),l&&l.setControlPoints(E)}getAttributeAsDbl(n,r,l){if(0===r)return 0===l?this.getCoordX(n):this.getCoordY(n);if(0===n)return this.getStartAttributeAsDbl(r,l);if(1===n)return this.getEndAttributeAsDbl(r,l);const _=this.getStartAttributeAsDbl(r,l),x=this.getEndAttributeAsDbl(r,l),E=this.calculateLength2D(),v=E>0?this.tToLength(n)/E:0,I=ao.getInterpolation(r);return(0,c.T)(I,_,x,v,ao.getDefaultValue(r))}getClosestCoordinate(n,r){const l=[Number.NaN];return On(this,n,c.E.unit(),r,-1,1,l),l[0]}getClosestCoordinateOnInterval(n,r,l=-1){const _=[Number.NaN];return 0===On(this,n,r,!1,l,1,_)?Number.NaN:_[0]}getYMonotonicParts(n,r=!1){return this.getMonotonicParts(n,r)}getMonotonicParts(n,r){n.length<2&&(0,R.t)("");const l=Nr(this);if(2===l.specialPointsCount()&&this.isMonotoneQuickAndDirty())return 0;let _=0;(0,R.g)(n.length>=l.specialPointsCount()-1);for(let x=1,E=l.specialPointsCount();x<E;++x)this.queryCut(l.specialPoints[x-1],l.specialPoints[x],n[_],r),_++;for(let x=0;x<_;++x)mo(n[x].get());return _}intersectionWithAxis2D(n,r,l,_){const x=(0,c.m)(c.P,4);return this.queryControlPoints(x),function Uh(f,n,r,l,_){const x=(0,c.m)(c.F,4),E=(0,c.m)(c.F,3),v=new c.E(0,1);let I=0;if(n){if(ri(f,x,!1),I=lt(x[3],x[2],x[1],x[0].sub(r),v,!1,E),l)for(let D=0;D<I;D++){const G=new c.P;$e(f,E[D].value(),G),l[D]=G.x}}else if(Hn(f,x,!1),I=lt(x[3],x[2],x[1],x[0].sub(r),v,!1,E),l)for(let D=0;D<I;D++){const G=new c.P;$e(f,E[D].value(),G),l[D]=G.y}if(_)for(let D=0;D<I;D++)_[D]=E[D].value();else l&&(0,c.C)(l,0,I,c.X);return I}(x,n,r,l,_)}intersectionOfYMonotonicWithAxisX(n,r){if(this.m_YStart===this.m_YEnd)return n===this.m_YStart?r:Number.NaN;if(n===this.m_YStart)return this.m_XStart;if(n===this.m_YEnd)return this.m_XEnd;const l=[0,0],_=this.intersectionWithAxis2D(!0,n,l,null);return(0,R.g)(2!==_),-1===_?r:l[0]}isCurve(){return!0}isDegenerate(n){return Te(this,n)}isDegenerate3D(n,r){return(0,R.g)(0),!1}queryLooseEnvelope(n){if(2===n.m_EnvelopeType)return n.setCoords({pt:this.getStartXY()}),n.mergeNe(this.m_cp[0]),n.mergeNe(this.m_cp[1]),void n.mergeNe(this.getEndXY());(0,R.g)(0)}clone(n){const r=this.createInstance();return this.copyTo(r),r}queryInterval(n,r){if(0===n){const l=dt.J.constructEmpty();this.queryEnvelope(l);const _=c.E.constructEmpty();return 0===r?l.queryIntervalX(_):l.queryIntervalY(_),_}return super.queryInterval(n,r)}queryLooseEnvelopeOnInterval(n,r){const l=(0,c.m)(c.P,4);this.queryControlPoints(l),ln(l,n.vmin,n.vmax,l),r.setFromPoints(l,4)}changeEndPoints2D(n,r){if(n.isEqual(this.m_XStart,this.m_YStart)&&r.isEqual(this.m_XEnd,this.m_YEnd))return;const l=this.m_cp[0].isEqual(this.m_XStart,this.m_YStart),_=this.m_cp[0].isEqual(this.m_XEnd,this.m_YEnd),x=this.m_cp[1].isEqual(this.m_XStart,this.m_YStart),E=this.m_cp[1].isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(n),this.setEndXY(r),l?this.m_cp[0].setCoordsPoint2D(n):_&&this.m_cp[0].setCoordsPoint2D(r),E?this.m_cp[1].setCoordsPoint2D(r):x&&this.m_cp[1].setCoordsPoint2D(n),this.normalizeAfterEndpointChange()}tToLength(n){return Tr(this,n,!0)}lengthToT(n){return function Yh(f,n,r){const l=Tr(f,1,!1);if(n<=0)return n;if(n>=l)return n-l+1;const _=[0];return 1!==wi(new Dl(f,n),c.E.unit(),1,_)&&(0,R.c)(""),_[0]}(this,n)}calculateWeightedAreaCentroid2D(n){const r=(0,c.m)(c.P,4);qh(this,r);const l=r[3],_=r[2],x=r[1],E=new c.P;E.x=(5*l.x*l.x*(7*_.y+16*x.y)+l.x*(-35*l.y*_.x+40*_.x*_.y-80*l.y*x.x+140*_.x*x.y+112*x.x*x.y)-2*(l.y*(20*_.x*_.x+70*_.x*x.x+56*x.x*x.x)-7*(4*_.x+5*x.x)*(-_.y*x.x+_.x*x.y)))/840,E.y=(-5*l.y*l.y*(7*_.x+16*x.x)+l.y*(5*l.x*(7*_.y+16*x.y)-4*(10*_.x*_.y+35*_.y*x.x+28*x.x*x.y))+2*(-7*(4*_.y+5*x.y)*(_.y*x.x-_.x*x.y)+l.x*(20*_.y*_.y+70*_.y*x.y+56*x.y*x.y)))/840;const v=Rh(this);return E.x+=(r[0].x-n.x)*v,E.y+=(r[0].y-n.y)*v,E}calculateWeightedCentroid2D(){const n=new c.P;return this.isDegenerate(0)?(n.setCoords(0,0),n):function fl(f){const n=c.P.distance(f.getStartXY(),f.getEndXY()),r=f.calculateUpperLength2D();return r-n<=8*Number.EPSILON*r}(this)?(n.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),n):(n.assign(function xl(f,n,r){void 0===r&&(r=n,n=0);const l=new c.P;if(n<0||r>1)return l.setNAN(),l;if(n>r&&(0,R.t)("calculate_sub_weightedCentroid"),n===r||f.isDegenerate(0))return l.setCoords(0,0),l;const _=Nr(f),x=Mh(f),E=x/f.calculateUpperLength2D();let v=n,I=0;for(let D=1,G=_.specialPointsCount();D<G;D++)if(n<_.specialPoints[D]){I=D-1;break}l.setCoords(0,0);for(let D=I+1,G=_.specialPointsCount();D<G;D++){const q=Math.min(_.specialPoints[D],r),B=Nl(f,v,q,E,x);if(l.addThis(B),v=q,r<=_.specialPoints[D])break}return l.add(f.getStartXY().mul(f.calculateLength2D()))}(this,1)),n)}getControlPoint1(){return this.m_cp[0].clone()}setControlPoint1(n){this.m_cp[0].setCoordsPoint2D(n),this.afterCompletedModification()}getControlPoint2(){return this.m_cp[1].clone()}setControlPoint2(n){this.m_cp[1].setCoordsPoint2D(n),this.afterCompletedModification()}queryControlPoints(n){n[0].assign(this.getStartXY()),n[1].assign(this.m_cp[0]),n[2].assign(this.m_cp[1]),n[3].assign(this.getEndXY())}setControlPoints(n){for(let r=0;r<4;r++)n[r].isNAN()&&(0,R.t)("NAN control points in bezier are not supported");this.m_XStart=n[0].x,this.m_YStart=n[0].y,this.m_cp[0].setCoordsPoint2D(n[1]),this.m_cp[1].setCoordsPoint2D(n[2]),this.m_XEnd=n[3].x,this.m_YEnd=n[3].y,this.afterCompletedModification()}getTangent(n){const r=(0,c.m)(c.P,4);return this.queryControlPoints(r),Un(r,n)}getDerivative(n){const r=(0,c.m)(c.P,4);return this.queryControlPoints(r),Rs(r,1,n)}getCurvature(n){const r=sn(this,1,n),l=sn(this,2,n),_=r.sqrLength();return 0===_?Number.NaN:(r.divThis(Math.sqrt(_)),r.crossProduct(l)/_)}isIntersectingPoint(n,r,l){if(l&&(n.equals(this.getStartXY())||n.equals(this.getEndXY())))return!1;const _=new dt.J;if(this.queryLooseEnvelope(_),_.inflateCoords(r,r),!_.contains(n))return!1;const x=this.getClosestCoordinate(n,!1),E=new c.P;return this.queryCoord2D(x,E),c.P.distance(E,n)<=r}isIntersectingPoint3D(n,r,l,_,x=1){return(0,R.g)(0),!1}isMonotoneQuickAndDirty(){const n=(0,c.m)(c.P,4);return this.queryControlPoints(n),function uo(f){const n=(0,c.Y)(f[0].y,f[1].y),r=(0,c.Y)(f[1].y,f[2].y),l=(0,c.Y)(f[2].y,f[3].y);if(n>=0&&r>=0&&l>=0||n<=0&&r<=0&&l<=0){const _=(0,c.Y)(f[0].x,f[1].x),x=(0,c.Y)(f[1].x,f[2].x),E=(0,c.Y)(f[2].x,f[3].x);if(_>=0&&x>=0&&E>=0||_<=0&&x<=0&&E<=0)return!0}return!1}(n)}getMonotonicPartParams(n,r){const l=Nr(this),_=l.specialPointsCount();if((0,R.g)(qs.s_maxMonotonicPartParams>=_),!r)return l.specialPointsCount();n<_&&(0,R.t)("");for(let x=0;x<_;x++)r[x]=l.specialPoints[x];return _}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=(0,c.b)(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=(0,c.b)(this.m_YStart,this.m_YStart=this.m_YEnd);for(let n=0,r=this.m_description.getTotalComponentCount()-2;n<r;n++)this.m_attributes[n+r]=(0,c.b)(this.m_attributes[n],this.m_attributes[n]=this.m_attributes[n+r]);this.m_cp[1]=(0,c.b)(this.m_cp[0],this.m_cp[0]=this.m_cp[1]),this.m_cachedValues=null}}findMinDeriv(){const n=new c.F;return Xh(this,n),n.value()}isLine(){return!1}isDegenerateToLineHelper(n){const r=this.getEndXY().sub(this.getStartXY()),l=r.length(),_=.1*n;let x=this.getControlPoint1();x.subThis(this.getStartXY());let E=Math.abs(x.crossProduct(r))/l;return!(E>_||(x=this.getControlPoint2(),x.subThis(this.getStartXY()),E=Math.abs(x.crossProduct(r))/l,E>_))}copyIgnoreAttributes(n){const r=(0,c.m)(c.P,4);this.queryControlPoints(r),n.setControlPoints(r)}calculateArea2DHelper(){return Rh(this)}absNorm(){return function bl(f){return f.getStartXY().norm(1)+f.getEndXY().norm(1)+f.m_cp[0].norm(1)+f.m_cp[1].norm(1)}(this)}queryEnvelopeW(n,r){Hh(this,n,r)}setSegmentFromCoords(n,r){!function wl(f,n,r){if((0,R.g)(r>=2),2===r){const L=new c.P;(0,c.Z)(n[0],n[r-1],1/3,L);const j=new c.P;return(0,c.Z)(n[0],n[r-1],2/3,j),void f.construct(n[0],L,j,n[r-1])}const l=n[0],_=n[r-1],x=[0,0],E=On(f,l,c.E.unit(),!1,Number.NaN,2,x),v=[0,0],I=On(f,_,c.E.unit(),!1,Number.NaN,2,v),D=[];for(let L=0;L<E;L++)for(let j=0;j<I;j++){const Q=x[L],et=v[j],K=(at,pt)=>{const gt=(0,c.d)(r-2,Number.NaN),yt=()=>{let ie=0;for(let ne=1,De=r-1;ne<De;ne++)ie+=c.P.distance(n[ne-1],n[ne]),gt[ne-1]=ie;ie+=c.P.distance(n[r-2],n[r-1]);for(let ne=1,De=r-1;ne<De;ne++)gt[ne-1]/=ie};let ft=!1,bt=!1;{const ie=new is;Q<=et?(f.queryCut(Q,et,ie,!0),at.assign(ie.get().getControlPoint1()),pt.assign(ie.get().getControlPoint2())):(f.queryCut(et,Q,ie,!0),at.assign(ie.get().getControlPoint2()),pt.assign(ie.get().getControlPoint1())),l.equals(at)&&(ft=!0),_.equals(pt)&&(bt=!0)}yt();let Dt=Number.MAX_VALUE;const Nt=at.clone(),Ft=pt.clone();for(let ie=0;ie<5;ie++)Dt=aa(!0,!1,l,Nt,Ft,_,ft,bt,gt,0,n,r);for(let ie=0;ie<30;ie++){const ne=Nt.clone();Ft.clone();const De=aa(!0,!0,l,Nt,Ft,_,ft,bt,gt,0,n,r);if(Dt<=De&&ne.equals(Nt)&&ne.equals(Ft))break;Dt=De}yt();let Ot=!1,Qt=Number.EPSILON;const Kt=at.clone(),Ce=pt.clone();for(let ie=0;ie<30;ie++){const ne=Kt.clone();Ce.clone();const De=aa(Ot,!0,l,Kt,Ce,_,ft,bt,gt,0,n,r);if(Qt<=De&&ne.equals(Kt)&&ne.equals(Ce))break;Ot=!0,Qt=De}return Qt<Dt?(at.assign(Kt),pt.assign(Ce)):(at.assign(Nt),pt.assign(Ft),Qt=Dt),Qt},rt=new c.P,ot=new c.P,nt=[K(rt,ot),c.P.distance(l,rt)+c.P.distance(rt,ot)+c.P.distance(ot,_),rt.x,rt.y,ot.x,ot.y];D.splice(D.length,0,...nt)}let G=D[0],q=D[1],B=0;for(let L=6;L<D.length;L+=6)D[L]<G&&(G=D[L],q=D[L+1],B=L);let z=B;for(let L=0;L<D.length;L+=6)L!==B&&D[L+1]<q&&Math.abs(G-D[L])<10*G&&(q=D[L+1],z=L);f.construct(l,new c.P(D[z+2],D[z+3]),new c.P(D[z+4],D[z+5]),_)}(this,n,r)}writeInBufferStream(n,r){const l=new Float64Array(4);return this.writeInBuffer_(l),n.writeRangeFromArray(r,l.length,l,!0,1),r+l.length}writeInBuffer_(n){return n[0]=this.m_cp[0].x,n[1]=this.m_cp[0].y,n[2]=this.m_cp[1].x,n[3]=this.m_cp[1].y,4}readFromBufferStream(n,r){const l=new Float64Array(4);n.queryRange(r,l.length,l,!0,1),this.readFromBuffer_(l)}readFromBuffer_(n){this.m_cp=(0,c.m)(c.P,2),this.m_cp[0].x=n[0],this.m_cp[0].y=n[1],this.m_cp[1].x=n[2],this.m_cp[1].y=n[3],this.m_cachedValues=null}snapControlPoints(n){const r=(0,c.m)(c.P,4);this.queryControlPoints(r);const l=(E,v,I)=>{let D=!1;return c.P.sqrDistance(E,I)<=n&&(D=!E.equals(I),E.setCoordsPoint2D(I),c.P.sqrDistance(v,I)<=n&&(D||=!v.equals(I),v.setCoordsPoint2D(I))),D},_=l(r[1],r[2],r[0]),x=l(r[2],r[1],r[3]);return(_||x)&&this.setControlPoints(r),_||x}needsSnapControlPoints(n){if(!n)return!1;const r=(0,c.m)(c.P,4);this.queryControlPoints(r);const l=(E,v,I)=>{let D=!1;return c.P.sqrDistance(E,I)<=n&&(D=!E.equals(I),E.setCoordsPoint2D(I),c.P.sqrDistance(v,I)<=n&&(D||=!v.equals(I),v.setCoordsPoint2D(I))),D},_=l(r[1],r[2],r[0]),x=l(r[2],r[1],r[3]);return _||x}calculateSpecialPointsForCracking(n,r){return function Oh(f,n,r){r.length=0;{const gt=new c.F;Xh(f,gt);const yt=new Vt;if(kh(f,gt,yt),yt.isZero())return gt.isZero()||gt.eq(new c.F(1))?0:(r.push(gt.value()),1)}const l=(0,c.m)(c.F,4);Vh(f,l,!0);const _=(0,c.m)(c.F,4);Bn(f,_,!0);const x=(0,c.m)(c.F,6),E=l[3].negate().mulE(_[1]).addE(l[2].mulE(_[2]).mul(2)).addE(l[1].mulE(_[3])),v=l[3].negate().mulE(_[1]).subE(l[2].mulE(_[2]).mul(2)).addE(l[1].mulE(_[3])),I=l[2].mulE(l[2]).subE(_[2].mulE(_[2]));x[0]=_[1].mulE(_[1]).mulE(E).addE(l[1].mulE(l[1]).mulE(v)).addE(l[1].mulE(_[1]).mulE(I).mul(2)).mul(6),x[1]=l[2].mulE(_[1]).subE(l[1].mulE(_[2])).mulE(l[2].mulE(l[2]).addE(l[1].mulE(l[3]).mul(2)).addE(_[2].mulE(_[2])).addE(_[1].mulE(_[3]).mul(2))).mul(24);const D=l[1].mulE(_[2]).mulE(_[2]).mulE(_[3]),G=l[2].mulE(l[2]).mulE(l[3]).mulE(_[1]).subE(D).mul(156),q=l[3].mulE(_[1]).subE(l[1].mulE(_[3])),B=l[3].mulE(_[1]).subE(l[1].mulE(_[3])),z=l[1].mulE(l[3]).mulE(B).addE(_[1].mulE(_[3]).mulE(q)).mul(72),L=_[1].mulE(_[3]).subE(l[1].mulE(l[3])),j=l[2].mulE(_[2]).mulE(L).mul(120),Q=l[1].mulE(l[2]).mulE(l[2]).mulE(_[3]),et=l[3].mulE(_[1]).mulE(_[2]).mulE(_[2]).subE(Q).mul(36);x[2]=G.addE(z).addE(j).addE(et);const K=l[2].mulE(l[3]).mulE(l[3]).mulE(_[1]).subE(l[1].mulE(_[2]).mulE(_[3]).mulE(_[3])).mul(360),rt=l[2].mulE(_[2]).mulE(l[2].mulE(l[3]).subE(_[2].mulE(_[3]))).addE(l[3].mulE(_[2]).mulE(_[2]).mulE(_[2])).subE(l[2].mulE(l[2]).mulE(l[2]).mulE(_[3])).mul(24),ot=l[2].mulE(_[1]).mulE(_[3]).mulE(_[3]).subE(l[1].mulE(l[3]).mulE(l[3]).mulE(_[2])).mul(72),nt=l[3].mulE(_[3]).mulE(_[1].mulE(_[2]).subE(l[1].mulE(l[2]))).mul(288);x[3]=K.addE(rt).addE(ot).addE(nt),x[4]=_[3].mulE(_[3]).addE(l[3].mulE(l[3])).mulE(l[3].mulE(_[1]).subE(l[1].mulE(_[3]))).mul(270).addE(l[3].mulE(_[2]).subE(l[2].mulE(_[3]))).mulE(l[2].mulE(l[3]).addE(_[2].mulE(_[3]))).mul(180),x[5]=l[3].mulE(_[2]).subE(l[2].mulE(_[3])).mulE(l[3].mulE(l[3]).addE(_[3].mulE(_[3]))).mul(216);const at=(0,c.m)(c.F,5),pt=xt(x,5,new c.E(0,1),!1,at,5);if(pt>0){let gt=Math.abs(f.getCurvature(0)),yt=0;const ft=Math.abs(f.getCurvature(1));(ft>gt||!Number.isFinite(ft))&&(yt=1);for(let bt=0;bt<pt;bt++){const Dt=Math.abs(f.getCurvature(at[bt].value()));f.getCoord2D(at[bt].value()),(Dt>gt||!Number.isFinite(Dt))&&(gt=Dt,yt=at[bt].value())}if((!Number.isFinite(gt)||1/gt<n)&&!(0,c.J)(yt,0,1)){const bt=f.getCoord2D(yt);if(!bt.equals(f.getStartXY())&&!bt.equals(f.getEndXY()))return r.push(yt),1}}return 0}(this,n,r)}ensureXYMonotone(){return mo(this)}setCoordsForIntersector(n,r,l){!function hn(f,n,r,l){if(n.isEqual(f.m_XStart,f.m_YStart)&&r.isEqual(f.m_XEnd,f.m_YEnd))return;const _=!!l&&f.isMonotoneQuickAndDirty(),x=new Y.T,E=(0,c.m)(c.P,3);E[0].setCoords(f.m_XStart,f.m_YStart),E[2].setCoords(f.m_XEnd,f.m_YEnd);const v=new c.P;v.setSub(E[2],E[0]),v.leftPerpendicularThis(),E[1].setAdd(E[0],v);const I=(0,c.m)(c.P,3);I[0].setCoordsPoint2D(n),I[2].setCoordsPoint2D(r),v.setSub(I[2],I[0]),v.leftPerpendicularThis(),I[1].setAdd(I[0],v),x.setFromTwoTriangles(E,I)?x.transformPoints2D(f.m_cp,2,f.m_cp):((0,c.Z)(n,r,1/3,f.m_cp[0]),(0,c.Z)(n,r,2/3,f.m_cp[1])),f.changeEndPoints2D(n,r),_&&mo(f)}(this,n,r,l)}copyToImpl(n){const r=n;r.m_cp[0].assign(this.m_cp[0]),r.m_cp[1].assign(this.m_cp[1]),Ai(r,oi(this))}reverseImpl(){this.m_cp[1]=(0,c.b)(this.m_cp[0],this.m_cp[0]=this.m_cp[1])}equalsImpl(n){const r=n;return!!this.m_cp[0].equals(r.m_cp[0])&&!!this.m_cp[1].equals(r.m_cp[1])}equalsImplTol(n,r){const l=n;return!!this.m_cp[0].isEqualPoint2D(l.m_cp[0],r)&&!!this.m_cp[1].isEqualPoint2D(l.m_cp[1],r)}swapImpl(n){const r=n;r.m_cp[0]=(0,c.b)(this.m_cp[0],this.m_cp[0]=r.m_cp[0]),r.m_cp[1]=(0,c.b)(this.m_cp[1],this.m_cp[1]=r.m_cp[1]),function ci(f,n){n.m_cachedValues=(0,c.b)(f.m_cachedValues,f.m_cachedValues=n.m_cachedValues)}(this,r)}afterCompletedModification(){xi(this)}isIntersecting(n,r,l){return 0!==Kn(!1,this,n,r,l)}intersect(n,r,l,_,x){return $n(!1,this,n,r,l,_,x)}intersectPoint(n,r,l){return function ai(f,n,r,l,_){const x=new jt;if(Hh(f,c.E.unit(),x),x.inflate(l),!x.isIntersectingPoint2D(n))return 0;const E=Nr(f);let v=0,I=E.specialPoints[0];const D=[];for(let G=1,q=E.specialPoints.length;G<q;++G){const B=E.specialPoints[G],z=Pl(f,n,I,B);if(0===D.length)D.push(z);else if(z.t===z.tmin)(0,R.g)(D.at(-1).d<=z.d),D.at(-1).tmax=z.tmax;else if(D.at(-1).t===D.at(-1).tmax){(0,R.g)(D.at(-1).d>=z.d);const L=D.at(-1).tmin;D[D.length-1]=z,D.at(-1).tmin=L}else D.push(z);I=B}for(const G of D)if(G.d<=l){const q=G.t;r&&(v>=r.length&&(0,R.n)(""),r[v]=q),v++}return v}(this,n,r,l)}endPointModified(){xi(this)}clearEndPointModified(){}}fi.type=R.G.enumBezier;class dl{constructor(){this.length=Number.NaN,this.specialPoints=[]}specialPointsCount(){return this.specialPoints.length}}function Mh(f){return function pl(f){return 256*(0,c.N)()*f}(f.calculateUpperLength2D())}function qh(f,n,r=!1){n[1].setCoords(f.m_cp[0].x-f.getStartX(),f.m_cp[0].y-f.getStartY()),n[1].mulThis(3),n[2].setCoords(f.m_cp[1].x-f.m_cp[0].x,f.m_cp[1].y-f.m_cp[0].y),n[2].mulThis(3),n[3]=f.getEndXY().sub(f.getStartXY()),n[3].subThis(n[2]),n[2].subThis(n[1]),r?n[0].setCoords(0,0):n[0]=f.getStartXY()}function Vh(f,n,r){const l=(0,c.m)(c.P,4);f.queryControlPoints(l),Hn(l,n,r)}function Bn(f,n,r){const l=(0,c.m)(c.P,4);f.queryControlPoints(l),ri(l,n,r)}function Hn(f,n,r){let l=f[1].x;l-=f[0].x,l*=3;let _=f[2].x;_-=f[1].x,_*=3;let x=f[3].x;x-=f[0].x,x-=_,_-=l,n[3].setWithEps(x),n[2].setWithEps(_),n[1].setWithEps(l),n[0].set(r?0:f[0].x)}function ri(f,n,r){let l=f[1].y;l-=f[0].y,l*=3;let _=f[2].y;_-=f[1].y,_*=3;let x=f[3].y;x-=f[0].y,x-=_,_-=l,n[3].setWithEps(x),n[2].setWithEps(_),n[1].setWithEps(l),n[0].set(r?0:f[0].y)}function zn(f,n,r=!1){const l=(0,c.m)(Ne,4);l[0].assignPoint2D(f[0]),l[1].assignPoint2D(f[1]),l[2].assignPoint2D(f[2]),l[3].assignPoint2D(f[3]),n[1].setCoords(l[1].x.sub(l[0].x),l[1].y.sub(l[0].y)),n[1].mulThis(c.M.constructInt32(3)),n[2].setCoords(l[2].x.sub(l[1].x),l[2].y.sub(l[1].y)),n[2].mulThis(c.M.constructInt32(3)),n[3]=l[3].sub(l[0]),n[3]=n[3].sub(n[2]),n[2]=n[2].sub(n[1]),r?n[0].setCoords(c.ad,c.ad):n[0]=l[0].clone()}function Tr(f,n,r){if(r){if(n<0)return n;if(n>1)return n-1+Tr(f,1,!1)}if(f.isDegenerate(0))return 0;const l=1===n,_=Nr(f);if(l&&!Number.isNaN(_.length)&&!Number.isNaN(_.length))return _.length;const x=Mh(f),E=x/f.calculateUpperLength2D();let v=0,I=0;for(let D=1,G=_.specialPointsCount();D<G;D++){const q=_.specialPoints[D];if(v+=Tl(f,I,Math.min(n,q),E,x),n<=q)break;I=q}return l&&(_.length=v),v}function Nr(f){if(f.m_cachedValues)return f.m_cachedValues;const n=new dl,r=(0,c.m)(c.F,8),l=(0,c.m)(c.P,4);f.queryControlPoints(l);const _=ra(l,r);n.specialPoints=[];for(let x=0;x<_;x++)n.specialPoints.push(r[x].value());return Ai(f,n),n}function oi(f){let n=null;return n=f.m_cachedValues,n}function Ai(f,n){f.m_cachedValues=n}function xi(f){f.m_cachedValues=null}function Pl(f,n,r,l){const _=(0,c.d)(18,Number.NaN),x=(0,c.m)(c.P,4);f.queryControlPoints(x);const E=wi(new hi(x,n),c.E.construct(r,l),18,_),v=new c.P;f.queryCoord2D(r,v);let I=r,D=c.P.distance(v,n);const G=new c.P;f.queryCoord2D(l,G);const q=c.P.distance(G,n);q<D&&(D=q,I=l,v.assign(G));for(let B=0;B<E;B++){f.queryCoord2D(_[B],G);const z=c.P.distance(G,n);z<D&&(D=z,I=_[B],v.assign(G))}return function qi(f,n,r,l,_){return{tmin:f,tmax:n,t:r,d:l,pt:_.clone()}}(r,l,I,D,v)}function Xh(f,n){const r=(0,c.m)(c.F,4);Vh(f,r,!0);const l=(0,c.m)(c.F,4);Bn(f,l,!0);const _=r[3].clone(),x=r[2].clone(),E=r[1].clone(),v=l[3].clone(),I=l[2].clone(),D=l[1].clone(),G=x.mulE(E).addE(I.mulE(D)).mul(4),q=x.mulE(x).mul(8).addE(_.mulE(E).mul(12)).addE(I.mulE(I).mul(8).addE(v.mulE(D).mul(12))),B=_.mulE(x).addE(v.mulE(I)).mul(36),z=_.mulE(_).addE(v.mulE(v)).mul(36),L=(0,c.m)(c.F,3),j=lt(z,B,q,G,new c.E(0,1),!1,L);if((0,R.g)(j<=3),j>0){const Q=sn(f,1,0).sqrLength(),et=sn(f,1,1).sqrLength();let K=Q;n.set(0),K<et&&(K=et,n.set(1));for(let rt=0;rt<j;rt++){const ot=sn(f,1,L[rt].value()).sqrLength();ot<K&&(K=ot,n=L[rt])}}}function Rs(f,n,r){const l=new c.P;return function yl(f,n,r,l){if(1===n){const _=1-r,x=_*_,E=r*r,v=f[1].sub(f[0]),I=f[2].sub(f[1]),D=f[3].sub(f[2]),G=v.mul(x).add(I.mul(2*_*r)).add(D.mul(E));l.assign(G.mul(3))}else if(2===n){const _=1-r,x=f[2].sub(f[1]).sub(f[1].sub(f[0])),E=f[3].sub(f[2]).sub(f[2].sub(f[1])),v=x.mul(_).add(E.mul(r));l.assign(v.mul(6))}else if(3===n){const _=f[2].sub(f[1]),x=f[3].sub(_.mul(3)).sub(f[0]);l.assign(x.mul(6))}else l.setCoords(0,0)}(f,n,r,l),l}function sn(f,n,r){const l=(0,c.m)(c.P,4);return f.queryControlPoints(l),Rs(l,n,r)}function Rh(f){const n=f.m_cp[0].sub(f.getStartXY()),r=f.m_cp[1].sub(f.m_cp[0]),l=f.getEndXY().sub(f.getStartXY());return n.mulThis(3),r.mulThis(3),l.subThis(r),r.subThis(n),(3*l.x*(2*r.y+5*n.y)-3*l.y*(2*r.x+5*n.x)+10*(r.x*n.y-r.y*n.x))/60}function mo(f){const n=(0,c.m)(c.P,4);f.queryControlPoints(n);const r=lo(n);return r&&(f.m_cp[0].setCoordsPoint2D(n[1]),f.m_cp[1].setCoordsPoint2D(n[2]),f.afterCompletedModification()),r}function lo(f){let n=!1;for(let r=0;r<2;r++){const l=(0,c.Y)(f[0][r],f[3][r]);l>0?((0,c.Y)(f[0][r],f[1][r])<0&&(f[1][r]=f[0][r],n=!0),(0,c.Y)(f[1][r],f[3][r])<0&&(f[1][r]=f[3][r],n=!0),(0,c.Y)(f[0][r],f[2][r])<0&&(f[2][r]=f[0][r],n=!0),(0,c.Y)(f[2][r],f[3][r])<0&&(f[2][r]=f[3][r],n=!0),(0,c.Y)(f[1][r],f[2][r])<0&&(f[2][r]=f[1][r],n=!0)):l<0?((0,c.Y)(f[0][r],f[1][r])>0&&(f[1][r]=f[0][r],n=!0),(0,c.Y)(f[1][r],f[3][r])>0&&(f[1][r]=f[3][r],n=!0),(0,c.Y)(f[0][r],f[2][r])>0&&(f[2][r]=f[0][r],n=!0),(0,c.Y)(f[2][r],f[3][r])>0&&(f[2][r]=f[3][r],n=!0),(0,c.Y)(f[1][r],f[2][r])>0&&(f[2][r]=f[1][r],n=!0)):f[1][r]===f[0][r]&&f[2][r]===f[0][r]||(f[1][r]=f[0][r],f[2][r]=f[0][r],n=!0)}return n}function co(f,n,r){const l=new c.P,_=new c.P,x=new c.P,E=new c.P,v=new c.P;n<=.5?((0,c.V)(2,f[0],f[1],n,l),(0,c.V)(2,f[1],f[2],n,_),(0,c.V)(2,f[2],f[3],n,x),(0,c.V)(2,l,_,n,E),(0,c.V)(2,_,x,n,v),(0,c.V)(2,E,v,n,r)):((0,c.W)(2,f[0],f[1],n,l),(0,c.W)(2,f[1],f[2],n,_),(0,c.W)(2,f[2],f[3],n,x),(0,c.W)(2,l,_,n,E),(0,c.W)(2,_,x,n,v),(0,c.W)(2,E,v,n,r))}function mn(f,n,r,l){(0,R.g)(n>=0&&n<=1);const _=new c.P,x=new c.P,E=new c.P,v=new c.P,I=new c.P,D=new c.P;n<=.5?((0,c.V)(2,f[0],f[1],n,_),(0,c.V)(2,f[1],f[2],n,x),(0,c.V)(2,f[2],f[3],n,E),(0,c.V)(2,_,x,n,v),(0,c.V)(2,x,E,n,I),(0,c.V)(2,v,I,n,D)):((0,c.W)(2,f[0],f[1],n,_),(0,c.W)(2,f[1],f[2],n,x),(0,c.W)(2,f[2],f[3],n,E),(0,c.W)(2,_,x,n,v),(0,c.W)(2,x,E,n,I),(0,c.W)(2,v,I,n,D));const G=f[3].clone();r&&(r[0].assign(f[0]),r[1].assign(_),r[2].assign(v),r[3].assign(D)),l&&(l[0].assign(D),l[1].assign(I),l[2].assign(E),l[3].assign(G))}function ln(f,n,r,l){if((0,R.g)(n>=0&&r<=1&&n<=r),n===r){const x=new c.P;return $e(f,n,x),l[0].assign(x),l[1].assign(x),l[2].assign(x),void l[3].assign(x)}if(0===n&&1===r){for(let x=0;x<4;++x)l[x].assign(f[x]);return}const _=(0,c.m)(c.P,4);mn(f,r,_,null),mn(_,r>0?n/r:0,null,_),$e(f,n,_[0]),$e(f,r,_[3]),l[0].setCoordsPoint2D(_[0]),l[1].setCoordsPoint2D(_[1]),l[2].setCoordsPoint2D(_[2]),l[3].setCoordsPoint2D(_[3])}function $e(f,n,r,l){if(l){if(n<0)return void Us(new ke({start:f[0],end:f[0].add(Un(f,0).getUnitVector())}),n,r);if(n>1)return void Us(new ke({start:f[3],end:f[3].add(Un(f,1).getUnitVector())}),n-1,r)}if(n<=.5){const _=new c.P;(0,c.V)(2,f[0],f[1],n,_);const x=new c.P;(0,c.V)(2,f[1],f[2],n,x);const E=new c.P;(0,c.V)(2,f[2],f[3],n,E);const v=new c.P;(0,c.V)(2,_,x,n,v);const I=new c.P;(0,c.V)(2,x,E,n,I),(0,c.V)(2,v,I,n,r)}else{const _=new c.P;(0,c.W)(2,f[0],f[1],n,_);const x=new c.P;(0,c.W)(2,f[1],f[2],n,x);const E=new c.P;(0,c.W)(2,f[2],f[3],n,E);const v=new c.P;(0,c.W)(2,_,x,n,v);const I=new c.P;(0,c.W)(2,x,E,n,I),(0,c.W)(2,v,I,n,r)}}function Un(f,n){const r=(0,c.c)(n,0,1);let l=Rs(f,1,r);return l.isZero()&&(l=Rs(f,2,r),l.isZero()?l=Rs(f,3,r):1===r&&l.negateThis()),l}function kh(f,n,r){const l=(0,c.m)(c.P,4);f.queryControlPoints(l),function Sl(f,n,r){n.value()<0&&n.set(0,n.eps()),n.value()>1&&n.set(1,n.eps()),r.setE(function ho(f,n,r){const l=[Vt.constructPoint2D(f[0]),Vt.constructPoint2D(f[1]),Vt.constructPoint2D(f[2]),Vt.constructPoint2D(f[3])],_=new Vt;return function El(f,n,r,l){{const _=c.G.subE(r),x=_.sqr(),E=r.sqr(),v=f[1].subE(f[0]).mulE(x).addE(f[2].subE(f[1]).mulE(new c.F(2).mulE(_).mulE(r))).addE(f[3].subE(f[2]).mulE(E));l.setE(v.mulE(new c.F(3)))}}(l,0,r,_),_}(f,0,n))}(l,n,r)}function Lh(f,n,r,l,_){if(_){if(0!==Fs(n,r))return f?4:2}else if(_e(n,r))return 1;return 0!==Ar(f,n,r,null,null,null,l,void 0!==_&&_,!0,!1)?4:0}function $o(f,n,r,l,_){if(_){if(0!==Fs(n,r))return f?4:2}else if(_e(n,r))return 1;return 0!==ea(f,n,r,null,null,null,l,void 0!==_&&_,!0,!1)?4:0}function Bh(f,n,r,l,_){if(_){if(0!==Fs(n,r))return f?4:2}else if(_e(n,r))return 1;return 0!==Gr(f,n,r,null,null,null,l,void 0!==_&&_,!0,!1)?4:0}function ta(f,n,r,l,_){if(_){if(0!==Fs(n,r))return f?4:2}else if(_e(n,r))return 1;return 0!==ia(f,n,r,null,null,null,l,_??!1,!0,!1)?4:0}function Ar(f,n,r,l,_,x,E,v,I,D){if(null!==_&&(_.length=0),null!=x&&(x.length=0),null!==l&&(l.length=0),r.isDegenerate(0)){const gt=[0,0,0],yt=n.intersectPoint(r.getStartXY(),gt,E);if(yt>0){if(null!==_)for(let ft=0;ft<yt;ft++)_.push(gt[ft]);if(null!==x)for(let ft=0;ft<yt;ft++)x.push(0);if(null!=l)for(let ft=0;ft<yt;ft++){const bt=new c.P;n.queryCoord2D(gt[ft],bt),l.push(bt)}}return yt}const G=qe(n,r);if(Ps(n,r,E=Math.max(E,G)))return 0;const q=(0,c.m)(c.P,4);qh(n,q);const B=r.getEndXY();B.subThis(r.getStartXY());const z=B.clone();z.leftPerpendicularThis();let L=3*q[3].dotProduct(z),j=2*q[2].dotProduct(z),Q=q[1].dotProduct(z);const et=(0,c.d)(15,Number.NaN),K=(0,c.d)(15,Number.NaN);let rt=Ns(L,j,Q,c.E.unit(),!1,et);rt<0&&(et[0]=0,et[1]=1,rt=2);let ot,nt=0;for(let gt=0,yt=nt;gt<rt;++gt){const ft=n.getCoord2D(et[gt+yt]);K[nt]=r.getClosestCoordinate(ft,!1),c.P.distance(ft,r.getCoord2D(K[nt]))<=E&&(et[nt]=et[gt+yt],nt++)}if(q[0].subThis(r.getStartXY()),Math.abs(B.x)>=Math.abs(B.y)){const gt=B.y/B.x;L=q[3].y-q[3].x*gt,j=q[2].y-q[2].x*gt,Q=q[1].y-q[1].x*gt,ot=q[0].y-q[0].x*gt}else{const gt=B.x/B.y;L=q[3].x-q[3].y*gt,j=q[2].x-q[2].y*gt,Q=q[1].x-q[1].y*gt,ot=q[0].x-q[0].y*gt}const at=n.getEndXY().equals(r.getStartXY())||n.getEndXY().equals(r.getEndXY()),pt=[0,0,0];rt=Ks(L,j,Q,ot,c.E.unit(),at,pt);for(let gt=0,yt=nt;gt<rt;++gt){et[gt+yt]=pt[gt];const ft=n.getCoord2D(et[gt+yt]);K[nt]=r.getClosestCoordinate(ft,!1),c.P.distance(ft,r.getCoord2D(K[nt]))<=E&&(et[nt]=et[gt+yt],nt++)}rt=n.intersectPoint(r.getStartXY(),pt,E);for(let gt=0;gt<rt;gt++)et[nt]=pt[gt],K[nt++]=0;rt=n.intersectPoint(r.getEndXY(),pt,E);for(let gt=0;gt<rt;gt++)et[nt]=pt[gt],K[nt++]=1;return 0!==r.intersectPoint(n.getStartXY(),pt,E)&&(K[nt]=pt[0],et[nt++]=0),0!==r.intersectPoint(n.getEndXY(),pt,E)&&(K[nt]=pt[0],et[nt++]=1),0===nt?0:Ws(f,n,r,et,K,nt,l,_,x,E,v,0,D)}function ea(f,n,r,l,_,x,E,v,I,D){if(ss(r))return Ar(f,n,new ke({start:r.getStartXY(),end:r.getEndXY()}),l,_,x,E,v,0,D);const G=qe(n,r);if(Ps(n,r,E=Math.max(E,G)))return 0;const q=[],B=[],z=[],L=(0,c.m)(c.P,4);{n.queryControlPoints(L);const Q=(0,c.m)(c.P,4),et=new Y.T;r.canonicToWorldTransformation(et);const K=new Y.T;K.setInvert(et),K.transformPoints2D(L,4,Q);const rt=(0,c.m)(Ne,4);zn(Q,rt);const ot=[rt[0].x,rt[1].x,rt[2].x,rt[3].x],nt=[rt[0].y,rt[1].y,rt[2].y,rt[3].y],at=(0,c.m)(c.M,3);at[0].setDouble(r.getSemiMinorAxis()),at[0].sqrThis(),at[1].setDouble(r.getSemiMajorAxis()),at[1].sqrThis(),at[2].setThis(at[0]),at[2].mulThis(at[1]),at[2].negateThis();const pt=Fo(ot,3,nt,3,null,0,at,0,c.E.unit(),c.E.unit(),B);if(pt>0){let gt=0;for(let yt=0;yt<pt;yt++){const ft=new c.P;n.queryCoord2D(B[yt],ft);const bt=r.getClosestCoordinate(ft,!1),Dt=new c.P;r.queryCoord2D(bt,Dt),c.P.distance(ft,Dt)<=E&&(q.push(ft.clone()),B[gt]=B[yt],z.push(bt),gt++)}B.length=gt,q.length=gt}}const j=[0,1];for(let Q=0;Q<2;Q++){const et=0===Q?r.getStartXY():r.getEndXY(),K=[0];us(L,et,c.E.unit(),!1,-1,1,K);const rt=new c.P;$e(L,K[0],rt),c.P.distance(et,rt)<=E&&(B.push(K[0]),z.push(j[Q]),q.push(rt.clone()))}for(let Q=0;Q<2;Q++){const et=[0,3];{const K=r.getClosestCoordinate(L[et[Q]],!1),rt=new c.P;r.queryCoord2D(K,rt),c.P.distance(L[et[Q]],rt)<=E&&(B.push(j[Q]),z.push(K),q.push(rt.clone()))}}return Ws(f,n,r,B,z,B.length,l,_,x,E,v,0,D)}function sa(f,n,r,l,_,x,E,v,I,D){const G=(0,c.m)(c.P,4);n.queryControlPoints(G);const q=(0,c.m)(c.P,4);if(r.queryControlPoints(q),ds(G,q,4)<0)return sa(f,r,n,l,x,_,E,v,I,!D);const B=qe(n,r);if(Ps(n,r,E=Math.max(E,B)))return 0;if(function Al(f,n,r,l,_,x,E,v,I){const D=(0,c.m)(c.P,4);f.queryControlPoints(D);const G=(0,c.m)(c.P,4);if(n.queryControlPoints(G),D[0].equals(G[0])){if(D[1].equals(G[1])&&D[2].equals(G[2])&&D[3].equals(G[3]))return r&&(r.length=0,r.push(D[0]),r.push(D[3])),l&&(l.length=0,l.push(0),l.push(1)),_&&(_.length=0,_.push(0),_.push(1)),!0;if(!D[0].equals(G[3]))return!1}return!!(D[0].equals(G[3])&&D[1].equals(G[2])&&D[2].equals(G[1])&&D[3].equals(G[0]))&&(l&&(l.length=0,l.push(0),l.push(1),I&&(l[1]=(0,c.b)(l[0],l[0]=l[1]))),_&&(_.length=0,_.push(1),_.push(0),I&&(_[1]=(0,c.b)(_[0],_[0]=_[1]))),r&&(r.length=0,r.push(D[0]),r.push(D[3]),I&&(r[1]=(0,c.b)(r[0],r[0]=r[1]))),!0)}(n,r,l,_,x,0,0,0,D))return 2;const z=new c.E(0,1),L=new c.E(0,1);{const ot=new jt;Fr(G,new c.E(0,1),ot);const nt=new jt;Fr(q,new c.E(0,1),nt);const at=Math.max(ot.maxDim(),nt.maxDim());if(ot.inflate(3*E),nt.inflate(3*E),!ot.intersectW(nt))return 0;if(ot.maxDim()<.1*at){if(En(G,ot,z),En(q,ot,L),z.isEmpty()||L.isEmpty())return 0;ln(G,z.vmin,z.vmax,G),ln(q,L.vmin,L.vmax,q)}}const j=tr(G,3,q,3,E);if(0===j)return 0;const Q=[],et=[],K=[];let rt=!1;if(-1===j){const ot=(0,c.m)(Ne,4);zn(G,ot);const nt=[ot[0].x,ot[1].x,ot[2].x,ot[3].x],at=[ot[0].y,ot[1].y,ot[2].y,ot[3].y],pt=(0,c.m)(Ne,4);zn(q,pt);const gt=[],yt=[],ft=ui(nt,3,at,3,null,0,[pt[0].x,pt[1].x,pt[2].x,pt[3].x],3,[pt[0].y,pt[1].y,pt[2].y,pt[3].y],3,null,0,0,c.E.unit(),c.E.unit(),gt,yt);if(ft>0)for(let bt=0;bt<ft;bt++){const Dt=new c.P;$e(q,yt[bt],Dt);const Nt=new c.P;$e(G,gt[bt],Nt),c.P.distance(Nt,Dt)<=E&&(Q.push(Nt.clone()),K.push(yt[bt]),et.push(gt[bt]))}else-1===ft&&(rt=!0)}for(let ot=0;ot<2;ot++){const nt=0===ot?G:q,at=0===ot?q:G;for(let pt=0;pt<2;pt++){const gt=0===pt?0:3,yt=[0];us(at,nt[gt],c.E.unit(),!1,-1,1,yt);const ft=new c.P;$e(at,yt[0],ft),c.P.distance(nt[gt],ft)<=E&&(0===ot?(et.push(0===gt?0:1),K.push(yt[0])):(K.push(0===gt?0:1),et.push(yt[0])),Q.push(ft.clone()))}}if(0===et.length&&rt){const ot=n.calculateUpperLength2D()>r.calculateUpperLength2D();{const nt=[0,0];if(2===function zh(f,n,r=!1){const l=(0,c.m)(c.P,4);f.queryControlPoints(l);const _=(0,c.m)(Ne,4);let x,E,v;zn(l,_,!0);const I=_[3].x.isZero(),D=_[3].y.isZero();if(I||D)if(I&&!D){if(_[2].x.isZero())return 0;x=_[1].x.div(_[2].x).negate(),E=_[2].y.div(_[3].y),v=_[1].y.div(_[3].y)}else{if(I||!D||_[2].y.isZero())return 0;x=_[1].y.div(_[2].y).negate(),E=_[2].x.div(_[3].x),v=_[1].x.div(_[3].x)}else{_[2].x.divThis(_[3].x),_[1].x.divThis(_[3].x),_[2].y.divThis(_[3].y),_[1].y.divThis(_[3].y);const z=_[2].x.sub(_[2].y);if(z.isZero())return 0;x=_[1].x.sub(_[1].y).div(z).negate(),E=_[2].x.clone(),v=_[1].x.clone()}if(!r&&x.abs().value()>2)return 0;const G=[0,0],q=f.getStartXY().equals(f.getEndXY()),B=Ns(1,-x.toDouble(),x.add(E).mul(x).add(v).toDouble(),c.E.unit(),q,G);if(0===B)return 0;if(G[0]>=0&&G[0]<=1){const z=x.toDouble()-G[0];if(r||z>=0&&z<=1)return n[0]=G[0],n[1]=z,n[0]>n[1]&&(n[1]=(0,c.b)(n[0],n[0]=n[1])),2}if(2===B&&G[1]>=0&&G[1]<=1){const z=x.toDouble()-G[1];if(r||z>=0&&z<=1)return n[0]=G[1],n[1]=z,n[0]>n[1]&&(n[1]=(0,c.b)(n[0],n[0]=n[1])),2}return 0}(ot?n:r,nt,!0)&&((0,R.g)(c.E.unit().containsCoordinate(nt[0])),!c.E.unit().containsCoordinate(nt[1]))){const at=new c.P;$e(ot?G:q,nt[0],at);const pt=[0,0];1===us(ot?q:G,at,c.E.unit(),!1,-1,2,pt)&&(Q.push(at.clone()),et.push(ot?nt[0]:pt[0]),K.push(ot?pt[0]:nt[0]))}}}if(0===et.length)return 0;if(!z.equalsRange(0,1))for(let ot=0;ot<et.length;++ot)et[ot]=fi.recalculateParentT(z.vmin,z.vmax,et[ot]);if(!L.equalsRange(0,1))for(let ot=0;ot<K.length;++ot)K[ot]=fi.recalculateParentT(L.vmin,L.vmax,K[ot]);return Ws(f,n,r,et,K,et.length,l,_,x,E,v,0,D)}function Gr(f,n,r,l,_,x,E,v,I,D){const G=qe(n,r);if(r.isDegenerateToLineHelper(G)){const nt=new ke({start:r.getStartXY(),end:r.getEndXY()}),at=Ar(f,n,nt,l,_,x,E,v,0,D);if(x)for(let pt=0;pt<at;++pt){const gt=nt.getCoord2D(x[pt]);x[pt]=r.getClosestCoordinate(gt,!1)}return at}if(Ps(n,r,E=Math.max(E,G)))return 0;const q=(0,c.m)(c.P,4);n.queryControlPoints(q);const B=(0,c.m)(c.P,3);r.queryControlPoints(B);const z=new c.E(0,1),L=new c.E(0,1),j=[0,0,0];r.queryWeights(j);const Q=[1,Ni(j),1];{const nt=new jt;Fr(q,new c.E(0,1),nt);const at=new jt;pr(B,Q,new c.E(0,1),at);const pt=Math.max(nt.maxDim(),at.maxDim());if(nt.inflate(3*E),at.inflate(3*E),!nt.intersectW(at))return 0;if(nt.maxDim()<.1*pt){if(En(q,nt,z),eo(B,Q,nt,L),z.isEmpty()||L.isEmpty())return 0;ln(q,z.vmin,z.vmax,q),$i(B,Q,L.vmin,L.vmax,B,Q)}}const et=tr(q,3,B,2,E);if(0===et)return 0;const K=[],rt=[],ot=[];if(-1===et){const nt=(0,c.m)(Ne,4);zn(q,nt);const at=[nt[0].x,nt[1].x,nt[2].x,nt[3].x],pt=[nt[0].y,nt[1].y,nt[2].y,nt[3].y],gt=(0,c.m)(c.M,3),yt=(0,c.m)(c.M,3),ft=(0,c.m)(c.M,3);xr(B,Q,gt,yt,ft);const bt=[],Dt=[],Nt=ui(gt,2,yt,2,ft,2,at,3,pt,3,null,0,0,c.E.unit(),c.E.unit(),Dt,bt);if(Nt>0)for(let Ft=0;Ft<Nt;Ft++){const Ot=new c.P;$e(q,bt[Ft],Ot);const Qt=new c.P;ps(B,Q,Dt[Ft],Qt),c.P.distance(Ot,Qt)<=E&&(K.push(Ot.clone()),rt.push(bt[Ft]),ot.push(Dt[Ft]))}}for(let nt=0;nt<2;nt++){let at,pt;0===nt?(at=q,pt=B):(pt=q,at=B);for(let gt=0;gt<2;gt++){const yt=0===gt?0:at.length-1,ft=[0],bt=new c.P;if(0===nt){const Dt=ko(pt,Q,at[yt],c.E.unit(),!1,-1,1,ft);(0,R.g)(1===Dt),ps(pt,Q,ft[0],bt)}else{const Dt=us(pt,at[yt],c.E.unit(),!1,-1,1,ft);(0,R.g)(1===Dt),$e(pt,ft[0],bt)}c.P.distance(at[yt],bt)<=E&&(0===nt?(rt.push(0===yt?0:1),ot.push(ft[0])):(ot.push(0===yt?0:1),rt.push(ft[0])),K.push(bt.clone()))}}if(0===rt.length)return 0;if(!z.equalsRange(0,1))for(let nt=0;nt<rt.length;++nt)rt[nt]=fi.recalculateParentT(z.vmin,z.vmax,rt[nt]);if(!L.equalsRange(0,1))for(let nt=0;nt<ot.length;++nt)ot[nt]=as.recalculateParentT(L.vmin,L.vmax,ot[nt]);for(let nt=0;nt<ot.length;++nt)ot[nt]=Xn(j,ot[nt]);return Ws(f,n,r,rt,ot,rt.length,l,_,x,E,v,0,D)}function ia(f,n,r,l,_,x,E,v,I,D){const G=qe(n,r);if(Ps(n,r,E=Math.max(E,G)))return 0;const q=(0,c.m)(c.P,4);n.queryControlPoints(q);const B=(0,c.m)(c.P,3);r.queryControlPoints(B);const z=tr(q,3,B,2,E);if(0===z)return 0;const L=[],j=[],Q=[];if(-1===z){const et=(0,c.m)(Ne,4);zn(q,et);const K=[et[0].x,et[1].x,et[2].x,et[3].x],rt=[et[0].y,et[1].y,et[2].y,et[3].y],ot=(0,c.m)(Ne,3);yn(B,ot);const nt=ui([ot[0].x,ot[1].x,ot[2].x],2,[ot[0].y,ot[1].y,ot[2].y],2,null,0,K,3,rt,3,null,0,0,c.E.unit(),c.E.unit(),Q,j);if(nt>0){let at=0;for(let pt=0;pt<nt;pt++){const gt=new c.P;n.queryCoord2D(j[pt],gt);const yt=new c.P;r.queryCoord2D(Q[pt],yt),c.P.distance(gt,yt)<=E&&(L.push(gt.clone()),j[at]=j[pt],Q[at]=Q[pt],at++)}j.length=at,L.length=at}}for(let et=0;et<2;et++){let K,rt;0===et?(K=q,rt=B):(rt=q,K=B);for(let ot=0;ot<2;ot++){const nt=0===ot?0:K.length-1,at=[0],pt=new c.P;if(0===et)Pn(rt,K[nt],at),ni(rt,at[0],pt);else{const gt=us(rt,K[nt],c.E.unit(),!1,-1,1,at);(0,R.g)(1===gt),$e(rt,at[0],pt)}c.P.distance(K[nt],pt)<=E&&(0===et?(j.push(0===nt?0:1),Q.push(at[0])):(Q.push(0===nt?0:1),j.push(at[0])),L.push(pt.clone()))}}return Ws(f,n,r,j,Q,j.length,l,_,x,E,v,0,D)}function Hh(f,n,r){const l=(0,c.m)(c.P,4);f.queryControlPoints(l),Fr(l,n,r)}function Fr(f,n,r){if(n.equalsRange(0,1))return void r.setFromPoints(f,4);const l=(0,c.m)(c.P,4);ln(f,n.vmin,n.vmax,l),r.setFromPoints(l,4)}class hi{constructor(n,r){this.controlPoints=n,this.point=r.clone()}getMaxDerivative(){return 6}getValue(n,r){switch(n){case 0:{const l=new c.P;$e(this.controlPoints,r,l);const _=Rs(this.controlPoints,1,r);return 2*l.sub(this.point).dotProduct(_)}case 1:{const l=new c.P;$e(this.controlPoints,r,l);const _=Rs(this.controlPoints,1,r),x=Rs(this.controlPoints,2,r);return 2*(l.sub(this.point).dotProduct(x)+_.dotProduct(_))}case 2:{const l=new c.P;$e(this.controlPoints,r,l);const _=Rs(this.controlPoints,1,r),x=Rs(this.controlPoints,2,r),E=Rs(this.controlPoints,3,r);return 2*(l.sub(this.point).dotProduct(E)+3*_.dotProduct(x))}case 3:{const l=Rs(this.controlPoints,1,r),_=Rs(this.controlPoints,2,r),x=Rs(this.controlPoints,3,r);return 2*(4*l.dotProduct(x)+3*_.sqrLength())}case 4:{const l=Rs(this.controlPoints,2,r),_=Rs(this.controlPoints,3,r);return 10*l.dotProduct(_)*2}case 5:{const l=Rs(this.controlPoints,3,r);return 10*l.dotProduct(l)*2}default:return 0}}getError(n){return 0}}function us(f,n,r,l,_,x,E){(0,R.w)(c.E.unit().contains(r)&&x>0,"getClosestCoordinate"),(_<0||Number.isNaN(_))&&(_=Number.MAX_VALUE);const v=[],I=new c.P;$e(f,r.vmin,I);let D=c.P.distance(I,n);if(D<=_&&v.push(new c.P(r.vmin,D)),r.vmin!==r.vmax&&($e(f,r.vmax,I),D=c.P.distance(I,n),D<=_&&v.push(new c.P(r.vmax,D))),r.width()>0){const B=(0,c.d)(18,Number.NaN),z=wi(new hi(f,n),r,18,B);for(let L=0;L<z;L++)$e(f,B[L],I),D=c.P.distance(I,n),D>_||v.push(new c.P(B[L],D))}if(l){(0,R.g)(r.equals(c.E.unit()));{$e(f,-1,I,!0);const B=new c.P;$e(f,0,B);const z=new ke({start:I,end:B}),L=z.getClosestCoordinate(n,!0);L<1&&(I.assign(z.getCoord2D(L)),D=c.P.distance(I,n),D<=_&&v.push(new c.P(L-1,D)))}{$e(f,2,I,!0);const B=new c.P;$e(f,r.vmax,B);const z=new ke({start:B,end:I}),L=z.getClosestCoordinate(n,!0);L>0&&(I.assign(z.getCoord2D(L)),D=c.P.distance(I,n),D<=_&&v.push(new c.P(1+L,D)))}}if(!v.length)return 0;v.sort((B,z)=>B.compare(z));let G=0;if(E[G++]=v[0].x,G<x){const B=(0,F.x)(f,4,!1).total(),z=v[0].y;for(let L=1,j=v.length;L<j;L++)if(v[L].y>z+B){v.length=L;break}v.sort((L,j)=>(0,c.X)(L.x,j.x)),G=0,E[G++]=v[0].x;for(let L=1,j=v.length;L<j;L++)v[L].x!==E[G-1]&&G<x&&(E[G++]=v[L].x)}return G}function On(f,n,r,l,_,x,E){const v=(0,c.m)(c.P,4);return f.queryControlPoints(v),us(v,n,r,l,_,x,E)}function ra(f,n){n[0].set(0);let r=1;const l=(0,c.m)(c.F,4);Hn(f,l,!0);const _=(0,c.m)(c.F,4);ri(f,_,!0);{const x=l[3].mul(3),E=l[2].mul(2),v=l[1].clone(),I=(0,c.m)(c.F,2);let D=it(x,E,v,new c.E(0,1),!1,I);D<0&&(D=0);for(let G=0;G<D;G++)(0,c.J)(I[G].value(),0,1)||(n[r]=I[G],r++)}{const x=_[3].mul(3),E=_[2].mul(2),v=_[1].clone(),I=(0,c.m)(c.F,2);let D=it(x,E,v,new c.E(0,1),!1,I);D<0&&(D=0);for(let G=0;G<D;G++)(0,c.J)(I[G].value(),0,1)||(n[r]=I[G],r++)}if(r+=function na(f,n,r){const l=f[1].mulE(n[2]).subThisE(f[2].mulE(n[1])),_=f[1].mulE(n[3]).subThisE(f[3].mulE(n[1])).mulThis(3),x=f[2].mulE(n[3]).subThisE(f[3].mulE(n[2])).mulThis(3),E=(0,c.m)(c.F,2);let v=it(x,_,l,new c.E(0,1),!1,E);v<0&&(v=0);let I=0;for(let D=0;D<v;D++)(0,c.J)(E[D].value(),0,1)||(r[I].setE(E[D]),I++);return I}(l,_,n.slice(r)),n[r].set(1),r++,r>2){(0,c.C)(n,0,r,(G,q)=>{const B=G.value(),z=q.value();return B<z?-1:B>z?1:0});let x=0;const E=n[0].clone();let v=0;const I=function Il(f){return f[0].norm(1)+f[1].norm(1)+f[2].norm(1)+f[3].norm(1)}(f)*(0,c.N)(),D=new c.P;co(f,n[0].value(),D);for(let G=1;G<r;G++){const q=new c.P;if(co(f,n[G].value(),q),n[G].eq(E)||q.isEqualPoint2D(D,I)){if(0!==x){if(0===n[G].eps())E.setE(n[G]),v=0;else if(0!==v){const B=(0,c.s)(1/n[G].eps()),z=1/v,L=B+z;E.set((n[G].value()*B+E.value()*z)/L),v=1/L,E.setError(Math.sqrt(v))}n[x].setE(E),co(f,E.value(),D)}}else x++,n[x].setE(n[G]),E.setE(n[G]),co(f,E.value(),D),v=(0,c.s)(n[G].eps())}x++,r=x}return 1===r&&(r=2,n[1].set(1)),(0,R.g)(0===n[0].value()),(0,R.g)(1===n[r-1].value()),r}function En(f,n,r){r.setEmpty();const l=[];l.push(new c.E(0,1));const _=.5*Math.max(n.width(),n.height());for(;l.length;){const x=l.at(-1);l.pop();const E=new jt;if(Fr(f,x,E),E.isIntersectingW(n)){const v=Math.max(E.width(),E.height());if(n.containsW(E)||v<=_||x.width()<1e-12)r.merge(x);else{const I=x.getCenter();l.push(c.E.construct(x.vmin,I)),l.push(c.E.construct(I,x.vmax))}}}}class Dl{constructor(n,r){this.b=n,this.len=r}getMaxDerivative(){return 1}getValue(n,r){return 0===n?this.len-Tr(this.b,r,!1):0}getError(n){return 0}}function oa(f,n,r,l,_,x,E){for(;;){const v=c.P.distance(n[0],n[3]),I=c.P.distance(n[0],n[1])+c.P.distance(n[1],n[2])+c.P.distance(n[2],n[3]);if(I-v<=l+r*I)return f+(0,c.q)(v,I,.5);const D=nt=>Rs(n,1,nt).length();if(0===x){(0,R.g)(E<8);let nt=D(0),at=D(1);_[0]+=2,nt>at&&(at=(0,c.b)(nt,nt=at),n[3]=(0,c.b)(n[0],n[0]=n[3]),n[2]=(0,c.b)(n[1],n[1]=n[2]));let pt=nt/(nt+at),gt=1,yt=I;for(;pt<1/32&&yt>=32*(l+r*yt);){gt/=4;const ft=D(gt);_[0]++,pt=nt/(ft+nt);const bt=new c.P;if($e(n,.5*gt,bt),yt=c.P.distance(bt,n[0]),yt<=l){const Dt=new c.P;$e(n,gt,Dt),yt+=c.P.distance(Dt,bt)}}if(1!==gt){const ft=(0,c.m)(c.P,4);mn(n,gt,n,ft),f=oa(f,ft,r,l,_,0,E+1),x++,E++;continue}}const G=8;_[0]+=G;const q=Wi(G,D,0,1),B=16;_[0]+=B;const z=Wi(B,D,0,1);let L=Math.abs(q-z)>l+r*I;if(!L)return f+z;if(x<3){const nt=(0,c.m)(c.P,4);mn(n,.5,n,nt),f=oa(f,nt,r,l,_,x+1,E+1),x++,E++;continue}const j=32;_[0]+=j;const Q=Wi(j,D,0,1);if(L=Math.abs(z-Q)>l+r*I,!L)return f+Q;const et=64;_[0]+=et;const K=Wi(et,D,0,1);if(L=Math.abs(Q-K)>l+r*I,!L)return f+K;const rt=128;_[0]+=rt;const ot=Wi(rt,D,0,1);return L=Math.abs(K-ot)>l+r*I,f+ot}}function Tl(f,n,r,l,_){if(r===n)return 0;const x=(0,c.m)(c.P,4);f.queryControlPoints(x);const E=(0,c.m)(c.P,4);return ln(x,n,r,E),oa(0,E,l,_,[0],0,0)}function Nl(f,n,r,l,_){let x=!0;const E=ji(5,n,r,l,_,I=>{const D=sn(f,1,I);return(x?f.getCoordX(I)-f.getStartX():f.getCoordY(I)-f.getStartY())*D.length()});x=!1;const v=ji(5,n,r,l,_,I=>{const D=sn(f,1,I);return(x?f.getCoordX(I)-f.getStartX():f.getCoordY(I)-f.getStartY())*D.length()});return new c.P(E,v)}function aa(f,n,r,l,_,x,E,v,I,D,G,q){let B=0,z=0,L=0,j=0,Q=0,et=0,K=0;for(let ot=1,nt=q-1;ot<nt;ot++){let at,pt,gt,yt,ft,bt,Dt=-1,Nt=I[ot-1];f&&(ot>2?(Nt=(0,c.c)(2*I[ot-2]-I[ot-3],0,1),I[ot-1]=Nt):2===ot&&Nt<=I[0]&&(Nt=I[0]));for(let Qt=0;Qt<11&&(at=I[ot-1],pt=at*at,gt=pt*at,yt=1-at,ft=yt*yt,bt=ft*yt,f)&&!(Math.abs(at-Dt)<1e-12)&&10!==Qt;Qt++){const Kt=r.x-2*l.x+_.x,Ce=r.x-3*l.x+3*_.x-x.x,ie=r.y-2*l.y+_.y,ne=r.y-3*l.y+3*_.y-x.y,De=r.x-l.x-2*Kt*at+Ce*pt,We=r.x*bt-G[ot].x+at*(3*l.x*ft+at*(3*_.x-3*_.x*at+x.x*at)),Li=r.y-l.y-2*ie*at+ne*pt,Ms=r.y*bt-G[ot].y+at*(3*l.y*ft+at*(3*_.y-3*_.y*at+x.y*at));Dt=at;const Ge=at- -6*(De*We+Li*Ms)/(6*(3*(0,c.s)(De)-(-2*Kt+2*Ce*at)*We)+6*(3*(0,c.s)(Li)-(-2*ie+2*ne*at)*Ms));I[ot-1]=(0,c.c)(Ge,ot>1?I[ot-2]:0,1)}B+=3*pt*ft*ft,z+=3*gt*bt,L+=3*pt*pt*ft;const Ft=-(bt*r.x+gt*x.x-G[ot].x);j+=Ft*at*ft,Q+=Ft*pt*yt;const Ot=-(bt*r.y+gt*x.y-G[ot].y);et+=Ot*at*ft,K+=Ot*pt*yt}if(n){const ot=B*L-z*z;Math.abs(ot)>=1e-12*(Math.abs(B*L)+Math.abs(z*z))+1e-10?(E||(l.x=(j*L-Q*z)/ot,l.y=(et*L-K*z)/ot),v||(_.x=(B*Q-z*j)/ot,_.y=(B*K-z*et)/ot)):((0,c.Z)(r,x,.3,l),(0,c.Z)(r,x,.6,_))}let rt=0;for(let ot=1,nt=q-1;ot<nt;ot++){const at=I[ot-1],pt=1-at,gt=r.mul((0,c.af)(pt)),yt=l.mul(3*at*pt*pt),ft=_.mul(3*at*at*pt),bt=x.mul((0,c.af)(at));rt+=gt.add(yt).add(ft).add(bt).sub(G[ot]).sqrLength()}return rt}function Wh(f,n,r,l){const _=f.getPathStart(n),x=f.getPathEnd(n);if(x-_<3)return;const E=2*_,v=c.P.getNAN();r.queryPoint2D(E,v);const I=v.x,D=v.y,G=c.P.getNAN();r.queryPoint2D(E+2,G);const q=c.P.getNAN();for(let B=E+4,z=2*x;B<z;B+=2)r.queryPoint2D(B,q),l.pe((q.x-v.x)*(G.y-D)),v.setCoordsPoint2D(G),G.setCoordsPoint2D(q);l.pe((I-v.x)*(G.y-D))}function Gl(f,n,r){for(;n.hasNextSegment();){const l=n.nextCurve();if(null===l)break;r.pe(2*l.calculateArea2DHelper())}}var Ue=F.V;class Gs{static toSegType(n){let r=0;switch(n){case R.G.enumLine:r=1;break;case R.G.enumBezier:r=2;break;case R.G.enumEllipticArc:r=4;break;case R.G.enumRationalBezier2:r=8;break;case R.G.enumBezier2:r=16;break;default:(0,R.c)("")}return r}constructor(){this.m_segmentFlags=null,this.m_segmentParamIndex=null,this.m_segmentParams=null,this.m_curveCount=0,this.m_bezierCount=0,this.m_arcCount=0,this.m_rbezier2Count=0,this.m_bezier2Count=0,this.m_curveParamWritePoint=0}assignCopy(n){return this.m_segmentFlags=n.m_segmentFlags,this.m_segmentParamIndex=n.m_segmentParamIndex,this.m_segmentParams=n.m_segmentParams,this.m_curveCount=n.m_curveCount,this.m_bezierCount=n.m_bezierCount,this.m_arcCount=n.m_arcCount,this.m_rbezier2Count=n.m_rbezier2Count,this.m_bezier2Count=n.m_bezier2Count,this.m_curveParamWritePoint=n.m_curveParamWritePoint,this}}let Vi=(()=>{class f extends Jt{constructor(r){super(r),this.m_cachedRingAreas2D=null,this.m_paths=null,this.m_pathFlags=null,this.m_curveData=null,r.move?(this.m_bPolygon=r.move.m_bPolygon,this.m_cachedLength2D=r.move.m_cachedLength2D,this.m_cachedArea2D=r.move.m_cachedArea2D,this.m_currentPathIndex=r.move.m_currentPathIndex,this.m_cachedRingAreas2D=r.move.m_cachedRingAreas2D,this.m_paths=r.move.m_paths,this.m_pathFlags=r.move.m_pathFlags,this.m_curveData=r.move.m_curveData,r.move.m_curveData=null,r.move.setEmpty()):(this.m_bPolygon=r.bPolygon,this.m_cachedLength2D=0,this.m_cachedArea2D=0,this.m_currentPathIndex=0)}getGeometryType(){return this.m_bPolygon?R.G.enumPolygon:R.G.enumPolyline}getDimension(){return this.m_bPolygon?2:1}changeRingStartPoint(r){(0,R.g)(this.m_bPolygon);const l=this.getPathIndexFromPointIndex(r),_=this.getPathStart(l);if(_===r)return;const x=this.getPathEnd(l);(r>=x||r<_)&&(0,R.t)("change_ring_start_point");for(let E=0,v=this.m_description.getAttributeCount();E<v;E++){const I=this.m_description.getSemantics(E),D=Ue.getComponentCount(I);this.m_vertexAttributes.get(E).rotate(_*D,r*D,x*D)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.rotate(_,r,x),this.m_curveData.m_segmentParamIndex.rotate(_,r,x))}setFillRule(r){this.m_bFillRule=1===r}getFillRule(){return this.m_bFillRule?1:0}isExteriorRingOGC(r){return!!this.m_bPolygon&&(this.updateOGCFlagsProtected(),!!(8&this.m_pathFlags.read(r)))}isExteriorRing(r){return this.calculateRingArea2D(r)>0}calculateRingArea2D(r){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedRingAreas2D.read(r)):0}updateRingAreas2DProtected(){if(!this.hasDirtyFlag(1024))return;const r=this.getPathCount();if(0===r)return this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=0),void this.setDirtyFlagProtected(1024,!1);const l=new F.y(r),_=new c.K(0),x=new c.K(0);if(0!==this.m_pointCount){const E=this.getAttributeStreamRef(0);if(this.hasNonLinearSegments()){const v=new Fn({parent:this});for(v.stripAttributes();v.nextPath();){x.reset();const I=v.getPathIndex();Wh(this,I,E,x),Gl(0,v,x);const D=.5*x.getResult();_.add(D),l.write(I,D)}}else for(let v=0;v<r;v++){x.reset(),Wh(this,v,E,x);const I=.5*x.getResult();_.add(I),l.write(v,I)}}this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=_.getResult(),this.m_cachedRingAreas2D=l,this.setDirtyFlagProtected(1024,!1))}getOGCPolygonCount(){if(!this.m_bPolygon)return 0;this.updateOGCFlagsProtected();let r=0;const l=this.getPathCount();for(let _=0;_<l;_++)8&this.m_pathFlags.read(_)&&r++;return r}getHashCodeImpl(){return(0,R.g)(0),0}equalsImpl(r){const l=r,_=this.getPathCount();if(_!==l.getPathCount())return!1;const x=this.hasNonLinearSegments();if(x!==l.hasNonLinearSegments()||x&&(this.m_curveData.m_curveCount!==l.m_curveData.m_curveCount||this.m_curveData.m_bezierCount!==l.m_curveData.m_bezierCount)||this.m_paths&&!this.m_paths.equals(l.m_paths,0,_+1)||this.m_bFillRule!==l.m_bFillRule||!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(l.m_pathFlags,0,_))return!1;if(this.hasNonLinearSegments()){if(!this.m_curveData.m_segmentFlags.equals(l.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;for(let E=0,v=this.getPointCount();E<v;E++){const I=this.m_curveData.m_segmentFlags.read(E);if(!f.isNonLinearSegmentFlag(I))continue;const D=this.m_curveData.m_segmentParamIndex.read(E),G=l.m_curveData.m_segmentParamIndex.read(E),q=Vs(I);for(let B=0;B<q;B++){const z=this.m_curveData.m_segmentParams.read(D+B),L=l.m_curveData.m_segmentParams.read(G+B);if(!(0,c.a3)(z,L))return!1}}}return!0}equalsImplTol(r,l){const _=r,x=this.getPathCount();if(x!==_.getPathCount())return!1;const E=this.hasNonLinearSegments();if(E!==_.hasNonLinearSegments()||E&&(this.m_curveData.m_curveCount!==_.m_curveData.m_curveCount||this.m_curveData.m_bezierCount!==_.m_curveData.m_bezierCount)||this.m_paths&&!this.m_paths.equals(_.m_paths,0,x+1)||this.m_bFillRule!==_.m_bFillRule||!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(_.m_pathFlags,0,x))return!1;if(!E)return!0;if(!this.m_curveData.m_segmentFlags.equals(_.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;const v=this.querySegmentIterator(),I=_.querySegmentIterator();for(;v.nextPath();){if(!I.nextPath())return!1;for(;v.hasNextSegment();){const D=v.nextCurve(),G=I.nextCurve();if(!(D&&G&&D.equals(G,l))){if(!D&&!G)break;return!1}}}return!0}reserveImplImpl(r,l){this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(r,1),this.m_curveData.m_segmentParamIndex.resize(r,-1),this.checkCompactSegmentParams())}verifyStreamsAfterSizeChangeExtraImpl(){this.m_paths||(this.m_paths=(0,F.z)(1,0),this.m_pathFlags=(0,F.D)(1,0)),this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount,1),this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount,-1),this.checkCompactSegmentParams())}copyToImpl(r,l){const _=r;_.m_bPathStarted=!1,_.m_bFillRule=this.m_bFillRule,_.m_paths=this.m_paths?l?this.m_paths:this.m_paths.clone():null,_.m_pathFlags=this.m_pathFlags?l?this.m_pathFlags:this.m_pathFlags.clone():null,this.m_curveData&&(_.m_curveData||(_.m_curveData=new Gs),_.m_curveData.assignCopy(this.m_curveData),_.m_curveData.m_curveCount=0,_.updateCurveCounter(this.m_curveData.m_curveCount),l||(_.m_curveData.m_segmentParamIndex=this.m_curveData.m_segmentParamIndex?this.m_curveData.m_segmentParamIndex.clone():null,_.m_curveData.m_segmentFlags=this.m_curveData.m_segmentFlags?this.m_curveData.m_segmentFlags.clone():null,_.m_curveData.m_segmentParams=this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams.clone():null)),_.hasDirtyFlag(512)||(_.m_cachedLength2D=this.m_cachedLength2D),_.m_cachedRingAreas2D=null,_.hasDirtyFlag(1024)||(_.m_cachedArea2D=this.m_cachedArea2D,null!==this.m_cachedRingAreas2D&&(_.m_cachedRingAreas2D=l?this.m_cachedRingAreas2D:this.m_cachedRingAreas2D.clone()))}calculateArea2D(){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedArea2D):0}calculateLength2D(){if(!this.hasDirtyFlag(512))return this.m_cachedLength2D;const r=this.querySegmentIterator(),l=new c.K(0);for(;r.nextPath();)for(;r.hasNextSegment();)l.add(r.nextSegment().calculateLength2D());return this.hasDirtyFlag(512)&&(this.m_cachedLength2D=l.getResult()),this.setDirtyFlagProtected(512,!1),l.getResult()}calculatePathLength2D(r){const l=this.querySegmentIteratorAtVertex(this.getPathStart(r)),_=new c.K(0);for(;l.hasNextSegment();)_.add(l.nextSegment().calculateLength2D());return _.getResult()}calculateLength3D(r){return(0,R.g)(0),0}calculatePathLength3D(r,l){return(0,R.g)(0),0}copyTo(r){(0,R.h)(r.getGeometryType())||(0,R.t)(""),this!==r&&super.copyTo(r)}swap(r){(0,R.g)(0)}hasNonLinearSegments(){return 0!==this.getCurveCount()}getSegmentCount(){let r=this.getPointCount();if(!this.m_bPolygon){r-=this.getPathCount();for(let l=0,_=this.getPathCount();l<_;l++)this.isClosedPath(l)&&r++}return r}getSegmentCountPath(r){let l=this.getPathSize(r);return!this.isClosedPath(r)&&l>0&&l--,l}add(r,l){this===r&&(0,R.t)("Multi_path_impl::add");for(let _=0,x=r.getPathCount();_<x;_++)this.addPath(r,_,!l)}addPath(r,l,_){this.insertPath(-1,r,l,_)}addPathPoint2D(r,l,_){this.insertPath2D(-1,r,0,l,_)}addPathMultiPoint(r,l,_,x){_<0&&(_=r.getPointCount()-l),this.insertPointsFromMultipoint(-1,0,r,l,_,x)}addSegmentsFromPath(r,l,_,x,E){if(this===r&&(0,R.t)("Multi_path_impl.add_segments_from_path"),E||0!==this.getPathCount()||(E=!0),l<0&&(l=r.getPathCount()-1),(l>=r.getPathCount()||_<0||x<0||_+x>r.getSegmentCountPath(l))&&(0,R.n)("add_segments_from_path"),0===x)return;const v=r.getPathStart(l),I=r.isClosedPath(l)&&_+x===r.getSegmentCountPath(l);this.m_bPathStarted=!1,this.mergeVertexDescription(r.getDescription());let D=x;const G=v+_;let q=G+1;E&&(D++,q--),!E&&r.hasNonLinearSegments()&&1!==r.m_curveData.m_segmentFlags.read(G)&&(r.getXY(G).equals(this.getXY(this.m_pointCount-1))||(0,R.t)("add_segments_from_path: start point mismatch"));const B=this.m_pointCount;if(this.resizeImpl(this.m_pointCount+D),this.verifyAllStreamsAfterSizeChange(),E){if(0===D)return;this.m_paths.add(this.m_pointCount);let L=r.m_pathFlags.read(l);this.m_bPolygon&&(L|=1),this.m_pathFlags.write(this.m_pathFlags.size()-1,L),this.m_pathFlags.add(0)}else this.m_paths.write(this.m_pathFlags.size()-1,this.m_pointCount);const z=I?D-1:D;for(let L=0,j=this.m_description.getAttributeCount();L<j;L++){const Q=this.m_description.getSemantics(L),et=Ue.getComponentCount(Q),K=r.m_description.getAttributeIndex(Q);if(z>0){if(K<0||!r.m_vertexAttributes.get(K)){const rt=Ue.getDefaultValue(Q);this.m_vertexAttributes.get(L).insertRange(et*B,rt,z*et,et*B),I&&this.m_vertexAttributes.get(L).insertRange(et*B+z*et,rt,et,et*B);continue}this.m_vertexAttributes.get(L).insertRangeFromStream(et*B,r.m_vertexAttributes.get(K),et*q,z*et,!0,et,et*B)}I&&this.m_vertexAttributes.get(L).insertRangeFromStream(et*(B+z),r.m_vertexAttributes.get(K),et*v,et,!0,et,et*(B+z))}if(this.hasNonLinearSegments()&&this.initSegmentData(0),r.hasNonLinearSegments()){let L=0;for(let j=0,Q=G;j<x;j++)L+=Vs(r.m_curveData.m_segmentFlags.read(Q)),Q++;if(L>0){this.initSegmentData(L);let j=G,Q=B-(E?0:1),et=0;for(let K=0;K<x;K++){const rt=r.m_curveData.m_segmentFlags.read(j);if(this.m_curveData.m_segmentFlags.write(Q,rt),f.isNonLinearSegmentFlag(rt)){et++;let ot=r.m_curveData.m_segmentParamIndex.read(j);const nt=Vs(rt);this.m_curveData.m_segmentParamIndex.write(Q,this.m_curveData.m_curveParamWritePoint);for(let at=0;at<nt;at++){const pt=r.m_curveData.m_segmentParams.read(ot);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,pt),this.m_curveData.m_curveParamWritePoint++,ot++}this.incCurveType(rt,1)}else this.m_curveData.m_segmentParamIndex.write(Q,-1);Q++,j++}this.modifyCurveCounter(et)}}if(I){const L=this.getPathCount()-1,j=this.getPathStart(L),Q=this.getPathEnd(L)-1,et=this.getXY(j),K=this.getXY(Q);et.isEqualPoint2D(K)&&(--this.m_pointCount,this.m_paths.write(L+1,this.m_pointCount))}this.notifyModifiedFlags(2001)}reverseAllPaths(){for(let r=0,l=this.getPathCount();r<l;r++)this.reversePath(r)}reversePath(r){r>=this.getPathCount()&&(0,R.t)("");const l=this.getPathSize(r);if(0===l)return;const _=this.getPathStart(r),x=this.isClosedPath(r);if(this.hasNonLinearSegments()){let I=_;const D=new this.m_segmentBufferCTor;let G=!1;for(let q=0;q<l;q++,I++){const B=this.m_curveData.m_segmentFlags.read(I);if(!f.isNonLinearSegmentFlag(B))continue;G=!0,this.querySegment(I,D,!0),D.get().reverse();const z=this.m_curveData.m_segmentParamIndex.read(I);D.get().writeInBufferStream(this.m_curveData.m_segmentParams,z)}if(G){const q=x?0:1;this.m_curveData.m_segmentFlags.reverseRange(_,l-q,1),this.m_curveData.m_segmentParamIndex.reverseRange(_,l-q,1)}}const E=x?1:0;for(let I=0,D=this.m_description.getAttributeCount();I<D;I++)if(this.m_vertexAttributes.get(I)){const G=this.m_description.getSemantics(I),q=Ue.getComponentCount(G);this.m_vertexAttributes.get(I).reverseRange(q*(_+E),q*(l-E),q)}const v=6&this.m_pathFlags.read(r);if(v){let I=0;4&v&&(I|=2),2&v&&(I|=4),this.m_pathFlags.clearBits(r,6),this.m_pathFlags.setBits(r,I)}this.notifyModifiedFlags(1233)}removePath(r){const l=this.getPathCount();r<0&&(r=l-1),r>=l&&(0,R.t)("");const _=this.getPathStart(r),x=this.getPathSize(r);for(let E=0,v=this.m_description.getAttributeCount();E<v;E++)if(this.m_vertexAttributes.get(E)){const I=this.m_description.getSemantics(E),D=Ue.getComponentCount(I);this.m_vertexAttributes.get(E).eraseRange(D*_,D*x,D*this.m_pointCount)}if(this.hasNonLinearSegments()){let E=0;for(let v=_,I=_+x;v<I;v++){const D=this.m_curveData.m_segmentFlags.read(v);f.isNonLinearSegmentFlag(D)&&(this.incCurveType(D,-1),E++)}this.modifyCurveCounter(-E),this.m_curveData.m_segmentFlags.eraseRange(_,x,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(_,x,this.m_pointCount)}for(let E=r+1;E<=l;E++){const v=this.m_paths.read(E);this.m_paths.write(E-1,v-x)}if(this.m_pathFlags)for(let E=r+1;E<=l;E++){const v=this.m_pathFlags.read(E);this.m_pathFlags.write(E-1,v)}this.m_paths.resize(l),this.m_pathFlags.resize(l),this.m_pointCount-=x,this.m_reservedPointCount-=x,r===l-1&&(this.m_bPathStarted=!1),this.notifyModifiedFlags(2001),this.checkCompactSegmentParams(),this.dbgVerifyCurves()}dbgVerifyCurves(){}insertPath(r,l,_,x){this===l&&(0,R.t)("Multi_path_impl::insert_path");const E=this.getPathCount();if(!x&&l.hasNonLinearSegmentsPath(_))return r=this.insertPath(r,l,_,!0),this.reversePath(r),r;_>=l.getPathCount()&&(0,R.t)(""),r>E&&(0,R.t)(""),r<0&&(r=E),_<0&&(_=l.getPathCount()-1),this.m_bPathStarted=!1,this.mergeVertexDescription(l.getDescription());const v=l.getPathStart(_),I=l.getPathSize(_);if(0===I)return this.insertPath2D(r,null,0,0,!0);const D=this.m_pointCount,G=l.isClosedPath(_)&&!x?1:0;this.resizeImpl(this.m_pointCount+I),this.verifyAllStreamsAfterSizeChange();const q=r<E?this.getPathStart(r):D;for(let L=0,j=this.m_description.getAttributeCount();L<j;L++){const Q=this.m_description.getSemantics(L),et=l.getDescription().getAttributeIndex(Q),K=Ue.getComponentCount(Q);if(et>=0&&l.m_vertexAttributes.get(et))0!==G&&this.m_vertexAttributes.get(L).insertRangeFromStream(q*K,l.m_vertexAttributes.get(et),K*v,K,!0,K,K*D),this.m_vertexAttributes.get(L).insertRangeFromStream((q+G)*K,l.m_vertexAttributes.get(et),K*(v+G),K*(I-G),x,K,K*(D+G));else{const rt=Ue.getDefaultValue(Q);this.m_vertexAttributes.get(L).insertRange(q*K,rt,K*I,K*D)}}this.m_paths.add(D+I);for(let L=E;L>=r+1;L--){const j=this.m_paths.read(L-1);this.m_paths.write(L,j+I)}this.m_pathFlags.add(0);for(let L=E-1;L>=r+1;L--){let j=this.m_pathFlags.read(L);j&=-9,this.m_pathFlags.write(L+1,j)}let z=l.getPathFlagsStreamRef().read(_);if(z&=-9,this.m_bPolygon&&(z|=1),this.m_pathFlags.write(r,z),l.hasNonLinearSegments()){this.initSegmentData(0);let L=v,j=0;for(let Q=0;Q<I;Q++)j+=Vs(l.m_curveData.m_segmentFlags.read(L)),L++;if(j>0){null===this.m_curveData.m_segmentFlags?(this.m_curveData.m_segmentFlags=(0,F.D)(this.m_pointCount,1),this.m_curveData.m_segmentParamIndex=(0,F.z)(this.m_pointCount,-1)):(this.m_curveData.m_segmentFlags.insertRange(q,1,I,D),this.m_curveData.m_segmentParamIndex.insertRange(q,-1,I,D)),this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint+j):this.m_curveData.m_segmentParams=(0,F.F)(j),L=v;let Q=q,et=0;for(let K=0;K<I;K++){const rt=l.m_curveData.m_segmentFlags.read(L);if(f.isNonLinearSegmentFlag(rt)){this.m_curveData.m_segmentFlags.write(Q,rt),this.m_curveData.m_segmentParamIndex.write(Q,this.m_curveData.m_curveParamWritePoint);const ot=Vs(rt);let nt=l.m_curveData.m_segmentParamIndex.read(L);for(let at=0;at<ot;at++){const pt=l.m_curveData.m_segmentParams.read(nt);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,pt),this.m_curveData.m_curveParamWritePoint++,nt++}et++,this.incCurveType(rt,1)}L++,Q++}this.modifyCurveCounter(et)}}return this.notifyModifiedFlags(2001),r}insertPath2D(r,l,_,x,E){const v=this.getPathCount();(r>v||_<0)&&(0,R.t)(""),r<0&&(r=v),this.m_bPathStarted=!1;const I=this.m_pointCount;this.resizeImpl(this.m_pointCount+x),0===x&&this.notifyModifiedFlags(32),this.verifyAllStreamsAfterSizeChange();const D=r<v?this.getPathStart(r):I;if(l)this.m_vertexAttributes.get(0).insertRangeFromPoints(2*D,l,_,x,E,2*I);else{const G=Ue.getDefaultValue(0);this.m_vertexAttributes.get(0).insertRange(2*D,G,2*x,2*I)}for(let G=1,q=this.m_description.getAttributeCount();G<q;G++){const B=this.m_description.getSemantics(G),z=Ue.getComponentCount(B),L=Ue.getDefaultValue(B);this.m_vertexAttributes.get(G).insertRange(D*z,L,z*x,z*I)}this.m_paths.add(this.m_pointCount);for(let G=v;G>=r+1;G--){const q=this.m_paths.read(G-1);this.m_paths.write(G,q+x)}this.m_pathFlags.add(0);for(let G=v-1;G>=r+1;G--){let q=this.m_pathFlags.read(G);q&=-9,this.m_pathFlags.write(G+1,q)}return this.m_bPolygon&&this.m_pathFlags.write(r,1),this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(D,1,x,I),this.m_curveData.m_segmentParamIndex.insertRange(D,-1,x,I)),this.notifyModifiedFlags(2001),r}insertPathFromMultipoint(r,l,_,x,E){const v=l.getImpl(),I=this.getPathCount();(r>I||_<0)&&(0,R.t)("");const D=x<0?v.getPointCount()-_:x;if(D>v.getPointCount()&&(0,R.t)(""),_>=v.getPointCount()&&(0,R.t)("pointsOffset"),r<0&&(r=I),this.m_bPathStarted=!1,this.mergeVertexDescription(v.getDescription()),0===D)return void this.insertPath2D(r,null,0,0,!0);const G=this.m_pointCount,q=_;this.resizeImpl(this.m_pointCount+D),this.verifyAllStreamsAfterSizeChange();const B=r<I?this.getPathStart(r):G;for(let j=0,Q=this.m_description.getAttributeCount();j<Q;j++){const et=this.m_description.getSemantics(j),K=v.getDescription().getAttributeIndex(et),rt=Ue.getComponentCount(et);if(K>=0){const ot=v.getAttributeStreamRef(et);this.m_vertexAttributes.get(j).insertRangeFromStream(B*rt,ot,rt*q,rt*D,E,rt,rt*G)}else{const ot=Ue.getDefaultValue(et);this.m_vertexAttributes.get(j).insertRange(B*rt,ot,rt*D,rt*G)}}this.m_paths.add(G+D);for(let j=I;j>=r+1;j--){const Q=this.m_paths.read(j-1);this.m_paths.write(j,Q+D)}this.m_pathFlags.add(0);for(let j=I-1;j>=r+1;j--){let Q=this.m_pathFlags.read(j);Q&=-9,this.m_pathFlags.write(j+1,Q)}let L=0;this.m_bPolygon&&(L|=1),this.m_pathFlags.write(r,L),this.notifyModifiedFlags(2001)}insertPoints(r,l,_,x,E,v,I){if(this===_&&(0,R.t)("Multi_path_impl.insert_points"),r<0&&(r=this.getPathCount()),x<0&&(x=_.getPathCount()-1),(r>this.getPathCount()||l>=0&&l>this.getPathSize(r)||x>=_.getPathCount()||v>_.getPathSize(x))&&(0,R.n)(""),!v)return;if(this.mergeVertexDescription(_.m_description),r===this.getPathCount()){this.m_paths.add(this.m_pointCount);let L=_.m_pathFlags.read(x);L&=-9,this.m_pathFlags.add(this.m_bPolygon?1|L:L)}l<0&&(l=this.getPathSize(r));const D=this.m_pointCount;this.resizeImpl(this.m_pointCount+v),this.verifyAllStreamsAfterSizeChange();const G=this.getPathStart(r),q=G+l;v<0&&(v=_.getPathSize(x));const B=_.getPathStart(x),z=B+v;for(let L=0,j=this.m_description.getAttributeCount();L<j;L++){const Q=this.m_description.getSemantics(L),et=Ue.getComponentCount(Q),K=_.m_description.getAttributeIndex(Q);if(K<0||!_.m_vertexAttributes.get(K)){const rt=Ue.getDefaultValue(Q);this.m_vertexAttributes.get(L).insertRange(et*q,rt,z*et,et*D)}else this.m_vertexAttributes.get(L)?.insertRangeFromStream(et*(G+l),_.m_vertexAttributes.get(K),et*(B+E),v*et,I,et,et*D)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(G+l,1,v,D),this.m_curveData.m_segmentParamIndex.insertRange(G+l,-1,v,D),l>0&&this.isNonLinearSegment(G+l-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(G+l-1),-1),this.m_curveData.m_segmentFlags.write(G+l-1,1),this.m_curveData.m_segmentParamIndex.write(G+l-1,-1),this.modifyCurveCounter(-1)));for(let L=r+1,j=this.getPathCount();L<=j;L++){const Q=this.m_paths.read(L);this.m_paths.write(L,Q+v)}this.notifyModifiedFlags(2001)}insertPointsFromPoints(r,l,_,x,E,v){if(r<0&&(r=this.getPathCount()),(r>this.getPathCount()||l>this.getPathSize(r)||x<0)&&(0,R.n)(""),!E)return;r===this.getPathCount()&&(this.m_paths.add(this.m_pointCount),this.m_pathFlags.add(this.m_bPolygon?1:0)),l<0&&(l=this.getPathSize(r));const I=this.m_pointCount;this.resizeImpl(this.m_pointCount+E),this.verifyAllStreamsAfterSizeChange();const D=this.getPathStart(r);this.m_vertexAttributes.get(0).insertRangeFromPoints(2*(D+l),_,x,E,v,2*I);for(let G=1,q=this.m_description.getAttributeCount();G<q;G++){const B=this.m_description.getSemantics(G),z=Ue.getComponentCount(B),L=Ue.getDefaultValue(B);this.m_vertexAttributes.get(G).insertRange((D+l)*z,L,z*E,z*I)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(D+l,1,E,I),this.m_curveData.m_segmentParamIndex.insertRange(D+l,-1,E,I),l>0&&this.isNonLinearSegment(D+l-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(D+l-1),-1),this.m_curveData.m_segmentFlags.write(D+l-1,1),this.m_curveData.m_segmentParamIndex.write(D+l-1,-1),this.modifyCurveCounter(-1)));for(let G=r+1,q=this.getPathCount();G<=q;G++)this.m_paths.write(G,this.m_paths.read(G)+E);this.notifyModifiedFlags(2001)}insertPointsFromMultipoint(r,l,_,x,E,v){const I=_.getImpl(),D=this.getPathCount();r<0&&(r=this.getPathCount());const G=I.getPointCount();if((x<0||x>G)&&(0,R.n)(""),(E<0||x+E>G)&&(E=G-x),l<0&&(l=r<D?this.getPathSize(r):0),(r>D||r<D&&l>this.getPathSize(r)||r===D&&l>0||E<0)&&(0,R.n)(""),!E)return;if(this.mergeVertexDescription(I.getDescription()),r===D){this.m_paths.add(this.m_pointCount);const Q=0;this.m_pathFlags.add(this.m_bPolygon?1|Q:Q)}l<0&&(l=this.getPathSize(r));const q=this.m_pointCount;this.resizeImpl(this.m_pointCount+E),this.verifyAllStreamsAfterSizeChange();const B=this.getPathStart(r),z=B+l,j=0+E;for(let Q=0,et=this.m_description.getAttributeCount();Q<et;Q++){const K=this.m_description.getSemantics(Q),rt=Ue.getComponentCount(K);if(I.getDescription().getAttributeIndex(K)<0){const nt=Ue.getDefaultValue(K);this.m_vertexAttributes.get(Q).insertRange(rt*z,nt,j*rt,rt*q);continue}const ot=I.getAttributeStreamRef(K);this.m_vertexAttributes.get(Q).insertRangeFromStream(rt*(B+l),ot,rt*(0+x),E*rt,v,rt,rt*q)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(B+l,1,E,q),this.m_curveData.m_segmentParamIndex.insertRange(B+l,-1,E,q),l>0&&this.isNonLinearSegment(B+l-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(B+l-1),-1),this.m_curveData.m_segmentFlags.write(B+l-1,1),this.m_curveData.m_segmentParamIndex.write(B+l-1,-1),this.modifyCurveCounter(-1)));for(let Q=r+1,et=this.getPathCount();Q<=et;Q++){const K=this.m_paths.read(Q);this.m_paths.write(Q,K+E)}this.notifyModifiedFlags(2001)}insertPoint2D(r,l,_){const x=this.getPathCount();r<0&&(r=x),(r>x||r<x&&l>this.getPathSize(r))&&(0,R.n)(""),r===x&&this.addPathPoint2D(null,0,!0);const E=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const v=this.getPathStart(r),I=l<0?this.getPathSize(r)+v:l+v,D=this.m_vertexAttributes.get(0);if(I===E)this.m_paths.write(r+1,E+1),D.writePoint2D(2*I,_);else{D.insert(2*I,_,2*E);for(let G=1,q=this.m_description.getAttributeCount();G<q;G++){const B=this.m_description.getSemantics(G),z=Ue.getComponentCount(B),L=Ue.getDefaultValue(B);this.m_vertexAttributes.get(G).insertRange(z*I,L,z,z*E)}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(I,1,1,E),this.m_curveData.m_segmentParamIndex.insertRange(I,-1,1,E));for(let G=r+1,q=x;G<=q;G++)this.m_paths.write(G,this.m_paths.read(G)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&I>v&&this.isNonLinearSegment(I-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(I-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(I-1,1),this.m_curveData.m_segmentParamIndex.write(I-1,-1)),this.notifyModifiedFlags(2001)}insertPoint(r,l,_){const x=this.getPathCount();r<0&&(r=x),(r>x||r<x&&l>this.getPathSize(r))&&(0,R.n)(""),r===x&&this.addPathPoint2D(null,0,!0);const E=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const v=this.getPathStart(r),I=l<0?this.getPathSize(r)+v:l+v;if(I===E)this.m_paths.write(r+1,E+1),this.setPointByVal(I,_);else{const D=_.getDescription();this.m_description!==D&&this.mergeVertexDescription(D);for(let G=0,q=this.m_description.getAttributeCount();G<q;G++){const B=this.m_description.getSemantics(G),z=Ue.getComponentCount(B);if(D.hasAttribute(B))this.m_vertexAttributes.get(G).insertAttributes(z*I,_,B,z*E);else{const L=Ue.getDefaultValue(B);this.m_vertexAttributes.get(G).insertRange(z*I,L,z,z*E)}}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(I,1,1,E),this.m_curveData.m_segmentParamIndex.insertRange(I,-1,1,E));for(let G=r+1,q=x;G<=q;G++)this.m_paths.write(G,this.m_paths.read(G)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&I>v&&this.isNonLinearSegment(I-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(I-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(I-1,1),this.m_curveData.m_segmentParamIndex.write(I-1,-1)),this.notifyModifiedFlags(2001)}removePointFromPath(r,l){const _=this.getPathCount();r<0&&(r=_-1),(r>=_||l>=this.getPathSize(r))&&(0,R.n)("Multi_path.remove_point");const x=this.getPathStart(r),E=this.isClosedPath(r);l<0&&(l=this.getPathSize(r)-1),l<0&&(0,R.n)("Multi_path.remove_point");const v=x+l;for(let I=0,D=this.m_description.getAttributeCount();I<D;I++)if(this.m_vertexAttributes.get(I)){const G=this.m_description.getSemantics(I),q=Ue.getComponentCount(G);this.m_vertexAttributes.get(I).eraseRange(q*v,q,q*this.m_pointCount)}if(this.m_curveData&&this.m_curveData.m_segmentFlags){this.checkCompactSegmentParams();let I=0;if(v>x&&this.isNonLinearSegment(v-1))I+=1,this.incCurveType(this.m_curveData.m_segmentFlags.read(v-1),-1),this.m_curveData.m_segmentFlags.write(v-1,1),this.m_curveData.m_segmentParamIndex.write(v-1,-1);else{const D=this.getPathEnd(r);E&&x+1<D&&this.isNonLinearSegment(D-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(D-1),-1),this.m_curveData.m_segmentFlags.write(D-1,1),this.m_curveData.m_segmentParamIndex.write(D-1,-1),I+=1)}this.isNonLinearSegment(v)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(v),-1),I+=1),I>0&&this.modifyCurveCounter(-I),this.m_curveData.m_segmentFlags.eraseRange(v,1,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(v,1,this.m_pointCount)}for(let I=_;I>=r+1;I--){const D=this.m_paths.read(I);this.m_paths.write(I,D-1)}this.m_pointCount--,this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}removePoint(r){let l;l=r<0?this.getPathCount()-1:this.getPathIndexFromPointIndex(r),this.removePointFromPath(l,r-this.getPathStart(l))}getNumberOfCurves(r){if(!this.hasNonLinearSegments())return 0;let l=0;for(let _=this.getPathStart(r),x=this.getPathEnd(r);_<x;_++)f.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(_))&&++l;return l}getPathCount(){return this.m_paths?this.m_paths.size()-1:0}getPathSize(r){return this.m_paths.read(r+1)-this.m_paths.read(r)}getPathStart(r){return this.m_paths.read(r)}getPathEnd(r){return this.m_paths.read(r+1)}getPathIndexFromPointIndex(r,l=-1){-1===l&&(l=this.m_currentPathIndex);const _=this.getPathCount(),x=f.getPathIndexFromPointIndexImpl(this.m_paths,_,r,l);return this.m_currentPathIndex=x,x}startPathCoords(r,l){this.startPathPoint(new F.P({x:r,y:l}))}startPath(r){this.startPathPoint(new F.P({pt:r}))}startPath3D(r){this.startPathPoint(new F.P({x:r.x,y:r.y,z:r.z}))}startPath3DCoords(r,l,_){this.startPathPoint(new F.P({x:r,y:l,z:_}))}startPathPoint(r){r.isEmpty()&&(0,R.t)("");const l=r.getDescription();let _;if(this.m_description!==l){this.mergeVertexDescription(l);const x=new F.P({vd:this.m_description});r.copyCommonAttributesTo(x),_=x}else _=r;this.m_bPathStarted?this.setPointByVal(this.m_pointCount-1,_):(this.insertPoint(-1,-1,_),this.m_bPathStarted=!0)}beforeNewSegmentHelper2(){this.m_paths=(0,F.z)(2),this.m_paths.write(0,0),this.m_pathFlags=(0,F.D)(2,0),this.m_bPolygon&&this.m_pathFlags.write(0,1)}beforeNewSegmentHelper1(){null!==this.m_paths?(this.m_paths.add(0),this.m_pathFlags.add(0),this.m_bPolygon&&this.m_pathFlags.write(this.m_pathFlags.size()-2,1)):this.beforeNewSegmentHelper2()}beforeNewSegment(r){0!==this.m_pointCount||this.m_bPathStarted||this.startPathCoords(0,0);const l=this.m_pointCount,_=this.m_paths.size()-1,x=l+r;this.m_paths.write(_,x),this.resizeImpl(x),this.m_bPathStarted&&(this.m_bPathStarted=!1)}finishLineTo(){if(this.hasNonLinearSegments()){const r=this.m_curveData.m_segmentFlags.read(this.m_pointCount-1);1!==r&&(this.m_curveData.m_segmentFlags.write(this.m_pointCount-1,1),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-1,-1),this.modifyCurveCounter(-1),this.incCurveType(r,-1))}}lineToCoords(r,l){if(this.beforeNewSegment(1),1===this.m_description.getAttributeCount())this.setXYCoords(this.m_pointCount-1,r,l);else{const _=(0,F.o)(),x=new F.P({vd:this.m_description,attribBuffer:_,initDefaultValues:!0});x.setXYCoords(r,l),this.setPointByVal(this.m_pointCount-1,x)}this.finishLineTo()}lineTo(r){this.lineToCoords(r.x,r.y)}lineTo3D(r){this.beforeNewSegment(1);const l=(0,F.l)(this.m_description,(0,F.w)()),_=(0,F.o)(),x=new F.P({vd:l,attribBuffer:_,initDefaultValues:!0});x.setXYZ(r),this.setPointByVal(this.m_pointCount-1,x),this.finishLineTo()}lineTo3DCoords(r,l,_){this.lineTo3D(new F.h(r,l,_))}lineToPoint(r){if(this.beforeNewSegment(1),this.m_description===r.getDescription())this.setPointByVal(this.m_pointCount-1,r);else{this.mergeVertexDescription(r.getDescription());const l=(0,F.o)(),_=new F.P({vd:this.m_description,attribBuffer:l,initDefaultValues:!1});r.copyCommonAttributesTo(_),this.setPointByVal(this.m_pointCount-1,_)}this.finishLineTo()}openPathAndDuplicateStartVertex(r){this.m_bPolygon&&(0,R.c)("");const l=this.getPathCount();if(r>l&&(0,R.t)(""),!this.isClosedPath(r))return;this.m_pathFlags||(0,R.c)("");const _=this.m_pointCount,x=this.getPathStart(r),E=this.getPathEnd(r);if(E-x!=0){this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();for(let v=0,I=this.m_description.getAttributeCount();v<I;v++)if(this.m_vertexAttributes.get(v)){const D=this.m_description.getSemantics(v),G=Ue.getComponentCount(D);this.m_vertexAttributes.get(v).insertRangeFromStream(G*E,this.m_vertexAttributes.get(v),G*x,G,!0,1,G*_)}for(let v=l;v>r;v--){const I=this.m_paths.read(v);this.m_paths.write(v,I+1)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(E,1,1,_),this.m_curveData.m_segmentParamIndex.insertRange(E,-1,1,_)),this.m_pathFlags.clearBits(r,1)}}openPath(r){this.m_bPolygon&&(0,R.c)(""),r>this.getPathCount()&&(0,R.t)(""),this.m_pathFlags||(0,R.c)(""),this.m_pathFlags.clearBits(r,1)}isStrongPathStart(r){return!!(2&this.m_pathFlags.read(r))}setStrongPathStart(r,l){l?this.m_pathFlags.setBits(r,2):this.m_pathFlags.clearBits(r,2)}isStrongPathEnd(r){return!!(4&this.m_pathFlags.read(r))}setStrongPathEnd(r,l){l?this.m_pathFlags.setBits(r,4):this.m_pathFlags.clearBits(r,4)}clearStrongPathEnds(){for(let r=0,l=this.getPathCount();r<l;++r)this.m_pathFlags.clearBits(r,6)}openAllPathsAndDuplicateStartVertex(){if(this.m_bPolygon&&(0,R.c)(""),this.isEmpty())return;this.m_pathFlags||(0,R.c)("");let r=0;const l=this.getPathCount();for(let q=0;q<l;q++)this.isClosedPath(q)&&(this.getPathSize(q)>0?r++:this.m_pathFlags.clearBits(q,1));if(0===r)return;const _=this.hasNonLinearSegments();let x=0;const E=this.getPathCount(),v=this.m_description.getAttributeCount(),I=new Array(v);let D=null,G=null;for(let q=0;q<E;++q){const B=this.getPathStart(q),z=this.getPathSize(q),L=this.isClosedPath(q);if(z>0){const j=B+x;for(let Q=0;Q<v;Q++)if(this.m_vertexAttributes.get(Q)){const et=this.m_description.getSemantics(Q),K=Ue.getComponentCount(et);if(!I[Q]){const ot=(0,F.u)(et,K*(this.m_pointCount+r));I[Q]=ot}I[Q].writeRange(j*K,z*K,this.m_vertexAttributes.get(Q),B*K,!0,1),L&&I[Q].writeRange((j+z)*K,K,this.m_vertexAttributes.get(Q),B*K,!0,1)}if(_){if(null===D){const Q=this.m_pointCount+r;D=(0,F.D)(Q),G=(0,F.z)(Q)}D.writeRange(j,z,this.m_curveData.m_segmentFlags,B,!0,1),G.writeRange(j,z,this.m_curveData.m_segmentParamIndex,B,!0,1),L&&(D.write(j+z,1),G.write(j+z,-1))}}this.m_paths.write(q,B+x),L&&(this.m_pathFlags.clearBits(q,1),++x)}this.m_paths.write(E,this.m_pointCount+r),this.m_pathFlags.clearBits(E,1);for(let q=0;q<v;q++)this.m_vertexAttributes.get(q)&&this.m_vertexAttributes.set(q,I[q]);_&&(this.m_curveData.m_segmentFlags=D,this.m_curveData.m_segmentParamIndex=G),this.m_pointCount+=r,this.m_reservedPointCount>0&&(this.m_reservedPointCount=this.m_pointCount)}closePathWithLine(r){void 0===r&&(r=this.getPathCount()-1),this.throwIfEmpty(),(r<0||r>=this.getPathCount())&&(0,R.t)("close_path_with_line"),r===this.getPathCount()-1&&(this.m_bPathStarted=!1);const l=this.m_pathFlags.read(r);if(1&l||this.m_pathFlags.write(r,1|l),this.m_curveData&&this.m_curveData.m_segmentFlags){const _=this.getPathEnd(r)-1,x=this.m_curveData.m_segmentFlags.read(_);1!==x&&(this.m_curveData.m_segmentFlags.write(_,1),this.m_curveData.m_segmentParamIndex.write(_,-1),1!==x&&(this.incCurveType(x,-1),this.modifyCurveCounter(-1)))}this.notifyModifiedFlags(2001)}closeLastPathWithSegment(r){this.closePathWithSegment(this.getPathCount()-1,r)}closePathWithSegment(r,l){if(this.throwIfEmpty(),(r<0||r>=this.getPathCount())&&(0,R.t)("close_path_with_line"),l.getEndXY().equals(this.getXY(this.getPathStart(r)))||(0,R.t)("close_path_with_segment: end point mismatch"),r===this.getPathCount()-1)this.m_bPathStarted=!1,this.addSegment(l,!1),--this.m_pointCount,this.m_paths.write(r+1,this.m_pointCount);else{this.mergeVertexDescription(l.getDescription());const x=l.getStartXY(),E=this.getPathEnd(r)-1;x.equals(this.getXY(E))||(0,R.t)("close_path_with_segment: start point mismatch");const v=l.getGeometryType();if(v===R.G.enumLine)return void this.closePathWithLine(r);{const I=lr(l);this.initSegmentData(I);const D=Gs.toSegType(v),G=this.m_curveData.m_segmentFlags.read(E);if(G!==D)this.m_curveData.m_segmentParamIndex.write(E,this.m_curveData.m_curveParamWritePoint),l.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=I,this.incCurveType(D,1),1!==G?this.incCurveType(G,-1):this.modifyCurveCounter(1);else{const q=this.m_curveData.m_segmentParamIndex.read(E);l.writeInBufferStream(this.m_curveData.m_segmentParams,q)}this.m_curveData.m_segmentFlags.write(E,D)}}const _=this.m_pathFlags.read(r);1&_||this.m_pathFlags.write(r,1|_),this.notifyModifiedFlags(2001)}closeAllPaths(){if(this.m_bPolygon||this.isEmptyImpl())return;this.m_bPathStarted=!1;let r=!1;for(let l=0,_=this.m_paths.size()-1;l<_;l++){if(this.isClosedPath(l))continue;const x=this.m_pathFlags.read(l);this.m_pathFlags.write(l,1|x),r=!0}r&&this.notifyModifiedFlags(512)}isClosedPath(r){return!!(1&this.m_pathFlags.read(r))}isClosedPathInXYPlane(r){if(this.isClosedPath(r))return!0;const l=this.getPathStart(r),_=this.getPathEnd(r)-1;if(l>_)return!1;const x=this.getXY(l),E=this.getXY(_);return x.isEqualPoint2D(E)}isClosedPathIn3D(r){return(0,R.g)(0),!1}hasNonLinearSegmentsPath(r){if(!this.hasNonLinearSegments())return!1;for(let l=this.getPathStart(r),_=this.getPathEnd(r);l<_;l++)if(f.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(l)))return!0;return!1}isNonLinearSegment(r){return!(1&this.getSegmentFlags(r))}addEnvelope(r,l){if(r.isEmpty())return;const _=0===this.m_pointCount;if(r instanceof dt.J)this.startPathCoords(r.xmin,r.ymin),l?(this.lineToCoords(r.xmax,r.ymin),this.lineToCoords(r.xmax,r.ymax),this.lineToCoords(r.xmin,r.ymax)):(this.lineToCoords(r.xmin,r.ymax),this.lineToCoords(r.xmax,r.ymax),this.lineToCoords(r.xmax,r.ymin));else{const x=r.getDescription(),E=(0,F.o)(),v=new F.P({vd:x,attribBuffer:E,initDefaultValues:!1});for(let I=0,D=4;I<D;I++)r.queryCornerByVal(l?D-I-1:I,v),0===I?this.startPathPoint(v):this.lineToPoint(v)}this.closePathWithLine(),this.m_bPathStarted=!1,_&&!l&&(this.setDirtyFlagProtected(256,!1),this.m_bPolygon&&Math.min(r.width(),r.height())>0&&this.setIsSimple(3,0))}addPathFromClosedSegment(r,l){if(r.isClosed()||(0,R.t)("add_path_from_closedSegment: segment must be closed"),l){const _=r.getReversed(),x=new F.P;_.queryStart(x),this.startPathPoint(x),this.closeLastPathWithSegment(_)}else{const _=new F.P;r.queryStart(_),this.startPathPoint(_),this.closeLastPathWithSegment(r)}}addSegment_(r,l){const _=r.getDescription();this.mergeVertexDescription(_);const x=(0,F.o)(),E=new F.P({vd:_,attribBuffer:x,initDefaultValues:!1}),v=r.getGeometryType();if(v===R.G.enumLine)(l||this.isEmptyImpl())&&(r.queryStart(E),this.startPathPoint(E)),r.queryEnd(E),this.lineToPoint(E);else{let I=!1;if((l||this.isEmptyImpl())&&(I=!0),!I&&(r.getStartXY().equals(this.getXY(this.m_pointCount-1))||(0,R.t)("add_segment: start point mismatch")),I&&(r.queryStart(E),this.startPathPoint(E)),this.beforeNewSegment(1),r.queryEnd(E),E.getDescription()===this.m_description)this.setPointByVal(this.m_pointCount-1,E);else{const q=(0,F.o)(),B=new F.P({vd:this.m_description,attribBuffer:q,initDefaultValues:!1});E.copyCommonAttributesTo(B),this.setPointByVal(this.m_pointCount-1,B)}const D=lr(r);this.initSegmentData(D),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-2,this.m_curveData.m_curveParamWritePoint),r.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=D;const G=Gs.toSegType(v);this.incCurveType(G,1),this.modifyCurveCounter(1),this.m_curveData.m_segmentFlags.write(this.m_pointCount-2,G)}}addSegment(r,l,_){_?l?this.addPathFromClosedSegment(r,!1):this.closeLastPathWithSegment(r):this.addSegment_(r,l)}interpolateAttributesRange(r,l,_,x){for(let I=r;I<_-1;I++)this.isClosedPath(I)&&(0,R.t)("cannot interpolate across closed paths");const E=this.m_description.getAttributeCount();if(1===E)return;const v=this.calculateSubLength2D(r,l,_,x);if(0!==v)for(let I=1;I<E;I++){const D=this.m_description.getSemantics(I);this.interpolateAttributesSemanticsImpl(D,r,l,_,x,v)}}interpolateAttributesSemantics(r,l,_,x,E){if(0===r)return;this.hasAttribute(r)||(0,R.t)("does not have the given attribute"),2===Ue.getInterpolation(r)&&(0,R.t)("angular interpolation");for(let I=l;I<x-1;I++)this.isClosedPath(I)&&(0,R.t)("cannot interpolate across closed paths");const v=this.calculateSubLength2D(l,_,x,E);0!==v&&this.interpolateAttributesSemanticsImpl(r,l,_,x,E,v)}interpolateAttributesPath(r,l,_){const x=this.m_description.getAttributeCount();if(1===x||l===_)return;const E=this.calculatePathSubLength2D(r,l,_);for(let v=1;v<x;v++){const I=this.m_description.getSemantics(v);this.interpolateAttributesSemanticsPathImpl(I,r,l,_,E)}}interpolateAttributesSemanticsPath(r,l,_,x){if(0===r)return;this.hasAttribute(r)||(0,R.t)("does not have the given attribute"),2===Ue.getInterpolation(r)&&(0,R.t)("angular interpolation");const E=this.calculatePathSubLength2D(l,_,x);0!==E&&this.interpolateAttributesSemanticsPathImpl(r,l,_,x,E)}interpolateAttributesSemanticsImpl(r,l,_,x,E,v){const I=this.querySegmentIterator(),D=this.getPathStart(l)+_,G=this.getPathStart(x)+E,q=Ue.getComponentCount(r),B=(0,c.d)(Ue.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(r,D,B,q);const z=(0,c.d)(Ue.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(r,G,z,q);const L=(0,c.d)(Ue.maxComponentCount(),Number.NaN);(0,c.a)(L,B,0,0,q);let j=0;const Q=Ue.getDefaultValue(r),et=Ue.getInterpolation(r);I.resetToVertex(D,l);do{if(I.hasNextSegment()){if(I.nextSegment(),I.getStartPointIndex()===G)return;this.setAttributeFromArray(r,I.getStartPointIndex(),L,q),I.previousSegment();do{const K=I.nextSegment();if(I.getEndPointIndex()===G)return;j+=K.calculateLength2D(),(0,c.B)(et,B,z,L,0,q,j/v,Q),I.isClosingSegment()||this.setAttributeFromArray(r,I.getEndPointIndex(),L,q)}while(I.hasNextSegment())}}while(I.nextPath())}interpolateAttributesSemanticsPathImpl(r,l,_,x,E){const v=this.querySegmentIterator(),I=Ue.getInterpolation(r),D=this.getPathStart(l)+_,G=this.getPathStart(l)+x;if(G===D)return;const q=Ue.getComponentCount(r),B=(0,c.d)(Ue.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(r,D,B,q);const z=(0,c.d)(Ue.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(r,G,z,q);const L=new c.K(0);v.resetToVertex(D,l),v.setCirculator(this.isClosedPath(l));const j=Ue.getDefaultValue(r),Q=(0,c.d)(Ue.maxComponentCount(),Number.NaN);(0,c.a)(Q,B,0,0,q);const et=0===E;let K=.5;do{const rt=v.nextSegment();if(this.setAttributeFromArray(r,v.getStartPointIndex(),Q,q),!et){const ot=rt.calculateLength2D();L.pe(ot),K=L.getResult()/E}(0,c.B)(I,B,z,Q,0,q,K,j)}while(v.getEndPointIndex()!==G)}querySegment(r,l,_){const x=this.getPathIndexFromPointIndex(r),E=r-this.getPathStart(x);E>=this.getSegmentCountPath(x)&&(0,R.t)("get_segment"),this.getSegmentFromPath(x,E,l,_)}getSegment(r,l){const _=new this.m_segmentBufferCTor;return this.getSegmentBuffer(r,_,l),_.releaseSegment()}getSegmentType(r){const l=this.getPathIndexFromPointIndex(r),_=r-this.getPathStart(l);return _>=this.getSegmentCountPath(l)&&(0,R.t)("get_segment"),this.getSegmentTypeFromPath(l,_)}getSegmentFromPath(r,l,_,x){const E=this.getPathStart(r)+l,v=this.getSegmentFlagsStreamRef();let I=1;switch(v&&(I=31&v.read(E)),I){case 1:_.createLine();break;case 2:_.createCubicBezier();break;case 4:_.createEllipticArc();break;case 8:_.createQuadraticRationalBezier();break;case 16:_.createQuadraticBezier();break;default:(0,R.c)("")}const D=_.get();let G,q=null;if(x?(q=(0,F.j)(),D.assignVertexDescription(q)):D.assignVertexDescription(this.m_description),G=E===this.getPathEnd(r)-1&&this.isClosedPath(r)?this.getPathStart(r):E+1,Le(D,this.getXY(E)),Re(D,this.getXY(G)),!x)for(let B=1,z=this.m_description.getAttributeCount();B<z;B++){const L=this.m_description.getSemantics(B),j=Ue.getComponentCount(L);for(let Q=0;Q<j;Q++){const et=this.getAttributeAsDbl(L,E,Q);D.setStartAttribute(L,Q,et);const K=this.getAttributeAsDbl(L,G,Q);D.setEndAttribute(L,Q,K)}}if(f.isNonLinearSegmentFlag(I)){const B=this.m_curveData.m_segmentParamIndex.read(E);D.readFromBufferStream(this.m_curveData.m_segmentParams,B)}}replaceLinearEllipticalArcsWithTrueLines(){if(!this.hasNonLinearSegments()||0===this.m_curveData.m_arcCount)return!1;let r=!1;for(let l=0,_=this.getPointCount();l<_;l++)if(4===this.m_curveData.m_segmentFlags.read(l)){const x=this.m_curveData.m_segmentParamIndex.read(l);Ao(this.m_curveData.m_segmentParams,x).isNAN()&&(this.m_curveData.m_segmentFlags.write(l,1),this.m_curveData.m_segmentParamIndex.write(l,-1),this.incCurveType(4,-1),this.modifyCurveCounter(-1),r=!0)}return r&&this.checkCompactSegmentParams(),r}queryPointAlongPath(r,l,_,x=!1){const E={iSegment:-1},v=x?E:{iSegment:-1,tSegment:0};if(_.setEmpty(),this.isEmpty()||((r<0||r>=this.getPathCount())&&(0,R.t)("query_point_along_path"),l<0))return E;const I=this.getPathSize(r);if(0===I)return E;if(1===I)return this.getPointByVal(this.getPathStart(r),_),v.tSegment=0,E.iSegment=this.getPathStart(r),E;const D=this.querySegmentIteratorAtVertex(this.getPathStart(r)),G=new c.K(0);for(;D.hasNextSegment();){const q=D.nextSegment(),B=q.calculateLength2D(),z=G.getResult();if(G.add(B),G.getResult()>=l){let L=l-z;L>B&&(L=B);const j=q.lengthToT(L);return q.queryCoord(j,_),v.tSegment=j,E.iSegment=D.getStartPointIndex(),E}}if(this.isClosedPath(r)){const q=this.getPathStart(r);return this.getPointByVal(q,_),v.tSegment=1,E.iSegment=this.getPathEnd(r)-1,E}{const q=this.getPathEnd(r)-1;return this.getPointByVal(q,_),this.getPathSize(r)>1?(v.tSegment=1,E.iSegment=this.getPathEnd(r)-2,E):(v.tSegment=0,E.iSegment=this.getPathStart(r),E)}}queryPointsAlongPath(r,l,_,x,E,v){{let j=0;for(let Q=0;Q<l;++Q)x&&x[Q].setEmpty(),E&&(E[Q]=-1),v&&(v[Q]=0),j>_[Q]&&(0,R.t)("query_points_along"),j=_[Q]}const I=this.getPathSize(r);if(0===l||0===I)return 0;if(1===I){const j=this.getPathStart(r);return x&&this.getPointByVal(j,x[0]),v&&(v[0]=0),E&&(E[0]=j),1}const D=this.getPathStart(r),G=new c.K(0),q=this.querySegmentIteratorAtVertex(D);let B=0,z=0,L=_[B];for(;q.hasNextSegment();){const j=q.nextSegment(),Q=j.calculateLength2D(),et=G.getResult();for(G.add(Q);G.getResult()>=L;){let K=L-et;K>Q&&(K=Q);const rt=j.lengthToT(K);if(x&&j.queryCoord(rt,x[z]),v&&(v[z]=rt),E&&(E[z]=q.getStartPointIndex()),z++,B++,L=_[B],B===l)return z}}if(this.isClosedPath(r)){const j=this.getPathStart(r),Q=0;x&&this.getPointByVal(j,x[z]),v&&(v[z]=Q),E&&(E[z]=j),z++}else if(this.getPathSize(r)>1){const j=this.getPathEnd(r)-2,Q=1;x&&this.getPointByVal(j+1,x[z]),v&&(v[z]=Q),E&&(E[z]=j),z++}return z}queryPointsAlong(r,l,_,x,E){{let z=0;for(let L=0;L<r;++L)_&&_[L].setEmpty(),x&&(x[L]=-1),E&&(E[L]=0),z>l[L]&&(0,R.t)("query_points_along"),z=l[L]}if(0===r)return 0;const v=new c.K(0),I=this.querySegmentIterator();let D=-1,G=0,q=0,B=l[G];for(;I.nextPath();)for(;I.hasNextSegment();){D=I.getPathIndex();const z=I.nextSegment(),L=z.calculateLength2D(),j=v.getResult();for(v.add(L);v.getResult()>=B;){let Q=B-j;Q>L&&(Q=L);const et=z.lengthToT(Q);if(_&&z.queryCoord(et,_[q]),E&&(E[q]=et),x&&(x[q]=I.getStartPointIndex()),q++,G++,B=l[G],G===r)return q}}if(D<0)return 0;if(this.isClosedPath(D)){const z=this.getPathStart(D),L=0;_&&this.getPointByVal(z,_[q]),E&&(E[q]=L),x&&(x[q]=z),q++}else if(this.getPathSize(D)>1){const z=this.getPathEnd(D)-2,L=1;_&&this.getPointByVal(z+1,_[q]),E&&(E[q]=L),x&&(x[q]=z),q++}return q}querySegmentIterator(){return new Fn({parent:this})}querySegmentIteratorAtVertex(r){return new Fn({parent:this,pointIndex:r})}queryPathEnvelope(r,l){this.queryPathEnvelopeImpl(r,l,!0)}queryLoosePathEnvelope(r,l){this.queryPathEnvelopeImpl(r,l,!1)}queryPathEnvelopeImpl(r,l,_){if(l instanceof F.E&&(0,R.g)(0,"not implemented for Envelope"),l instanceof F.n&&(0,R.g)(0,"not implemented for Envelope3D"),(r>=this.getPathCount()||r<0)&&(0,R.t)(""),this.isEmpty())return void l.setEmpty();const x=this.getAttributeStreamRef(0),E=dt.J.constructEmpty();E.setEmpty();for(let v=2*this.getPathStart(r),I=2*this.getPathEnd(r);v<I;){const D=I-v;(0,R.g)(!(1&D)),E.mergePointsInterleaved(x,v/2,D/2),v+=D}if(l.setCoords({env2D:E}),this.hasNonLinearSegmentsPath(r)){const v=this.querySegmentIterator();if(v.resetToPath(r),v.nextPath())for(;v.hasNextSegment();){const I=v.nextCurve();if(!I)break;{const D=dt.J.constructEmpty();_?I.queryEnvelope(D):I.queryLooseEnvelope(D),l.mergeEnvelope2D(D)}}else(0,R.g)(0)}}checkCompactSegmentParams(){if(!this.m_curveData||null===this.m_curveData.m_segmentParams||this.m_curveData.m_segmentParams.size()<=this.m_vertexAttributes.get(0).size())return!1;const l=Vs(4)*this.m_curveData.m_arcCount+Vs(2)*this.m_curveData.m_bezierCount+Vs(8)*this.m_curveData.m_rbezier2Count+Vs(16)*this.m_curveData.m_bezier2Count;return this.m_curveData.m_segmentParams.size()>Math.max(3*l>>1,10)?(this.forceCompactSegmentParams(),!0):(0===this.m_pointCount&&(this.m_curveData.m_curveParamWritePoint=0),!1)}forceCompactSegmentParams(){let r=0;for(let x=0,E=this.getPointCount();x<E;x++){const v=this.m_curveData.m_segmentFlags.read(x);f.isNonLinearSegmentFlag(v)&&(r+=Vs(v))}const l=(0,F.F)(r);let _=0;for(let x=0,E=this.getPointCount();x<E;x++){const v=this.m_curveData.m_segmentFlags.read(x);if(f.isNonLinearSegmentFlag(v)){let I=this.m_curveData.m_segmentParamIndex.read(x);this.m_curveData.m_segmentParamIndex.write(x,_);const D=Vs(v);for(let G=0;G<D;G++)l.write(_,this.m_curveData.m_segmentParams.read(I)),_++,I++}}this.m_curveData.m_segmentParams=l,this.m_curveData.m_curveParamWritePoint=_}setEmpty(){this.m_curveData&&(this.removeAllCurvesFromGlobalCounter(),this.m_curveData=null),this.m_bPathStarted=!1,this.m_paths=null,this.m_pathFlags=null,this.setEmptyImpl()}applyTransformation(r){this.applyTransformationToPath(r,-1)}applyTransformation3D(r){(0,R.g)(0)}getImpl(){return this}reserve(r){this.reserveImpl(r),r>0&&!this.m_paths&&(this.m_paths=(0,F.z)(0),this.m_pathFlags=(0,F.D)(0),this.m_paths.reserve(2),this.m_pathFlags.reserve(2),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0))}reserveParts(r,l){this.reserveImpl(r),l>0&&(this.m_paths?(this.m_paths.reserve(l+1),this.m_pathFlags.reserve(l+1)):(this.m_paths=(0,F.z)(0),this.m_pathFlags=(0,F.D)(0),this.m_paths.reserve(l+1),this.m_pathFlags.reserve(l+1),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0)))}clone(){const r=this.createInstance();return this.copyTo(r),r}queryLimitedSegmentIterator(r){return new Fl(this,r)}getPathStreamRef(){return this.throwIfEmpty(),this.m_paths}setPathStreamRef(r){this.m_paths=r}getSegmentFlagsStreamRef(){return this.throwIfEmpty(),null!=this.m_curveData?this.m_curveData.m_segmentFlags:null}getPathFlagsStreamRef(){return this.throwIfEmpty(),this.m_pathFlags}setPathFlagsStreamRef(r){this.m_pathFlags=r}getSegmentIndexStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParamIndex:null}getSegmentDataStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParams:null}setSegmentData(r,l,_,x){this.m_curveData||(this.m_curveData=new Gs),this.m_curveData.m_segmentFlags=_,this.m_curveData.m_segmentParams=l,this.m_curveData.m_segmentParamIndex=r,this.m_curveData.m_curveParamWritePoint=x}static getPathIndexFromPointIndexImpl(r,l,_,x){if(x>=0&&x<l){if(_>=r.read(x)){if(_<r.read(x+1))return x;x++}else x--;if(x>=0&&x<l&&_>=r.read(x)&&_<r.read(x+1))return x}if(l<5){for(let I=0;I<l;I++)if(_<r.read(I+1))return I;(0,R.k)("")}let E=0,v=l-1;for(;v>E;){const I=E+(v-E>>1);if(_<r.read(I))v=I-1;else{if(!(_>=r.read(I+1)))return I;E=I+1}}return E}getHighestPointIndex(r){(0,R.g)(r>=0&&r<this.getPathCount());const l=this.getAttributeStreamRef(0),_=this.getPathEnd(r),x=this.getPathStart(r);let E=-1;const v=new c.P;v.y=Number.NEGATIVE_INFINITY,v.x=Number.NEGATIVE_INFINITY;for(let I=x+0;I<_;I++){const D=l.readPoint2D(2*I);-1===v.compare(D)&&(E=I,v.setCoordsPoint2D(D))}return E}applyTransformationToPath(r,l){if(l>=this.getPathCount()&&(0,R.t)("apply_transformation"),this.isEmpty()||r.isIdentity())return;const _=this.m_vertexAttributes.get(0);if(!(l<0?this.hasNonLinearSegments():this.hasNonLinearSegmentsPath(l))){let I,D;return l<0?(I=0,D=this.m_pointCount):(I=this.getPathStart(l),D=this.getPathEnd(l)),_.applyTransformation(r,2*I,D-I),void this.notifyModifiedFlags(2001)}const x=new this.m_segmentBufferCTor,E=this.getPathCount();let v=l<0?0:l;do{const I=this.getPathStart(v),D=this.getPathEnd(v),G=this.isClosedPath(v),q=_.readPoint2D(2*I);if(!this.hasNonLinearSegmentsPath(v)){_.applyTransformation(r,2*I,D-I);continue}const B=c.P.getNAN();for(let z=I;z<D;++z){if(1!=(31&this.m_curveData.m_segmentFlags.read(z))){const j=G&&z+1===D;j&&_.writePoint2D(2*I,q),this.getSegmentBuffer(z,x,!0),x.get().applyTransformation(r);const Q=this.m_curveData.m_segmentParamIndex.read(z);x.get().writeInBufferStream(this.m_curveData.m_segmentParams,Q),_.writePoint2D(2*z,x.get().getStartXY()),j&&_.writePoint2D(2*I,x.get().getEndXY());continue}const L=2*z;_.queryPoint2D(L,B),r.transformInPlace(B),_.writePoint2D(L,B)}if(v===l)break}while(++v<E);this.notifyModifiedFlags(2001)}calculateSubLength2D(r,l,_,x){const E=this.getPathStart(r)+l,v=this.getPathStart(_)+x;(v<E||E<0||v>this.getPointCount()-1)&&(0,R.m)("");const I=this.querySegmentIterator();let D=0;I.resetToVertex(E,r);do{for(;I.hasNextSegment();){const G=I.nextSegment();if(I.getStartPointIndex()===v)break;D+=G.calculateLength2D()}if(I.getStartPointIndex()===v)break}while(I.nextPath());return D}calculatePathSubLength2D(r,l,_){const x=this.getPathStart(r)+l,E=this.getPathStart(r)+_;(x<0||E>this.getPointCount()-1)&&(0,R.m)("");const v=this.querySegmentIterator();if(x>E&&(this.isClosedPath(r)||(0,R.t)("cannot iterate across an open path"),v.setCirculator(!0)),x===E)return 0;let I=0,D=0;v.resetToVertex(x,r);do{D+=I,I=v.nextSegment().calculateLength2D()}while(v.getStartPointIndex()!==E);return D}calculateEnvelope2D(r){return this.updateXYImpl(r)}updateXYImpl(r){const l=super.updateXYImpl(r);if(this.hasNonLinearSegments()){const _=dt.J.constructEmpty(),x=this.querySegmentIterator();for(;x.nextPath();)for(;x.hasNextSegment();){const E=x.nextCurve();if(!E)break;r?E.queryEnvelope(_):E.queryLooseEnvelope(_),l.mergeEnvelope2D(_)}}return l}notifyModifiedAllImpl(){this.m_pointCount=null!==this.m_paths&&this.m_paths.size()?this.m_paths.read(this.m_paths.size()-1):0}setDirtyOGCFlags(r){this.setDirtyFlagProtected(16,r)}hasDirtyOGCStartFlags(){return this.hasDirtyFlag(16)}setDirtyRingAreas2D(r){this.setDirtyFlagProtected(1024,r)}hasDirtyRingAreas2D(){return this.hasDirtyFlag(1024)}static isNonLinearSegmentFlag(r){return!(1&r)}addAndExplicitlyOpenAllPaths(r,l){this===r&&(0,R.t)("Multi_path_impl::add");let _=this.getPathCount();for(let x=0,E=r.getPathCount();x<E;x++)this.addPath(r,x,!l),this.openPathAndDuplicateStartVertex(_),_++}getSegmentFlags(r){return null!==this.m_curveData&&null!==this.m_curveData.m_segmentFlags?this.m_curveData.m_segmentFlags.read(r):1}getSegmentBuffer(r,l,_){const x=this.getPathIndexFromPointIndex(r),E=r-this.getPathStart(x);E>=this.getSegmentCountPath(x)&&(0,R.t)("getSegmentBuffer"),this.getSegmentFromPath(x,E,l,_)}getSegmentTypeFromPath(r,l){const _=this.getPathStart(r)+l,x=this.getSegmentFlagsStreamRef();let E=1;switch(x&&(E=31&x.read(_)),E){case 1:return R.G.enumLine;case 2:return R.G.enumBezier;case 4:return R.G.enumEllipticArc;case 8:return R.G.enumRationalBezier2;case 16:return R.G.enumBezier2;default:(0,R.c)("")}}ensureXYMonotoneSegments(){if(!this.m_curveData)return!1;let r=!1;for(let l=0,_=this.getPathCount();l<_;l++){const x=this.getPathStart(l),E=this.getPathEnd(l),v=E-x;for(let I=x;I<E;I++){const D=31&this.m_curveData.m_segmentFlags.read(I);if(1===D)continue;2!==D&&(0,R.b)("ensure_xy_monotone_segments");const G=(I-x+1)%v+x,q=this.m_curveData.m_segmentParamIndex.read(I),B=(0,c.m)(c.P,4);B[0]=this.getXY(I),B[3]=this.getXY(G),B[1].x=this.m_curveData.m_segmentParams.read(q),B[1].y=this.m_curveData.m_segmentParams.read(q+1),B[2].x=this.m_curveData.m_segmentParams.read(q+2),B[2].y=this.m_curveData.m_segmentParams.read(q+3),lo(B)&&(r=!0,this.m_curveData.m_segmentParams.write(q,B[1].x),this.m_curveData.m_segmentParams.write(q+1,B[1].y),this.m_curveData.m_segmentParams.write(q+2,B[2].x),this.m_curveData.m_segmentParams.write(q+3,B[2].y))}}return r&&this.notifyModifiedFlags(2001),r}buildRasterizedGeometryAccelerator(r,l){return!1}buildQuadTreeAccelerator(r){if(this.m_accelerators||(this.m_accelerators=new pn),null!==this.m_accelerators.getQuadTree())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTree(null);const l=(0,F.G)(this);return this.m_accelerators.setQuadTree(l),!0}buildQuadTreeForPathsAccelerator(r){if(this.m_accelerators||(this.m_accelerators=new pn),null!==this.m_accelerators.getQuadTreeForPaths())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTreeForPaths(null);const l=(0,F.H)(this);return this.m_accelerators.setQuadTreeForPaths(l),!0}updateCurveCounter(r){this.modifyCurveCounter(r-this.getCurveCount())}removeAllCurvesFromGlobalCounter(){this.m_curveData&&(f.st_totalCurveCount-=this.m_curveData.m_curveCount,this.m_curveData.m_curveCount=0,this.m_curveData.m_bezierCount=0,this.m_curveData.m_arcCount=0,this.m_curveData.m_bezier2Count=0,this.m_curveData.m_rbezier2Count=0,this.m_curveData.m_curveParamWritePoint=0)}modifyCurveCounter(r){r&&(this.m_curveData||(this.m_curveData=new Gs),f.st_totalCurveCount+=r,this.m_curveData.m_curveCount+=r)}getCurveCount(){return this.m_curveData?this.m_curveData.m_curveCount:0}incCurveType(r,l){this.m_curveData||(this.m_curveData=new Gs),2&r?this.m_curveData.m_bezierCount+=l:4&r?this.m_curveData.m_arcCount+=l:8&r?this.m_curveData.m_rbezier2Count+=l:16&r&&(this.m_curveData.m_bezier2Count+=l)}getCurveWritePoint(){return null!==this.m_curveData?this.m_curveData.m_curveParamWritePoint:0}initSegmentData(r){null===this.m_curveData&&(this.m_curveData=new Gs);const l=this.m_reservedPointCount>0?this.m_reservedPointCount:this.m_pointCount;null===this.m_curveData.m_segmentParamIndex&&(this.m_curveData.m_segmentFlags=(0,F.D)(l,1),this.m_curveData.m_segmentParamIndex=(0,F.z)(l,-1));const _=this.m_curveData.m_curveParamWritePoint+r;null===this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams=(0,F.F)(_):_!==this.m_curveData.m_segmentParams.size()&&this.m_curveData.m_segmentParams.resize(_,0),this.m_curveData.m_segmentFlags.size()<l&&(this.m_curveData.m_segmentFlags.resize(l,1),this.m_curveData.m_segmentParamIndex.resize(l,-1))}updateCurveWritePoint(r){null===this.m_curveData&&(this.m_curveData=new Gs),this.m_curveData.m_curveParamWritePoint=r}updateOGCFlagsHelper(){const r=this.getPathCount();if(0===r)return;const l=this.m_pathFlags;let _=0;for(let x=0;x<r;x++){const E=this.m_cachedRingAreas2D.read(x);0===_&&(_=(0,c.e)(E)),E*_>0||0===_?l.setBits(x,8):l.clearBits(x,8)}}updateOGCFlagsProtected(){this.hasDirtyFlag(16)&&(this.updateRingAreas2DProtected(),this.updateOGCFlagsHelper(),this.setDirtyFlagProtected(16,!1))}replaceSegment(r,l,_){(r<0||r>=this.getPointCount())&&(0,R.t)("Multi_path_impl.replace_segment"),(0,R.g)(l.isCurve());const x=this.getPathIndexFromPointIndex(r),E=this.getPathStart(x),v=(r-E+1)%this.getPathSize(x)+E;{const K=this.getXY(r),rt=this.getXY(v),ot=!K.isEqualPoint2D(l.getStartXY())||!rt.isEqualPoint2D(l.getEndXY());(0,R.g)(!ot)}const I=l.getDescription();this.mergeVertexDescription(I);const D=(0,c.d)(32,Number.NaN),G=new F.P({vd:I,attribBuffer:D,initDefaultValues:!1}),q=null===this.m_curveData?1:31&this.m_curveData.m_segmentFlags.read(r),B=Vs(q),z=lr(l);let L,j=!1;B>=z?((0,R.g)(null!==this.m_curveData),j=!0,L=this.m_curveData.m_segmentParamIndex.read(r)):(this.initSegmentData(z),j=!1,L=this.m_curveData.m_curveParamWritePoint);const Q=l.getGeometryType(),et=Gs.toSegType(Q);_||(l.queryStart(G),this.setPointByVal(r,G),l.queryEnd(G),this.setPointByVal(v,G)),this.m_curveData.m_segmentParamIndex.write(r,1!==et?L:-1),this.m_curveData.m_segmentFlags.write(r,et),1!==et&&l.writeInBufferStream(this.m_curveData.m_segmentParams,L),j||(this.m_curveData.m_curveParamWritePoint+=z),q!==et&&(this.incCurveType(q,-1),this.incCurveType(et,1),this.modifyCurveCounter(1===q?1:-1))}setAttributeImpl(r,l,_){if(this.addAttribute(r),!this.isEmpty())if(this.hasNonLinearSegments()&&0===r){(l<0||l>1)&&(0,R.t)("");const x=new Y.T;x.setShiftCoords(0===l?_:0,0===l?0:1),0===l?x.xx=0:x.yy=0,this.applyTransformation(x)}else super.setAttributeImpl(r,l,_)}}return f.st_totalCurveCount=0,f})();class Fl{constructor(n,r){this.m_segIter=null,this.m_quadTree=null,this.m_qtIter=null,this.m_extentOfInterest=new dt.J(r),this.m_bfirst=!0,this.m_prevIndex=-100,this.m_parent=n}nextSegment(){return this.m_bfirst&&this.prepare_(),this.m_quadTree?this.nextSegmentQt():this.nextSegmentNoQt()}getPathIndex(){return this.m_segIter.getPathIndex()}getStartPointIndex(){return this.m_segIter.getStartPointIndex()}getEndPointIndex(){return this.m_segIter.getEndPointIndex()}isClosingSegment(){return this.m_segIter.isClosingSegment()}isPathClosed(){return this.m_segIter.isPathClosed()}prepare_(){const n=this.m_parent.getAccelerators();n&&(this.m_quadTree=n.getQuadTree(),this.m_quadTree&&(this.m_qtIter=this.m_quadTree.getSortedIterator(this.m_extentOfInterest,0))),this.m_segIter=this.m_parent.querySegmentIterator()}nextSegmentQt(){this.m_bfirst=!1;const n=this.m_qtIter.next();if(-1===n)return null;const r=this.m_quadTree.getElement(n);return(r!==this.m_prevIndex+1||this.m_segIter.isLastSegmentInPath())&&(this.m_segIter.resetToVertex(r,this.m_segIter.getPathIndex()),this.m_prevIndex=r),this.m_segIter.nextSegment()}nextSegmentNoQt(){for(;;){if(!this.m_bfirst&&this.m_segIter.hasNextSegment()){const n=this.m_segIter.nextSegment(),r=dt.J.constructEmpty();if(n.queryLooseEnvelope(r),!r.isIntersecting(this.m_extentOfInterest))continue;return n}if(this.m_bfirst=!1,!this.m_segIter.nextPath())return null}}}class Yi extends Vi{constructor(n){n?n.vd?(super({vd:n.vd,bPolygon:!1}),this.m_segmentBufferCTor=is):n.copy?(super({vd:n.copy.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=is,n.copy.copyTo(this)):n.move?(super({move:n.move}),this.m_segmentBufferCTor=is):n.start?(super({vd:n.start.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=is,this.startPathPoint(n.start),this.lineToPoint(n.end)):n.path?(super({bPolygon:!1}),this.m_segmentBufferCTor=is,this.addPathPoint2D(n.path,n.pointCount,n.bForward)):(0,R.c)("bad constructor arg"):(super({bPolygon:!1}),this.m_segmentBufferCTor=is)}getBoundary(){return mi(this)}assignCopy(n){return this!==n&&n.copyTo(this),this}assignMove(n){return n.copyTo(this),this}getGeometryType(){return Yi.type}getDimension(){return 1}createInstance(){return new Yi({vd:this.getDescription()})}equals(n,r){return this.equalsBase(n,r)}}Yi.type=R.G.enumPolyline;var gi=R.G;function jh(f,n){if(f.isEmpty())return!1;const r=f.getGeometryType();if(r===gi.enumPolygon)return 0!==f.calculateArea2D();if(r===gi.enumPolyline)return ha(f.getImpl(),0,!0).bNotEmpty;if(r===gi.enumEnvelope)return!0;if((0,R.f)(r))return!!f.isClosed();if((0,R.e)(r))return!1;if(r===gi.enumGeometryCollection){const l=f;for(let _=0,x=l.getGeometryCount();_<x;_++)if(jh(l.getGeometry(_),n))return!0;return!1}(0,R.b)("")}function mi(f,n){const r=f.getGeometryType();if(r===gi.enumPolygon){const l=new Yi({vd:f.getDescription()});return f.isEmpty()||f.copyToUnchecked(l),l}if(r===gi.enumPolyline)return ha(f.getImpl(),0,!1).boundary;if(r===gi.enumEnvelope){const l=new Yi({vd:f.getDescription()});return f.isEmpty()||l.addEnvelope(f,!1),l}if((0,R.f)(r)){const l=new Ut({vd:f.getDescription()});if(!f.isEmpty()&&!f.isClosed()){const _=new F.P;l.reserve(2),f.queryStart(_),l.add(_),f.queryEnd(_),l.add(_)}return l}if(r===gi.enumGeometryCollection){const l=f;let _=null;for(let x=0,E=l.getGeometryCount();x<E;x++){const v=mi(l.getGeometry(x),n);null!==v&&(null===_&&(_=f.createInstance()),_.addGeometry(v))}return _}if((0,R.e)(r))return new F.P({vd:f.getDescription()});(0,R.b)("")}function ha(f,n,r){const _=f;let x=null;if(r||(x=new Ut({vd:_.getDescription()})),!_.isEmpty()){const E=new F.A(0);for(let v=0,I=_.getPathCount();v<I;v++)if(_.getPathSize(v)>0&&!_.isClosedPathInXYPlane(v)){const D=_.getPathStart(v);E.add(D);const G=_.getPathEnd(v)-1;E.add(G)}if(E.size()>0){const v=new F.B,I=_.getAttributeStreamRef(0),D={userSort(L,j,Q){const et=c.P.getNAN(),K=c.P.getNAN();Q.sort(L,j,(rt,ot)=>(I.queryPoint2D(2*rt,et),I.queryPoint2D(2*ot,K),et.compare(K)))},getValue:L=>I.read(2*L+1)};v.sort(E,0,E.size(),D);let G=I.readPoint2D(2*E.read(0)),q=0,B=1;const z=new F.P;for(let L=1,j=E.size();L<j;L++){const Q=I.readPoint2D(2*E.read(L));if(Q.isEqualPoint2D(G))E.read(q)>E.read(L)?(E.write(q,(0,c.j)()),q=L):E.write(L,(0,c.j)()),B++;else{if(1&B){if(r)return{bNotEmpty:!0,boundary:new Ut({})}}else E.write(q,(0,c.j)());G=Q,q=L,B=1}}if(1&B){if(r)return{bNotEmpty:!0,boundary:new Ut({})}}else E.write(q,(0,c.j)());if(!r){E.sort(0,E.size());for(let L=0,j=E.size();L<j&&E.read(L)!==(0,c.j)();L++)_.getPointByVal(E.read(L),z),x.add(z)}}}return r?{bNotEmpty:!1,boundary:new Ut({})}:{bNotEmpty:!1,boundary:x}}const Ml=c.a4/180,ma=180/c.a4;function Mr(f){let n=f;return n=function la(f){let n=f;return n>=-360&&n<720?(n<0?n+=360:n>=360&&(n-=360),n):(n=(0,c.o)(n,360),n<0&&(n+=360),n)}(n),n>180&&(n-=360),n}function Jh(f){return f*Ml}function Zh(f){return f*ma}function Qh(f){const n=(0,c.a8)();let r=f;return r>=-n&&r<2*n?(r<0&&(r+=n),r>=n&&(r-=n),r):(r=(0,c.o)(r,n),r<0&&(r+=n),r)}function ua(f){const n=(0,c.a5)();let r=f;return r>-n&&r<=n||(r=Qh(r),r>n&&(r-=(0,c.a8)())),r}function ql(f,n){return Mr(n-f)}var un=F.V;class Pi extends Ls{constructor(n){if(void 0===n||(0,c.O)(n,"vd"))return super({vd:n?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_semiMajorAxis=0,this.m_minorMajorRatio=1,this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,this.m_center=new c.P(0,0),this.m_sweepAngle=0,this.m_startAngle=0,this.m_interior=new c.P(0,0),void(this.m_bits=0);if(n.copy)return super(n),void(this!==n.copy&&(this.m_center=new c.P(0,0),this.m_interior=new c.P(0,0),n.copy.copyToImpl(this)));if(n.move)super(n),this.m_semiMajorAxis=n.move.m_semiMajorAxis,this.m_minorMajorRatio=n.move.m_minorMajorRatio,this.m_rotation=n.move.m_rotation,this.m_cosr=n.move.m_cosr,this.m_sinr=n.move.m_sinr,this.m_center=n.move.m_center.clone(),this.m_sweepAngle=n.move.m_sweepAngle,this.m_startAngle=n.move.m_startAngle,this.m_interior=n.move.m_interior.clone(),this.m_bits=n.move.m_bits,this.m_cachedValues=n.move.m_cachedValues,n.move.m_cachedValues=null;else{if(n.fromPoint)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new c.P(0,0),this.m_interior=new c.P(0,0),void this.constructCircularArcThreePoint(n.fromPoint,n.toPoint,n.interiorPoint);if(n.center)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new c.P(0,0),this.m_interior=new c.P(0,0),void this.constructCircleRadius(n.radius,n.center,n.bIsCounterClockwise);if(n.semiMajorAxis)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),void this.constructEllipticArcEndPoints(n.fromPoint,n.toPoint,n.semiMajorAxis,n.minorMajorRatio,n.axisXRotationRad,n.bBigArc,n.bIsCounterClockwise)}}getBoundary(){return mi(this)}assignCopy(n){return this!==n&&n.copyTo(this),this}constructCircleRadius(n,r,l=!1){return this.constructEllipse(n,1,r,0,l),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircleCenterAndPoint(n,r,l=!1){const _=c.P.distance(n,r);return this.constructEllipticArcEndPointsCenter(r,r,_,1,0,!0,l,n),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructTwoPointCircle(n,r,l=!1){const _=c.P.lerp(n,r,.5);return this.constructCircleCenterAndPoint(_,n,l),this}constructLineEllipticArc(n,r){return Ci(this,n,r,1),this}constructLineCircularArc(n,r){return Ci(this,n,r,0),this}constructEllipse(n,r,l,_,x=!1){this.m_semiMajorAxis=Math.abs(n),this.m_minorMajorRatio=Math.abs(r),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const E=new c.P(0,this.m_minorMajorRatio*this.m_semiMajorAxis),v=Math.cos(_),I=Math.sin(_);return E.rotateDirect(v,I),E.addThis(l),this.constructEllipticArcEndPointsCenter(E,E,this.m_semiMajorAxis,this.m_minorMajorRatio,_,!0,x,l),this}inflate(n){if(this.isDegenerateToLine())return;let r=this.getSemiMinorAxis()+n;if(r=r<=0?0:(this.getSemiMajorAxis()+n)/this.getSemiMajorAxis(),this.isCircular()){const l=new Y.T;l.setShiftCoords(-this.m_center.x,-this.m_center.y),l.scale(r,r),l.shiftCoords(this.m_center.x,this.m_center.y),this.applyTransformation(l)}else{const l=new Y.T;this.canonicToWorldTransformation(l);const _=l.clone();_.invertPreciseThis(),_.scale(r,r),_.multiply(l),this.applyTransformation(_)}}constructEnclosingCircle(n,r,l=!1){return function Eo(f,n,r,l){0===r&&(0,R.t)("construct_enclosing_circle");const _=[0,0,0],x=function Vl(f,n,r,l){const _=[];return function ga(f,n){n.length=f;for(let r=0;r<n.length;++r)n[r]=r;f>3&&ee(f,n)}(n,_),function Kh(f,n,r,l,_){let x=0;const E=[0,0,0];let v=0,D=0;for(let G=0;G<3;++G){let q=!1;for(;D<r;){const B=f.at(n[D]);let z=1;if(3===x?z=c.P.inCircleRobust(f.at(l[0]),f.at(l[1]),f.at(l[2]),B):2===x?z=c.P.inCircleRobust3Point(f.at(l[0]),f.at(l[1]),B):1===x&&B.equals(f.at(l[0]))&&(z=0),z<=0){if(z<0&&G+1<3){n[v]=(0,c.b)(n[D],n[D]=n[v]);for(let j=0;j<x;j++)if(l[j]===n[D]){E[j]=D;break}v++}D++;continue}q=!0;let L=0;for(let j=0;j<x;j++)E[j]>D&&(l[L]=l[j],E[L]=E[j],L++);x=L,l[x]=n[D],E[x]=D,x++,x<3?D=v:(1===c.P.orientationRobust(f.at(l[0]),f.at(l[1]),f.at(l[2]))&&(l[2]=(0,c.b)(l[0],l[0]=l[2]),E[2]=(0,c.b)(E[0],E[0]=E[2])),D++)}if(!q)break;if(G+1<3){v=0;let B=!1;for(let z=0;z<x;z++)for(let L=z+1;L<x;L++)E[z]>E[L]&&(E[L]=(0,c.b)(E[z],E[z]=E[L]),l[L]=(0,c.b)(l[z],l[z]=l[L]),B=!0);for(let z=0;z<x;z++)n[E[z]]=(0,c.b)(n[z],n[z]=n[E[z]]),E[z]=z;B&&3===x&&1===c.P.orientationRobust(f.at(l[0]),f.at(l[1]),f.at(l[2]))&&(l[2]=(0,c.b)(l[0],l[0]=l[2]),E[2]=(0,c.b)(E[0],E[0]=E[2]))}D=x}return x}(f,_,n,r)}(n,r,_);if(1===x)f.constructCircleRadius(0,n[_[0]],l);else if(2===x){const E=c.P.lerp(n[_[0]],n[_[1]],.5),v=c.P.distance(n[_[0]],E),I=c.P.distance(n[_[1]],E);f.constructCircleRadius(Math.max(v,I),E,l)}else if(3===x){const E=c.P.calculateCircleCenterFromThreePoints(n[_[0]],n[_[1]],n[_[2]]),v=c.P.distance(n[_[0]],E),I=c.P.distance(n[_[1]],E),D=c.P.distance(n[_[2]],E);f.constructCircleRadius(Math.max(v,I,D),E,l)}else(0,R.c)("unexpected")}(this,n,r,l),this}constructThreePointCircle(n,r,l,_=!1){if(n.equals(r)||r.equals(l)||n.equals(l)){const x=n.clone(),E=r.clone(),v=l.clone();return x.equals(E)&&E.assign(v),this.constructTwoPointCircle(x,E,_)}{const x=c.P.calculateCircleCenterFromThreePoints(n,r,l);if(!x.isFinite()||!Number.isFinite(c.P.distance(n,x))){const E=c.P.distance(n,r),v=c.P.distance(n,l);this.constructLineCircularArc(n,E>=v?r:l)}return this.constructCircleCenterAndPoint(x,n,_)}}constructCircularArcThreePoint(n,r,l){const _=new c.F(n.x),x=new c.F(r.x),E=new c.F(l.x),v=new c.F(n.y),I=new c.F(r.y),D=new c.F(l.y),G=new c.F(.5),q=x.subE(_),B=I.subE(v),z=E.subE(_),L=D.subE(v),j=q.mulE(L).subThisE(B.mulE(z));if(j.scaleError(10),j.isZero()){if(!q.isZero()||!B.isZero())return Ci(this,n,r,0),this;{const Ce=n.clone().addThis(r).mulThis(.5).addThis(l).mulThis(.5),ie=l.sub(Ce).length();this.constructEllipticArcEndPointsCenter(n,r,ie,1,0,!0,!1,Ce),this.m_interior.assign(l)}return this.setProjectionBehavior(0),this}const Q=q.sqr().addThisE(B.sqr()).mulThisE(G),et=z.sqr().addThisE(L.sqr()).mulThisE(G),K=Q.mulE(L).subThisE(et.mulE(B)),rt=q.mulE(et).subThisE(z.mulE(Q));K.divThisE(j),rt.divThisE(j);const ot=K.sqr().addThisE(rt.sqr());ot.sqrtThis();const nt=K.addE(_),at=rt.addE(v);let pt=n.x-nt.value(),gt=n.y-at.value();const yt=Math.atan2(gt,pt);pt=r.x-nt.value(),gt=r.y-at.value();const ft=Math.atan2(gt,pt);pt=l.x-nt.value(),gt=l.y-at.value();const bt=Math.atan2(gt,pt);let Dt=bt-2*(0,c.a5)();for(;Dt<yt;)Dt+=2*(0,c.a5)();let Nt=ft-2*(0,c.a5)();for(;Nt<Dt;)Nt+=2*(0,c.a5)();let Ft=bt+2*(0,c.a5)();for(;Ft>yt;)Ft-=2*(0,c.a5)();let Ot,Qt=ft+2*(0,c.a5)();for(;Qt>Ft;)Qt-=2*(0,c.a5)();Ot=Nt-yt<yt-Qt?Nt-yt:Qt-yt;const Kt=new c.P(nt.value(),at.value());return this.constructEllipticArcEndPointsCenter(n,r,ot.value(),1,0,Math.abs(Ot)>(0,c.a5)(),Ot>0,Kt),this.m_interior.assign(l),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircularArc(n,r,l,_){return this.constructEllipticArcGeneral(n,1,r,l,_,0),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructEllipticArcEndPoints(n,r,l,_,x,E,v){return um(this,n,r,l,_,x,E,v)}constructEllipticArcEndPointsCenter(n,r,l,_,x,E,v,I){return um(this,n,r,l,_,x,E,v,I)}constructEllipticArcGeneral(n,r,l,_,x,E){this.m_semiMajorAxis=Math.abs(n),this.m_minorMajorRatio=Math.abs(r),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const v=ua(E),I=Math.cos(v),D=Math.sin(v),G=new c.P(this.m_semiMajorAxis,this.m_minorMajorRatio*this.m_semiMajorAxis),q=c.P.getNAN(),B=ua(_);q.x=G.x*Math.cos(B),q.y=G.y*Math.sin(B),q.rotateDirect(I,D),q.addThis(l);const z=(0,c.ag)(x,(0,c.a8)());let L=z;Math.abs(L)===(0,c.a8)()&&(L=0);const j=c.P.getNAN();return j.x=G.x*Math.cos(B+L),j.y=G.y*Math.sin(B+L),j.rotateDirect(I,D),j.addThis(l),this.constructEllipticArcEndPointsCenter(q,j,this.m_semiMajorAxis,this.m_minorMajorRatio,v,Math.abs(z)>(0,c.a5)(),z>0,l)}constructEllipticArcAsNURB(n,r,l,_){return(_>=1||_<0)&&(0,R.t)("construct_elliptic_arc_as_NURB: weight"),r.isFinite()||(0,R.t)("construct_elliptic_arc_as_NURB: control_point"),bn([n,r,l],_*_,null,!1,this),this}constructCanonic(n){return this.assignCopy(n),n.isDegenerateToLine()||n.m_center.isEqual(0,0)&&0===this.m_rotation||(this.m_XStart=n.getSemiMajorAxis()*Math.cos(n.m_startAngle),this.m_YStart=n.getSemiMinorAxis()*Math.sin(n.m_startAngle),this.m_XEnd=n.getSemiMajorAxis()*Math.cos(n.getEndAngle()),this.m_YEnd=n.getSemiMinorAxis()*Math.sin(n.getEndAngle()),this.m_center.setCoords(0,0),this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,jn(this),this.afterCompletedModification(),n!==this&&Ts(this,n)),this}isCircular(){return 1===this.m_minorMajorRatio&&0===this.m_rotation&&!this.isDegenerateToLine()}isDegenerateToLineHelper(n){return!!Pe(this,[n])&&ss(this)}isDegenerateToLine(){return ss(this)}getCenter(){return this.m_center.clone()}setCenter(n){if(!this.m_center.isNAN()){const r=n.sub(this.m_center);this.m_XStart+=r.x,this.m_YStart+=r.y,this.m_XEnd+=r.x,this.m_YEnd+=r.y,this.m_interior.addThis(r),this.m_center.assign(n),this.endPointModified(),this.normalizeAfterEndpointChange()}}getAxisXRotation(){return this.m_rotation}getSemiAxes(){return c.P.construct(this.m_semiMajorAxis,this.m_semiMajorAxis*this.m_minorMajorRatio)}getSemiMajorAxis(){return this.m_semiMajorAxis}getSemiMinorAxis(){return this.m_semiMajorAxis*this.m_minorMajorRatio}getMinorMajorRatio(){return this.m_minorMajorRatio}isClockwise(){return!vn(this)}isMajor(){return Ia(this)}getSweepAngle(){return this.m_sweepAngle}getStartAngle(){return this.m_startAngle}getEndAngle(){return this.m_startAngle+this.m_sweepAngle}getGeometryType(){return R.G.enumEllipticArc}queryEnvelope(n){if(4===n.m_EnvelopeType){n.setEmpty(),n.assignVertexDescription(this.m_description);const r=dt.J.constructEmpty();this.queryEnvelope(r),n.setEnvelope(r);for(let l=1,_=this.m_description.getAttributeCount();l<_;l++){const x=this.m_description.getSemantics(l);for(let E=0,v=un.getComponentCount(x);l<v;l++){const I=this.queryInterval(x,E);n.setIntervalEnvelope(x,E,I)}}}else 2===n.m_EnvelopeType?xm(this,c.E.unit(),n):(0,R.b)("3d not impl")}applyTransformation(n){va(this,n,!1)}createInstance(){return new Pi}calculateLength2D(){return function Bl(f,n,r){if(ss(f))return(r-n)*c.P.distance(f.getStartXY(),f.getEndXY());if(1===f.m_minorMajorRatio)return Math.abs(f.getSweepAngle()*(n-r))*f.m_semiMajorAxis;const l=po(f,n);return po(f,r)-l}(this,0,1)}queryCoord2D(n,r){if(ss(this))nr(n,this.getStartXY(),this.getEndXY(),r);else if(0===n)r.assign(c.P.construct(this.m_XStart,this.m_YStart));else if(1===n)r.assign(c.P.construct(this.m_XEnd,this.m_YEnd));else{const l=Ri(this,n),_=new c.P(this.m_semiMajorAxis*Math.cos(l),this.getSemiMinorAxis()*Math.sin(l));_.rotateDirect(this.m_cosr,this.m_sinr),_.addThis(this.m_center),r.assign(_)}}queryCoord2DE(n,r){!function rm(f,n,r){if(ss(f))or(new ke({start:f.getStartXY(),end:f.getEndXY()}),n,r);else if(0===n.value())r.set(f.getStartXY());else if(1===n.value())r.set(f.getEndXY());else{const l=new c.F;hm(f,n,l);const _=new c.F,x=new c.F;c.F.st_cosAndSin(l,_,x);const E=Vt.constructCoordsE(new c.F(f.m_semiMajorAxis).mulThisE(_),new c.F(f.m_semiMajorAxis).mulThis(f.m_minorMajorRatio).mulThisE(x)),v=new c.F(f.m_rotation);c.F.st_cosAndSin(v,_,x),E.rotateDirect(_,x),E.addThisE(Vt.constructPoint2D(f.m_center)),r.setE(E)}}(this,n,r)}getCoordX(n){const r=new c.P;return this.queryCoord2D(n,r),r.x}getCoordY(n){const r=new c.P;return this.queryCoord2D(n,r),r.y}cut(n,r,l){const _=new is;return this.queryCut(n,r,_,l),_.releaseSegment()}queryCut(n,r,l,_){const x=l.createEllipticArc();let E=0===n&&1===r;if(E&&!_)return void this.copyTo(x);const v=c.P.getNAN();this.queryCoord2D(n,v);const I=c.P.getNAN();if(this.queryCoord2D(r,I),!E)if(v.equals(I))r-n>.5&&this.isMajor()&&this.isClosed()?(E=!0,n=0,r=1):1===r?n=r:r=n;else if(n>0&&v.isEqual(this.m_XStart,this.m_YStart)&&(n=0),r<1&&I.isEqual(this.m_XEnd,this.m_YEnd)&&(r=1),E=0===n&&1===r,E&&!_)return void this.copyTo(x);if(x.m_center.assign(this.m_center),x.m_semiMajorAxis=this.m_semiMajorAxis,x.m_minorMajorRatio=this.m_minorMajorRatio,x.m_interior.assign(this.m_interior),x.m_rotation=this.m_rotation,x.m_cosr=this.m_cosr,x.m_sinr=this.m_sinr,x.m_sweepAngle=this.m_sweepAngle,x.m_startAngle=this.m_startAngle,x.m_bits=this.m_bits,Be(x,v.x,v.y),we(x,I.x,I.y),E)return void ba(x,Ea(this));x.m_startAngle=Ri(this,n),x.m_sweepAngle=Ri(this,r)-x.m_startAngle,x.m_startAngle=Cn(x.m_startAngle),Wn(x,Math.abs(x.m_sweepAngle)>(0,c.a5)()),x.assignVertexDescription(this.m_description),jn(x),ya(x);const D=this.m_description.getAttributeCount();if(D>1){for(let G=1;G<D;G++){const q=this.m_description.getSemantics(G),B=un.getComponentCount(q);for(let z=0;z<B;z++){const L=this.getAttributeAsDbl(n,q,z);x.setStartAttribute(q,z,L)}}for(let G=1;G<D;G++){const q=this.m_description.getSemantics(G),B=un.getComponentCount(q);for(let z=0;z<B;z++){const L=this.getAttributeAsDbl(r,q,z);x.setEndAttribute(q,z,L)}}}x.afterCompletedModification()}queryDerivative(n,r){!function Co(f,n,r){if(ss(f))r.setE(Vt.constructPoint2D(f.getEndXY()).subE(Vt.constructPoint2D(f.getStartXY())));else{const l=new c.F;hm(f,n,l);const _=new Vt;if(_.setCoordsE(new c.F(f.m_semiMajorAxis).negate().mulE((new c.F).setSin(l)),new c.F(f.getSemiMinorAxis()).mulE((new c.F).setCos(l))),f.m_rotation){const x=new c.F(f.m_rotation);_.rotateDirect((new c.F).setCos(x),(new c.F).setSin(x))}_.scaleThis(new c.F(f.getSweepAngle())),r.setE(_)}}(this,n,r)}cutArcIgnoreAttributes(n,r,l){let _=0===n&&1===r;const x=new c.P;this.queryCoord2D(n,x);const E=new c.P;this.queryCoord2D(r,E),_||(x.equals(E)?r-n>.5&&this.isMajor()&&this.isClosed()?(_=!0,n=0,r=1):1===r?n=r:r=n:(n>0&&x.isEqual(this.m_XStart,this.m_YStart)&&(n=0),r<1&&E.isEqual(this.m_XEnd,this.m_YEnd)&&(r=1),_=0===n&&1===r)),l.m_center.assign(this.m_center),l.m_semiMajorAxis=this.m_semiMajorAxis,l.m_minorMajorRatio=this.m_minorMajorRatio,l.m_interior.assign(this.m_interior),l.m_rotation=this.m_rotation,l.m_cosr=this.m_cosr,l.m_sinr=this.m_sinr,l.m_sweepAngle=this.m_sweepAngle,l.m_startAngle=this.m_startAngle,l.m_bits=this.m_bits,Be(l,x.x,x.y),we(l,E.x,E.y),_?ba(l,Ea(this)):(l.m_startAngle=Ri(this,n),l.m_sweepAngle=Ri(this,r)-l.m_startAngle,l.m_startAngle=Cn(l.m_startAngle),Wn(l,Math.abs(l.m_sweepAngle)>Math.PI),jn(l),l.afterCompletedModification())}changeEndPoints2D(n,r){mm(this,n,r,!1)}getAttributeAsDbl(n,r,l){if(0===r)return 0===l?this.getCoordX(n):this.getCoordY(n);if(0===n)return this.getStartAttributeAsDbl(r,l);if(1===n)return this.getEndAttributeAsDbl(r,l);const _=this.calculateLength2D(),x=_>0?this.tToLength(n)/_:0,E=un.getInterpolation(r),v=this.getStartAttributeAsDbl(r,l),I=this.getEndAttributeAsDbl(r,l);return(0,c.T)(E,v,I,x,un.getDefaultValue(r))}getClosestCoordinate(n,r){return Pm(this,n,c.E.unit(),r)}getClosestCoordinateOnInterval(n,r,l=-1){return Pm(this,n,r,!1)}getYMonotonicParts(n,r=!1){n.length<2&&(0,R.t)("");const l=this.getSemiAxes(),_=Math.atan2(l.y*this.m_cosr,l.x*this.m_sinr),x=_+(0,c.a5)(),E=(0,c.d)(3,Number.NaN);let v=0;if(E[0]=xs(this,_),E[0]>0&&E[0]<1&&v++,E[1]=xs(this,x),E[1]>0&&E[1]<1&&(E[v]=E[1],v++),0===v)return 0;E[v]=1,v++,(0,R.g)(n.length>=v);let I=0;for(let D=0;D<v;D++){const G=E[D];this.queryCut(I,G,n[D],r),I=G}return v}getMonotonicParts(n,r){if(n.length<4&&(0,R.t)(""),this.isDegenerateToLine())return n[0].createEllipticArc().assignCopy(this),r&&n[0].get().dropAllAttributes(),1;const l=this.getSemiAxes(),_=(0,c.d)(4,Number.NaN);_[0]=Math.atan2(l.y*this.m_cosr,l.x*this.m_sinr),_[1]=_[0]+(0,c.a5)(),_[2]=Math.atan2(-l.y*this.m_sinr,l.x*this.m_cosr),_[3]=_[2]+(0,c.a5)();const x=(0,c.d)(5,Number.NaN);let E=0;for(let I=0;I<4;I++)x[E]=xs(this,_[I]),x[E]>0&&x[E]<1&&E++;if(0===E)return 0;(0,c.U)(x,E),x[E-1]<1&&(x[E]=1,E++),(0,R.g)(n.length>=E);let v=0;for(let I=0;I<E;I++){const D=x[I];this.queryCut(v,D,n[I],r),v=D}return E}intersectionWithAxis2D(n,r,l,_){if(ss(this))return new ke({start:this.getStartXY(),end:this.getEndXY()}).intersectionWithAxis2D(n,r,l,_);let x,E;const v=new c.F(r),I=this.getSemiAxes();if(n){if(r>this.m_center.y+I.x||r<this.m_center.y-I.x)return 0;x=new c.F(I.x).mulThis(this.m_sinr),E=new c.F(I.y).mulThis(this.m_cosr),v.subThis(this.m_center.y)}else{if(r>this.m_center.x+I.x||r<this.m_center.x-I.x)return 0;x=new c.F(I.x).mulThis(this.m_cosr),E=new c.F(I.y).mulThis(-this.m_sinr),v.subThis(this.m_center.x)}const D=x.sqr(),G=E.sqr(),q=D.addE(G),B=E.mulE(v).mulThis(-2),z=v.sqr().subThisE(D),L=B.sqr().subThisE(q.mulE(z).mulThis(4)),j=x.mulE(v).mulThis(-2),Q=v.sqr().subThisE(G),et=j.sqr().subThisE(q.mulE(Q).mulThis(4));let K=L.eps()*Math.abs(et.value())<=et.eps()*Math.abs(L.value());K?x.isZero()&&(K=!1):E.isZero()&&(K=!0),K||(B.setE(j),z.setE(Q));const rt=(0,c.m)(c.F,2);let ot=it(q,B,z,c.E.construct(-1,1),!1,rt);if(0===ot)return 0;const nt=[0,0];let at=0;for(let pt=0;pt<ot;pt++){const gt=new c.F,yt=new c.F;K?(gt.setE(rt[pt]),yt.setE(v.subE(E.mulE(rt[pt])).divThisE(x))):(yt.setE(rt[pt]),gt.setE(v.subE(x.mulE(rt[pt])).divThisE(E)));const ft=xs(this,Math.atan2(gt.value(),yt.value()));ft>=0&&ft<=1&&(nt[at]=ft,at++)}return ot=at,0===ot?0:(2===ot&&nt[0]>nt[1]&&(nt[1]=(0,c.b)(nt[0],nt[0]=nt[1])),_&&(0,c.a)(_,nt,0,0,ot),l&&(l[0]=n?this.getCoordX(nt[0]):this.getCoordY(nt[0]),ot>1&&(l[1]=n?this.getCoordX(nt[1]):this.getCoordY(nt[1]),!_&&l[0]>l[1]&&(l[1]=(0,c.b)(l[0],l[0]=l[1])))),ot)}intersectionOfYMonotonicWithAxisX(n,r){if(this.m_YStart===this.m_YEnd)return n===this.m_YStart?r:Number.NaN;if(n===this.m_YStart)return this.m_XStart;if(n===this.m_YEnd)return this.m_XEnd;const l=[0,0];return-1===this.intersectionWithAxis2D(!0,n,l,null)?r:l[0]}isCurve(){return!0}isDegenerate(n){return Te(this,n)}isDegenerate3D(n,r){return(0,R.g)(0),!1}queryLooseEnvelope(n){3!==n.m_EnvelopeType?this.queryLooseEnvelopeOnInterval(new c.E(0,1),n):(0,R.b)("3d not impl")}clone(n){const r=new Pi;return this.copyTo(r),r}queryInterval(n,r){if(0===n){if(ss(this))return 0===r?c.E.construct(this.getStartX(),this.getEndX()):c.E.construct(this.getStartY(),this.getEndY());let l;const _=this.getSemiAxes();l=0===r?Math.atan2(-_.y*this.m_sinr,_.x*this.m_cosr):Math.atan2(_.y*this.m_cosr,_.x*this.m_sinr);const x=l+Math.PI,E=[0,0];E[0]=xs(this,l),E[1]=xs(this,x);const v=0===r?c.E.construct(this.getStartX(),this.getEndX()):c.E.construct(this.getStartY(),this.getEndY()),I=new c.P;for(let D=0;D<2;D++){const G=E[D];G>0&&G<1&&(this.queryCoord2D(G,I),v.mergeNeCoordinate(0===r?I.x:I.y))}return v}return super.queryInterval(n,r)}queryLooseEnvelopeOnInterval(n,r){const l=new c.E(0,1);if(l.intersect(n),l.isEmpty())return void r.setEmpty();if(ss(this))return r.setCoords(this.getCoord2D(l.vmin)),void r.mergeNe(this.getCoord2D(l.vmax));const _=this.getCoord2D(l.vmin),x=this.getCoord2D(l.vmax);if(1===this.m_minorMajorRatio&&Math.abs(this.m_sweepAngle)*l.width()<=c.l){let E=c.P.lerp(_,x,.5);const v=E.sub(this.m_center);return v.normalize(),E=E.add(v.mul(.5*c.P.distance(_,x))),r.setCoords(_),r.mergeNe(x),void r.mergeNe(E)}xm(this,l,r)}tToLength(n){return ss(this)?n*c.P.distance(this.getStartXY(),this.getEndXY()):1===this.m_minorMajorRatio?Math.abs(this.getSweepAngle()*n)*this.m_semiMajorAxis:po(this,n)}parametricAngleToT(n){return xs(this,n)}tToParametricAngle(n){return Ri(this,n)}lengthToT(n){if(ss(this)){const r=c.P.distance(this.getStartXY(),this.getEndXY());return 0===r?0:n/r}if(1===this.m_minorMajorRatio){const r=Math.abs(this.getSweepAngle())*this.m_semiMajorAxis;return 0===r?0:n/r}return function fo(f,n){if(ss(f)){const I=c.P.distance(f.getStartXY(),f.getEndXY());return 0===I?0:n/I}if(1===f.m_minorMajorRatio){const I=Math.abs(f.getSweepAngle()*f.m_semiMajorAxis);return 0===I?0:n/I}if(0===n)return 0;const r=f.getSweepAngle();if(0===r)return.5;const l=Ca(f),_=(0,c.a7)(),x=Sa(f);r<0&&(n=-n);let v=(0,c.aa)(n/f.m_semiMajorAxis+x,l.e2,l.completeE);return v-=_,v-=f.getStartAngle(),v/r}(this,n)}calculateWeightedAreaCentroid2D(n){if(ss(this)){const G=new c.P;return G.setCoords(0,0),G}const r=dm(this),l=this.getStartXY().sub(this.m_center),_=this.getEndXY().sub(this.m_center),x=this.m_semiMajorAxis,E=this.getSemiMinorAxis(),v=this.m_startAngle+this.m_sweepAngle,I=new c.P;I.x=x*E*(x*this.m_cosr*(-Math.sin(v)+Math.sin(this.m_startAngle))+E*(-Math.cos(v)+Math.cos(this.m_startAngle))*this.m_sinr)/3,I.y=x*E*(E*(Math.cos(v)-Math.cos(this.m_startAngle))*this.m_cosr+x*(-Math.sin(v)+Math.sin(this.m_startAngle))*this.m_sinr)/3;const D=_.add(l).mul(_.crossProduct(l)/6);return I.x-=D.x,I.y-=D.y,I.add(this.m_center.sub(n).mul(r))}calculateWeightedCentroid2D(){const n=new c.P;if(this.isDegenerate(0))return n.setCoords(0,0),n;if(ss(this))return n.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),n;let r=this.m_startAngle,l=this.m_startAngle+this.m_sweepAngle;if(l<r){const I=r;r=l,l=I}const _=Math.sin(r),x=Math.sin(l),E=Math.cos(r),v=Math.cos(l);if(1===this.m_minorMajorRatio){const I=this.getSemiMajorAxis(),D=I*I;n.setCoords(D*(x-_),D*(E-v))}else{const I=this.getSemiMajorAxis(),D=this.getSemiMinorAxis(),G=I*I,q=D*D,B=I*D,z=G-q,L=z/q,j=z/G,Q=Math.sqrt(L),et=Math.sqrt(j),K=.5*B*(Math.asinh(Q*x)/Q+x*Math.sqrt(1+L*x*x))-.5*B*(Math.asinh(Q*_)/Q+_*Math.sqrt(1+L*_*_)),rt=-.5*B*(Math.asin(et*v)/et+v*Math.sqrt(1-j*v*v))- -.5*B*(Math.asin(et*E)/et+E*Math.sqrt(1-j*E*E));n.setCoords(K,rt)}return n.rotateDirect(this.m_cosr,this.m_sinr),n.assign(n.add(this.m_center.mul(this.calculateLength2D()))),n}isIntersectingPoint(n,r,l){if(l&&(n.isEqualPoint2D(this.getStartXY())||n.isEqualPoint2D(this.getEndXY())))return!1;if(!ss(this)){const E=c.P.distance(n,this.m_center),v=this.getSemiAxes();if(E<v.x-r||E>v.y+r)return!1}const _=this.getClosestCoordinate(n,!1),x=new c.P;return this.queryCoord2D(_,x),c.P.distance(x,n)<=r}isIntersectingPoint3D(n,r,l,_,x=1){return(0,R.g)(0),!1}getTangent(n){if(ss(this))return this.getEndXY().sub(this.getStartXY());{const r=Ri(this,n),l=new c.P;return l.setCoords(-this.m_semiMajorAxis*Math.sin(r),this.getSemiMinorAxis()*Math.cos(r)),this.m_rotation&&l.rotateDirect(this.m_cosr,this.m_sinr),l.scale(this.getSweepAngle()),l}}getDerivative(n){if(ss(this))return this.getEndXY().sub(this.getStartXY());{const r=Ri(this,n),l=new c.P;return l.setCoords(-this.m_semiMajorAxis*Math.sin(r),this.getSemiMinorAxis()*Math.cos(r)),this.m_rotation&&l.rotateDirect(this.m_cosr,this.m_sinr),l.scale(this.getSweepAngle()),l}}normalizeAfterEndpointChange(){return!!wa(this)&&(ss(this)?(qr(this),!1):Po(this,!1))}projectionBehavior(){return(4&this.m_bits)>>2}setProjectionBehavior(n){this.m_bits=-5&this.m_bits|n<<2}convertToCanonic(n){const r=new c.P(n.x,n.y);return r.subThis(this.m_center),r.rotateReverse(this.m_cosr,this.m_sinr),r}convertFromCanonic(n){const r=new c.P(n.x,n.y);return r.rotateDirect(this.m_cosr,this.m_sinr),r.addThis(this.m_center),r}canonicToWorldTransformation(n){n.setRotate(this.m_cosr,this.m_sinr),n.shiftCoords(this.m_center.x,this.m_center.y)}getCurvature(n){const r=Ri(this,n),l=new c.P,_=this.getSemiMinorAxis();l.setCoords(-this.m_semiMajorAxis*Math.sin(r),_*Math.cos(r));const x=new c.P;x.setCoords(-this.m_semiMajorAxis*Math.cos(r),-_*Math.sin(r)),this.m_rotation&&(l.rotateDirect(this.m_cosr,this.m_sinr),x.rotateDirect(this.m_cosr,this.m_sinr));const E=l.sqrLength();if(0===E)return Number.NaN;const v=Math.sqrt(E);return l.divThis(v),l.crossProduct(x)/E}getMonotonicPartParams(n,r){const l=(0,c.d)(6,Number.NaN);l[0]=0;let _=1;if(this.isDegenerateToLine())l[1]=1,_=2;else{const x=this.getSemiAxes(),E=(0,c.d)(4,Number.NaN);this.m_rotation?(E[0]=Math.atan2(x.y*this.m_cosr,x.x*this.m_sinr),E[1]=E[0]+Math.PI,E[2]=Math.atan2(-x.y*this.m_sinr,x.x*this.m_cosr),E[3]=E[2]+Math.PI):(E[0]=0,E[1]=Math.PI,E[2]=.5*Math.PI,E[3]=(0,c.a6)());for(let v=0;v<4;v++){const I=xs(this,E[v]);I>0&&I<1&&(l[_]=I,_++)}_>2&&(0,c.U)(l,_),l[_]=1,_++}if(r){n<_&&(0,R.t)("");for(let x=0;x<_;x++)r[x]=l[x]}return _}calculateLowerLength2D(){const n=c.P.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return n;const r=Math.abs(this.m_sweepAngle)*this.getSemiMinorAxis();return Math.max(r,n)}calculateUpperLength2D(){const n=c.P.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return n;const r=Math.abs(this.m_sweepAngle)*this.getSemiMajorAxis();return Math.max(r,n)}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=(0,c.b)(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=(0,c.b)(this.m_YStart,this.m_YStart=this.m_YEnd);for(let n=0,r=this.m_description.getTotalComponentCount()-2;n<r;n++)this.m_attributes[n+r]=(0,c.b)(this.m_attributes[n],this.m_attributes[n]=this.m_attributes[n+r]);this.m_startAngle=this.m_startAngle+this.m_sweepAngle,this.m_sweepAngle=-this.m_sweepAngle}}isLine(){return ss(this)}copyIgnoreAttributes(n){n.m_XStart=this.m_XStart,n.m_YStart=this.m_YStart,n.m_XEnd=this.m_XEnd,n.m_YEnd=this.m_YEnd,n.m_center.assign(this.m_center),n.m_semiMajorAxis=this.m_semiMajorAxis,n.m_minorMajorRatio=this.m_minorMajorRatio,n.m_interior.assign(this.m_interior),n.m_rotation=this.m_rotation,n.m_cosr=this.m_cosr,n.m_sinr=this.m_sinr,n.m_sweepAngle=this.m_sweepAngle,n.m_startAngle=this.m_startAngle,n.m_bits=this.m_bits,Sn(n)}calculateArea2DHelper(){return dm(this)}absNorm(){let n=this.getStartXY().norm(1)+this.getEndXY().norm(1);return this.isDegenerateToLine()||(n+=this.m_center.norm(1),n+=this.m_semiMajorAxis),n}queryEnvelopeW(n,r){if(r.setCoords(this.getCoord2D(n.vmin)),r.mergeNe(this.getCoord2D(n.vmax)),ss(this))return;const l=this.getSemiAxes(),_=(0,c.d)(8,Number.NaN);{const E=Math.atan2(-l.y*this.m_sinr,l.x*this.m_cosr),v=E+Math.PI,I=Math.atan2(l.y*this.m_cosr,l.x*this.m_sinr),D=I+Math.PI;_[0]=xs(this,E),_[1]=xs(this,v),_[2]=xs(this,I),_[3]=xs(this,D)}{const E=this.m_cosr+this.m_sinr,v=this.m_cosr-this.m_sinr,I=Math.atan2(-l.y*E,l.x*v),D=I+Math.PI,G=Math.atan2(l.y*v,l.x*E),q=G+Math.PI;_[4]=xs(this,I),_[5]=xs(this,D),_[6]=xs(this,G),_[7]=xs(this,q)}const x=c.P.getNAN();for(let E=0;E<8;E++){const v=_[E];n.containsExclusiveCoordinate(v)&&(this.queryCoord2D(v,x),r.mergeNe(x))}}setSegmentFromCoords(n,r){!function lm(f,n,r){const l=0===f.projectionBehavior();if(r<=2)return void Ci(f,n[0],n[r-1],l?0:1);if(l){f.constructCircularArcThreePoint(n[0],n[r-1],n[Math.trunc(r/2)]);const L=new c.P;return f.queryCoord2D(.5,L),void f.m_interior.setCoordsPoint2D(L)}const _=f.getSemiMajorAxis(),x=f.getMinorMajorRatio(),E=f.getAxisXRotation(),v=f.getCenter(),I=new Array(4);I[0]=f.isMajor(),I[1]=!I[0],I[2]=I[0],I[3]=!I[0];const D=new Array(4);D[0]=f.isClockwise(),D[1]=D[0],D[2]=!D[0],D[3]=!D[0];const G=Math.trunc(r<5?1:(r+4)/5),q=(0,c.m)(Pi,4),B=(0,c.d)(4,Number.NaN);let z=0;for(let L=0;L<4;L++){q[L].constructEllipticArcEndPointsCenter(n[0],n[r-1],_,x,E,I[L],D[L],v),B[L]=0;let j=0;for(let Q=G;Q<r-1;Q+=G){const et=q[L].getClosestCoordinate(n[Q],!1);B[L]+=c.P.sqrDistance(q[L].getCoord2D(et),n[Q]),j++}B[L]/=j,B[L]<B[z]&&(z=L)}f.assignCopy(q[z])}(this,n,r)}writeInBufferStream(n,r){const l=new Float64Array(10);return l[0]=this.m_bits,l[1]=this.m_semiMajorAxis,l[2]=this.m_minorMajorRatio,l[3]=this.m_rotation,l[4]=this.m_center.x,l[5]=this.m_center.y,l[6]=this.m_sweepAngle,l[7]=this.m_startAngle,l[8]=this.m_interior.x,l[9]=this.m_interior.y,n.writeRangeFromArray(r,l.length,l,!0,1),r+l.length}readFromBufferStream(n,r){const l=new Float64Array(10);n.queryRange(r,l.length,l,!0,1),this.m_bits=l[0],this.m_semiMajorAxis=l[1],this.m_minorMajorRatio=l[2],this.m_rotation=l[3],this.m_center.x=l[4],this.m_center.y=l[5],this.m_sweepAngle=l[6],this.m_startAngle=l[7],this.m_interior.x=l[8],this.m_interior.y=l[9],this.m_cosr=Math.cos(this.m_rotation),this.m_sinr=Math.sin(this.m_rotation),this.m_cachedValues=null}snapControlPoints(n){return!1}needsSnapControlPoints(n){return!1}calculateSpecialPointsForCracking(n,r){return(0,R.c)("should not1; be called"),0}ensureXYMonotone(){if(ss(this))return!1;if(this.getStartXY().equals(this.getEndXY()))return Ci(this,this.getStartXY(),this.getEndXY(),this.projectionBehavior()),!0;const n=(0,c.m)(c.P,3);let r=yo(this,n);if(xn(n)){let l=!1;if(0===this.projectionBehavior()){const _=new dt.J;_.setCoords({pt:n[0]}),_.mergeNe(n[2]);const x=new c.P;x.setSub(n[2],n[0]),x.leftPerpendicularThis(),x.normalize(),x.scale(c.P.distance(n[2],n[0]));const E=c.P.lerp(n[2],n[0],.5),v=E.sub(x),I=E.add(x);_.clipLine(v,I);const D=c.P.getClosestCoordinate(v,I,n[1],!1);n[1]=c.P.lerp(v,I,D);const G=n[2].sub(n[1]),q=n[0].sub(n[1]),B=G.crossProduct(q),z=G.dotProduct(q);r=(0,c.a7)()-Math.abs(.5*Math.atan2(B,z)),l=!0}return bn(n,r*r,null,l,this),!0}return!1}setCoordsForIntersector(n,r,l){mm(this,n,r,l)}getInteriorPoint(){return this.m_interior.clone()}copyToImpl(n){const r=n;r.m_center.assign(this.m_center),r.m_semiMajorAxis=this.m_semiMajorAxis,r.m_minorMajorRatio=this.m_minorMajorRatio,r.m_interior.assign(this.m_interior),r.m_rotation=this.m_rotation,r.m_cosr=this.m_cosr,r.m_sinr=this.m_sinr,r.m_sweepAngle=this.m_sweepAngle,r.m_startAngle=this.m_startAngle,r.m_bits=this.m_bits,ba(r,Ea(this))}reverseImpl(){xo(this,!vn(this)),ya(this),(0!==this.projectionBehavior()||this.getStartXY().equals(this.getEndXY()))&&jn(this)}equalsImpl(n){const r=n;return!(this.m_bits!==r.m_bits||this.m_semiMajorAxis!==r.m_semiMajorAxis||this.m_minorMajorRatio!==r.m_minorMajorRatio||!(this.m_center.isEqualPoint2D(r.m_center)||this.m_center.isNAN()&&r.m_center.isNAN())||this.m_rotation!==r.m_rotation||!this.m_interior.equals(r.m_interior))&&(this.m_sweepAngle===r.m_sweepAngle&&this.m_startAngle===r.m_startAngle)}equalsImplTol(n,r){const l=n;if(this.m_bits!==l.m_bits)return!1;if(this.m_center.isNAN()&&l.m_center.isNAN())return!0;if(this.m_center.isNAN()!==l.m_center.isNAN()||!this.getSemiAxes().isEqualPoint2D(l.getSemiAxes(),r)||!this.m_center.isEqualPoint2D(l.m_center,r))return!1;const _=Math.abs(Jh(Mr(Zh(this.m_rotation-l.m_rotation)))),x=Math.abs((0,c.a5)()-_),E=Math.min(_,x);if(this.m_semiMajorAxis*Math.abs(E)>r)return!1;const v=this.getCoord2D(.5),I=l.getCoord2D(.5);return!!v.isEqualPoint2D(I,r)}swapImpl(n){const r=n;this.m_center=(0,c.b)(r.m_center,r.m_center=this.m_center),this.m_semiMajorAxis=(0,c.b)(r.m_semiMajorAxis,r.m_semiMajorAxis=this.m_semiMajorAxis),this.m_minorMajorRatio=(0,c.b)(r.m_minorMajorRatio,r.m_minorMajorRatio=this.m_minorMajorRatio),this.m_interior=(0,c.b)(r.m_interior,r.m_interior=this.m_interior),this.m_rotation=(0,c.b)(r.m_rotation,r.m_rotation=this.m_rotation),this.m_cosr=(0,c.b)(r.m_cosr,r.m_cosr=this.m_cosr),this.m_sinr=(0,c.b)(r.m_sinr,r.m_sinr=this.m_sinr),this.m_sweepAngle=(0,c.b)(r.m_sweepAngle,r.m_sweepAngle=this.m_sweepAngle),this.m_startAngle=(0,c.b)(r.m_startAngle,r.m_startAngle=this.m_startAngle),this.m_bits=(0,c.b)(r.m_bits,r.m_bits=this.m_bits),function ki(f,n){n.m_cachedValues=(0,c.b)(f.m_cachedValues,f.m_cachedValues=n.m_cachedValues)}(this,r)}afterCompletedModification(){qr(this),Sn(this)}intersect(n,r,l,_,x){return $n(!1,this,n,r,l,_,x)}intersectPoint(n,r,l){if(r.length<2&&(0,R.n)(""),ss(this))return new ke({start:this.getStartXY(),end:this.getEndXY()}).intersectPoint(n,r,l);{const E=c.P.distance(n,this.m_center);if(E>this.m_semiMajorAxis+l||E<this.getSemiMinorAxis()-l)return 0}const _=this.getClosestCoordinate(n,!1),x=c.P.getNAN();return this.queryCoord2D(_,x),c.P.distance(x,n)<=l?(0,c.J)(_,0,1)&&(this.queryCoord2D(0===_?1:0,x),c.P.distance(x,n)<=l)?(r&&(r[0]=0,r[1]=1),2):(r&&(r[0]=_),1):0}isIntersecting(n,r,l){return 0!==Kn(!1,this,n,r,l)}endPointModified(){this.m_bits|=8,Sn(this)}clearEndPointModified(){qr(this)}}Pi.type=R.G.enumEllipticArc;class yi extends Vi{constructor(n){n?n.vd?(super({vd:n.vd,bPolygon:!0}),this.m_segmentBufferCTor=is):n.copy?(super({vd:n.copy.getDescription(),bPolygon:!0}),this.m_segmentBufferCTor=is,n.copy.copyTo(this)):n.move?(super({move:n.move}),this.m_segmentBufferCTor=is):n.envelope?(0,R.b)("envelope constructor not impl"):(0,R.c)("bad arg to polygon constructor"):(super({bPolygon:!0}),this.m_segmentBufferCTor=is)}assignMove(n){return n.copyTo(this),this}assignCopy(n){return n.copyTo(this),this}getBoundary(){return mi(this)}getExteriorRingCount(){return this.getOGCPolygonCount()}getGeometryType(){return yi.type}getDimension(){return 2}createInstance(){return new yi({vd:this.getDescription()})}equals(n,r){return this.equalsBase(n,r)}}function $h(f,n,r,l,_,x){return new Ei(0,0,0,null,!1,(0,c.i)()).densifyEx(f,n,r,l,!1,x)}function _a(f,n,r,l,_,x,E,v){x&&(x.length=0),E&&(E.length=0);const I=f.getGeometryType();if(I===R.G.enumLine)return x&&(x.push(f.getStartXY()),x.push(c.P.getNAN()),x.push(c.P.getNAN()),x.push(f.getEndXY())),E&&(E.push(0),E.push(1)),1;if(I===R.G.enumBezier){if(!l)return x&&(x.push(f.getStartXY()),x.push(f.getControlPoint1()),x.push(f.getControlPoint2()),x.push(f.getEndXY())),E&&(E.push(0),E.push(1)),1;const D=(0,c.d)(9,Number.NaN);let G=f.getMonotonicPartParams(D.length,D);if(D.length=G,G=Xi(f,r,D),2===G&&_&&(D[1]=.5,D.push(1),G=3),E&&E.splice(0,0,...D.slice(0,G)),x){const q=new is;for(let B=1;B<G;B++){f.queryCut(D[B-1],D[B],q,!0);const j=q.get();mo(j),1===B&&x.push(j.getStartXY()),x.push(j.getControlPoint1()),x.push(j.getControlPoint2()),x.push(j.getEndXY())}}return G-1}if(I===R.G.enumEllipticArc){const D=f;if(D.isDegenerateToLine()||D.isDegenerate(0))return x&&(x.push(f.getStartXY()),x.push(c.P.getNAN()),x.push(c.P.getNAN()),x.push(f.getEndXY())),E&&(E.push(0),E.push(1)),1;if(l&&(_||!D.isMonotoneQuickAndDirty())){const G=(0,c.d)(6,Number.NaN);let q=D.getMonotonicPartParams(G.length,G);G.length=q,q=Xi(f,r,G),2===q&&_&&(G[1]=.5,G.push(1),q=3);let B=0;if(q>2){const z=new is,L=E||[];let j=0;for(let Q=1;Q<q;Q++){if(D.queryCut(G[j],G[Q],z,!0),z.get().isDegenerate(0))continue;const rt=L.length,ot=da(1===Q,z.get(),n,r,l,x,E);(0,R.g)(ot>0),B+=ot;const nt=Q===q-1,at=G[j],pt=z.get().getSweepAngle()/D.getSweepAngle();for(let gt=rt,yt=L.length;gt<yt;gt++)if(L[gt]=!nt||gt+1<yt?at+L[gt]*pt:1,x){const ft=3*gt,bt=D.getCoord2D(L[gt]);x[ft].setCoordsPoint2D(bt),ft>0&&lo(x.slice(ft-3))}j=Q}return B}}return da(!0,D,n,r,l,x,E)}if(I===R.G.enumRationalBezier2){const D=f;if(l&&(_||!D.isMonotoneQuickAndDirty())){const G=(0,c.d)(6,Number.NaN);let q=D.getMonotonicPartParams(G.length,G);G.length=q,q=Xi(f,r,G),2===q&&_&&(G[1]=.5,G.push(1),q=3);let B=0;if(q>2){const z=new is,L=E||[];for(let j=1;j<q;j++){D.queryCut(G[j-1],G[j],z,!0);const K=L.length;B+=pa(1===j,z.get(),n,r,!1,x,E);const rt=j===q-1,ot=G[j-1];for(let nt=K,at=L.length;nt<at;nt++)if(L[nt]=!rt||nt+1<at?ot+L[nt]:1,x){const pt=3*nt,gt=D.getCoord2D(L[nt]);x[pt].setCoordsPoint2D(gt),pt>0&&Mi(x.slice(pt-3))}}return B}}return pa(!0,D,n,r,l,x,E)}if(I===R.G.enumBezier2){const D=f,G=(0,c.m)(c.P,3);D.queryControlPoints(G);const q=new fi;return q.constructFromQuadratic(G),_a(q,n,r,l,_,x,E)}(0,R.b)("")}function go(f,n,r,l,_,x,E,v,I){const D=f.getGeometryType();if(x&&(x.length=0,E.length=0),v&&(v.length=0),D===R.G.enumEllipticArc){const B=f;if(B.isDegenerateToLine()||B.isDegenerate(0))return x&&(x.push(f.getStartXY()),x.push(c.P.getNAN()),x.push(f.getEndXY()),E.push(Number.NaN),E.push(Number.NaN),E.push(Number.NaN)),v&&(v.push(0),v.push(1)),1}const G=(0,c.d)(9,Number.NaN);let q;if(_)q=f.getMonotonicPartParams(G.length,G),G.length=q,q=Xi(f,r,G);else{if(q=2,G[0]=0,G[1]=1,D===Pi.type){const B=f.getSweepAngle();if(B>.9*Math.PI){const z=2*Math.PI/3;Math.min(3,Math.trunc(B/z+.5))>2?(G[0]=0,G[1]=1/3,G[2]=2/3,G[3]=1,q=4):(G[0]=0,G[1]=.5,G[2]=1,q=3)}}else(0,R.g)(D===as.type);G.length=q}if(2===q&&l&&(G[1]=.5,G.push(1),q=3),x){const B=new is;let z=1;for(;z<q;){const L=G[z-1],j=G[z];f.queryCut(L,j,B,!0);const Q=(0,c.m)(c.P,3),et=[1,1,1];if(D===R.G.enumEllipticArc){const K=B.get();if(Math.abs(K.getSweepAngle())>.9*Math.PI){const rt=(j-L)/3;G.splice(z,0,L+rt),G.splice(z+1,0,L+2*rt),q+=2;continue}et[1]=yo(K,Q)}else{const K=B.get();K.queryControlPoints(Q),K.queryWeights(et)}_&&xn(Q),1===z&&(x.push(Q[0].clone()),E.push(et[0])),x.push(Q[1].clone()),x.push(Q[2].clone()),E.push(et[1]),E.push(et[2]),z++}}return v&&(v.length=q,(0,c.a)(v,G,0,0,q)),q-1}yi.type=R.G.enumPolygon;class Ei{static constructDefault(n){return new Ei(0,0,0,n,!1,(0,c.i)())}constructor(n,r,l,_,x,E){this.m_segmentBuffer=null,this.m_dummyPoint=new F.P,this.m_progressCounter=0,this.m_progressTracker=_,this.m_bSetDensifyFlag=x,this.m_maxLength=n,this.m_maxDeviation=r,this.m_maxAngle=l>(0,c.a7)()?(0,c.a7)():l,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_maxSegmentsPerCurve=E,(0,R.w)(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve}densify(n){return this.densifyGeom(n)}densifySegment(n,r){this.densifySegmentEx(n,null,!0,!1,r)}densifyEx(n,r,l,_,x,E){return this.m_maxLength=r,this.m_maxDeviation=l,this.m_maxAngle=_>(0,c.a7)()?(0,c.a7)():_,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_bSetDensifyFlag=x,this.m_maxSegmentsPerCurve=E,(0,R.w)(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve,this.densifyGeom(n)}densifyGeom(n){if(n.isEmpty()||n.getDimension()<1)return n;const r=n.getGeometryType();return(0,R.o)(r)?n:(0,R.h)(r)?this.densifyMultiPath(n):(0,R.f)(r)?this.densifySegmentImpl(n):r===R.G.enumEnvelope?this.densifyEnvelope(n):void(0,R.c)("")}densifySegmentEx(n,r,l,_,x){const E=n.getGeometryType();if(!(this.m_maxLength>0||this.m_bOnlyCurveDensify&&E!==R.G.enumLine)&&(!_||l))return void(r?E===R.G.enumLine?r.addSegment(n,l):(l&&(n.queryStart(this.m_dummyPoint),r.startPathPoint(this.m_dummyPoint)),n.queryEnd(this.m_dummyPoint),r.lineToPoint(this.m_dummyPoint)):(l&&x.push(0),x.push(1)));if(E===R.G.enumBezier)return void this.densifyCubicBezier(n,r,l,_,x);if(E===R.G.enumRationalBezier2)return void this.densifyRationalBezier2(n,r,l,_,x);if(E===R.G.enumBezier2)return void this.densifyBezier2(n,r,l,_,x);if(E===R.G.enumEllipticArc&&!n.isLine()&&n.getMinorMajorRatio()<.25)return void this.densifyEllipticArc(n,r,l,_,x);let v=1;this.m_maxLength>0&&(v=this.calculateLengthSubdivisionStep(n,this.m_maxLength)),this.m_maxDeviation>0&&(v=Math.min(v,this.calculateDeviationSubdivisionStep(n,this.m_maxDeviation))),this.m_maxAngle>0&&(v=Math.min(v,this.calculateAngularSubdivisionStep(n,this.m_maxAngle))),this.densifySegmentByLength(n,v,r,l,_,x)}densifyMultiPath(n){if(!n.hasNonLinearSegments()){if(1===n.getDescription().getAttributeCount())return this.densifyMultiPathLinear(n);if(!(this.m_maxLength>0))return n}const r=n.createInstance();r.getGeometryType()===R.G.enumPolygon&&r.setFillRule(n.getFillRule()),r.reserve(n.getPointCount());const l=n.getImpl().querySegmentIterator();for(;l.nextPath();){let _=!0;for(;l.hasNextSegment();){const x=l.nextSegment(),E=l.isClosingSegment();this.densifySegmentEx(x,r,_,E,null),E&&r.closePathWithLine(),_=!1}}return r}densifySegmentImpl(n){const r=new Yi({vd:n.getDescription()});return this.densifySegmentEx(n,r,!0,!1,[0]),r}densifyEnvelope(n){const r=new yi({vd:n.getDescription()});r.addEnvelope(n,!1);const l=dt.J.constructEmpty();n.queryEnvelope(l);const _=l.width(),x=l.height();return!(this.m_maxLength>0)||_<=this.m_maxLength&&x<=this.m_maxLength?r:this.densifyMultiPath(r)}densifyMultiPathLinear(n){if(!(this.m_maxLength>0))return n;const r=n.createInstance();r.getGeometryType()===R.G.enumPolygon&&r.setFillRule(n.getFillRule()),r.reserve(n.getPointCount());const l=r.getImpl(),_=n.getImpl(),x=_.getAttributeStreamRef(0),E=new ke;for(let v=0,I=_.getPathCount();v<I;v++){const D=_.isClosedPath(v);if(0===_.getPathSize(v))continue;const G=_.getPathStart(v),q=x.readPoint2D(2*G),B=q.clone();l.startPath(q);for(let z=G+1,L=_.getPathEnd(v);z<L;z++){const j=x.readPoint2D(2*z),Q=c.P.distance(B,j);if(Q>this.m_maxLength){let et=Math.ceil(Q/this.m_maxLength);et>(0,c.i)()&&(et=(0,c.i)());const K=1/et;let rt,ot,nt;B.compare(j)<0?(E.setStartXY(B),E.setEndXY(j),rt=0,ot=1):(E.setStartXY(j),E.setEndXY(B),rt=et-2,ot=-1);for(let at=0,pt=et-1;at<pt;at++,rt+=ot){this.progress_(),nt=K*(rt+1);const gt=new c.P;E.queryCoord2D(nt,gt),l.lineTo(gt),this.m_bSetDensifyFlag&&l.setAttribute(10,l.getPointCount()-1,0,1)}}else this.progress_();r.lineTo(j),B.assign(j)}if(D){const z=c.P.distance(B,q);if(z>this.m_maxLength){const L=q;let j=Math.ceil(z/this.m_maxLength);j>(0,c.i)()&&(j=(0,c.i)());const Q=1/j;let et,K;B.compare(L)<0?(E.setStartXY(B),E.setEndXY(L),et=0,K=1):(E.setStartXY(L),E.setEndXY(B),et=j-2,K=-1);const rt=new c.P(0,0);let ot;for(let nt=0,at=j-1;nt<at;nt++,et+=K)this.progress_(),ot=Q*(et+1),E.queryCoord2D(ot,rt),l.lineTo(rt),this.m_bSetDensifyFlag&&l.setAttribute(10,l.getPointCount()-1,0,1)}l.closePathWithLine()}}return r}densifySegmentByLength(n,r,l,_,x,E){(0,R.g)(n.getGeometryType()!==R.G.enumBezier);let v=n.getStartXY().compare(n.getEndXY());0===v&&r<1&&(n.getGeometryType()===R.G.enumEllipticArc?v=n.getSweepAngle()<0?1:-1:(0,R.b)("densify segment by length"));let I=0;if(_&&(l?(n.queryStart(this.m_dummyPoint),l.startPathPoint(this.m_dummyPoint)):E.push(0),++I),r*this.m_maxSegmentsPerCurve<1&&(r=1/this.m_maxSegmentsPerCurve),r<1){this.m_segmentBuffer||(this.m_segmentBuffer=new is);let D=Math.ceil(1/r);D>(0,c.i)()&&(D=(0,c.i)()),r=1/D,this.m_segmentBuffer.create(n.getGeometryType());let G,q,B,z=n;v<0?(G=0,q=1):(n.copyTo(this.m_segmentBuffer.get()),this.m_segmentBuffer.get().reverse(),G=D-2,q=-1,z=this.m_segmentBuffer.get());const L=D-1;for(let j=0;j<L;j++,G+=q)B=r*(G+1),l?(z.queryCoord(B,this.m_dummyPoint),l.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==B&&0!==B&&l.setAttribute(10,l.getPointCount()-1,0,1)):E.push(v>0?1-B:B),this.progress_();B=1,I+=L}(!x||x&&_&&I<2)&&(l?(n.queryEnd(this.m_dummyPoint),l.lineToPoint(this.m_dummyPoint)):E.push(1))}densifyCubicBezier(n,r,l,_,x){const E=new fi;let v=n;const I=n.calculateUpperLength2D();let D=n.getStartXY().compare(n.getEndXY());if(0===D&&I>0){const Q=(0,c.m)(c.P,4);n.queryControlPoints(Q),D=Q[1].compare(Q[2]),0===D&&(D=Q[1].compare(Q[0]))}D>0&&(n.copyTo(E),E.reverse(),v=E);let G=0;l&&(r?(n.queryStart(this.m_dummyPoint),r.startPathPoint(this.m_dummyPoint)):x.push(0),++G);const q=[],B=[],z=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));let L=!0,j=0;if(D>0)for(q.push([v.getStartXY(),v.getControlPoint1(),v.getControlPoint2(),v.getEndXY(),new c.P(0,1)]),B.push(0);q.length;){this.progress_();const Q=q.at(-1),et=B.at(-1),K=Q[4].x,rt=Q[4].y;if(et<z&&this.bezierNeedsSplit(Q)){L&&(j=v.findMinDeriv(),L=!1);let ot=.5*(K+rt);Math.abs(j-ot)<.4*(rt-K)&&(ot=j);const nt=(ot-K)/(rt-K),at=Q[0].mul(1-nt).add(Q[1].mul(nt)),pt=Q[1].mul(1-nt).add(Q[2].mul(nt)),gt=Q[2].mul(1-nt).add(Q[3].mul(nt)),yt=at.mul(1-nt).add(pt.mul(nt)),ft=pt.mul(1-nt).add(gt.mul(nt)),bt=yt.mul(1-nt).add(ft.mul(nt)),Dt=Q[3];Q[1]=at,Q[2]=yt,Q[3]=bt,Q[4].setCoords(K,ot);const Nt=[bt,ft,gt,Dt,new c.P(ot,rt)];q.push(Nt),B[B.length-1]=et+1,B.push(et+1)}else q.pop(),B.pop(),(q.length>0||!_||_&&l&&G<2)&&(r?(v.queryCoord(K,this.m_dummyPoint),r.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==K&&0!==K&&r.setAttribute(10,r.getPointCount()-1,0,1)):x.push(1-K),++G)}else for(q.push([v.getStartXY(),v.getControlPoint1(),v.getControlPoint2(),v.getEndXY(),new c.P(0,1)]),B.push(0);q.length;){this.progress_();const Q=q.at(-1),et=B.at(-1),K=Q[4].x,rt=Q[4].y;if(et<z&&this.bezierNeedsSplit(Q)){L&&(j=v.findMinDeriv(),L=!1);let ot=.5*(K+rt);Math.abs(j-ot)<.4*(rt-K)&&(ot=j);const nt=(ot-K)/(rt-K),at=Q[0].mul(1-nt).add(Q[1].mul(nt)),pt=Q[1].mul(1-nt).add(Q[2].mul(nt)),gt=Q[2].mul(1-nt).add(Q[3].mul(nt)),yt=at.mul(1-nt).add(pt.mul(nt)),ft=pt.mul(1-nt).add(gt.mul(nt)),bt=yt.mul(1-nt).add(ft.mul(nt)),Dt=Q[0];Q[0]=bt,Q[1]=ft,Q[2]=gt,Q[4].setCoords(ot,rt);const Nt=[Dt,at,yt,bt,new c.P(K,ot)];q.push(Nt),B[B.length-1]=et+1,B.push(et+1)}else q.pop(),B.pop(),(q.length>0||!_||_&&l&&G<2)&&(r?(v.queryCoord(rt,this.m_dummyPoint),r.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==rt&&0!==rt&&r.setAttribute(10,r.getPointCount()-1,0,1)):x.push(rt),++G)}}densifyRationalBezier2(n,r,l,_,x){const E=new as;let v=n;const I=n.calculateUpperLength2D();let D=n.getStartXY().compare(n.getEndXY());0===D&&I>0&&(D=0),D>0&&(n.copyTo(E),E.reverse(),v=E);let G=0;l&&(r?(n.queryStart(this.m_dummyPoint),r.startPathPoint(this.m_dummyPoint)):x.push(0),++G);const q=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),B=new as,z=[],L=[];for(z.push(new c.E(0,1)),L.push(0);z.length;){this.progress_();const j=z.at(-1).clone(),Q=L.at(-1);if(Q<q&&this.rationalBezier2NeedsSplit(v,B,j.vmin,j.vmax)){const et=j.getCenter();D>0?(z.at(-1).vmax=et,z.push(new c.E(et,j.vmax))):(z.at(-1).vmin=et,z.push(new c.E(j.vmin,et))),L[L.length-1]=Q+1,L.push(Q+1)}else if(z.pop(),L.pop(),z.length>0||!_||_&&l&&G<2){const et=D>0?j.vmin:j.vmax;r?(v.queryCoord(et,this.m_dummyPoint),r.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==et&&0!==et&&r.setAttribute(10,r.getPointCount()-1,0,1)):x.push(D>0?1-et:et),++G}}}densifyBezier2(n,r,l,_,x){const E=new ns;let v=n;const I=n.calculateUpperLength2D();let D=n.getStartXY().compare(n.getEndXY());0===D&&I>0&&(D=0),D>0&&(n.copyTo(E),E.reverse(),v=E);let G=0;l&&(r?(n.queryStart(this.m_dummyPoint),r.startPathPoint(this.m_dummyPoint)):x.push(0),++G);const q=Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)),B=new ns,z=[],L=[];for(z.push(new c.E(0,1)),L.push(0);z.length;){this.progress_();const j=z.at(-1).clone(),Q=L.at(-1);if(Q<q&&this.bezier2NeedsSplit(v,B,j.vmin,j.vmax)){const et=j.getCenter();D>0?(z.at(-1).vmax=et,z.push(new c.E(et,j.vmax))):(z.at(-1).vmin=et,z.push(new c.E(j.vmin,et))),L[L.length-1]=Q+1,L.push(Q+1)}else if(z.pop(),L.pop(),z.length>0||!_||_&&l&&G<2){const et=D>0?j.vmin:j.vmax;r?(v.queryCoord(et,this.m_dummyPoint),r.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==et&&0!==et&&r.setAttribute(10,r.getPointCount()-1,0,1)):x.push(D>0?1-et:et),++G}}}densifyEllipticArc(n,r,l,_,x){const E=new Pi;let v=n;const I=n.calculateUpperLength2D();let D=n.getStartXY().compare(n.getEndXY());0===D&&I>0&&(D=n.isClockwise()?0:1),D>0&&(n.copyTo(E),E.reverse(),v=E);let G=0;l&&(r?(n.queryStart(this.m_dummyPoint),r.startPathPoint(this.m_dummyPoint)):x.push(0),++G);const q=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),B=new Pi,z=[],L=[];for(z.push(new c.E(0,1)),L.push(0);z.length;){this.progress_();const j=z.at(-1).clone(),Q=L.at(-1);if(Q<q&&this.ellipticArcNeedsSplit(v,B,j.vmin,j.vmax)){const et=j.getCenter();D>0?(z.at(-1).vmax=et,z.push(new c.E(et,j.vmax))):(z.at(-1).vmin=et,z.push(new c.E(j.vmin,et))),L[L.length-1]=Q+1,L.push(Q+1)}else if(z.pop(),L.pop(),z.length>0||!_||_&&l&&G<2){const et=D>0?j.vmin:j.vmax;r?(v.queryCoord(et,this.m_dummyPoint),r.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==et&&0!==et&&r.setAttribute(10,r.getPointCount()-1,0,1)):x.push(D>0?1-et:et),++G}}}calculateLengthSubdivisionStep(n,r){const l=n.calculateUpperLength2D();if(!n.isCurve())return l?r/l:1;if(n.getGeometryType()===R.G.enumEllipticArc){const _=n;if(_.isCircular()||_.isDegenerate(0)||_.isDegenerateToLine()){let x=r/l;return x<this.m_minStep&&(x=this.m_minStep),x}return r/l*_.getSemiAxes().y/_.getSemiAxes().x}n.getGeometryType()===R.G.enumBezier&&(0,R.b)(""),(0,R.b)("")}calculateDeviationSubdivisionStep(n,r){if(!n.isCurve())return 1;if(n.getGeometryType()===R.G.enumEllipticArc){const l=n;if(l.isDegenerate(0)||l.isDegenerateToLine())return 1;{const _=l.getSemiMajorAxis();let E=Math.PI/2;if(1-r/_>0){const I=4*Math.sqrt(r/_*.5);E=Math.min(Math.PI/2,Math.abs(I))}return E=Math.max(E,2*Math.PI/this.m_maxSegmentsPerCurve),this.calculateLengthSubdivisionStep(n,E*_)}}(0,R.b)("")}calculateAngularSubdivisionStep(n,r){if(!n.isCurve())return 1;if(n.getGeometryType()===R.G.enumEllipticArc){const l=n;return l.isDegenerate(0)||l.isDegenerateToLine()?1:this.calculateLengthSubdivisionStep(n,r*l.getSemiMinorAxis())}(0,R.b)("")}rationalBezier2NeedsSplit(n,r,l,_){n.cutBezierIgnoreAttributes(l,_,r);let x=!1;if(this.m_maxLength>0&&r.calculateUpperLength2D()>this.m_maxLength)return x=!0,!0;const E=(0,c.m)(c.P,3);r.queryControlPoints(E);const v=[0,0,0];return r.queryWeights(v),!x&&this.m_maxDeviation>0&&(x=!Ei.checkRationalBezier2MaxDeviation(E,v,this.m_maxDeviation)),!x&&this.m_maxAngle>0&&(x=!Ei.checkRationalBezier2MaxAngle(E,v,this.m_cosMaxAngle)),x}bezier2NeedsSplit(n,r,l,_){n.cutBezierIgnoreAttributes(l,_,r);let x=!1;if(this.m_maxLength>0&&r.calculateUpperLength2D()>this.m_maxLength)return x=!0,!0;const E=(0,c.m)(c.P,3);return r.queryControlPoints(E),!x&&this.m_maxDeviation>0&&(x=!Ei.checkBezier2MaxDeviation(E,this.m_maxDeviation)),!x&&this.m_maxAngle>0&&(x=!Ei.checkBezier2MaxAngle(E,this.m_cosMaxAngle)),x}ellipticArcNeedsSplit(n,r,l,_){n.cutArcIgnoreAttributes(l,_,r);let x=!1;return this.m_maxLength>0&&r.calculateUpperLength2D()>this.m_maxLength?(x=!0,!0):(!x&&this.m_maxDeviation>0&&(x=!Ei.checkEllipticArcMaxDeviation(r,this.m_maxDeviation)),!x&&this.m_maxAngle>0&&(x=!Ei.checkEllipticArcMaxAngle(r,this.m_cosMaxAngle)),x)}bezierNeedsSplit(n){let r=!1;return this.m_maxLength>0&&c.P.distance(n[0],n[1])+c.P.distance(n[1],n[2])+c.P.distance(n[2],n[3])>this.m_maxLength?(r=!0,!0):(!r&&this.m_maxDeviation>0&&(r=!Ei.checkBezierMaxDeviation(n,this.m_maxDeviation)),!r&&this.m_maxAngle>0&&(r=!Ei.checkBezierMaxAngle(n,this.m_cosMaxAngle)),r)}progress_(){}static checkBezierMaxDeviation(n,r){const l=n[3].sub(n[0]);if(l.sqrLength()>0){const _=l.clone();_.leftPerpendicularThis(),_.normalize();const x=_.dotProduct(n[0].sub(n[1])),E=_.dotProduct(n[0].sub(n[2]));if(Math.max(Math.abs(x),Math.abs(E))<=r){const v=new c.P;$e(n,.5,v,!1);const I=v.sub(n[0]).dotProduct(l);return I>=0&&I<=l.sqrLength()}return!1}return Math.max(n[0].sub(n[1]).sqrLength(),n[0].sub(n[2]).sqrLength())<=r*r}static checkBezierMaxAngle(n,r){if(n[0].equals(n[3]))return!(!n[0].equals(n[1])||!n[1].equals(n[2]));const l=n[3].sub(n[0]);l.normalize();{const _=n[1].sub(n[0]),x=_.dotProduct(l);if(x<0||_.length()*r>x)return!1}{const _=n[2].sub(n[0]),x=_.dotProduct(l);if(x<0||_.length()*r>x)return!1}{const _=n[2].sub(n[1]),x=_.dotProduct(l);if(x<0||_.length()*r>x)return!1}return!0}static checkRationalBezier2MaxDeviation(n,r,l){if(0===r[1])return!1;const _=n[2].sub(n[0]);if(_.sqrLength()>0){const x=_.clone();x.leftPerpendicularThis(),x.normalize();const E=x.dotProduct(n[0].sub(n[1]));if(Math.abs(E)<=l){const v=n[1].sub(n[0]).dotProduct(_);return v>=0&&v<=_.sqrLength()}return!1}return n[0].sub(n[1]).sqrLength()<=l*l}static checkRationalBezier2MaxAngle(n,r,l){if(0===r[1])return!1;if(n[0].equals(n[2]))return!!n[0].equals(n[1]);const _=n[2].sub(n[0]);_.normalize();{const x=n[1].sub(n[0]),E=x.dotProduct(_);if(E<0||x.length()*l>E)return!1}return!0}static checkBezier2MaxDeviation(n,r){const l=n[2].sub(n[0]);if(l.sqrLength()>0){const _=l.clone();_.leftPerpendicularThis(),_.normalize();const x=_.dotProduct(n[0].sub(n[1]));if(Math.abs(x)<=r){const E=n[1].sub(n[0]).dotProduct(l);return E>=0&&E<=l.sqrLength()}return!1}return n[0].sub(n[1]).sqrLength()<=r*r}static checkBezier2MaxAngle(n,r){if(n[0].equals(n[2]))return!!n[0].equals(n[1]);const l=n[2].sub(n[0]);l.normalize();{const _=n[1].sub(n[0]),x=_.dotProduct(l);if(x<0||_.length()*r>x)return!1}return!0}static checkEllipticArcMaxDeviation(n,r){if(Math.abs(n.getSweepAngle())<Math.PI){const x=n.getEndXY().sub(n.getStartXY()),E=[0,0];if(1===function Ol(f,n,r){(0,R.g)(!ss(f));const l=new Y.T;l.setRotateAngle(-f.getAxisXRotation());const _=new c.P;l.queryTransform(n,_);const x=Math.atan2(-_.x*f.getMinorMajorRatio(),_.y),E=x+(0,c.a5)();let v=xs(f,x),I=xs(f,E);I<v&&(I=(0,c.b)(v,v=I));let D=0;return v>=0&&v<=1&&(r[D++]=v),I>=0&&I<=1&&(r[D++]=I),D}(n,x,E)){const v=n.getCoord2D(E[0]),I=c.P.getClosestCoordinate(n.getStartXY(),n.getEndXY(),v),D=new c.P;return(0,c.Z)(n.getStartXY(),n.getEndXY(),I,D),c.P.distance(v,D)<=r}}const l=n.getCoord2D(.5),_=new c.P;return(0,c.Z)(n.getEndXY(),n.getStartXY(),.5,_),c.P.distance(l,_)<=r}static checkEllipticArcMaxAngle(n,r){const l=n.getTangent(0),_=n.getTangent(1),x=l.dotProduct(_);return!(x<0||l.length()*_.length()*r>x)}static checkTypeForReplace(n,r){return n.getGeometryType()===r&&(r!==R.G.enumEllipticArc||n.isCircular())}}function Xi(f,n,r){const l=r.length;if(n<=0||l<=2)return l;let _=0;const x=(0,c.d)(l-1,Number.NaN);for(let E=1,v=l;E<v;E++){const I=f.tToLength(r[E]);x[E-1]=I-_,_=I}for(;x.length>1;){const E=x.findIndex(D=>D<=2*n);if(-1===E)break;let v=E+1,I=E+1;if(E>0){const D=E-1;(I===x.length||x[D]>x[I])&&(I=D,v--)}x[I]+=x[E],x.splice(E,1),r.splice(v,1)}return r.length}function da(f,n,r,l,_,x,E,v){const I=n.clone();I.dropAllAttributes();const D=(Kt,Ce,ie,ne)=>(Ce&&(Kt&&Ce.push(ne.getStartXY()),Ce.push(c.P.getNAN()),Ce.push(c.P.getNAN()),Ce.push(ne.getEndXY())),ie&&(Kt&&ie.push(0),ie.push(1)),1);if(I.isDegenerateToLine()||I.isDegenerate(0))return D(f,x,E,n);const G=I.getStartXY(),q=I.getEndXY(),B=I.getSemiAxes(),z=new Y.T;if(I.isCircular())z.setIdentity();else{const Kt=I.getAxisXRotation();z.setScaleCoords(1,I.getMinorMajorRatio()),z.rotateAngle(Kt)}const L=I.getCenter();z.shift(L);const j=z.clone();j.invertThis(),I.applyTransformation(j);const Q=I.getSweepAngle();if(0===Q)return D(f,x,E,n);const et=dt.J.constructEmpty();et.setCoords({center:L,width:2*B.x,height:2*B.x});const K=.05*et.calculateToleranceFromEnvelope(),rt=Math.max(r/B.x,K/B.x);let ot=4*Math.pow(rt/.0741,1/6);ot=Math.min(ot,Math.PI/2);const nt=Qh(I.getStartAngle());let at=Q>0?Math.floor(nt/ot):Math.ceil(nt/ot);at*=ot;const pt=Q>0?ot:-ot;at+pt===nt&&(at+=pt);let gt=4/3*Math.tan(Math.abs(ot)/4);Q>0&&(gt=-gt),E&&f&&E.push(0);const yt=ot/Math.abs(Q);let ft=(at-nt)/Q;const bt=G.clone(),Dt=new c.P;I.queryCoord2D(0,Dt);const Nt=Dt.clone(),Ft=1-.01*yt;let Ot=0,Qt=0;for(;ft<1;){let Kt;ft+=yt,Qt>0&&ft<Ft?Kt=gt:(ft>=Ft&&(ft=1),Kt=4/3*Math.tan(Math.abs((ft-Qt)*Q)/4),Q>0&&(Kt=-Kt)),I.queryCoord2D(ft,Dt);const Ce=new c.P;z.queryTransform(Dt,Ce);const ie=n.getClosestCoordinate(Ce,!1);if(n.queryCoord2D(ie,Ce),1!==ft&&(c.P.distance(bt,Ce)<=2*l||c.P.distance(Ce,q)<=2*l))continue;bt.setCoordsPoint2D(Ce);const ne=(0,c.m)(c.P,4);ne[0].assign(Nt),ne[3].assign(Dt),ne[1].rightPerpendicularOther(Nt),ne[1].scaleAddThis(Kt,Nt),ne[2].leftPerpendicularOther(Dt),ne[2].scaleAddThis(Kt,Dt),z.transformPoints2D(ne,3,ne),ne[3].assign(Ce),0===Qt&&ne[0].setCoordsPoint2D(G),1===ft&&ne[3].setCoordsPoint2D(q),_&&lo(ne);let De=!0;for(let We=1;We<4;We++)if(!ne[We].isEqualPoint2D(ne[0])){De=!1;break}De||(E&&E.push(ie),x&&(0===Qt&&f&&x.push(ne[0].clone()),x.push(ne[1].clone()),x.push(ne[2].clone()),x.push(ne[3].clone())),Ot++),Qt=ft,Nt.setCoordsPoint2D(Dt)}return Ot}function pa(f,n,r,l,_,x,E,v){n.clone().dropAllAttributes();const I=new dt.J;n.queryLooseEnvelope(I);const D=.05*I.calculateToleranceFromEnvelope(),G=Math.max(r,D);E&&f&&E.push(0);let q=0;const B=(0,c.m)(c.P,3);n.queryControlPoints(B);const z=[0,0,0];n.queryWeights(z);const L=[],j=(0,c.d)(9,Number.NaN);let Q=0;_?(Q=n.getMonotonicPartParams(j.length,j),j.length=Q,Q=Xi(n,l,j)):(j.length=2,Q=2,j[0]=0,j[1]=1);let et=0,K=f;for(let rt=1;rt<Q;rt++){const ot=j[rt];for(L.length=0,L.push(ot),L.push(et);L.length>1;){const nt=L.at(-1);L.pop();const at=L.at(-1),pt=(0,c.m)(c.P,3),gt=[0,0,0];$i(B,z,nt,at,pt,gt);const yt=(0,c.m)(c.P,4);G>=dh(pt,gt,yt)||L.length>16?(E.push(at),x&&(K&&(x.push(yt[0]),K=!1),x.push(yt[1]),x.push(yt[2]),x.push(yt[3])),q++):(L.push(.5*(nt+at)),L.push(nt))}et=ot}return q}class nm{constructor(n,r){this.m_arc=n,this.m_sqrChordLength=r}getMaxDerivative(){return 1}getValue(n,r){return 0===n?c.P.sqrDistance(this.m_arc.getCoord2D(r),this.m_arc.getCoord2D(1-r))-this.m_sqrChordLength:0}getError(n){return 0}}function fa(f,n){return f.convertToCanonic(n)}function am(f,n,r,l){let _=f.m_startAngle,x=f.m_sweepAngle;const E=1e-12;for(;_>(0,c.a5)();)_-=2*(0,c.a5)();for(;_<=-(0,c.a5)();)_+=2*(0,c.a5)();if(!Number.isNaN(n)){for(;n>(0,c.a5)();)n-=2*(0,c.a5)();for(;n<=-(0,c.a5)();)n+=2*(0,c.a5)();!r&&n>_&&(n-=2*(0,c.a5)()),r&&n<_&&(n+=2*(0,c.a5)()),x=n-_,Math.abs(x)<E&&!l&&(x=r?2*(0,c.a5)():-2*(0,c.a5)()),Math.abs(x)>2*(0,c.a5)()-E&&l&&(x=0)}Math.abs(x)>2*(0,c.a5)()-E&&(x=x>=0?2*(0,c.a5)():-2*(0,c.a5)(),f.setEndXY(f.getStartXY())),Math.abs(x)<E&&(x=0,f.setEndXY(f.getStartXY())),l=Math.abs(x)<=(0,c.a5)(),x&&(r=x>0),f.m_startAngle=Cn(_),f.m_sweepAngle=x,Wn(f,!l),xo(f,r)}function Cn(f){let n=f,r=!1;return n<=-(0,c.a5)()?(n+=(0,c.a8)(),r=!0):n>(0,c.a5)()&&(n-=(0,c.a8)(),r=!0),n<=-(0,c.a5)()?(n=(0,c.o)(n,(0,c.a8)()),n<=-(0,c.a5)()&&(n+=(0,c.a8)()),r=!0):n>(0,c.a5)()&&(n=(0,c.o)(n,(0,c.a8)()),n>(0,c.a5)()&&(n-=(0,c.a8)()),r=!0),r&&(n>(0,c.a5)()||n<=-(0,c.a5)())&&(n=(0,c.a5)()),n}function xa(f,n,r){const l=r,_=l.getSemiAxes();let x=new c.P(_.x*Math.cos(f[0]),_.y*Math.sin(f[0]));return x=l.convertFromCanonic(x),c.P.sqrDistance(x,l.getStartXY())}function Pa(f,n,r){const l=r,_=l.getSemiAxes(),x=f[0]+l.getStartAngle();let E=new c.P(_.x*Math.cos(x),_.y*Math.sin(x));return E=l.convertFromCanonic(E),c.P.sqrDistance(E,l.getEndXY())}function ya(f){if(f.m_center.isNAN())return f.m_startAngle=0,void(f.m_sweepAngle=0);const n=f.getStartXY(),r=f.getEndXY(),l=n.equals(r),_=Ia(f),x=vn(f),E=f.projectionBehavior();if(l){const v=f.convertToCanonic(n),I=new c.P(f.m_semiMajorAxis,f.m_semiMajorAxis*f.m_minorMajorRatio);v.x/=I.x,v.y/=I.y,f.m_startAngle=Cn(Math.atan2(v.y,v.x)),f.m_sweepAngle=_?x?(0,c.a8)():-(0,c.a8)():0}else{const v=f.convertToCanonic(n),I=new c.P(f.m_semiMajorAxis,f.m_semiMajorAxis*f.m_minorMajorRatio);v.x/=I.x,v.y/=I.y;const D=f.convertToCanonic(r);D.x/=I.x,D.y/=I.y,f.m_startAngle=Math.atan2(v.y,v.x),f.m_sweepAngle=c.P.calculateAngle(v,D),x?f.m_sweepAngle<0&&(f.m_sweepAngle+=(0,c.a8)()):f.m_sweepAngle>0&&(f.m_sweepAngle-=(0,c.a8)()),f.m_startAngle=Cn(f.m_startAngle);let G=xa([f.m_startAngle],0,f);if(G=Math.sqrt(G),G>.25*re(f)){const L=[0];Di(xa,f,1,[f.m_startAngle],[f.m_startAngle-1e-4],[f.m_startAngle+1e-4],0,L),f.m_startAngle=Cn(L[0])}if(G=Pa([f.m_sweepAngle],0,f),G=Math.sqrt(G),G>.25*re(f)){const L=[0];Di(Pa,f,1,[f.m_sweepAngle],[f.m_sweepAngle-1e-4],[f.m_sweepAngle+1e-4],0,L),f.m_sweepAngle=L[0]}const q=Math.abs(f.m_sweepAngle)>(0,c.a5)();if(Wn(f,q),_!==q&&!_&&Math.abs(f.m_sweepAngle)>1.5*(0,c.a5)()||0===f.m_sweepAngle||x!==f.m_sweepAngle>0)return void Ci(f,n,r,E)}}function xs(f,n){return(function om(f,n){const r=new c.E(f.getStartAngle(),f.getEndAngle());r.normalize();const l=(0,c.a8)(),_=(0,c.o)(n,l);if(_<r.vmin){let x=_+l;for(;x<r.vmin;)x+=l;return r.containsCoordinate(x)?x:r.vmin-_<x-r.vmax?_:x}if(_>r.vmax){let x=_-l;for(;x>r.vmax;)x-=l;return r.containsCoordinate(x)||r.vmin-x<_-r.vmax?x:_}return _}(f,n)-f.getStartAngle())/f.getSweepAngle()}function Ri(f,n){return f.m_startAngle+n*f.m_sweepAngle}function hm(f,n,r){r.assign(new c.F(f.m_startAngle).addE(n.mulE(new c.F(f.m_sweepAngle))))}function Ea(f){return f.m_cachedValues}function Ca(f){if(f.m_cachedValues)return f.m_cachedValues;const n={e2:0,completeE:0};return n.e2=function Hl(f){return 1-(0,c.s)(f.m_minorMajorRatio)}(f),n.completeE=(0,c.ah)(n.e2),f.m_cachedValues=n,n}function mm(f,n,r,l){if(!n.isEqual(f.m_XStart,f.m_YStart)||!r.isEqual(f.m_XEnd,f.m_YEnd)){if(ss(f))return f.m_XStart=n.x,f.m_YStart=n.y,f.m_XEnd=r.x,f.m_YEnd=r.y,jn(f),void f.afterCompletedModification();if(l&&Math.abs(f.getSweepAngle())<=1.01*(0,c.a7)()){const _=(0,c.m)(c.P,3),x=yo(f,_);if(Kr(_)){if(_[0].assign(n),_[2].assign(r),xn(_),0===f.projectionBehavior()){let E=0,v=2;c.P.sqrDistance(_[1],_[0])<c.P.sqrDistance(_[1],_[2])&&(v=(0,c.b)(E,E=v));const I=_[v].sub(_[E]),D=I.length();I.divThis(D);const G=_[1].sub(_[E]),q=G.length(),B=G.dotProduct(I)/q,z=G.crossProduct(I)/q,L=new c.P;(0,c.Z)(_[E],_[v],.5,L);const j=.5*D/z*(0,c.c)(1-B,0,1),Q=_[1].side(_[E],_[v]),et=I.clone();Q?et.leftPerpendicularThis():et.rightPerpendicularThis();const K=L.sub(et.mul(j));f.constructCircularArcThreePoint(_[0],_[2],K)}else bn(_,x*x,null,!1,f);return}}0===f.projectionBehavior()?function Wl(f,n,r,l){const _=f.getStartXY(),x=f.getEndXY(),E=_.equals(x),v=n.equals(r);if(!E&&!v){const j=new Y.T;j.setShiftCoords(-f.m_XStart,-f.m_YStart);const Q=c.P.distance(n,r),et=c.P.distance(_,x),K=Q/et;j.scale(K,K);const rt=x.sub(_);rt.divThis(et);const ot=r.sub(n);ot.divThis(Q);const nt=rt.crossProduct(ot),at=ot.dotProduct(rt);return j.rotate(at,nt),j.shiftCoords(n.x,n.y),va(f,j,!0),f.m_XStart=n.x,f.m_YStart=n.y,f.m_XEnd=r.x,void(f.m_YEnd=r.y)}const I=new c.P;if(f.queryCoord2D(.5,I),v){if(E){const j=f.m_center.add(n.sub(_));f.constructEllipticArcEndPointsCenter(n,r,f.getSemiMajorAxis(),1,0,!0,!f.isClockwise(),j),f.setProjectionBehavior(0)}else if(f.isMajor()){const j=I.sub(n).getUnitVector().mul(2*f.getSemiMajorAxis()).add(n);f.constructCircularArcThreePoint(n,r,j)}else f.constructCircularArcThreePoint(n,r,n);return}const D=n.add(r).mul(.5),G=r.sub(n);G.rightPerpendicularThis();const q=D.add(G),B=c.P.getClosestCoordinate(D,q,f.getCenter(),!0),z=new c.P;(0,c.Z)(D,q,B,z);const L=c.P.distance(n,z);f.constructEllipticArcEndPointsCenter(n,r,L,1,0,!0,!f.isClockwise(),z),f.setProjectionBehavior(0)}(f,n,r):Em(f,n,r)}}function um(f,n,r,l,_,x,E,v,I){return f.m_bits=0,f.m_rotation=x,Le(f,n),Re(f,r),f.m_cosr=Math.cos(x),f.m_sinr=Math.sin(x),Wn(f,E),xo(f,v),void 0!==I?f.m_center.assign(I):f.m_center.setNAN(),f.setProjectionBehavior(1),f.m_semiMajorAxis=l,f.m_minorMajorRatio=_,Po(f,void 0===I)}function Ci(f,n,r,l){f.m_bits=0,f.m_rotation=0,Le(f,n),Re(f,r),f.m_interior.assign(n.add(r).mul(.5)),f.m_startAngle=0,f.m_sweepAngle=0,f.m_cosr=1,f.m_sinr=0,Wn(f,!1),xo(f,!1),f.m_center.setNAN(),f.m_semiMajorAxis=1,f.m_minorMajorRatio=0,f.setProjectionBehavior(l),f.afterCompletedModification()}function ss(f){return f.m_center.isNAN()}function po(f,n){if(0===n)return 0;const r=Ca(f),l=Ri(f,n),_=(0,c.a7)(),x=Sa(f),E=(0,c.a9)(l+_,r.e2,r.completeE);return Math.abs(f.m_semiMajorAxis*(E-x))}function Sa(f){const n=Ca(f);return(0,c.a9)(f.getStartAngle()+(0,c.a7)(),n.e2,n.completeE)}function va(f,n,r){if(2===n.m_TransformationType)return void(0,R.g)(0);if((0,R.g)(!wa(f)),n.isIdentity())return;Sn(f);const l=c.P.getNAN();l.x=f.m_XStart,l.y=f.m_YStart,n.transformInPlace(l);const _=c.P.getNAN();if(_.x=f.m_XEnd,_.y=f.m_YEnd,n.transformInPlace(_),ss(f))return f.m_XStart=l.x,f.m_YStart=l.y,f.m_XEnd=_.x,void(f.m_YEnd=_.y);const x=f.m_center.clone();if(n.transformInPlace(x),r||n.isUniformNoRotation()){let E=vn(f);if(n.isReflective()&&(E=!E),0===f.projectionBehavior()){if(!l.equals(_)){const q=f.m_interior.clone();return n.transformInPlace(q),void f.constructCircularArcThreePoint(l,_,q)}return void cm(f,l,_,x,E,!1)}const v=new c.P(f.m_cosr,f.m_sinr);n.transformWithoutTranslateInPlace(v);const I=Math.atan2(v.y,v.x),D=f.getSemiAxes();n.transformWithoutTranslateInPlace(D);const G=f.m_center.clone();return n.transformInPlace(G),void f.constructEllipticArcEndPointsCenter(l,_,D.x,D.y/D.x,I,f.isMajor(),E,G)}{{const q=new Array(4);!function kl(f,n){const r=new c.F(f.m_cosr).sqrThis(),l=new c.F(f.m_sinr).sqrThis(),_=new c.F(f.m_minorMajorRatio),x=new c.F(1/f.m_minorMajorRatio),E=_.mulE(r).addThisE(x.mulE(l)),v=_.subE(x).mulThis(2*f.m_cosr*f.m_sinr),I=_.mulE(l).addThisE(x.mulE(r));n[0]=E,n[1]=v,n[2]=I,n[3]=new c.F(-f.m_semiMajorAxis).mulThis(f.m_semiMajorAxis).mulThis(f.m_minorMajorRatio)}(f,q);const B=new xe;if(B.a11.setE(q[0]),B.a12.setE(q[1]),B.a12.mulThisByPower2(.5),B.a21.setE(B.a12),B.a22.setE(q[2]),!B.det().isZero()){const z=new xe;if(z.a11.set(n.xx),z.a12.set(n.xy),z.a21.set(n.yx),z.a22.set(n.yy),z.invertThis()){const L=z.clone();L.transposeThis();const j=B.clone();if(j.mulThis(z),j.mulLeftThis(L),!j.det().isZero()){const Q=(0,c.m)(c.F,4);Q[0].setE(j.a11),Q[1].setE(j.a12),Q[1].mulThisByPower2(2),Q[2].setE(j.a22),Q[3].setE(q[3]);const et=c.P.getNAN(),K=function Ll(f,n){const r=new xe;r.a11.setE(f[0]),r.a12=c.F.st_mulByPower2(f[1],.5),r.a21.setE(r.a12),r.a22.setE(f[2]);const l=[c.P.getNAN(),c.P.getNAN()],_=[new c.F,new c.F];r.eigenSymmetric(_,l);const x=f[3].clone();return x.negateThis(),x.invThis(),_[0].mulThisE(x),_[1].mulThisE(x),_[0].sqrtThis().invThis(),_[1].sqrtThis().invThis(),n.x=_[0].toDouble(),n.y=_[1].toDouble(),Math.atan2(l[0].y,l[0].x)}(Q,et);let rt=vn(f);return n.isReflective()&&(rt=!rt),void f.constructEllipticArcEndPointsCenter(l,_,et.x,et.y/et.x,K,f.isMajor(),rt,x)}}}}const E=[c.P.getNAN(),c.P.getNAN(),c.P.getNAN()];E[0].setCoords(f.getSemiMajorAxis(),0),E[0].rotateDirect(f.m_cosr,f.m_sinr),E[1].setCoords(f.getSemiMajorAxis(),f.getSemiMinorAxis()),E[1].rotateDirect(f.m_cosr,f.m_sinr),E[2].setCoords(0,f.getSemiMinorAxis()),E[2].rotateDirect(f.m_cosr,f.m_sinr);let v=f.isClockwise();v&&(E[2]=(0,c.b)(E[0],E[0]=E[2]));const I=.5;n.transformWithoutTranslateArray(E,3,E),n.isReflective()&&(v=!v);const D=new c.P(0,0),G=f.createInstance();bn(E,I,D,!1,G),f.constructEllipticArcEndPointsCenter(l,_,G.getSemiMajorAxis(),G.getMinorMajorRatio(),G.getAxisXRotation(),f.isMajor(),!v,x)}}function cm(f,n,r,l,_,x){const E=.5*(l.sub(n).length()+l.sub(r).length());f.m_center.assign(l),f.m_startAngle=Math.atan2(n.y-f.m_center.y,n.x-f.m_center.x),am(f,Math.atan2(r.y-f.m_center.y,r.x-f.m_center.x),_,x);const v=f.constructEllipticArcEndPointsCenter(n,r,E,1,0,Math.abs(f.m_sweepAngle)>Math.PI,f.m_sweepAngle>0,l);return f.setProjectionBehavior(0),v}function ba(f,n){f.m_cachedValues=n}function Sn(f){f.m_cachedValues=null}function xo(f,n){f.m_bits=-2&f.m_bits|(n?1:0)}function vn(f){return!!(1&f.m_bits)}function Wn(f,n){f.m_bits=-3&f.m_bits|(n?1:0)<<1}function Ia(f){return!!(2&f.m_bits)}function wa(f){return!!(8&f.m_bits)}function qr(f){f.m_bits&=-9}function Po(f,n){qr(f);const r=f.getStartXY(),l=f.getEndXY();let _=!1;const x=Ia(f),E=vn(f),v=f.projectionBehavior(),I=r.equals(l);let D=0===f.m_minorMajorRatio||0===f.m_semiMajorAxis;if(Number.isNaN(f.m_minorMajorRatio)&&(0===f.m_semiMajorAxis?f.m_minorMajorRatio=1:(0,R.k)("NAN minor major ratio and non-zero major axis")),D||=n?I:f.m_center.isNAN(),D)return Ci(f,r,l,v),!0;f.m_semiMajorAxis=Math.abs(f.m_semiMajorAxis),f.m_minorMajorRatio=Math.abs(f.m_minorMajorRatio),f.m_minorMajorRatio>1&&(f.m_semiMajorAxis*=f.m_minorMajorRatio,f.m_minorMajorRatio=1/f.m_minorMajorRatio);const G=new c.P(f.m_semiMajorAxis,f.m_semiMajorAxis*f.m_minorMajorRatio);if(I){const q=f.convertToCanonic(r);q.x/=G.x,q.y/=G.y;const B=Math.sqrt((0,c.s)(q.x)+(0,c.s)(q.y));if(_=1!==B,f.m_semiMajorAxis*=B,G.mulThis(B),f.m_startAngle=Cn(Math.atan2(q.y,q.x)),!x)return f.m_interior.assign(r),f.m_sweepAngle=0,f.afterCompletedModification(),_;f.m_sweepAngle=E?(0,c.a8)():-(0,c.a8)()}else{let q=f.m_center.isNAN()||function zl(f){if(f.m_center.isNAN())return!1;const r=new Vt;r.setWithEps(f.getStartXY(),8),r.subThisE((new Vt).setWithEps(f.m_center,8));const l=new c.F;l.setWithEps(f.m_rotation,8);const _=new c.F,x=new c.F;c.F.st_cosAndSin(l,_,x),r.rotateReverse(_,x);const E=new Vt;E.setWithEps(f.getEndXY()),E.subThisE(Vt.constructPoint2D(f.m_center)),E.rotateReverse(_,x);const v=new c.F;v.setWithEps(f.m_semiMajorAxis,8);const I=v.clone(),D=new c.F;D.setWithEps(f.m_minorMajorRatio),I.mulThisE(D),r.x.divThisE(v),r.y.divThisE(I),E.x.divThisE(v),E.y.divThisE(I);const G=r.x.sqr().addThisE(r.y.sqr()).subThisE(c.G),q=E.x.sqr().addThisE(E.y.sqr()).subThisE(c.G);return!G.isZero()||!q.isZero()}(f);if(!q){const B=f.convertToCanonic(r);B.x/=G.x,B.y/=G.y;const z=new c.P(1,0);f.m_startAngle=c.P.calculateAngle(z,B);const L=f.convertToCanonic(l);L.x/=G.x,L.y/=G.y,f.m_sweepAngle=c.P.calculateAngle(B,L),q=!_m(f)}if(q){_=!0;const B=r.sub(l).mulThis(.5);B.rotateReverse(f.m_cosr,f.m_sinr);let z=(0,c.s)(B.x/G.x)+(0,c.s)(B.y/G.y);z>1&&(z=Math.sqrt(z),f.m_semiMajorAxis*=z,G.mulThis(z));const L=new c.P(0,0);{const j=G.x*G.x,Q=G.y*G.y,et=j*B.y*B.y+Q*B.x*B.x,K=j*Q-et;if(K>0){const rt=Math.sqrt(K/et);L.setCoords(G.x*B.y/G.y,-G.y*B.x/G.x),L.mulThis(rt),x===E&&L.negateThis()}}{const j=new c.P(L.x,L.y);j.rotateDirect(f.m_cosr,f.m_sinr),j.addThis(r.add(l).mulThis(.5)),f.m_center.assign(j)}}if(ya(f),!_m(f))return Ci(f,r,l,v),!0}return jn(f),f.afterCompletedModification(),_}function yo(f,n){(0,R.g)(Math.abs(f.getSweepAngle())<15*Math.PI/16);const r=f.getSemiMajorAxis(),l=f.getSemiMinorAxis();let _;if(0===r)return n[0].setCoordsPoint2D(f.getStartXY()),n[1].setCoordsPoint2D(f.getStartXY()),n[2].setCoordsPoint2D(f.getStartXY()),_=1,_;if(0===l)return n[0].setCoordsPoint2D(f.getStartXY()),n[2].setCoordsPoint2D(f.getEndXY()),n[1]=c.P.lerp(n[0],n[2],.5),_=1,_;const x=f.getSweepAngle(),E=f.getStartAngle(),v=E+x,I=new c.P(-r*Math.sin(E),l*Math.cos(E)),D=new c.P(-r*Math.sin(v),l*Math.cos(v));I.normalize(),D.normalize(),I.rotateDirect(f.m_cosr,f.m_sinr),D.rotateDirect(f.m_cosr,f.m_sinr),n[0].setCoordsPoint2D(f.getStartXY()),n[2].setCoordsPoint2D(f.getEndXY()),n[1].setSub(n[2],n[0]);const G=I.crossProduct(D);return n[1].assign(I.mul(n[1].crossProduct(D)/G)),n[1].addThis(n[0]),_=Math.cos(.5*x),_}function bn(f,n,r,l,_){if(l){const Kt=Math.sqrt(n),Ce=(0,c.s)(.5)+2*Kt*.5*.5+(0,c.s)(.5),ie=f[0].mul((0,c.s)(.5)).add(f[1].mul(2*Kt*.5*.5)).add(f[2].mul((0,c.s)(.5))).divThis(Ce);return _.constructCircularArcThreePoint(f[0],f[2],ie),!0}const x=f[0].sub(f[1]),E=f[2].sub(f[1]),v=x.crossProduct(E),I=x.dotProduct(E),D=n;(0,R.g)(D<=1),(0,R.g)(D>0);const G=.5/(1-D),q=x.sqrLength(),B=I,z=E.sqrLength(),L=(0,c.s)(v),j=x.sub(E).sqrLength();if(0===L||I<=-Math.sqrt(q)*Math.sqrt(z))return Ci(_,f[0],f[2],1),!1;const Q=[0,0],et=new c.E;et.setInfinite();const K=Ns(2*L,-(j/D+4*B),2*(1-D)/D,et,!1,Q);if(0===K)return Ci(_,f[0],f[2],1),!1;1===K&&(Q[1]=Q[0]);const rt=Math.sqrt(G/Q[0]),ot=Math.sqrt(G/Q[1]),nt=.5/D;let at=nt-z*Q[0],pt=nt-q*Q[0];Math.abs(at)>Math.abs(pt)?pt=B*Q[0]-nt+1:at=B*Q[0]-nt+1;const gt=x.mul(at).add(E.mul(pt)),yt=gt.norm(1)<1e-15*rt?0:Math.atan2(gt.y,gt.x)+Math.PI,ft=x.add(E),bt=r?r.clone():f[1].add(ft.mul(G)),Dt=f[0].sub(bt),Nt=f[2].sub(bt),Ft=Dt.crossProduct(Nt)<0;return new Pi,_.constructEllipticArcEndPointsCenter(f[0],f[2],rt,ot/rt,yt,!1,!Ft,bt)}function gm(f,n,r,l,_){return bn(f,n,r,l,_)}function _m(f){let n=!1;{const l=new c.P(f.m_semiMajorAxis*Math.cos(f.m_startAngle),f.getSemiMinorAxis()*Math.sin(f.m_startAngle));l.rotateDirect(f.m_cosr,f.m_sinr),l.addThis(f.m_center),n=c.P.distance(f.getStartXY(),l)>re(f)}let r=!1;if(!n){const l=new c.P(f.m_semiMajorAxis*Math.cos(f.m_startAngle+f.m_sweepAngle),f.getSemiMinorAxis()*Math.sin(f.m_startAngle+f.m_sweepAngle));l.rotateDirect(f.m_cosr,f.m_sinr),l.addThis(f.m_center),r=c.P.distance(f.getEndXY(),l)>re(f)}return!n&&!r}function dm(f){if(ss(f)||f.isDegenerate(0))return 0;const n=f.m_semiMajorAxis,r=f.getSemiMinorAxis(),l=n*n+r*r,_=f.getStartAngle(),x=f.getEndAngle(),E=f.m_center.y-f.m_YStart,v=f.m_cosr,I=f.m_sinr;let D=1,G=0;f.m_rotation&&(D=(v-I)*(v+I),G=2*v*I);const q=((-.5*(x-_)+.25*D*(2*Math.cos(x+_)*Math.sin(x-_)))*r+-2*Math.sin(.5*(x+_))*Math.sin(.5*(x-_))*v*E)*n/l;let B=0;return f.m_rotation&&(B=-2*Math.sin(x+_)*Math.sin(x-_)*.125*G-r*E/l*(2*Math.cos(.5*(x+_))*Math.sin(.5*(x-_)))*I),l*(q+B)+-.5*(f.m_XEnd-f.m_XStart)*(f.m_YEnd-f.m_YStart)}function jn(f){f.queryCoord2D(.5,f.m_interior)}function pm(f,n,r,l,_){if(_){if(0!==Fs(n,r))return 2}else if(_e(n,r))return 1;return 0!==Vr(f,n,r,null,null,null,l,void 0!==_&&_,!0,!1)?4:0}function Vr(f,n,r,l,_,x,E,v,I,D){if(ss(n))return Gn(new ke({start:n.getStartXY(),end:n.getEndXY()}),r,l,_,x,E,v,D);null!==_&&(_.length=0),null!==x&&(x.length=0),null!==l&&(l.length=0);const G=qe(n,r);if(Ps(n,r,E=Math.max(G,E)))return 0;const q=r.getStartXY();q.subThis(n.m_center);const B=r.getEndXY();B.subThis(n.m_center),q.rotateReverse(n.m_cosr,n.m_sinr),B.rotateReverse(n.m_cosr,n.m_sinr);const z=B.clone();z.subThis(q);const L=n.m_semiMajorAxis,j=1/L,Q=n.getSemiMinorAxis(),et=1/Q,K=z.clone();K.leftPerpendicularThis();const rt=Math.atan2(Q*K.y,L*K.x),ot=(0,c.d)(16,Number.NaN),nt=(0,c.d)(16,Number.NaN);let at=0;const pt=[rt,rt+Math.PI];for(let Ft=0;Ft<2;++Ft){const Ot=xs(n,pt[Ft]);if(Ot>=0&&Ot<=1){ot[at]=Ot;const Qt=n.getCoord2D(ot[at]);nt[at]=r.getClosestCoordinate(Qt,!1),c.P.distance(Qt,r.getCoord2D(nt[at]))<=E&&at++}}const gt=q.x*j,yt=q.y*et,ft=z.x*j,bt=z.y*et;let Dt=Ns(ft*ft+bt*bt,2*(gt*ft+yt*bt),gt*gt+yt*yt-1,c.E.unit(),!1,nt);(0,R.g)(Dt>=0);for(let Ft=0;Ft<Dt;Ft++){const Ot=z.mul(nt[Ft]).add(q);Ot.x*=j,Ot.y*=et;const Qt=xs(n,Math.atan2(Ot.y,Ot.x));if(Qt>=0&&Qt<=1){ot[at]=Qt;const Kt=n.getCoord2D(Qt);nt[at]=r.getClosestCoordinate(Kt,!1),c.P.distance(Kt,r.getCoord2D(nt[at]))<=E&&at++}}(0,R.g)(at<ot.length+4);const Nt=(0,c.d)(16,Number.NaN);Dt=n.intersectPoint(r.getStartXY(),Nt,E);for(let Ft=0;Ft<Dt;Ft++,at++)ot[at]=Nt[Ft],nt[at]=0;Dt=n.intersectPoint(r.getEndXY(),Nt,E);for(let Ft=0;Ft<Dt;Ft++,at++)ot[at]=Nt[Ft],nt[at]=1;Dt=r.intersectPoint(n.getStartXY(),Nt,E);for(let Ft=0;Ft<Dt;Ft++,at++)ot[at]=0,nt[at]=Nt[Ft];Dt=r.intersectPoint(n.getEndXY(),Nt,E);for(let Ft=0;Ft<Dt;Ft++,at++)ot[at]=1,nt[at]=Nt[Ft];return 0===at?0:Ws(f,n,r,ot,nt,at,l,_,x,E,v,0,D)}function fm(f,n,r,l,_,x,E,v,I,D){if(ss(n)){const ft=new ke({start:n.getStartXY(),end:n.getEndXY()});return Vr(f,r,ft,l,x,_,E,v,0,!0)}if(ss(r)){const ft=new ke({start:r.getStartXY(),end:r.getEndXY()});return Vr(f,n,ft,l,_,x,E,v,0,D)}const G=qe(n,r);E=Math.max(E,G);let q=!1;{const ft=n.getSemiAxes(),bt=n.getCenter(),Dt=r.getSemiAxes(),Nt=r.getCenter(),Ft=c.P.distance(Nt,bt),Ot=ft.x+Dt.x;if(Ft>Ot+E)return 0;if(ft.y>Dt.x){if(Ft+Dt.x+E<ft.y)return 0}else if(Dt.y>ft.x&&Ft+ft.x+E<Dt.y)return 0;if(I&&!v){const Qt=1===n.m_minorMajorRatio&&n.isClosed()&&n.isMajor(),Kt=1===r.m_minorMajorRatio&&r.isClosed()&&r.isMajor();if(Qt&&Kt&&(q=!0,Ft<=Ot)&&Math.max(ft.x,Dt.x)<=Math.min(ft.x,Dt.x)+Ft)return(0,R.g)(!_&&!x),1}}if(!q&&Ps(n,r,E))return 0;const B=[],z=[],Q=go(n,0,0,!1,!1,B,z,null),et=[],K=[],rt=go(r,0,0,!1,!1,et,K,null);if(1===Q&&1===rt){const ft=new as({points:B,weights:z}),bt=new as({points:et,weights:K}),Dt=[],Nt=[],Ft=fr(!1,ft,bt,l,null===_?null:Dt,null===x?null:Nt,E,v,I,D);if(Ft>0&&null!==_||null!==x){_&&(_.length=0),x&&(x.length=0);for(let Ot=0;Ot<Ft;++Ot){if(_)if((0,c.J)(Dt[Ot],0,1))_.push(Dt[Ot]);else{const Qt=ft.tToLength(Dt[Ot]),Kt=n.lengthToT(Qt);_.push(Kt)}if(x)if((0,c.J)(Nt[Ot],0,1))x.push(Nt[Ot]);else{const Qt=bt.tToLength(Nt[Ot]),Kt=r.lengthToT(Qt);x.push(Kt)}}}return Ft}let ot=[];const nt=[];let at=0;const pt=I&&!v;for(let ft=0;ft<Q;ft++){const bt=new as({points:B.slice(2*ft,2*ft+3),weights:z.slice(2*ft,2*ft+3)});let Dt=0;for(let Nt=0;Nt<rt;Nt++){nt.length<=Nt&&nt.push(new as({points:et.slice(2*Nt,2*Nt+3),weights:K.slice(2*Nt,2*Nt+3)}));const Ft=[],Ot=[],Ce=fr(!1,bt,nt[Nt],null,pt?null:Ft,pt?null:Ot,E,!1,pt,!1);if(Ce>0&&pt)return 1;for(let ie=0;ie<Ce;++ie){if(0===Ft[ie]&&0===ft)Ft[ie]=0;else if(1===Ft[ie]&&ft===Q-1)Ft[ie]=1;else{const ne=bt.tToLength(Ft[ie])+at,De=n.lengthToT(ne);Ft[ie]=De}if(0===Ot[ie]&&0===Nt)Ot[ie]=0;else if(1===Ot[ie]&&Nt===rt-1)Ot[ie]=1;else{const ne=nt[Nt].tToLength(Ot[ie])+Dt,De=r.lengthToT(ne);Ot[ie]=De}ot.push((0,c.n)(Ft[ie],Ot[ie]))}Dt+=nt[Nt].calculateLength2D()}at+=bt.calculateLength2D()}if(0===ot.length)return 0;if(v&&(ot=ot.filter(ft=>!(0,c.J)(ft.first,0,1)||!(0,c.J)(ft.second,0,1)||!n.getCoord2D(ft.first).equals(r.getCoord2D(ft.second)))),I)return ot.length;const gt=[],yt=[];for(const ft of ot)gt.push(ft.first),yt.push(ft.second);return Ws(f,n,r,gt,yt,gt.length,l,_,x,E,v,0,D)}function xm(f,n,r){if(r.setCoords(f.getCoord2D(n.vmin)),r.mergeNe(f.getCoord2D(n.vmax)),ss(f))return;const l=f.getSemiAxes(),_=[0,0,0,0];{const E=Math.atan2(-l.y*f.m_sinr,l.x*f.m_cosr),v=E+Math.PI,I=Math.atan2(l.y*f.m_cosr,l.x*f.m_sinr),D=I+Math.PI;_[0]=xs(f,E),_[1]=xs(f,v),_[2]=xs(f,I),_[3]=xs(f,D)}const x=new c.P;for(let E=0;E<4;E++){const v=_[E];n.containsExclusiveCoordinate(v)&&(f.queryCoord2D(v,x),r.mergeNe(x))}}function Pm(f,n,r,l,_){if(0===f.m_semiMajorAxis)return r.vmin;let x=c.P.getNAN();f.queryCoord2D(r.vmin,x);let E=c.P.getNAN();if(f.queryCoord2D(r.vmax,E),ss(f))return new ke({start:x,end:E}).getClosestCoordinate(n,l);const v=fa(f,n);if(x=fa(f,x),E=fa(f,E),1===f.m_minorMajorRatio){if(v.isEqual(0,0))return r.vmin;const at=xs(f,Math.atan2(v.y,v.x));return l||r.containsCoordinate(at)?at:c.P.distance(v,x)<=c.P.distance(v,E)?r.vmin:r.vmax}const I=f.getSemiMajorAxis(),D=f.getSemiMinorAxis(),G=(I-D)*(I+D),q=(0,c.s)(G),B=v.x,z=v.y,L=(0,c.s)(D*z),j=D*G*z*2,Q=[new c.F(L),new c.F(j),new c.F(q-(0,c.s)(I*B)-L),new c.F(-j),new c.F(-q)],et=(0,c.m)(c.F,4),K=xt(Q,4,new c.E(-1,1),!1,et,4);let rt=r.vmin,ot=c.P.sqrDistance(v,x);{const at=c.P.sqrDistance(v,E);at<ot&&(rt=r.vmax,ot=at)}(0,R.g)(!l);let nt=(0,c.d)(8,Number.NaN);for(let at=0;at<K;++at){const pt=et[at].value(),gt=Math.sqrt(1-pt*pt),yt=Math.atan2(pt,gt),ft=Math.atan2(pt,-gt);nt[2*at]=xs(f,yt),nt[2*at+1]=xs(f,ft)}nt=nt.slice(0,2*K),(0,c.v)(nt);for(let at=0,pt=2*K;at<pt;++at)if(nt[at]>r.vmin&&nt[at]<r.vmax){const gt=c.P.sqrDistance(n,f.getCoord2D(nt[at]));ot>gt&&(ot=gt,rt=nt[at])}return rt}function ym(f,n,r){return f.m_semiMajorAxis===n.m_semiMajorAxis&&f.isMajor()!==n.isMajor()&&!!f.m_center.equals(n.m_center)&&f.m_sinr===n.m_sinr&&f.m_cosr===n.m_cosr&&f.m_minorMajorRatio===n.m_minorMajorRatio&&(r?f.isClockwise()!==n.isClockwise():f.isClockwise()===n.isClockwise())}function Em(f,n,r,l){const _=f.getStartXY(),x=f.getEndXY(),E=_.equals(x),v=n.equals(r);if(!E&&!v){const z=new Y.T;return z.initializeFromTwoPoints(_,x,n,r),va(f,z,!0),f.m_XStart=n.x,f.m_YStart=n.y,f.m_XEnd=r.x,f.m_YEnd=r.y,f.endPointModified(),void f.normalizeAfterEndpointChange()}if(!f.isMajor())return void Ci(f,n,r,1);if(E&&v){const z=f.m_center.add(n.sub(_));return void f.constructEllipticArcEndPointsCenter(n,r,f.getSemiMajorAxis(),f.getMinorMajorRatio(),f.getAxisXRotation(),!0,!f.isClockwise(),z)}if(!E){const z=.5*((0,c.a8)()-Math.abs(f.getSweepAngle())),L=(f.getSweepAngle()+z*(0,c.e)(f.getSweepAngle()))/f.getSweepAngle(),j=new c.P;f.queryCoord2D(L,j),f.constructEllipticArcEndPointsCenter(j,j,f.getSemiMajorAxis(),f.getMinorMajorRatio(),f.getAxisXRotation(),!0,!f.isClockwise(),f.getCenter());const Q=f.getCenter().add(n.sub(j));return void f.constructEllipticArcEndPointsCenter(n,r,f.getSemiMajorAxis(),f.getMinorMajorRatio(),f.getAxisXRotation(),!0,!f.isClockwise(),Q)}const I=c.P.sqrDistance(n,r);let D=.25,G=.75;if(I<c.P.sqrDistance(f.getCoord2D(.25),f.getCoord2D(.75))){const z=[0],L=wi(new nm(f,I),c.E.construct(0,.25),1,z);L>0&&((0,R.g)(1===L),D=z[0],G=1-z[0])}const q=f.getCoord2D(D),B=f.getCoord2D(G);(0,R.g)(!q.equals(B)),f.constructEllipticArcEndPointsCenter(q,B,f.getSemiMajorAxis(),f.getMinorMajorRatio(),f.getAxisXRotation(),!0,!f.isClockwise(),f.m_center),Em(f,n,r)}var Yr=F.V;const Mt=-1;class Da{constructor(n){this.m_shape=n}userSort(n,r,l){this.m_shape.sortVerticesSimpleByYHelper(l,n,r)}getValue(n){return this.m_shape.getY(n)}}class Jn{constructor(n){!function Jl(f){return void 0!==f.parent}(n)?(this.m_parent=n.copy.m_parent,this.m_geometry=n.copy.m_geometry,this.m_path=n.copy.m_path,this.m_vertex=n.copy.m_vertex,this.m_index=n.copy.m_index,this.m_bSkipMultiPoints=n.copy.m_bSkipMultiPoints,this.m_firstVertex=n.copy.m_firstVertex,this.m_bFirst=!0,this.m_selection=n.copy.m_selection,this.m_bOneGeom=n.copy.m_bOneGeom):(this.m_parent=n.parent,this.m_geometry=n.geometry,this.m_path=n.path,this.m_vertex=n.vertex,this.m_firstVertex=n.firstVertex,this.m_index=n.selection?0:n.index,this.m_bSkipMultiPoints=n.bSkipMultiPoints,this.m_selection=n.selection,this.m_bOneGeom=n.bOneGeom,this.m_bFirst=!0)}moveToNextHelper(){for(this.m_path=this.m_parent.getNextPath(this.m_path),this.m_index=0;this.m_geometry!==Mt;){for(;this.m_path!==Mt;this.m_path=this.m_parent.getNextPath(this.m_path))if(this.m_vertex=this.m_parent.getFirstVertex(this.m_path),this.m_firstVertex=this.m_vertex,this.m_vertex!==Mt)return this.m_vertex;if(this.m_bOneGeom)return Mt;if(this.m_geometry=this.m_parent.getNextGeometry(this.m_geometry),this.m_geometry===Mt)break;this.m_bSkipMultiPoints&&!(0,R.h)(this.m_parent.getGeometryType(this.m_geometry))||(this.m_path=this.m_parent.getFirstPath(this.m_geometry))}return Mt}nextSelection(){for(;this.m_index<this.m_parent.m_selectedVertices.length;){const n=this.m_parent.m_selectedVertices[this.m_index++];if(n!==Mt&&(this.m_path=this.m_parent.getPathFromVertex(n),!this.m_bOneGeom||this.m_geometry===this.m_parent.getGeometryFromPath(this.m_path)))return this.m_geometry=this.m_parent.getGeometryFromPath(this.m_path),n}return Mt}next(){return this.m_selection?this.nextSelection():this.m_bFirst?(this.m_bFirst=!1,this.m_vertex):this.m_vertex!==Mt?(this.m_vertex=this.m_parent.getNextVertex(this.m_vertex),this.m_index++,this.m_vertex!==Mt&&this.m_vertex!==this.m_firstVertex?this.m_vertex:this.moveToNextHelper()):Mt}currentGeometry(){return this.m_geometry}currentPath(){return this.m_path}static create_(n,r,l,_,x,E,v,I,D){return new Jn({parent:n,geometry:r,path:l,vertex:_,firstVertex:x,index:E,bSkipMultiPoints:v,selection:I,bOneGeom:D})}}class Ta{constructor(n){this.parentage=n}equals(n){return this.parentage===n.parentage}}class Zn{setPrevPath(n,r){this.m_pathIndexList.setField(n,1,r)}setNextPath(n,r){this.m_pathIndexList.setField(n,2,r)}setPathFlags(n,r){this.m_pathIndexList.setField(n,6,r)}getPathFlags(n){return this.m_pathIndexList.getField(n,6)}setPathGeometry(n,r){this.m_pathIndexList.setField(n,7,r)}getPathIndex(n){return this.m_pathIndexList.getField(n,0)}setNextGeometry(n,r){this.m_geometryIndexList.setField(n,1,r)}setPrevGeometry(n,r){this.m_geometryIndexList.setField(n,0,r)}getGeometryIndex(n){return this.m_geometryIndexList.getField(n,7)}setFirstPath(n,r){this.m_geometryIndexList.setField(n,3,r)}setLastPath(n,r){this.m_geometryIndexList.setField(n,4,r)}newGeometry(n){const r=this.m_geometryIndexList.newElement();return this.m_geometryIndexList.setField(r,2,n),this.m_geometryIndexList.setField(r,5,0),this.m_geometryIndexList.setField(r,6,0),this.m_geometryIndexList.setField(r,7,this.m_geometryIndexList.elementToIndex(r)),r}freeGeometry(n){this.m_geometryIndexList.deleteElement(n)}newPath(n){const r=this.m_pathIndexList.newElement(),l=this.m_pathIndexList.elementToIndex(r);if(this.m_pathIndexList.setField(r,0,l),this.m_pathIndexList.setField(r,3,0),this.m_pathIndexList.setField(r,6,0),this.setPathGeometry(r,n),l>=this.m_pathAreas.length){const _=Math.trunc(l<16?16:3*l/2);this.m_pathAreas.length=_,this.m_pathLengths.length=_}return this.m_pathAreas[l]=0,this.m_pathLengths[l]=0,this.m_pathCount++,r}freePath(n){this.m_pathIndexList.deleteElement(n),this.m_pathCount--}newVertex(n){const r=this.m_vertexIndexList.newElement(),l=n>=0?n:this.m_vertexIndexList.elementToIndex(r);if(this.m_vertexIndexList.setField(r,0,l),n<0){if(l>=this.m_vertices.getPointCount()){const _=Math.trunc(l<16?16:3*l/2);this.m_vertices.reserveRounded(_),this.m_vertices.resizeNoInit(_),null!==this.m_segments&&(this.m_segments.length=_),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0)}this.m_segments&&(this.m_segments[l]=null)}return this.m_pointCount++,r}freeVertex(n){this.unselect(n);const r=this.getVertexIndex(n);this.m_vertexIndexList.deleteElement(n),this.m_pointCount--;for(let l=0,_=this.m_indices.length;l<_;l++){if(l===this.m_selectionIndex)continue;const x=this.m_indices[l];null!==x&&x.size()>r&&x.write(r,-1)}this.m_weights&&this.m_weights.size()>r&&this.m_weights.write(r,1),this.m_ranks&&this.m_ranks.size()>r&&this.m_ranks.write(r,1),this.m_segmentWeights&&this.m_segmentWeights.size()>r&&this.m_segmentWeights.write(r,1),this.m_segmentRanks&&this.m_segmentRanks.size()>r&&this.m_segmentRanks.write(r,1),this.m_segments&&this.setSegmentToIndex(r,null)}insertVertex_(n,r,l,_){this.m_hasForceSetEnvelope=0;const x=r!==Mt?this.getPrevVertex(r):this.getLastVertex(n),E=x!==Mt?this.getNextVertex(x):Mt,v=this.newVertex(null===l?this.m_pointCount:-1),I=this.getVertexIndex(v);null!==l&&this.m_vertices.setPointByVal(I,l),this.setPathToVertex(v,n),this.setNextVertex(v,E),this.setPrevVertex(v,x),E!==Mt&&this.setPrevVertex(E,v),x!==Mt&&this.setNextVertex(x,v);const D=this.isClosedPath(n),G=this.getFirstVertex(n);r===Mt&&this.setLastVertex(n,v),r===G&&(D&&_&&G!==Mt||this.setFirstVertex(n,v)),D&&E===Mt&&(this.setNextVertex(v,v),this.setPrevVertex(v,v)),this.setPathSize(n,this.getPathSize(n)+1);const q=this.getGeometryFromPath(n);return this.setGeometryVertexCount(q,this.getPointCount(q)+1),v}getHelperPoint(){return this.m_helperPoint||(this.m_helperPoint=new F.P({vd:this.m_vertices.getDescription()}),this.m_helperPoint.setXYCoords(0,0)),this.m_helperPoint}addMultiPoint(n,r){const l=this.createGeometry(n.getGeometryType(),n.getDescription());return this.appendMultiPoint(l,n,r),l}addPoint_(n,r){const l=this.createGeometry(R.G.enumMultiPoint,n.getDescription());return this.appendPoint(l,n,r),l}appendMultiPath_(n,r){if(r.isEmpty())return;const l=r.getImpl();this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+l.getPointCount()),this.m_verticesMp.addPoints(r,0,l.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const _=null!==this.m_segments||null!==l.getSegmentFlagsStreamRef();this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+l.getPointCount()),this.m_pathIndexList.setCapacity(this.m_pathIndexList.size()+l.getPathCount());for(let x=0,E=l.getPathCount();x<E;x++){if(0===l.getPathSize(x))continue;const v=this.insertPath(n,Mt);this.setClosedPath(v,l.isClosedPath(x));for(let I=l.getPathStart(x),D=l.getPathEnd(x);I<D;I++){const G=this.insertVertex_(v,Mt,null,!1);if(_){const q=this.getVertexIndex(G);if(1&l.getSegmentFlags(I))this.setSegmentToIndex(q,null);else{const B=new is;l.querySegment(I,B,!0),this.setSegmentToIndex(q,B.releaseSegment())}}}l.isStrongPathStart(x)&&this.setStrongPathStart(v,!0),l.isStrongPathEnd(x)&&this.setStrongPathEnd(v,!0)}}addMultiPath(n,r){const l=this.createGeometry(n.getGeometryType(),n.getDescription());return n.getGeometryType()===R.G.enumPolygon&&this.setFillRule(l,n.getFillRule()),this.appendMultiPath(l,n,r),l}appendMultiPathPolyline(n,r,l){const _=r.getImpl(),x=null!==this.m_segments||null!==_.getSegmentFlagsStreamRef(),E=new dt.J;r.queryEnvelope(E);{const v=l.clone();let I=_.getPointCount();const D=_.getAccelerators();if(D&&D.getQuadTree()&&(I=D.getQuadTree().getIntersectionCount(v,0,_.getPointCount()+1)),I<r.getPointCount()){if(0===I)return;const G=_.queryLimitedSegmentIterator(v);let q=-1,B=-100,z=-1,L=0,j=-1,Q=Mt,et=!1,K=G.nextSegment();if(null!==K)for(;;K=G.nextSegment()){let rt=null===K;const ot=null!==K?G.getPathIndex():q,nt=null!==K?G.getStartPointIndex():B;if(rt||(q===ot&&B+1===nt?L++:rt=!0),rt){if(-1!==j){let at=-1,pt=-1;if(L===z){this.setClosedPath(Q,et);const gt=_.getPathEnd(q);this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+gt-j),this.m_verticesMp.addPoints(r,j,gt),pt=_.getPathSize(q),at=gt-1}else if(!et||B+1<_.getPathEnd(q))this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+B+2-j),this.m_verticesMp.addPoints(r,j,B+2),pt=B-j+2,at=B;else{this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+B+2-j),this.m_verticesMp?.addPoints(r,j,B+1),at=B,pt=B-j+1;const gt=_.getPathStart(q);this.m_verticesMp.addPoints(r,gt,gt+1),pt+=1}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);for(let gt=0,yt=j;gt<pt;gt++,yt++){const ft=this.insertVertex_(Q,Mt,null,!1);if(x){const bt=this.getVertexIndex(ft);if(1&_.getSegmentFlags(yt)||yt>at)this.setSegmentToIndex(bt,null);else{const Dt=new is;_.getSegmentBuffer(yt,Dt,!0),this.setSegmentToIndex(bt,Dt.releaseSegment())}}}}if(null===K)break;L=1,j=nt,q!==ot?(Q=this.insertPath(n,Mt),this.setClosedPath(Q,!1),z=_.getSegmentCountPath(ot),et=_.isClosedPath(ot),q=ot):Q=this.insertPath(n,Mt)}B=nt}return}}this.appendMultiPath_(n,r)}appendMultiPathPolygon(n,r,l){const _=r.getImpl(),x=null!==this.m_segments||null!==_.getSegmentFlagsStreamRef(),E=dt.J.constructEmpty();r.queryEnvelope(E),(0,R.g)(l.isIntersecting(E)&&!l.containsEnvelope(E));let v=dt.J.construct(Number.NEGATIVE_INFINITY,l.ymin,Number.POSITIVE_INFINITY,l.ymax),I=dt.J.construct(l.xmin,Number.NEGATIVE_INFINITY,l.xmax,Number.POSITIVE_INFINITY);const D=_.getAccelerators();if(D&&D.getQuadTree()){const nt=D.getQuadTree(),at=nt.getIntersectionCount(v,0,0);at>nt.getIntersectionCount(I,0,at+1)&&(I=(0,c.b)(v,v=I))}else v.height()>I.width()&&(I=(0,c.b)(v,v=I));const G=[],q=_.queryLimitedSegmentIterator(v);let B=-1,z=-100,L=-1,j=0,Q=-1,et=-1,K=Mt,rt=!0,ot=q.nextSegment();if(null!==ot)for(;;ot=q.nextSegment()){let nt=null===ot;const at=null!==ot?q.getPathIndex():B,pt=null!==ot?q.getStartPointIndex():z;if(nt||(at===B?z+1===pt?j++:nt=!0:(nt=B>=0,B<0&&(B=at,L=_.getSegmentCountPath(B),Q=pt,K=Mt,j=1))),nt){if(0!==G.length||L!==j){0!==G.length&&G[0].first===Q||(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(r,Q,Q+1),-1===et&&(et=Q),K===Mt&&(K=this.insertPath(n,Mt),this.setClosedPath(K,!0)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.insertVertex_(K,Mt,null,!1));for(const{first:gt,second:yt}of G){-1===et&&(et=gt);let ft=-1,bt=-1;const Dt=gt+yt-1;if(yt===L){const Nt=Dt+1;bt=Nt-gt,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+bt),this.m_verticesMp.addPoints(r,gt,Nt),ft=Dt,(0,R.g)(1===G.length)}else if(Dt+1<_.getPathEnd(B)){const Nt=Dt+2;bt=Nt-gt,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+bt),this.m_verticesMp.addPoints(r,gt,Nt),ft=Dt}else{const Nt=_.getPathStart(B),Ft=Nt!==et?1:0,Ot=Dt+1;bt=Ot-gt+Ft,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+(Ot-gt)+Ft),this.m_verticesMp.addPoints(r,gt,Ot),ft=Dt,Ft>0&&this.m_verticesMp?.addPoints(r,Nt,Nt+1)}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),K===Mt&&(K=this.insertPath(n,Mt),this.setClosedPath(K,!0));for(let Nt=0,Ft=gt;Nt<bt;Nt++,Ft++){const Ot=this.insertVertex_(K,Mt,null,!1);if(x){const Qt=this.getVertexIndex(Ot);if(1&_.getSegmentFlags(Ft)||Ft>ft)this.setSegmentToIndex(Qt,null);else{const Kt=new is;_.getSegmentBuffer(Ft,Kt,!0),this.setSegmentToIndex(Qt,Kt.releaseSegment())}}}}if(0===G.length||G.at(-1).first+G.at(-1).second!==Q+j){let gt=Q+j;gt===r.getPathEnd(B)&&(gt=r.getPathStart(B)),et!==gt&&(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(r,gt,gt+1),this.insertVertex_(K,Mt,null,!1))}}G.length=0,rt=!0,at!==B&&(B=at,L=_.getSegmentCountPath(B),K=Mt,et=-1),Q=pt,j=1}if(!ot)break;{const gt=dt.J.constructEmpty();ot.queryLooseEnvelope(gt),I.isIntersecting(gt)?(rt?G.push((0,c.n)(pt,1)):G.at(-1).second++,rt=!1):rt=!0}z=pt}}appendMultiPath(n,r,l){if(void 0===l)return void this.appendMultiPath_(n,r);if(r.isEmpty())return;const _=r.getGeometryType()===R.G.enumPolygon,x=dt.J.constructEmpty();r.queryEnvelope(x),l.isIntersecting(x)&&(!l.containsEnvelope(x)&&r.getPointCount()>10?_?this.appendMultiPathPolygon(n,r,l):this.appendMultiPathPolyline(n,r,l):this.appendMultiPath_(n,r))}appendPoint(n,r,l){if(r.isEmpty()||void 0!==l&&!l.contains(r.getXY()))return;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.add(r),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+1);const _=this.insertPath(n,Mt);this.insertVertex_(_,Mt,null,!1)}appendMultiPoint_(n,r){this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+r.getPointCount()),this.m_verticesMp.addPoints(r,0,r.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+r.getPointCount());const l=this.insertPath(n,Mt);for(let _=0,x=r.getPointCount();_<x;_++)this.insertVertex_(l,Mt,null,!1)}appendMultiPoint(n,r,l){if(void 0===l)return void this.appendMultiPoint_(n,r);const _=r.getAttributeStreamRef(0);let x=0;for(let G=0,q=r.getPointCount();G<q;G++){const B=_.readPoint2D(2*G);l.contains(B)&&x++}this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+x);let E=-1,v=-1,I=0;for(let G=0,q=r.getPointCount();G<q;G++){const B=_.readPoint2D(2*G);l.contains(B)?(-1===E&&(E=G,v=G),v++):E>=0&&(this.m_verticesMp.addPoints(r,E,v-E),E=-1,I++)}if(E>0&&(this.m_verticesMp.addPoints(r,E,v-E),I++),!I)return;this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+x);const D=this.insertPath(n,Mt);for(let G=0,q=r.getPointCount();G<q;G++){const B=_.readPoint2D(2*G);l.contains(B)&&this.insertVertex_(D,Mt,null,!1)}}splitSegmentForward(n,r,l,_,x){const E=this.getNextVertex(n);E===Mt&&(0,R.t)("Edit_shape.split_segment_forward_");const v=this.getHelperPoint(),I=this.getPathFromVertex(n);let D=n;const G=this.hasSegmentParentage();for(let q=0,B=r.getResultSegmentCount(l);q<B;q++){const z=this.getVertexIndex(D),L=this.getNextVertex(D),j=r.getResultSegment(l,q);let Q=null;if(j.getGeometryType()!==R.G.enumLine&&(Q=j.clone(),Q.dropAllAttributes()),0===q&&(j.queryStart(v),this.setSegmentToIndex(z,null),this.setPointEx(D,v,r.getResultSegmentStartPointRank(l,q),r.getResultSegmentStartPointWeight(l,q),x)),this.setSegmentRank(D,r.getResultSegmentInteriorRank(l,q)),this.setSegmentWeight(D,r.getResultSegmentInteriorWeight(l,q)),G){const et=r.getResultSegmentSegmentParentage(l,q),K=r.getResultSegmentStartPointIsBreak(l,q);this.setSegmentParentageAndBreak(D,et,K)}if(j.queryEnd(v),q<B-1){this.setSegmentToIndex(z,Q);const et=this.insertVertex(I,L,v);this.setWeight(et,r.getResultSegmentEndPointWeight(l,q)),this.setRank(et,r.getResultSegmentEndPointRank(l,q)),this.select(et),D=et}else{this.setPointEx(E,v,r.getResultSegmentEndPointRank(l,q),r.getResultSegmentEndPointWeight(l,q),x);const et=r.getResultSegmentEndPointIsBreak(l,q);this.setSegmentParentageBreakVertex(E,et),this.setSegmentToIndex(z,Q)}}}splitSegmentBackward(n,r,l,_,x){const E=this.getNextVertex(n);E===Mt&&(0,R.t)("Edit_shape.split_segment_backward_");const v=this.getHelperPoint(),I=this.getPathFromVertex(n);let D=n;const G=this.hasSegmentParentage();for(let q=0,B=r.getResultSegmentCount(l);q<B;q++){const z=B-q-1,L=this.getVertexIndex(D),j=this.getNextVertex(D),Q=r.getResultSegment(l,z);let et=null;if(Q.getGeometryType()!==R.G.enumLine&&(et=Q.clone(),et.reverse(),et.dropAllAttributes()),0===q&&(Q.queryEnd(v),this.setSegmentToIndex(L,null),this.setPointEx(D,v,r.getResultSegmentEndPointRank(l,z),r.getResultSegmentEndPointWeight(l,z),x),this.setSegmentParentageAndBreak(D,r.getResultSegmentSegmentParentage(l,z),r.getResultSegmentEndPointIsBreak(l,z))),Q.getGeometryType()===R.G.enumLine?this.setSegmentToIndex(L,null):this.setSegmentToIndex(L,et),this.setSegmentRank(D,r.getResultSegmentInteriorRank(l,z)),this.setSegmentWeight(D,r.getResultSegmentInteriorWeight(l,z)),Q.queryStart(v),q<B-1){const K=this.insertVertex(I,j,v);this.setWeight(K,r.getResultSegmentStartPointWeight(l,z)),this.setRank(K,r.getResultSegmentStartPointRank(l,z)),this.select(K),D=K,G&&this.setSegmentParentageAndBreak(K,r.getResultSegmentSegmentParentage(l,z),r.getResultSegmentEndPointIsBreak(l,z))}else this.setPointEx(E,v,r.getResultSegmentStartPointRank(l,z),r.getResultSegmentStartPointWeight(l,z),x)}}selected_(n){return this.getUserIndex(n,this.m_selectionIndex)>=0}allocateIndex(n=!0){if(this.m_deletedIndices.length){const r=this.m_deletedIndices.pop();return n&&r.setRange(-1,0,r.size()),r}return n?(0,F.z)(0,-1):(0,F.z)(0)}recycleUserIndex(n){this.m_deletedIndices.push(n)}allocatePathIndex(){if(this.m_deletedPathIndices.length){const n=this.m_deletedPathIndices.at(-1);return this.m_deletedPathIndices.pop(),n}return(0,F.z)(0)}recyclePathUserIndex(n){this.m_deletedPathIndices.push(n)}peelALoop_(n,r,l){const _=this.getNextVertex(n),x=this.getNextVertex(r),E=this.getVertexIndex(n),v=this.getVertexIndex(r);if(this.setNextVertex(n,x),this.setPrevVertex(x,n),this.setNextVertex(r,_),this.setPrevVertex(_,r),this.m_segments){const I=this.getSegmentFromIndex(E),D=this.getSegmentFromIndex(v);this.setSegmentToIndex(v,null),this.setSegmentToIndex(E,D),this.setSegmentToIndex(v,I)}if(this.hasSegmentParentage()){let I=this.getSegmentParentage(r),D=this.getSegmentParentage(n);-1===I&&-1===D||(D=(0,c.b)(I,I=D),this.setSegmentParentageAndBreak(n,D),this.setSegmentParentageAndBreak(r,I))}if(l){const I=this.getPathFromVertex(n),D=this.getGeometryFromPath(I),G=[!1],q=this.insertClosedPath(D,Mt,_,this.getFirstVertex(I),G);G[0]&&this.setFirstVertex(I,x);let B=this.getPathSize(I);return B-=this.getPathSize(q),this.setPathSize(I,B),q}return Mt}sortVerticesSimpleByYHelper(n,r,l){n.sort(r,l,(_,x)=>{let E=this.compareVerticesSimpleY(_,x);if(0===E){const v=this.getPathInternalIndexFromVertex(_),I=this.getPathInternalIndexFromVertex(x);E=v<I?-1:v>I?1:0}return E})}sortVerticesSimpleByYHelper3D(n,r,l){(0,R.g)(0)}constructor(){this.m_verticesMp=null,this.m_vertices=null,this.m_xyStream=null,this.m_vertexDescription=null,this.m_segments=null,this.m_weights=null,this.m_ranks=null,this.m_segmentWeights=null,this.m_segmentRanks=null,this.m_indices=[],this.m_deletedIndices=[],this.m_pathAreas=[],this.m_pathLengths=[],this.m_pathindices=[],this.m_deletedPathIndices=[],this.m_geometryIndices=[],this.m_selectedVertices=[],this.m_helperPoint=null,this.m_forceSetEnvelope=F.n.constructEmpty(),this.m_hasForceSetEnvelope=0,this.m_workPoint2D=c.P.getNAN(),this.m_workPoint2_2D=c.P.getNAN(),this.m_curveStitcher=null,this.m_pathCount=0,this.m_pointCount=0,this.m_firstGeometry=Mt,this.m_lastGeometry=Mt,this.m_vertexIndexList=new F.S(5),this.m_pathIndexList=new F.S(8),this.m_geometryIndexList=new F.S(8),this.m_bHasAttributes=!1,this.m_selectedCount=0,this.m_selectionIndex=-1,this.m_selection=!1,this.m_bucketSort=new F.B,this.m_segmentParentageIndex=-1}getTotalPointCount(){return this.m_pointCount}getEnvelope2D(n){if(0!==this.m_hasForceSetEnvelope)return new dt.J(this.m_forceSetEnvelope.xmin,this.m_forceSetEnvelope.ymin,this.m_forceSetEnvelope.xmax,this.m_forceSetEnvelope.ymax);const r=this.hasCurves(),l=dt.J.constructEmpty(),_=this.queryVertexIterator();let x=!0;for(let E=_.next();E!==Mt;E=_.next()){if(x?l.merge(this.getXY(E)):l.mergeNe(this.getXY(E)),r){const v=this.getSegment(E);if(null!==v){const I=dt.J.constructEmpty();v.queryLooseEnvelope(I),l.mergeEnvelope2D(I)}}x=!1}return l}getEnvelope3D(n){return(0,R.g)(0),F.n.constructEmpty()}forceSetEnvelope2D(n){this.m_hasForceSetEnvelope=1,this.m_forceSetEnvelope.setCoords(n.xmin,n.ymin,0,n.xmax,n.ymax,0)}forceSetEnvelope3D(n){(0,R.g)(0)}forgetForceSetEnvelope(){this.m_hasForceSetEnvelope=0}getGeometryCount(){return this.m_geometryIndexList.size()}addGeometry(n,r){const l=n.getGeometryType();if((0,R.h)(l))return this.addMultiPath(n,r);if(l===R.G.enumMultiPoint)return this.addMultiPoint(n,r);if(l===R.G.enumPoint)return this.addPoint_(n,r);if(l===R.G.enumEnvelope){const _=new yi;return _.addEnvelope(n,!1),this.addMultiPath(_,r)}(0,R.t)("")}appendGeometry(n,r){this.mergeVertexDescription(r.getDescription());const l=r.getGeometryType();(0,R.h)(l)?this.appendMultiPath(n,r):l!==R.G.enumMultiPoint?(0,R.t)(""):this.appendMultiPoint(n,r)}assignRankToGeometryVertices(n,r){r<1&&(r=1);const l=this.queryVertexIterator();for(let _=l.next();_!==Mt;_=l.next())this.setRank(_,r),this.setSegmentRank(_,r)}collapseAllGeometriesToFirst(){this.collapseGeometriesToFirst(R.G.enumUnknown)}collapseGeometriesToFirst(n){this.dbgVerifyVertexCounts();let r=Mt,l=-1,_=-1;for(let x=this.getFirstGeometry();x!==Mt;)if(n!==R.G.enumUnknown&&this.getGeometryType(x)!==n)x=this.getNextGeometry(x);else{if(r===Mt){r=x,l=this.getPathCount(r),_=this.getPointCount(r),x=this.getNextGeometry(x);continue}for(let D=this.getFirstPath(x);D!==Mt;D=this.getNextPath(D))this.setPathGeometry(D,r);l+=this.getPathCount(x),_+=this.getPointCount(x);const E=this.getLastPath(r),v=this.getFirstPath(x);E!==Mt?this.setNextPath(E,v):this.setFirstPath(r,v),v!==Mt&&(this.setPrevPath(v,E),this.setLastPath(r,this.getLastPath(x))),this.setFirstPath(x,Mt),this.setLastPath(x,Mt);const I=x;x=this.getNextGeometry(x),this.setGeometryVertexCount(I,0),this.removeGeometry(I)}return r!==Mt&&(this.setGeometryVertexCount(r,_),this.setGeometryPathCount(r,l),this.dbgVerifyVertexCounts()),r}setFillRule(n,r){let l=this.m_geometryIndexList.getField(n,2);l&=-134217729,l|=1===r?134217728:0,this.m_geometryIndexList.setField(n,2,l)}getFillRule(n){return 134217728&this.m_geometryIndexList.getField(n,2)?1:0}setGeometryModified(n,r){let l=this.m_geometryIndexList.getField(n,2);!!(67108864&l)!==r&&(l&=-67108865,l|=r?67108864:0,this.m_geometryIndexList.setField(n,2,l))}getGeometryModified(n){return!!(67108864&this.m_geometryIndexList.getField(n,2))}setGeometryModifiedWithVertex(n,r){const l=this.getPathFromVertex(n),_=this.getGeometryFromPath(l);this.setGeometryModified(_,r)}getGeometryModifiedWithVertex(n){const r=this.getPathFromVertex(n),l=this.getGeometryFromPath(r);return this.getGeometryModified(l)}swapGeometry(n,r){const l=this.getFirstPath(n),_=this.getFirstPath(r),x=this.getLastPath(n),E=this.getLastPath(r);for(let z=this.getFirstPath(n);z!==Mt;z=this.getNextPath(z))this.setPathGeometry(z,r);for(let z=this.getFirstPath(r);z!==Mt;z=this.getNextPath(z))this.setPathGeometry(z,n);this.setFirstPath(n,_),this.setFirstPath(r,l),this.setLastPath(n,E),this.setLastPath(r,x);const v=this.getPointCount(n),I=this.getPathCount(n),D=this.getPointCount(r),G=this.getPathCount(r);this.setGeometryVertexCount(n,D),this.setGeometryVertexCount(r,v),this.setGeometryPathCount(n,G),this.setGeometryPathCount(r,I);const q=this.m_geometryIndexList.getField(n,2),B=this.m_geometryIndexList.getField(r,2);this.m_geometryIndexList.setField(n,2,B),this.m_geometryIndexList.setField(r,2,q)}addPathFromMultiPath(n,r,l){const _=this.createGeometry(l?R.G.enumPolygon:R.G.enumPolyline,n.getDescription()),x=n.getImpl();if(n.getPathSize(r)<2)return _;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+n.getPathSize(r)),this.m_verticesMp.addPoints(n,n.getPathStart(r),x.getPathEnd(r)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const E=this.insertPath(_,Mt);this.setClosedPath(E,x.isClosedPath(r)||l);const v=null!==this.m_segments||null!==x.getSegmentFlagsStreamRef();for(let I=x.getPathStart(r),D=x.getPathEnd(r);I<D;I++){const G=this.insertVertex_(E,Mt,null,!1);if(v){const q=this.getVertexIndex(G);if(1&x.getSegmentFlags(I))this.setSegmentToIndex(q,null);else{const B=new is;x.querySegment(I,B,!0),this.setSegmentToIndex(q,B.releaseSegment())}}}return x.isStrongPathStart(r)&&this.setStrongPathStart(E,!0),x.isStrongPathEnd(r)&&this.setStrongPathEnd(E,!0),_}getGeometry(n){const r=this.getGeometryType(n),l=function jl(f,n){let r,l=n,_=null;switch(l||(_=(0,R.o)(f)?(0,F.w)():(0,F.j)(),l=_),f){case R.G.enumPoint:r=new F.P({vd:l});break;case R.G.enumLine:r=new ke({vd:l});break;case R.G.enumBezier:r=new fi({vd:l});break;case R.G.enumEllipticArc:r=new Pi({vd:l});break;case R.G.enumRationalBezier2:r=new as({vd:l});break;case R.G.enumBezier2:r=new ns({vd:l});break;case R.G.enumEnvelope:r=new F.E({vd:l});break;case R.G.enumMultiPoint:r=new Ut({vd:l});break;case R.G.enumPolyline:r=new Yi({vd:l});break;case R.G.enumPolygon:r=new yi({vd:l});break;case R.G.enumMultipatch:(0,R.b)("multipatch not impl");break;case R.G.enumGeometryCollection:r=new li({vd:l});break;default:(0,R.t)("Geometry.create")}return r}(r,this.m_verticesMp.getDescription()),_=this.getPointCount(n);if(0===_)return l;if((0,R.h)(r)){const x=l.getImpl(),E=this.getPathCount(n),v=(0,F.z)(E+1),I=(0,F.D)(E+1,0),D=l.getDescription(),G=this.hasCurves();for(let q=0,B=D.getAttributeCount();q<B;q++){const z=D.getSemantics(q),L=Yr.getComponentCount(z),j=(0,F.t)(z,_),Q=this.m_vertices.getAttributeStreamRef(z);let et=0,K=0,rt=0;for(let ot=this.getFirstPath(n);ot!==Mt;ot=this.getNextPath(ot)){let nt=0;this.isClosedPath(ot)&&(nt|=1),this.isExterior(ot)&&(nt|=8),this.isStrongPathStart(ot)&&(nt|=2),this.isStrongPathEnd(ot)&&(nt|=4),nt&&I.setBits(K,nt);const at=this.getPathSize(ot);if(v.write(K++,rt),rt+=at,0===z){const pt=Q,gt=j;let yt;for(let ft=this.getFirstVertex(ot);et<rt;ft=this.getNextVertex(ft),et++){const bt=this.getVertexIndex(ft);yt=pt.readPoint2D(2*bt),gt.writePoint2D(2*et,yt)}}else for(let pt=this.getFirstVertex(ot);et<rt;pt=this.getNextVertex(pt),et++){const gt=this.getVertexIndex(pt);for(let yt=0;yt<L;yt++){const ft=Q.readAsDbl(gt*L+yt);j.writeAsDbl(et*L+yt,ft)}}}x.setAttributeStreamRef(z,j),v.write(E,_)}if(x.setPathFlagsStreamRef(I),x.setPathStreamRef(v),x.notifyModifiedFlags(65535),G){let q=0,B=0;for(let z=this.getFirstPath(n);z!==Mt;z=this.getNextPath(z)){q+=this.getPathSize(z);for(let L=this.getFirstVertex(z);B<q;L=this.getNextVertex(L)){const j=this.getSegment(L);null!==j&&j.isCurve()&&x.replaceSegment(B,j,!0),B++}}}}else if(r===R.G.enumMultiPoint){const x=l.getImpl(),E=l.getDescription();x.reserve(_),x.resizeNoInit(_);for(let v=0,I=E.getAttributeCount();v<I;v++){const D=E.getSemantics(v),G=Yr.getComponentCount(D),q=x.getAttributeStreamRef(D),B=this.m_vertices.getAttributeStreamRef(D);let z=0;const L=this.getFirstPath(n),j=this.getPathSize(L);for(let Q=this.getFirstVertex(L);z<j;Q=this.getNextVertex(Q),z++){const et=this.getVertexIndex(Q);for(let K=0;K<G;K++){const rt=B.readAsDbl(et*G+K);q.writeAsDbl(z*G+K,rt)}}x.setAttributeStreamRef(D,q)}x.notifyModifiedFlags(65535)}else(0,R.c)("getGeometry");return l}queryPointGeometryOnly(n,r){this.getGeometryType(n)!==R.G.enumMultiPoint&&(0,R.t)("get_point_geometry_only");const l=this.getPointCount(n);if(l>1&&(0,R.t)("get_point_geometry_only"),0===l)return r.assignVertexDescription(this.m_vertexDescription),void r.setEmpty();const _=this.getFirstPath(n),x=this.getFirstVertex(_);this.queryPoint(x,r)}removeGeometry(n){for(let _=this.getFirstPath(n);_!==Mt;_=this.removePath(_));const r=this.getPrevGeometry(n),l=this.getNextGeometry(n);return r!==Mt?this.setNextGeometry(r,l):this.m_firstGeometry=l,l!==Mt?this.setPrevGeometry(l,r):this.m_lastGeometry=r,this.freeGeometry(n),l}createGeometry(n,r){void 0===r&&(r=(0,F.j)());const l=this.newGeometry(n);return this.m_vertices||(this.m_verticesMp=new Ut({vd:r}),this.m_vertices=this.m_verticesMp.getImpl()),this.mergeVertexDescription(r),this.m_firstGeometry===Mt?(this.m_firstGeometry=l,this.m_lastGeometry=l):(this.setPrevGeometry(l,this.m_lastGeometry),this.setNextGeometry(this.m_lastGeometry,l),this.m_lastGeometry=l),l}getFirstGeometry(){return this.m_firstGeometry}getLastGeometry(){return this.m_lastGeometry}getNextGeometry(n){return this.m_geometryIndexList.getField(n,1)}getPrevGeometry(n){return this.m_geometryIndexList.getField(n,0)}getGeometryType(n){return 16777215&this.m_geometryIndexList.getField(n,2)}setGeometryUserIndex(n,r,l){const _=this.m_geometryIndices[r],x=this.getGeometryIndex(n);x>=_.size()&&_.resize(Math.max(1.25*x,16),-1),_.write(x,l)}getGeometryUserIndex(n,r){const l=this.getGeometryIndex(n),_=this.m_geometryIndices[r];return l<_.size()?_.read(l):-1}createGeometryUserIndex(){for(let r=0;r<this.m_geometryIndices.length;r++)if(null===this.m_geometryIndices[r])return this.m_geometryIndices[r]=(0,F.z)(0),r;this.m_geometryIndices.push((0,F.z)(0));const n=this.m_geometryIndices.length-1;return(0,R.g)(n>=0&&n<=Number.MAX_SAFE_INTEGER),n}removeGeometryUserIndex(n){for(this.m_geometryIndices[n]=null;this.m_geometryIndices.length>0&&null===this.m_geometryIndices.at(-1);)this.m_geometryIndices.pop()}getFirstPath(n){return this.m_geometryIndexList.getField(n,3)}getLastPath(n){return this.m_geometryIndexList.getField(n,4)}hasPointFeatures(){for(let n=this.getFirstGeometry();n!==Mt;n=this.getNextGeometry(n))if(!(0,R.h)(this.getGeometryType(n)))return!0;return!1}getPointCount(n){return this.m_geometryIndexList.getField(n,5)}getPathCount(n){return this.m_geometryIndexList.getField(n,6)}filterClosePoints(n,r,l,_,x){const E=n*n;let v=0;const I=this.hasCurves(),D=this.hasSegmentParentage();for(let G=x===Mt?this.getFirstGeometry():x;G!==Mt;G=x===Mt?this.getNextGeometry(G):Mt){const q=this.getGeometryType(G);if(!(0,R.h)(q)||l&&q!==R.G.enumPolygon)continue;const B=this.getGeometryType(G)===R.G.enumPolygon;let z=this.getGeometryModified(G);for(let L=this.getFirstPath(G);L!==Mt;){let j=0;for(let rt=this.getFirstVertex(L);j<Math.trunc(this.getPathSize(L)/2);){const ot=this.getNextVertex(rt);if(ot===Mt)break;const nt=this.getXY(rt),at=this.getXY(ot);let pt=c.P.sqrDistance(nt,at),gt=!0;do{if(pt<=E){if(I){const yt=this.getSegment(rt);if(null!==yt){const ft=yt.calculateLength2D();if(pt=ft*ft,pt>E)break}}if(0===pt?0===v&&(v=-1):v=1,ot!==this.getLastVertex(L)){const yt=D&&(this.getSegmentParentageBreakVertex(rt)||this.getSegmentParentageBreakVertex(ot));if(this.transferAllDataToTheVertex(ot,rt),this.removeVertex(ot,!1),_&&!z&&(this.setGeometryModified(G,!0),z=!0),D&&rt!==ot){this.setSegmentParentageBreakVertex(rt,yt);const ft=this.getNextVertex(rt);(0,R.g)(ft!==Mt),this.isDiscontinuousSegmentParentage(ft)&&this.setSegmentParentageBreakVertex(ft,!0)}}gt=!1}}while(0);gt&&(rt=this.getNextVertex(rt)),j++}let Q=this.getFirstVertex(L);for(let rt=this.isClosedPath(L)?Q:this.getLastVertex(L);this.getPathSize(L)>0;){const ot=this.getPrevVertex(rt);if(ot===Mt)break;{const nt=this.getXY(ot),at=this.getXY(rt);let pt=c.P.sqrDistance(nt,at),gt=!0;do{if(pt<=E){if(I){const ft=this.getSegment(ot);if(null!==ft){const bt=ft.calculateLength2D();if(pt=bt*bt,pt>E)break}}0===pt?0===v&&(v=-1):v=1;const yt=D&&(this.getSegmentParentageBreakVertex(rt)||this.getSegmentParentageBreakVertex(ot));this.removeVertex(ot,!0),_&&!z&&(this.setGeometryModified(G,!0),z=!0),D&&ot!==rt&&(yt||this.isDiscontinuousSegmentParentage(rt))&&this.setSegmentParentageBreakVertex(rt,!0),Q===ot&&(Q=this.getFirstVertex(L)),gt=!1}}while(0);if(gt&&(rt=this.getPrevVertex(rt),rt===Q))break}}const et=this.getPathSize(L);let K=r&&et<(B?3:2);K&&B&&2===et&&I&&(K=!this.pathHasCurves(L)),K?(L=this.removePath(L),0===v&&(v=-1),_&&!z&&(this.setGeometryModified(G,!0),z=!0)):L=this.getNextPath(L)}}return v}filterClosePoints3D(n,r,l,_,x,E){return(0,R.g)(0),0}hasDegenerateSegments(n){for(let r=this.getFirstGeometry();r!==Mt;r=this.getNextGeometry(r))if((0,R.h)(this.getGeometryType(r)))for(let l=this.getFirstPath(r);l!==Mt;){const _=this.getPathSize(l);if(0===_)return!0;let x=this.getFirstVertex(l);for(let E=0;E<_;E++){const v=this.getNextVertex(x);if(v===Mt)break;const I=this.getVertexIndex(x),D=this.getSegmentFromIndex(I);let G=0;if(null!==D){if(G=D.calculateLowerLength2D(),G<=n&&(G=D.calculateUpperLength2D(),G<=n||(G=D.calculateLength2D(),G<=n)))return!0}else{const q=this.getVertexIndex(v);if(G=this.m_vertices.getShortestDistance(I,q),G<=n)return!0}x=v}l=this.getNextPath(l)}return!1}hasDegenerateSegments3D(n,r){return(0,R.g)(0),!1}transferAllDataToTheVertex(n,r){const l=this.getVertexIndex(n),_=this.getVertexIndex(r);if(this.m_weights){const E=this.getWeightWithIndex(l);this.setWeightWithIndex(_,E)}if(this.m_ranks){const E=this.getRankWithIndex(l);this.setRankWithIndex(_,E)}if(this.m_segmentWeights){const E=this.getSegmentWeightWithIndex(l);this.setSegmentWeightWithIndex(_,E)}if(this.m_segmentRanks){const E=this.getSegmentRankWithIndex(l);this.setSegmentRankWithIndex(_,E)}for(let E=0,v=this.m_indices.length;E<v;E++)if(E!==this.m_selectionIndex&&null!==this.m_indices[E]){const I=this.getUserIndex(n,E);-1!==I&&this.setUserIndex(r,E,I)}const x=this.selected(n);x!==this.selected(r)&&(x?this.select(r):this.unselect(r))}splitSegmentAxisAware(n,r,l,_,x){let E=0;const v=this.getNextVertex(n);v===Mt&&(0,R.t)("");const I=this.getVertexIndex(n),D=this.getVertexIndex(v),G=this.getSegmentFromIndex(I);let q=this.m_vertices.getShortestDistance(I,D);const B=this.getPathFromVertex(n),z=this.m_bHasAttributes;z&&G&&(q=G.calculateLength2D());const L=this.getSegmentParentage(n),j=this.getHelperPoint();if(G){let Q=0,et=0,K=Mt;for(let rt=0;rt<l;rt++){const ot=r[rt];if(Q<ot&&ot<1){const nt=G.cut(Q,ot);if(null!==_&&(rt>0&&nt.setStartXY(_[rt-1]),nt.setEndXY(_[rt]),nt.normalizeAfterEndpointChange(),et=rt),z){const gt=q>0?G.calculateSubLengthFromStart(ot)/q:0;this.m_vertices.interpolateTwoVertices(I,D,gt,j)}j.setXY(nt.getEndXY()),K=this.insertVertex(B,v,j),E++;const at=this.getPrevVertex(K),pt=this.getVertexIndex(at);this.setSegmentToIndex(pt,nt),-1!==L&&this.setSegmentParentageAndBreak(K,L,!1),Q=ot}}if(K!==Mt){const rt=G.cut(Q,1);null!==_&&(rt.setStartXY(_[et]),rt.normalizeAfterEndpointChange());const ot=this.getVertexIndex(K);this.setSegmentToIndex(ot,rt)}}else{let Q=0;for(let et=0;et<l;et++){const K=r[et];if(Q<K&&K<1){this.m_vertices.interpolateTwoVertices(I,D,K,j);const rt=this.insertVertex(B,v,j);E++,-1!==L&&this.setSegmentParentageAndBreak(rt,L,!1)}Q=K}}return E}splitSegment(n,r,l,_=null){return this.splitSegmentAxisAware(n,r,l,_,-1)}snapControlPoints(n,r,l){this.getNextVertex(n)===Mt&&(0,R.t)("");let _=n,x=!1;for(let E=0;E<r;++E){const v=this.getVertexIndex(_),I=this.getSegmentFromIndex(v);if(I){const D=I.snapControlPoints(l);x||=D}_=this.getNextVertex(_)}return x}snapControlPointsOnSelection(n){if(!this.hasCurves())return!1;let r=0;const l=this.queryVertexIteratorOnSelection();for(let _=l.next();_!==Mt;_=l.next()){const x=this.getVertexIndex(_),E=this.getSegmentFromIndex(x);E&&(r|=E.snapControlPoints(n)?1:0)}return 0!==r}calculateSubLength2D(n,r,l){return(0,R.g)(0),0}setPoint(n,r,l){if(this.setPointOnly(n,r),null!==this.m_segments){const _=this.getVertexIndex(n),x=this.getSegmentFromIndex(_);null!==x&&(x.setStartXY(r.getXY()),x.normalizeAfterEndpointChange(),l&&x.ensureXYMonotone());const E=this.getPrevVertex(n);if(E!==Mt){const v=this.getVertexIndex(E),I=this.getSegmentFromIndex(v);null!==I&&(I.setEndXY(r.getXY()),I.normalizeAfterEndpointChange(),l&&I.ensureXYMonotone())}}}setPointEx(n,r,l,_,x){this.setPoint(n,r,x);const E=this.getVertexIndex(n);this.setWeightWithIndex(E,_),this.setRankWithIndex(E,l)}setPointOnly(n,r){const l=this.getVertexIndex(n);this.m_vertices.setPointByVal(l,r)}setPointOnlyEx(n,r,l,_){(0,R.g)(0)}queryPoint(n,r){const l=this.getVertexIndex(n);this.m_vertices.getPointByVal(l,r)}setXY(n,r){this.setXYCoords(n,r.x,r.y)}setXYCoords(n,r,l){const _=this.getVertexIndex(n);if(this.m_vertices?.setXYCoords(_,r,l),null!==this.m_segments){const x=this.getSegmentFromIndex(_);null!==x&&(x.setStartXYCoords(r,l),x.normalizeAfterEndpointChange());const E=this.getPrevVertex(n);if(E!==Mt){const v=this.getVertexIndex(E),I=this.getSegmentFromIndex(v);null!=I&&(I.setEndXYCoords(r,l),I.normalizeAfterEndpointChange())}}}setXYMonotonic(n,r,l){const _=this.getVertexIndex(n);if(this.m_vertices.setXYCoords(_,r,l),null!==this.m_segments){const x=this.getSegmentFromIndex(_);if(null!==x){const v=x.getEndXY();x.setCoordsForIntersector(new c.P(r,l),v,!1),x.ensureXYMonotone()}const E=this.getPrevVertex(n);if(E!==Mt){const v=this.getVertexIndex(E),I=this.getSegmentFromIndex(v);if(null!==I){const D=I.getStartXY();I.setCoordsForIntersector(D,new c.P(r,l),!1),I.ensureXYMonotone()}}}}setXYMonotonicPoint2D(n,r){this.setXYMonotonic(n,r.x,r.y)}queryXY(n,r){const l=this.getVertexIndex(n);return this.m_vertices.queryXY(l,r)}getXY(n){const r=this.getVertexIndex(n);return this.m_vertices.getXY(r)}getXYWithIndex(n){return this.m_xyStream.readPoint2D(2*n)}static setSegDefault(n,r,l){(0,R.g)(0)}setXYZ(n,r,l){(0,R.g)(0)}setXYZCoords(n,r,l,_){(0,R.g)(0)}queryXYZ(n,r){(0,R.g)(0)}getXYZ(n){return(0,R.g)(0),F.h.getNAN()}getXYZWithIndex(n){return(0,R.g)(0),F.h.getNAN()}mergeVertexDescription(n){this.m_verticesMp.mergeVertexDescription(n),this.m_vertexDescription=this.m_verticesMp.getDescription(),this.m_bHasAttributes=this.m_vertexDescription.getAttributeCount()>1}addAttribute(n){(0,R.g)(0)}getAttributeAsDbl(n,r,l){return this.m_vertices.getAttributeAsDbl(n,this.getVertexIndex(r),l)}queryAttributeAsDbl(n,r,l,_){(0,R.g)(0)}setAttribute(n,r,l,_){(0,R.g)(0)}setAttributeInt(n,r,l,_){(0,R.g)(0)}getVertexDescription(){return this.m_vertexDescription}getMinPathVertexY(n){return(0,R.g)(0),0}getVertexIndex(n){return this.m_vertexIndexList.getField(n,0)}getY(n){const r=this.getVertexIndex(n);return this.m_vertices.queryXY(r,this.m_workPoint2D),this.m_workPoint2D.y}getX(n){return this.getXY(n).x}isEqualXY(n,r){return this.queryXY(n,this.m_workPoint2D),this.queryXY(r,this.m_workPoint2_2D),this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D)}isEqualXYPoint2D(n,r){return this.queryXY(n,this.m_workPoint2D),this.m_workPoint2D.isEqualPoint2D(r)}isEqualXYZPoint3D(n,r){return(0,R.g)(0),!1}setWeight(n,r){r<1&&(r=1);const l=1===r;if(null==this.m_weights){if(l)return;this.m_weights=(0,F.F)(this.m_vertices.getPointCount(),1)}const _=this.getVertexIndex(n);if(_>=this.m_weights.size()){if(l)return;this.m_weights.resize(_+1,1)}this.m_weights.write(_,r)}setWeightWithIndex(n,r){r<1&&(r=1);const l=1===r;if(null===this.m_weights){if(l)return;this.m_weights=(0,F.F)(this.m_vertices.getPointCount(),1)}if(n>=this.m_weights.size()){if(l)return;this.m_weights.resize(n+1,1)}this.m_weights.write(n,r)}getWeight(n){if(null===this.m_weights)return 1;const r=this.getVertexIndex(n);return r>=this.m_weights.size()?1:this.m_weights.read(r)}getWeightWithIndex(n){return null===this.m_weights||n>=this.m_weights.size()?1:this.m_weights.read(n)}getRank(n){if(null===this.m_ranks)return 1;const r=this.getVertexIndex(n);return r>=this.m_ranks.size()?1:this.m_ranks.read(r)}getRankWithIndex(n){return null===this.m_ranks||n>=this.m_ranks.size()?1:this.m_ranks.read(n)}setRank(n,r){r<1&&(r=1);const l=1===r;if(null===this.m_ranks){if(l)return;this.m_ranks=(0,F.z)(this.m_vertices.getPointCount(),1)}const _=this.getVertexIndex(n);if(_>=this.m_ranks.size()){if(l)return;this.m_ranks.resize(_+1,1)}this.m_ranks.write(_,r)}setRankWithIndex(n,r){r<1&&(r=1);const l=1===r;if(null===this.m_ranks){if(l)return;this.m_ranks=(0,F.z)(this.m_vertices.getPointCount(),1)}if(n>=this.m_ranks.size()){if(l)return;this.m_ranks.resize(n+1,1)}this.m_ranks.write(n,r)}setSegmentWeight(n,r){r<1&&(r=1);const l=1===r;if(null===this.m_segmentWeights){if(l)return;this.m_segmentWeights=(0,F.F)(this.m_vertices.getPointCount(),1)}const _=this.getVertexIndex(n);if(_>=this.m_segmentWeights.size()){if(l)return;this.m_segmentWeights.resize(_+1,1)}this.m_segmentWeights.write(_,r)}setSegmentWeightWithIndex(n,r){r<1&&(r=1);const l=1===r;if(null==this.m_segmentWeights){if(l)return;this.m_segmentWeights=(0,F.F)(this.m_vertices.getPointCount(),1)}if(n>=this.m_segmentWeights.size()){if(l)return;this.m_segmentWeights.resize(n+1,1)}this.m_segmentWeights.write(n,r)}getSegmentWeight(n){if(null===this.m_segmentWeights)return 1;const r=this.getVertexIndex(n);return r>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(r)}getSegmentWeightWithIndex(n){return null==this.m_segmentWeights||n>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(n)}getSegmentRank(n){if(null===this.m_segmentRanks)return Zn.st_defaultRank;const r=this.getVertexIndex(n);return r>=this.m_segmentRanks.size()?Zn.st_defaultRank:this.m_segmentRanks.read(r)}getSegmentRankWithIndex(n){return null===this.m_segmentRanks||n>=this.m_segmentRanks.size()?1:this.m_segmentRanks.read(n)}setSegmentRank(n,r){r<1&&(r=1);const l=1===r;if(null===this.m_segmentRanks){if(l)return;this.m_segmentRanks=(0,F.z)(this.m_vertices.getPointCount(),1)}const _=this.getVertexIndex(n);if(_>=this.m_segmentRanks.size()){if(l)return;this.m_segmentRanks.resize(_+1,1)}this.m_segmentRanks.write(_,r)}setSegmentRankWithIndex(n,r){r<1&&(r=1);const l=1===r;if(null===this.m_segmentRanks){if(l)return;this.m_segmentRanks=(0,F.z)(this.m_vertices.getPointCount(),1)}if(n>=this.m_segmentRanks.size()){if(l)return;this.m_segmentRanks.resize(n+1,1)}this.m_segmentRanks.write(n,r)}removeWeights(){this.m_weights=null,this.m_segmentWeights=null}removeRanks(){this.m_ranks=null,this.m_segmentRanks=null}setUserIndex(n,r,l){const _=this.m_indices[r],x=this.getVertexIndex(n);if(_.size()<=x){if(-1===l)return;_.resize(this.m_vertices.getPointCount(),-1)}_.write(x,l)}getUserIndex(n,r){const l=this.getVertexIndex(n),_=this.m_indices[r];return l<_.size()?_.read(l):-1}addToUserIndex(n,r,l){const _=this.m_indices[r],x=this.getVertexIndex(n);_.size()<=x&&_.resize(this.m_vertices.getPointCount(),-1);const E=_.read(x);_.write(x,E+l)}createUserIndex(){for(let r=0;r<this.m_indices.length;r++)if(null===this.m_indices[r])return this.m_indices[r]=this.allocateIndex(),r;this.m_indices.push(this.allocateIndex());const n=this.m_indices.length-1;return(0,R.g)(n>=0&&n<=(0,c.i)()),n}createUserIndexUninitialized(){for(let r=0;r<this.m_indices.length;r++)if(null===this.m_indices[r])return this.m_indices[r]=this.allocateIndex(!1),r;this.m_indices.push(this.allocateIndex(!1));const n=this.m_indices.length-1;return(0,R.g)(n>=0&&n<=Number.MAX_SAFE_INTEGER),n}fillUserIndexForGeometry(n,r,l){const _=this.m_indices[r],x=_.size();for(let E=this.getFirstPath(n);E!==Mt;E=this.getNextPath(E)){let v=this.getFirstVertex(E);for(let I=0,D=this.getPathSize(E);I<D;I++,v=this.getNextVertex(v)){const G=this.getVertexIndex(v);G<x&&_.write(G,l)}}}fillUserIndexForSelection(n,r){(0,R.g)(0)}removeUserIndex(n){for(this.recycleUserIndex(this.m_indices[n]),this.m_indices[n]=null;this.m_indices.length>0&&null===this.m_indices[this.m_indices.length-1];)this.m_indices.pop()}replaceCurveWithLine(n){if(null!==this.m_segments){const r=this.getVertexIndex(n);this.setSegmentToIndex(r,null)}}queryLineConnector(n,r,l=!1){const _=this.getNextVertex(n);if(_===Mt)return!1;if(!this.m_bHasAttributes||l){const x=this.getXY(n);r.setStartXY(x);const E=this.getXY(_);r.setEndXY(E)}else{const x=new F.P({vd:this.getVertexDescription()});this.queryPoint(n,x),r.setStart(x),this.queryPoint(_,x),r.setEnd(x)}return!0}queryLineConnector3D(n,r,l=!1){return(0,R.g)(0),!1}hasCurves(){return null!==this.m_segments}geometryHasCurves(n){return(0,R.g)(0),!1}pathHasCurves(n){if(!this.hasCurves())return!1;const r=this.getFirstVertex(n);if(r===Mt)return!1;const l=this.getPathSize(n);let _=r;for(let x=0;x<l;x++,_=this.getNextVertex(_)){const E=this.getSegment(_);if(null!==E&&E.getGeometryType()!==R.G.enumLine)return!0}return!1}insertPath(n,r){let l=Mt;r!==Mt?(n!==this.getGeometryFromPath(r)&&(0,R.t)(""),l=this.getPrevPath(r)):l=this.getLastPath(n);const _=this.newPath(n);return r!==Mt&&this.setPrevPath(r,_),this.setNextPath(_,r),this.setPrevPath(_,l),l!==Mt?this.setNextPath(l,_):this.setFirstPath(n,_),r===Mt&&this.setLastPath(n,_),this.setGeometryPathCount(n,this.getPathCount(n)+1),_}removePath(n){const r=this.getPrevPath(n),l=this.getNextPath(n),_=this.getGeometryFromPath(n);return r!==Mt?this.setNextPath(r,l):this.setFirstPath(_,l),l!==Mt?this.setPrevPath(l,r):this.setLastPath(_,r),this.clearPath(n),this.setGeometryPathCount(_,this.getPathCount(_)-1),this.freePath(n),l}clearPath(n){const r=this.getFirstVertex(n);if(r!==Mt){let l=r;for(let x=0,E=this.getPathSize(n);x<E;x++){const v=l;l=this.getNextVertex(l),this.freeVertex(v)}const _=this.getGeometryFromPath(n);this.setGeometryVertexCount(_,this.getPointCount(_)-this.getPathSize(n))}this.setPathSize(n,0)}getNextPath(n){return this.m_pathIndexList.getField(n,2)}getPrevPath(n){return this.m_pathIndexList.getField(n,1)}getPathSize(n){return this.m_pathIndexList.getField(n,3)}isClosedPath(n){return!!(1&this.getPathFlags(n))}setClosedPath(n,r){if(this.isClosedPath(n)===r)return;if(this.getPathSize(n)>0){const _=this.getFirstVertex(n),x=this.getLastVertex(n);if(r){this.setNextVertex(x,_),this.setPrevVertex(_,x);const E=this.getVertexIndex(x);this.setSegmentToIndex(E,null)}else{this.setNextVertex(x,Mt),this.setPrevVertex(_,Mt);const E=this.getVertexIndex(x);this.setSegmentToIndex(E,null)}}const l=(1|this.getPathFlags(n))-1;this.setPathFlags(n,l|(r?1:0))}closeAllPaths(n){(0,R.g)(0)}isStrongPathStart(n){return!!(8&this.getPathFlags(n))}isStrongPathEnd(n){return!!(16&this.getPathFlags(n))}setStrongPathStart(n,r){const l=(8|this.getPathFlags(n))-8;this.setPathFlags(n,l|(r?8:0))}setStrongPathEnd(n,r){const l=(16|this.getPathFlags(n))-16;this.setPathFlags(n,l|(r?16:0))}getGeometryFromPath(n){return this.m_pathIndexList.getField(n,7)}isExterior(n){return!!(2&this.getPathFlags(n))}setExterior(n,r){const l=(2|this.getPathFlags(n))-2;this.setPathFlags(n,l|(r?2:0))}getRingArea(n){if(this.isRingAreaValid(n))return this.m_pathAreas[this.getPathIndex(n)];const r=this.getFirstVertex(n);if(r===Mt)return 0;const l=this.getXY(r),_=new c.K(0),x=this.getPathSize(n);if(x>2){const v=l.clone(),I=v.x,D=v.y;let G=this.getNextVertex(r);const q=this.getXY(G);G=this.getNextVertex(G);const B=c.P.getNAN();for(let z=2;z<x;z++,G=this.getNextVertex(G))this.queryXY(G,B),_.pe((B.x-v.x)*(q.y-D)),v.setCoordsPoint2D(q),q.setCoordsPoint2D(B);_.pe((I-v.x)*(q.y-D))}if(this.hasCurves()){let v=r;for(let I=0;I<x;I++,v=this.getNextVertex(v)){const D=this.getSegment(v);if(null===D||D.getGeometryType()===R.G.enumLine)continue;const G=2*D.calculateArea2DHelper();_.pe(G)}}this.setRingAreaValid(n,!0);const E=.5*_.getResult();return this.m_pathAreas[this.getPathIndex(n)]=E,E}getPathIndexInternal(n){return this.getPathIndex(n)}getPathInternalIndexFromVertex(n){return this.getPathIndex(this.getPathFromVertex(n))}setPathUserIndex(n,r,l){const _=this.m_pathindices[r],x=this.getPathIndex(n);_.size()<this.m_pathAreas.length&&_.resize(this.m_pathAreas.length,-1),_.write(x,l)}getPathUserIndex(n,r){const l=this.getPathIndex(n),_=this.m_pathindices[r];return l<_.size()?_.read(l):-1}createPathUserIndex(){for(let r=0;r<this.m_pathindices.length;r++)if(null===this.m_pathindices[r])return this.m_pathindices[r]=this.allocatePathIndex(),r;this.m_pathindices.push(this.allocatePathIndex());const n=this.m_pathindices.length-1;return(0,R.g)(n>=0&&n<=Number.MAX_SAFE_INTEGER),n}fillPathUserIndexForGeometry(n,r,l){const _=this.m_pathindices[r],x=_.size();for(let E=this.getFirstPath(n);E!==Mt;E=this.getNextPath(E)){const v=this.getPathIndex(E);v<x&&_.write(v,l)}}removePathUserIndex(n){for(this.recyclePathUserIndex(this.m_pathindices[n]),this.m_pathindices[n]=null;this.m_pathindices.length>0&&null===this.m_pathindices.at(-1);)this.m_pathindices.pop()}movePath(n,r,l){if(l===Mt&&(0,R.t)(""),r===l)return;const _=this.getNextPath(l);let x=this.getPrevPath(l);const E=this.getGeometryFromPath(l);x===Mt?this.setFirstPath(E,_):this.setNextPath(x,_),_===Mt?this.setLastPath(E,x):this.setPrevPath(_,x),this.setGeometryVertexCount(E,this.getPointCount(E)-this.getPathSize(l)),this.setGeometryPathCount(E,this.getPathCount(E)-1),x=r===Mt?this.getLastPath(n):this.getPrevPath(r),this.setPrevPath(l,x),this.setNextPath(l,r),r===Mt?this.setLastPath(n,l):this.setPrevPath(r,l),x===Mt?this.setFirstPath(n,l):this.setNextPath(x,l),this.setGeometryVertexCount(n,this.getPointCount(n)+this.getPathSize(l)),this.setGeometryPathCount(n,this.getPathCount(n)+1),this.setPathGeometry(l,n)}addVertex(n,r){return this.m_vertices.getPointByVal(this.getVertexIndex(r),this.getHelperPoint()),this.insertVertex_(n,Mt,this.getHelperPoint(),!1)}insertVertex(n,r,l){return this.insertVertex_(n,r,l,!0)}removeVertex(n,r){const l=this.getPathFromVertex(n),_=this.getPrevVertex(n),x=this.getNextVertex(n);_!==Mt&&this.setNextVertex(_,x);const E=this.getPathSize(l);if(n===this.getFirstVertex(l)&&this.setFirstVertex(l,E>1?x:Mt),x!==Mt&&this.setPrevVertex(x,_),n===this.getLastVertex(l)&&this.setLastVertex(l,E>1?_:Mt),this.hasCurves()&&_!==Mt&&x!==Mt){const I=this.getVertexIndex(n),D=this.getVertexIndex(_),G=this.getVertexIndex(x);if(r){const q=this.getSegmentFromIndex(D);if(null!==q){const B=this.m_vertices.getXY(G);q.setEndXY(B),q.normalizeAfterEndpointChange()}this.setSegmentToIndex(I,null)}else{const q=this.getSegmentFromIndex(I);if(this.setSegmentToIndex(I,null),null!==q){const B=this.m_vertices.getXY(D);q.setStartXY(B),q.normalizeAfterEndpointChange()}this.setSegmentToIndex(D,q)}}this.setPathSize(l,E-1);const v=this.getGeometryFromPath(l);return this.setGeometryVertexCount(v,this.getPointCount(v)-1),this.freeVertex(n),x}removeVertices(n,r){(0,R.g)(n!==r);const l=this.getPathFromVertex(n),_=this.getPrevVertex(n),x=this.getPrevVertex(r);_!==Mt&&this.setNextVertex(_,r);let E=this.getPathSize(l);const v=this.getVertexIndex(n);this.setSegmentToIndex(v,null),this.setPrevVertex(r,_),this.setPrevVertex(n,Mt),this.setNextVertex(x,Mt);let I=0,D=n;const G=this.getFirstVertex(l);let q=!1;for(;;){const z=this.getNextVertex(D);if(q||=G===D,this.freeVertex(D),I++,D===x)break;D=z}E-=I,q&&this.setFirstVertex(l,E>0?r:Mt),this.setPathSize(l,E);const B=this.getGeometryFromPath(l);this.setGeometryVertexCount(B,this.getPointCount(B)-I)}getFirstVertex(n){return this.m_pathIndexList.getField(n,4)}getLastVertex(n){return this.m_pathIndexList.getField(n,5)}getNextVertex(n){return this.m_vertexIndexList.getField(n,2)}getPrevVertex(n){return this.m_vertexIndexList.getField(n,1)}getNextVertexEx(n,r){return this.m_vertexIndexList.getField(n,r>0?2:1)}getPrevVertexEx(n,r){return this.m_vertexIndexList.getField(n,r>0?1:2)}getPathFromVertex(n){return this.m_vertexIndexList.getField(n,3)}addPoint(n,r){return this.insertVertex_(n,Mt,r,!1)}getGeometryFromVertex(n){return this.getGeometryFromPath(this.getPathFromVertex(n))}replaceNaNs(n,r){this.m_vertexDescription.hasAttribute(n)||(0,R.c)(""),this.m_vertices.replaceNaNs(n,r)}removeNaNVertices(){for(let n=this.getFirstGeometry();n!==Mt;n=this.getNextGeometry(n))for(let r=this.getFirstPath(n);r!==Mt;r=this.getNextPath(r)){let l=this.getFirstVertex(r);for(let _=0,x=this.getPathSize(r);_<x;_++)l=this.getXY(l).isFinite()?this.getNextVertex(l):this.removeVertex(l,!0)}}queryVertexIterator(n=Mt){return this.queryVertexIteratorEx(!1,n)}queryVertexIteratorEx(n,r=Mt){let l=Mt,_=Mt,x=Mt,E=Mt,v=0,I=!1;for(l=r!==Mt?r:this.getFirstGeometry();l!==Mt;l=this.getNextGeometry(l))if(!n||(0,R.h)(this.getGeometryType(l))){for(_=this.getFirstPath(l);_!==Mt;_=this.getNextPath(_))if(x=this.getFirstVertex(_),E=x,v=0,x!==Mt){I=!0;break}if(I||r!==Mt)break}return I||(l=Mt),Jn.create_(this,l,_,x,E,v,n,!1,r!==Mt)}queryVertexIteratorOnSelection(n=Mt){return this.m_selection?Jn.create_(this,n,Mt,Mt,Mt,-1,!1,!0,n!==Mt):this.queryVertexIteratorEx(!1,n)}hasSelection(){return this.m_selection}createEmptySelection(){(0,R.g)(0)}removeSelection(){this.m_selection&&(this.m_selectedVertices.length=0,this.removeUserIndex(this.m_selectionIndex),this.m_selectionIndex=-1,this.m_selection=!1,this.m_selectedCount=0)}select(n){return!!this.selected(n)||(this.setUserIndex(n,this.m_selectionIndex,this.m_selectedVertices.length),this.m_selectedVertices.push(n),this.m_selectedCount++,!1)}unselect(n){if(!this.m_selection)return;const r=this.getUserIndex(n,this.m_selectionIndex);r>=0&&(this.m_selectedVertices[r]=Mt,this.setUserIndex(n,this.m_selectionIndex,-1),this.m_selectedCount--)}selected(n){return!this.m_selection||this.selected_(n)}getSelectedCount(){return this.m_selection?this.m_selectedCount:this.getTotalPointCount()}createSelectionForCrackingAndClustering(n,r){return(0,R.g)(0),!1}peelALoop(n,r){this.peelALoop_(n,r,!1)}peelALoopIntoAPath(n,r){return this.peelALoop_(n,r,!0)}applyTransformation(n){if(this.m_verticesMp.applyTransformation(n),null!==this.m_segments)for(let r=0,l=this.m_segments.length;r<l;r++)this.m_segments[r]&&this.m_segments[r].applyTransformation(n)}setGeometryType(n,r){this.m_geometryIndexList.setField(n,2,r)}splitSegmentWithIntersector(n,r,l,_,x){_?this.splitSegmentForward(n,r,l,!0,x):this.splitSegmentBackward(n,r,l,!0,x)}setPrevVertex(n,r){this.m_vertexIndexList.setField(n,1,r)}setNextVertex(n,r){this.m_vertexIndexList.setField(n,2,r)}setPathToVertex(n,r){this.m_vertexIndexList.setField(n,3,r)}setPathSize(n,r){this.m_pathIndexList.setField(n,3,r)}setFirstVertex(n,r){this.m_pathIndexList.setField(n,4,r)}setLastVertex(n,r){this.m_pathIndexList.setField(n,5,r)}getSegment(n){if(null!=this.m_segments){const r=this.getVertexIndex(n);return this.getSegmentFromIndex(r)}return null}isCurve(n){return(0,R.g)(0),!1}querySegment(n,r,l=!0,_=!1){const x=this.getNextVertex(n);if(x===Mt)return!1;const E=this.getSegment(n);if(!E)return!l&&(this.queryLineConnector(n,r.createLine(),_),!0);if(r.copyFrom(E,!0),_)return!0;if(this.m_vertexDescription.getAttributeCount()>1){const v=this.getHelperPoint();this.queryPoint(n,v),r.get().setStart(v),this.queryPoint(x,v),r.get().setEnd(v)}return!0}getSegmentFromIndex(n){return(null!==this.m_segments&&this.m_segments.length>n?this.m_segments[n]:null)||null}getAndClearSegmentFromIndex(n){return(null!==this.m_segments&&this.m_segments.length>n?this.m_segments[n]:null)||null}setSegmentToIndex(n,r){if(this.m_hasForceSetEnvelope=0,null===this.m_segments){if(!r)return;this.m_segments=[],this.m_segments.length=this.m_vertices.getPointCount()}n>=this.m_segments.length&&(this.m_segments.length=n+1),this.m_segments[n]=r}setGeometryPathCount(n,r){this.m_geometryIndexList.setField(n,6,r)}setGeometryVertexCount(n,r){this.m_geometryIndexList.setField(n,5,r)}ringParentageCheckInternal(n,r){return(0,R.g)(0),!1}reverseRingInternal(n){const r=this.hasCurves(),l=this.hasSegmentParentage();let _=null,x=-1,E=n;if(r){const v=this.getVertexIndex(E);_=this.getAndClearSegmentFromIndex(v)}l&&(x=this.getSegmentParentage(E));do{const v=this.getPrevVertex(E),I=this.getNextVertex(E);if(this.setNextVertex(E,v),this.setPrevVertex(E,I),r){const D=this.getVertexIndex(I),G=this.getSegmentFromIndex(D);_&&_.reverse(),this.setSegmentToIndex(D,_),_=G}if(l){const D=this.getSegmentParentage(I);this.setSegmentParentagePreserveBreak(I,x),x=D}E=I}while(E!==n);this.dbgVerifyIntegrity(n)}setTotalPointCount(n){this.m_pointCount=n}removePathOnly(n){const r=this.getPrevPath(n),l=this.getNextPath(n),_=this.getGeometryFromPath(n);r!==Mt?this.setNextPath(r,l):this.setFirstPath(_,l),l!==Mt?this.setPrevPath(l,r):this.setLastPath(_,r),this.setFirstVertex(n,Mt),this.setLastVertex(n,Mt),this.freePath(n)}insertClosedPath(n,r,l,_,x){const E=this.insertPath(n,Mt);let v=0,I=l;for(x[0]=!1;;){I===_&&(x[0]=!0),this.setPathToVertex(I,E),v++;const D=this.getNextVertex(I);if(D===l)break;I=D}return this.setClosedPath(E,!0),this.setPathSize(E,v),x[0]&&(l=_),this.setFirstVertex(E,l),this.setLastVertex(E,this.getPrevVertex(l)),this.setRingAreaValid(E,!1),E}findVertex2D(n,r){return(0,R.g)(0),0}findVertex3D(n,r,l){return(0,R.g)(0),0}dbgVerifyMonotone(){}dbgCheckSelection(){}dbgVerifySegment(n){}dbgVerifyIntegrity(n,r=!0){}dbgVerifyVertexCounts(){}dbgVerifyCurves(){}dbgDumpGeometry(n,r){}removeVertexInternal(n,r){const l=this.getPrevVertex(n),_=this.getNextVertex(n);if(l!==Mt&&this.setNextVertex(l,_),_!==Mt&&this.setPrevVertex(_,l),this.hasCurves()&&l!==Mt&&_!==Mt){const x=this.getVertexIndex(n),E=this.getVertexIndex(l),v=this.getVertexIndex(_);if(r){const I=this.getSegmentFromIndex(E);if(null!==I){const D=this.m_vertices.getXY(v);I.setEndXY(D),I.normalizeAfterEndpointChange()}this.setSegmentToIndex(x,null)}else{const I=this.getSegmentFromIndex(x);if(this.setSegmentToIndex(x,null),null!==I){const D=this.m_vertices.getXY(E);I.setStartXY(D),I.normalizeAfterEndpointChange()}this.setSegmentToIndex(E,I)}}return this.freeVertex(n),_}isRingAreaValid(n){return!!(4&this.getPathFlags(n))}setRingAreaValid(n,r){const l=(4|this.getPathFlags(n))-4;this.setPathFlags(n,l|(r?4:0))}compareVerticesSimpleY(n,r){return this.queryXY(n,this.m_workPoint2D),this.queryXY(r,this.m_workPoint2_2D),this.m_workPoint2D.compare(this.m_workPoint2_2D)}compareVerticesSimpleY3D(n,r){return this.getXYZ(n).compare(this.getXYZ(r))}compareVerticesSimpleX(n,r){return this.getXY(n).compareX(this.getXY(r))}sortVerticesSimpleByYHeapMerge(n,r){(0,R.g)(0)}sortVerticesSimpleByY(n,r,l){this.m_bucketSort.sort(n,r,l,new Da(this))}sortVerticesSimpleByX(n,r,l){(0,R.g)(0)}sortVerticesSimpleByY3D(n,r,l){(0,R.g)(0)}snapVertexForPoleClipping(n,r){const l=this.getPrevVertex(n);l!==Mt&&this.replaceCurveWithLine(l),this.getNextVertex(n)!==Mt&&this.replaceCurveWithLine(n);const _=new c.P;this.queryXY(n,_),_.y=r,this.setXY(n,_)}setSegmentParentageAndBreak(n,r,l=!0){if(-1===this.m_segmentParentageIndex){if(-1===r)return;this.m_segmentParentageIndex=this.createUserIndex()}r>=0&&((0,R.g)(r<=(0,c.j)()>>1),r<<=1,r|=l?1:0),this.setUserIndex(n,this.m_segmentParentageIndex,r)}setSegmentParentagePreserveBreak(n,r){if((0,R.g)(r>=-1),-1===this.m_segmentParentageIndex){if(-1===r)return;this.m_segmentParentageIndex=this.createUserIndex()}r>=0&&((0,R.g)(r<=(0,c.j)()>>1),r<<=1,r|=this.getSegmentParentageBreakVertex(n)?1:0),this.setUserIndex(n,this.m_segmentParentageIndex,r)}getSegmentParentage(n){if(-1===this.m_segmentParentageIndex)return-1;const r=this.getUserIndex(n,this.m_segmentParentageIndex);return r<0?r:r>>1}getOriginalSegmentInfo(n){if(-1!==this.m_segmentParentageIndex){const r=this.getSegmentParentage(n);return new Ta(r)}return new Ta(-1)}setSegmentParentageBreakVertex(n,r){if(-1===this.m_segmentParentageIndex)return;let l=this.getUserIndex(n,this.m_segmentParentageIndex);l<0||!!(1&l)!==r&&(r?l|=1:l&=(0,c.j)()>>1<<1,this.setUserIndex(n,this.m_segmentParentageIndex,l))}getSegmentParentageBreakVertex(n){if(-1===this.m_segmentParentageIndex)return!0;const r=this.getUserIndex(n,this.m_segmentParentageIndex);return r<0||!!(1&r)}isDiscontinuousSegmentParentage(n){const r=this.getPrevVertex(n);return r!==Mt&&this.getSegmentParentage(r)!==this.getSegmentParentage(n)}setCurveStitcherPointer(n){this.m_curveStitcher=n}hasSegmentParentage(){return-1!==this.m_segmentParentageIndex}deleteSegmentParentage(){-1!==this.m_segmentParentageIndex&&(this.removeUserIndex(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),this.m_curveStitcher=null}clearSegments(){this.m_segments=null}}function Zl(f){if(f.isEmpty())return new yi({vd:f.getDescription()});const n=f.getImpl(),r=n.getPointCount();if(r<=2){if(1===r||n.getXY(0).equals(n.getXY(1))){const z=new F.P({vd:n.getDescription()});return n.getPointByVal(0,z),z}{const z=new F.P,L=new Yi({vd:n.getDescription()});return n.getPointByVal(0,z),L.startPathPoint(z),n.getPointByVal(1,z),L.lineToPoint(z),L}}const l=n.getAttributeStreamRef(0),_=new Aa({stream:l,n:r});let E=1;const v=l.readPoint2D(0),I=new c.P;for(;E<r&&l.queryPoint2D(E<<1,I).equals(v);)E++;if(_.m_treeHull.addElement(0),E<r){_.m_treeHull.addBiggestElement(E);const z=new c.P;for(let L=E+1;L<n.getPointCount();L++){l.queryPoint2D(L<<1,z);const j=_.treeHull(z);-1!==j&&_.m_treeHull.setElement(j,L)}}const D=n.getDescription(),G=D.getAttributeCount()>1,q=_.m_treeHull.size();let B=null;if(q>=2){B=q>=3?new yi({vd:D}):new Yi({vd:D});const z=B.getImpl();z.reserve(_.m_treeHull.size()),z.addPathPoint2D(null,0,!0);const L=new c.P;for(let j=_.m_treeHull.getFirst();-1!==j;j=_.m_treeHull.getNext(j))if(G){const Q=new F.P;n.getPointByVal(_.m_treeHull.getElement(j),Q),z.insertPoint(0,-1,Q)}else l.queryPoint2D(_.m_treeHull.getElement(j)<<1,L),z.insertPoint2D(0,-1,L)}else if(G){const z=new F.P({vd:D});n.getPointByVal(_.m_treeHull.getElement(_.m_treeHull.getFirst()),z),B=z}else{const z=l.readPoint2D(_.m_treeHull.getElement(_.m_treeHull.getFirst())<<1);B=new F.P(z)}return B}function Cm(f,n,r){if(n<=262144)return function Qn(f,n,r){const l=new F.A(0);for(let v=0;v<n;v++)l.add(v);const _={userSort(v,I,D){D.sort(v,I,(G,q)=>f[G].compareX(f[q]))},getValue:v=>f[v].x};F.B.sortEx(l,0,n,_);let x=0;t:for(let v=0;v<n;++v){const I=l.read(v);for(;x>=2;){const D=r[x-2],G=r[x-1];if(f[G].equals(f[I])){l.write(v,-1);continue t}if(!(Ga(f[D],f[G],f[I])>=0)){G===l.read(v-1)&&l.write(v-1,-1);break}x--}r[x++]=I,2===x&&f[I].equals(f[r[0]])&&(l.write(1,-1),x--)}const E=x+1;t:for(let v=n-2;v>=0;--v){const I=l.read(v);if(!(I<0)){for(;x>=E;){const D=r[x-2],G=r[x-1];if(f[G].equals(f[I]))continue t;if(!(Fa(f[D],f[G],f[I])>=0))break;x--}if(0!==v){const D=r[x-1];r[x++]=I,f[I].equals(f[D])&&x--}}}return x>1&&f[r[0]].equals(f[r[x-1]])&&x--,x}(f,n,r);(0,R.g)(0);const l=new Aa({points:f,n});let x=1;const E=f[0].clone();for(;x<n&&f[x].equals(E);)x++;if(l.m_treeHull.addElement(0),x<n){l.m_treeHull.addBiggestElement(x);for(let I=x+1;I<n;I++){const G=l.treeHull(f[I]);-1!==G&&l.m_treeHull.setElement(G,I)}}let v=0;for(let I=l.m_treeHull.getFirst();-1!==I;I=l.m_treeHull.getNext(I))r[v++]=l.m_treeHull.getElement(I);return v}function Ql(f,n,r){const l=f.getImpl(),_=l.getPathStart(n),x=l.getPathEnd(n),E=!l.isClosedPath(n)&&l.isClosedPathInXYPlane(n),v=l.getAttributeStreamRef(0),I=2*_;let D=2*x;if(E&&(D-=2),D-I<6)return!0;const G=v.readPoint2D(I),q=v.readPoint2D(I+2),B=v.readPoint2D(I+4);if(!nn(c.P.orientationRobust(q,B,G)))return!1;const z=q.clone(),L=new c.P;for(let j=I+6;j<D;j+=2)if(L.assign(q),q.assign(B),v.queryPoint2D(j,B),!nn(c.P.orientationRobust(q,B,G))||!nn(c.P.orientationRobust(z,B,G))||!nn(c.P.orientationRobust(q,B,L)))return!1;return!0}function Na(f,n,r,l,_){if(r.setNAN(),l.setCoords(1,0),_.setCoords(0,0),f.isEmpty())return;if(f.getGeometryType()===R.G.enumPoint)return void r.assign(f.getXY());const x=f,E=x.getPointCount();if(2===E){const v=x.getXY(0),I=x.getXY(1);r.assign(v.add(I).mul(.5));const D=I.sub(v);l=Rr(D),_.setCoords(.5*D.length(),0)}else{let v=Number.MAX_VALUE;const I=[0,1,0,0],D=new c.ai(4,2);for(D.set(0,0,0),D.set(0,1,1),D.set(1,0,1),D.set(1,1,2);I[0]<E;++I[0],Ma(D,0,E)){I[1]===I[0]&&(++I[1],Ma(D,1,E));for(let j=1;;++j){for(;;){const Q=$l(x.getXY(D.get(0,0)),x.getXY(D.get(0,1)),x.getXY(D.get(j,0)),x.getXY(D.get(j,1)),2^j);if(Q>0||(++I[j],Ma(D,j,E),0===Q))break}if(3===j)break;I[j+1]<I[j]&&(I[j+1]=I[j],D.set(j+1,0,D.get(j,0)),D.set(j+1,1,D.get(j,1)))}const G=x.getXY(D.get(0,0)).add(x.getXY(D.get(2,0))).mul(.5),q=Rr(x.getXY(D.get(0,1)).sub(x.getXY(D.get(0,0)))),B=new c.P;let z,L;if(B.x=Math.max(0,q.dotProduct(x.getXY(D.get(1,0)).sub(x.getXY(D.get(3,0))))),B.y=Math.max(0,q.crossProduct(x.getXY(D.get(0,0)).sub(x.getXY(D.get(2,0))))),n?(z=B.x*B.y,L=z<v):(z=B.y,L=z<v),L){v=z;const j=x.getXY(D.get(1,0)),Q=x.getXY(D.get(3,0)),et=j.add(Q).mul(.5).sub(G);r.assign(G.add(q.mul(q.dotProduct(et)))),l.assign(q),_.assign(B)}}_.mulThis(.5),_.x<_.y&&(_.y=(0,c.b)(_.x,_.x=_.y),l.leftPerpendicularThis())}l.y<0?l.negateThis():0===l.y&&(l.x=1)}Zn.st_defaultRank=1;class Kl{constructor(n){this.m_handleP=-1,this.m_handleQ=-1,this.m_currentSupport=-1,this.m_area=0,this.m_bDone=!0,(0,R.g)(0),this.m_convexHull=n,this.m_function=this.done_}next(){return(0,R.g)(0),!1}get_vertex_handle_p(){return(0,R.g)(0),0}get_vertex_handle_q(){return(0,R.g)(0),0}get_current_support(){return(0,R.g)(0),0}getNext(n){return(0,R.g)(0),0}getPrev(n){return(0,R.g)(0),0}intialize_(){return(0,R.g)(0),!1}increment_(){return(0,R.g)(0),!1}increment_q_(){return(0,R.g)(0),!1}increment_p_(){return(0,R.g)(0),!1}parallel_edge_with_q_support_(){return(0,R.g)(0),!1}parallel_edge_with_p_support_(){return(0,R.g)(0),!1}done_(){return(0,R.g)(0),!1}}class Aa{nullGetXY(n){return(0,R.c)("m_getXY is null"),{}}nullDeleteNode(n){(0,R.c)("m_deleteNode is null")}constructor(n){return this.m_treeHull=new F.T,this.m_shape=null,this.m_stream=null,this.m_points=null,this.m_geometryHandle=-1,this.m_pathHandle=-1,this.m_getXY=this.nullGetXY,this.m_deleteNode=this.nullDeleteNode,n?n.stream?(this.m_treeHull.setCapacity(Math.min(20,n.n)),this.m_stream=n.stream,this.m_getXY=this.getXYStream,this.m_deleteNode=this.deleteNodeStream,this.m_points=null,this.m_geometryHandle=Mt,void(this.m_pathHandle=Mt)):n.points?(this.m_treeHull.setCapacity(Math.min(20,n.n)),this.m_points=n.points,this.m_getXY=this.getXYPoints,this.m_deleteNode=this.deleteNodePoints,this.m_stream=null,this.m_geometryHandle=Mt,void(this.m_pathHandle=Mt)):void(0,R.m)("unrecognized constructor parameter"):(this.m_treeHull.setCapacity(20),this.m_shape=new Zn,this.m_geometryHandle=this.m_shape.createGeometry(R.G.enumMultiPoint),this.m_pathHandle=this.m_shape.insertPath(this.m_geometryHandle,Mt),this.m_getXY=this.getXYShape,this.m_deleteNode=this.deleteNodeShape,this.m_stream=null,void(this.m_points=null))}getXYShape(n){return this.m_shape.getXY(n)}getXYStream(n){return this.m_stream.readPoint2D(n<<1)}getXYPoints(n){return(0,R.g)(0),new c.P}deleteNodeShape(n){const r=this.m_treeHull.getElement(n);this.m_treeHull.deleteNode(n),this.m_shape.removeVertex(r,!1)}deleteNodeStream(n){this.m_treeHull.deleteNode(n)}deleteNodePoints(n){(0,R.g)(0)}addGeometry(n){if(n.isEmpty())return;const r=n.getGeometryType();if(r===R.G.enumGeometryCollection){const l=n;for(let _=0,x=l.getGeometryCount();_<x;_++)this.addGeometry(l.getGeometry(_))}else(0,R.i)(r)?this.addMultiVertexGeometry(n):(0,R.f)(r)?this.addSegment(n):r===R.G.enumEnvelope?this.addEnvelope(n):r===R.G.enumPoint?this.addPoint(n):(0,R.t)("Convex_hull: geometry not supported")}getBoundingGeometry(){const n=new F.P,r=this.m_treeHull.getFirst(),l=new yi({vd:this.m_shape.getVertexDescription()});if(0===this.m_treeHull.size())return l;l.reserve(this.m_treeHull.size()),this.m_shape.queryPoint(this.m_treeHull.getElement(r),n),l.startPathPoint(n);for(let _=this.m_treeHull.getNext(r);-1!==_;_=this.m_treeHull.getNext(_))this.m_shape.queryPoint(this.m_treeHull.getElement(_),n),l.lineToPoint(n);return l}getAntipodalPairsIterator(){return(0,R.g)(0),new Kl(this)}getXY(n){return(0,R.g)(0),new c.P}getXYWithIndex(n){return(0,R.g)(0),new c.P}getFirst(){return(0,R.g)(0),0}getLast(){return(0,R.g)(0),0}getNext(n){return(0,R.g)(0),0}getPrev(n){return(0,R.g)(0),0}getVertexIndex(n){return(0,R.g)(0),0}getPointCount(){return(0,R.g)(0),0}addMultiVertexGeometry(n){const r=new F.P,l=n.getImpl(),_=new c.P;for(let x=0;x<n.getPointCount();x++){l.queryXY(x,_);const E=this.addPoint2D(_);if(-1!==E){n.getPointByVal(x,r);const v=this.m_shape.addPoint(this.m_pathHandle,r);this.m_treeHull.setElement(E,v)}}}addEnvelope(n){const r=new F.P;for(let l=0;l<4;l++){const _=new c.P;n.queryCorner(l,_);const x=this.addPoint2D(_);if(-1!==x){n.queryCornerByVal(l,r);const E=this.m_shape.addPoint(this.m_pathHandle,r);this.m_treeHull.setElement(x,E)}}}addSegment(n){const r=new F.P,l=n.getStartXY(),_=this.addPoint2D(l);if(-1!==_){n.queryStart(r);const v=this.m_shape.addPoint(this.m_pathHandle,r);this.m_treeHull.setElement(_,v)}const x=n.getEndXY(),E=this.addPoint2D(x);if(-1!==E){n.queryEnd(r);const v=this.m_shape.addPoint(this.m_pathHandle,r);this.m_treeHull.setElement(E,v)}}addPoint(n){const r=n.getXY(),l=this.addPoint2D(r);if(-1!==l){const _=this.m_shape.addPoint(this.m_pathHandle,n);this.m_treeHull.setElement(l,_)}}addPoint2D(n){let r=-1;if(0===this.m_treeHull.size())return r=this.m_treeHull.addElement(-4),r;if(1===this.m_treeHull.size()){const l=this.m_treeHull.getElement(this.m_treeHull.getFirst()),_=this.m_shape.getXY(l);return n.equals(_)||(r=this.m_treeHull.addBiggestElement(-5)),r}return r=this.treeHull(n),r}treeHull(n){let r=-1;do{const l=this.m_treeHull.getFirst(),_=this.m_treeHull.getLast(),x=this.m_treeHull.getElement(l),E=this.m_treeHull.getElement(_),v=this.m_getXY(x),I=this.m_getXY(E),D=c.P.orientationRobust(I,n,v);if(nn(D)){r=this.m_treeHull.addBiggestElement(-1);const G=this.treeHullWalkBackward(n,_,l);G!==l&&this.treeHullWalkForward(n,l,this.m_treeHull.getPrev(G));break}if(Xr(D)){let G=this.m_treeHull.getRoot(),q=this.m_treeHull.getFirst(),B=this.m_treeHull.getLast(),z=-1,L=-1,j=-1;for(;q!==this.m_treeHull.getPrev(B);){L=this.m_treeHull.getElement(G);const K=this.m_getXY(L);Xr(c.P.orientationRobust(K,n,v))?(B=G,G=this.m_treeHull.getLeft(G)):(q=G,G=this.m_treeHull.getRight(G))}G=B,z=q,L=this.m_treeHull.getElement(G),j=this.m_treeHull.getElement(z);const Q=this.m_getXY(L),et=this.m_getXY(j);if(z!==l&&!nn(c.P.orientationRobust(et,n,Q)))break;r=this.m_treeHull.addElementAtPosition(z,G,-2,!0,!1),this.treeHullWalkForward(n,G,_),this.treeHullWalkBackward(n,z,l);break}{const G=In(n,I,v);if(-1===G){const q=this.m_treeHull.getPrev(_);this.m_treeHull.deleteNode(_),r=this.m_treeHull.addBiggestElement(-3),this.treeHullWalkBackward(n,q,l)}else if(1===G){const q=this.m_treeHull.getNext(l);this.m_treeHull.deleteNode(l),r=this.m_treeHull.addElementAtPosition(-1,q,-3,!0,!1),this.treeHullWalkForward(n,q,_)}break}}while(0);return r}treeHullWalkForward(n,r,l){if(r===l)return l;let _=r,x=this.m_treeHull.getElement(_),E=this.m_treeHull.getNext(_);const v=this.m_getXY(x);for(;_!==l&&this.m_treeHull.size()>2;){const I=this.m_treeHull.getElement(E),D=this.m_getXY(I);if(nn(c.P.orientationRobust(D,n,v)))break;const G=_;_=E,x=I,v.assign(D),E=this.m_treeHull.getNext(_),this.m_deleteNode(G)}return _}treeHullWalkBackward(n,r,l){if(r===l)return l;let _=r,x=this.m_treeHull.getElement(_),E=this.m_treeHull.getPrev(_);const v=this.m_getXY(x);for(;_!==l&&this.m_treeHull.size()>2;){const I=this.m_treeHull.getElement(E),D=this.m_getXY(I);if(nn(c.P.orientationRobust(v,n,D)))break;const G=_;_=E,x=I,v.assign(D),E=this.m_treeHull.getPrev(_),this.m_deleteNode(G)}return _}}function Ga(f,n,r){const l=n.sub(f),_=r.sub(n);if(0===l.x)return _.x>0?-1:0;if(0===l.y)return _.y>0?1:_.y<0?-1:0;const x=l.crossProduct(_),E=4*Number.EPSILON*(Math.abs(_.x*l.y)+Math.abs(_.y*l.x));return x>E?1:x<-E?-1:c.P.orientationRobust(f,n,r)}function Fa(f,n,r){const l=n.sub(f),_=r.sub(n);if(0===l.x)return _.x<0?-1:0;if(0===l.y)return _.y>0?-1:_.y<0?1:0;const x=l.crossProduct(_),E=4*Number.EPSILON*(Math.abs(_.x*l.y)+Math.abs(_.y*l.x));return x>E?1:x<-E?-1:c.P.orientationRobust(f,n,r)}function nn(f){return f<0}function Xr(f){return f>0}function In(f,n,r){let l=-1;l=n.y===r.y?0:n.x===r.x?1:Math.abs(n.x-r.x)>=Math.abs(n.y-r.y)?0:1;let _=-1;return _=n[l]<r[l]?f[l]<n[l]?-1:r[l]<f[l]?1:0:n[l]<f[l]?-1:f[l]<r[l]?1:0,_}function Rr(f){return(f=f.clone()).divThis(Math.max(Math.abs(f.x),Math.abs(f.y))),f.normalize(),f}function Ma(f,n,r){f.inc(n,0)===r&&f.set(n,0,0),f.inc(n,1)===r&&f.set(n,1,0)}function $l(f,n,r,l,_){switch(_){case 0:break;case 1:n.rightPerpendicularThis(),f.rightPerpendicularThis();break;case 2:n.negateThis(),f.negateThis();break;case 3:n.leftPerpendicularThis(),f.leftPerpendicularThis();break;default:(0,R.t)("")}return c.P.orientationRobustEx(f,n,r,l)}function Kn(f,n,r,l,_){return wn(f,!1,n,r,l,_)}function wn(f,n,r,l,_,x){const E=r.getGeometryType(),v=l.getGeometryType(),I=Math.max(_,qe(r,l));if(E===R.G.enumLine&&v===R.G.enumLine)return Oi(r,l,I,x);let D=r,G=l,q=r.getStartXY(),B=r.getEndXY();if(q.compare(B)>0&&(D=r.clone().reverse()),q=l.getStartXY(),B=l.getEndXY(),q.compare(B)>0&&(G=l.clone().reverse()),n){if(r.equals(l))return 2;if(function je(f,n,r){return(0,R.g)(f.isCurve()||n.isCurve()),!!(f.getStartXY().equals(n.getStartXY())&&Ie(f,n,0,0,r,2,[0,0],[0,0])||f.getEndXY().equals(n.getEndXY())&&Ie(f,n,1,1,r,2,[0,0],[0,0])||f.getStartXY().equals(n.getEndXY())&&Ie(f,n,0,1,r,2,[0,0],[0,0])||f.getEndXY().equals(n.getStartXY())&&Ie(f,n,1,0,r,2,[0,0],[0,0]))}(r,l,I))return 4}switch(E){case R.G.enumLine:switch(v){case R.G.enumEllipticArc:return pm(f,G,D,I,x);case R.G.enumBezier:return Lh(f,G,D,I,x);case R.G.enumRationalBezier2:return fh(f,G,D,I,x);case R.G.enumBezier2:return Oo(f,G,D,I,x);default:(0,R.c)("")}break;case R.G.enumEllipticArc:switch(v){case R.G.enumLine:return pm(f,D,G,I,x);case R.G.enumEllipticArc:return function Ul(f,n,r,l,_){if(_){if(0!==Fs(n,r))return 2}else if(_e(n,r))return 1;return 0!==fm(f,n,r,null,null,null,l,void 0!==_&&_,!0,!1)?4:0}(f,D,G,I,x);case R.G.enumBezier:return $o(f,G,D,I,x);case R.G.enumRationalBezier2:return xh(f,G,D,I,x);case R.G.enumBezier2:return Wo(f,G,D,I,x);default:(0,R.c)("")}break;case R.G.enumBezier:switch(v){case R.G.enumLine:return Lh(f,D,G,I,x);case R.G.enumEllipticArc:return $o(f,D,G,I,x);case R.G.enumBezier:return function vl(f,n,r,l,_){if(_){if(0!==Fs(n,r))return 2}else if(_e(n,r))return 1;return 0!==sa(f,n,r,null,null,null,l,void 0!==_&&_,!0,!1)?4:0}(f,D,G,I,x);case R.G.enumRationalBezier2:return Bh(f,D,G,I,x);case R.G.enumBezier2:return ta(f,D,G,I,x);default:(0,R.c)("")}break;case R.G.enumRationalBezier2:switch(v){case R.G.enumLine:return fh(f,D,G,I,x);case R.G.enumEllipticArc:return xh(f,D,G,I,x);case R.G.enumBezier:return Bh(f,G,D,I,x);case R.G.enumRationalBezier2:return function Km(f,n,r,l,_){if(_){const x=Fs(n,r);if(0!==x){if(f){if(1===x){if(n.m_weights[0]===r.m_weights[0]&&n.m_weights[1]===r.m_weights[1]&&n.m_weights[2]===r.m_weights[2])return 2}else if(n.m_weights[0]===r.m_weights[2]&&n.m_weights[1]===r.m_weights[1]&&n.m_weights[2]===r.m_weights[0])return 2;return 4}return 2}}else if(_e(n,r))return 1;return 0!==fr(f,n,r,null,null,null,l,void 0!==_&&_,!0,!1)?4:0}(f,D,G,I,x);case R.G.enumBezier2:return Ph(f,D,G,I,x);default:(0,R.c)("")}break;case R.G.enumBezier2:switch(v){case R.G.enumLine:return Oo(f,D,G,I,x);case R.G.enumEllipticArc:return Wo(f,D,G,I,x);case R.G.enumBezier:return ta(f,G,D,I,x);case R.G.enumRationalBezier2:return Ph(f,G,D,I,x);case R.G.enumBezier2:return function Nh(f,n,r,l,_){if(_){if(0!==Fs(n,r))return 2}else if(_e(n,r))return 1;return 0!==Jo(f,n,r,null,null,null,l,_??!1,!0,!1)?4:0}(f,D,G,I,x);default:(0,R.c)("")}break;default:(0,R.c)("")}}function Fs(f,n,r=!0){if(!r&&!qa(f,n))return 0;const l=f.isLine()&&n.isLine();if(f.getStartXY().equals(n.getStartXY())&&f.getEndXY().equals(n.getEndXY())){if(l)return 1;const x=f.getGeometryType();if(x!==n.getGeometryType())return 0;if(x===R.G.enumBezier){const E=f,v=n;return E.getControlPoint1().equals(v.getControlPoint1())&&E.getControlPoint2().equals(v.getControlPoint2())?1:0}if(x===R.G.enumEllipticArc)return ym(f,n,!1)?1:0;if(x===R.G.enumRationalBezier2){const E=f,v=n;if(E.getControlPoint1().equals(v.getControlPoint1())&&E.getStandardFormWeight()===v.getStandardFormWeight())return 1}else if(x===R.G.enumBezier2){const E=n;if(f.getControlPoint1().equals(E.getControlPoint1()))return 1}return 0}if(f.getStartXY().equals(n.getEndXY())&&f.getEndXY().equals(n.getStartXY())){if(l)return-1;const x=f.getGeometryType();if(x!==n.getGeometryType())return 0;if(x===R.G.enumBezier){const E=f,v=n;return E.getControlPoint1().equals(v.getControlPoint2())&&E.getControlPoint2().equals(v.getControlPoint1())?-1:0}if(x===R.G.enumEllipticArc)return ym(f,n,!0),-1;if(x===R.G.enumRationalBezier2){const E=f,v=n;if(E.getControlPoint1().equals(v.getControlPoint1())&&E.getStandardFormWeight()===v.getStandardFormWeight())return-1}else if(x===R.G.enumBezier2){const E=n;if(f.getControlPoint1().equals(E.getControlPoint1()))return-1}return 0}return 0}function qa(f,n){const r=f.getGeometryType();return r===n.getGeometryType()&&(r!==R.G.enumEllipticArc||f.projectionBehavior()===n.projectionBehavior())}function $n(f,n,r,l,_,x,E){!_&&x&&(0,R.t)("");const v=n.getGeometryType(),I=r.getGeometryType(),D=Math.max(E,qe(n,r));if(l&&(l.length=0),_&&(_.length=0),x&&(x.length=0),v===R.G.enumLine&&I===R.G.enumLine)return Gn(n,r,l,_,x,D,!1,!1);let G=n,q=r,B=n.getStartXY(),z=n.getEndXY(),L=!1,j=!1;B.compare(z)>0&&(G=n.clone(!0).reverse(),L=!0),B=r.getStartXY(),z=r.getEndXY(),B.compare(z)>0&&(q=r.clone(!0).reverse(),j=!0);let Q=0;switch(v){case R.G.enumLine:switch(I){case R.G.enumEllipticArc:Q=Vr(f,q,G,l,x,_,D,!1,0,!0);break;case R.G.enumBezier:Q=Ar(f,q,G,l,x,_,D,!1,0,!0);break;case R.G.enumRationalBezier2:Q=an(f,q,G,l,x,_,D,!1,0,!0);break;case R.G.enumBezier2:Q=kn(f,q,G,l,x,_,D,!1,0,!0);break;default:(0,R.c)("")}break;case R.G.enumEllipticArc:switch(I){case R.G.enumLine:Q=Vr(f,G,q,l,_,x,D,!1,0,!1);break;case R.G.enumEllipticArc:Q=fm(f,G,q,l,_,x,D,!1,!1,!1);break;case R.G.enumBezier:Q=ea(f,q,G,l,x,_,D,!1,0,!0);break;case R.G.enumRationalBezier2:Q=to(f,q,G,l,x,_,D,!1,0,!0);break;case R.G.enumBezier2:Q=jo(f,q,G,l,x,_,D,!1,0,!0);break;default:(0,R.c)("")}break;case R.G.enumRationalBezier2:switch(I){case R.G.enumLine:Q=an(f,G,q,l,_,x,D,!1,0,!1);break;case R.G.enumEllipticArc:Q=to(f,G,q,l,_,x,D,!1,0,!1);break;case R.G.enumBezier:Q=Gr(f,q,G,l,x,_,D,!1,0,!0);break;case R.G.enumRationalBezier2:Q=fr(f,G,q,l,_,x,D,!1,!1,!1);break;case R.G.enumBezier2:Q=Lo(f,G,q,l,_,x,D,!1,!1,!1);break;default:(0,R.c)("")}break;case R.G.enumBezier2:switch(I){case R.G.enumLine:Q=kn(f,G,q,l,_,x,D,!1,0,!1);break;case R.G.enumEllipticArc:Q=jo(f,G,q,l,_,x,D,!1,0,!1);break;case R.G.enumBezier:Q=ia(f,q,G,l,x,_,D,!1,0,!0);break;case R.G.enumRationalBezier2:Q=Lo(f,q,G,l,x,_,D,!1,!1,!0);break;case R.G.enumBezier2:Q=Jo(f,G,q,l,_,x,D,!1,!1,!1);break;default:(0,R.c)("")}break;case R.G.enumBezier:switch(I){case R.G.enumLine:Q=Ar(f,G,q,l,_,x,D,!1,0,!1);break;case R.G.enumEllipticArc:Q=ea(f,G,q,l,_,x,D,!1,0,!1);break;case R.G.enumBezier:Q=sa(f,G,q,l,_,x,D,!1,!1,!1);break;case R.G.enumRationalBezier2:Q=Gr(f,G,q,l,_,x,D,!1,0,!1);break;case R.G.enumBezier2:Q=ia(f,G,q,l,_,x,D,!1,0,!1);break;default:(0,R.c)("")}break;default:(0,R.c)("")}if(L){if(_){for(let et=0;et<Q;et++)_[et]=1-_[et];_.reverse()}l&&l.reverse(),x&&x.reverse()}if(j&&x)for(let et=0;et<Q;et++)x[et]=1-x[et];return Q}function gn(f,n,r){return n===r?0:(n>r&&(r=(0,c.b)(n,n=r)),f.cut(n,r,!0).calculateUpperLength2D())}function Ws(f,n,r,l,_,x,E,v,I,D,G,q,B){if(!x)return 0;const z=(et,K)=>{for(let rt=0;rt<x;++rt){let ot=K[rt];if((0,c.J)(ot,0,1)){ot=(0,c.al)(ot);continue}const nt=et.getCoord2D(ot);ot<.5?nt.equals(et.getStartXY())&&gn(et,0,ot)<=re(et)&&(K[rt]=0):nt.equals(et.getEndXY())&&gn(et,ot,1)<=re(et)&&(K[rt]=1)}};z(n,l),z(r,_),function So(f,n,r,l,_){const x=[],E=[],v=[];for(let D=0,G=_;D<G;D++)x.push(f.calculateSubLengthFromStart(r[D])),E.push(n.calculateSubLengthFromStart(l[D])),(0,c.J)(r[D],0,1)&&(0,c.J)(l[D],0,1)&&f.getCoord2D(r[D]).equals(n.getCoord2D(l[D]))&&v.push(D);if(0===v.length||v.length===_)return;v.sort((D,G)=>r[D]<r[G]?-1:r[D]>r[G]?1:l[D]<l[G]?-1:l[D]>l[G]?1:0);let I=-1;for(const D of v){if(I>=0&&r[D]===r[I]&&r[D]===r[I]){I=D;continue}I=D;const G=[];G.length=_;for(let q=0;q<G.length;++q)G[q]=q;G.sort((q,B)=>{const z=x[D],L=E[D],j=x[q]-z,Q=E[q]-L,et=j*j+Q*Q,K=x[B]-z,rt=E[B]-L,ot=K*K+rt*rt;return et<ot?-1:et>ot?1:0});for(let q=0;q<_;q++){const B=G[q];if(B===D||r[B]===r[D]&&l[B]===l[D]||(0,c.J)(r[B],0,1)&&(0,c.J)(l[B],0,1))continue;const z=(at,pt,gt,yt)=>{const ft=new Vt,bt=new c.F;bt.setWithEps(1);const Dt=new c.F;Dt.set(pt,bt.eps()),f.queryCoord2DE(Dt,ft);const Nt=new Vt;f.queryCoord2DE(new c.F(at),Nt);let Ft=!1;return ft.eq(Nt)&&(Dt.set(yt,bt.eps()),n.queryCoord2DE(Dt,ft),n.queryCoord2DE(new c.F(gt),Nt),Ft=ft.eq(Nt)),!Ft},L=c.P.getNAN();f.queryCoord2D(r[B],L);const j=c.P.getNAN();if(n.queryCoord2D(l[B],j),0===c.P.distance(L,j)&&z(r[D],r[B],l[D],l[B]))break;const Q=new c.E(l[B],l[D]);Q.normalizeNoNAN();const et=new c.E(r[B],r[D]);et.normalizeNoNAN();let K=-1,rt=Number.POSITIVE_INFINITY,ot=Number.POSITIVE_INFINITY,nt=r[B];L.assign(f.getCoord2D(nt));for(let at=0;at<5;at++){const pt=n.getClosestCoordinateOnInterval(L,Q,-1);j.assign(n.getCoord2D(pt));const gt=c.P.distance(L,j);if(nt=f.getClosestCoordinateOnInterval(j,et,-1),nt===r[D]&&pt===l[D]){K=1;break}L.assign(f.getCoord2D(nt));const yt=c.P.distance(j,L);if(!(yt<ot&&gt<rt)){K=0;break}if(0===yt&&0===gt){z(r[D],r[B],l[D],l[B])?(r[B]=nt,l[B]=pt,K=0):K=1;break}ot=yt,rt=gt}if(-1===K&&(K=(0,c.J)(r[B],0,1)||(0,c.J)(l[B],0,1)?0:1),1!==K)break;r[B]=r[D],l[B]=l[D]}}}(n,r,l,_,x);const L=[];for(let et=0,K=x;et<K;et++)L.push(et);const j=(et,K)=>B?(0,c.am)(_[et],l[et],_[K],l[K]):(0,c.am)(l[et],_[et],l[K],_[K]);if(L.length>1){L.sort(j);const et=Math.max(re(n),re(r));let K=0;for(let rt=1,ot=L.length;rt<ot;rt++){const nt=l[L[K]],at=l[L[rt]],pt=_[L[K]],gt=_[L[rt]];if(nt!==at||pt!==gt)if(!(gn(n,nt,at)<=et&&gn(r,pt,gt)<=et)||(0,c.J)(nt,0,1)&&(0,c.J)(pt,0,1)||(0,c.J)(at,0,1)&&(0,c.J)(gt,0,1))K++,L[K]=L[rt];else{const yt=c.P.distance(n.getCoord2D(nt),r.getCoord2D(pt)),ft=c.P.distance(n.getCoord2D(at),r.getCoord2D(gt));if(yt<=ft)continue;if(ft<yt){L[K]=L[rt];continue}}}if(L.length=K+1,1===L.length&&0!==L[0]&&(l[0]=l[L[0]],_[0]=_[L[0]],L[0]=0),L.length>2){const rt=c.E.constructEmpty(),ot=c.E.constructEmpty();rt.setCoords(l[L[0]],l[L.at(-1)]),ot.setCoords(_[L[0]],_[L.at(-1)]);let nt=!0;for(let at=1,pt=L.length-1;at<pt;at++)if(!rt.containsCoordinate(l[L[at]])||!ot.containsCoordinate(_[L[at]])){nt=!1;break}if(nt){const at=[.5,.2,.7,.1,.3,.4,.6,.8,.9];for(let pt=0;pt<at.length;pt++){let gt=(0,c.q)(rt.vmin,rt.vmax,at[pt]);const yt=n.getCoord2D(gt);if(!r.isCloserThanDistance(yt,ot,D)){nt=!1;break}gt=(0,c.q)(ot.vmin,ot.vmax,at[pt]);const ft=r.getCoord2D(gt);if(!n.isCloserThanDistance(ft,rt,D)){nt=!1;break}}}nt&&(L[1]=L.at(-1),L.length=2)}}if(1===L.length&&f&&Ie(n,r,l[0],_[0],D,1,[0],[0])&&(L.push(1),l[1]=0,_[1]=0,L.sort(j)),G&&1===L.length){let et=!0;for(let K=0,rt=L.length;K<rt;K++)if(!(0,c.J)(l[L[K]],0,1)||!(0,c.J)(_[L[K]],0,1)||0!==c.P.distance(n.getCoord2D(l[L[K]]),r.getCoord2D(_[L[K]]))){et=!1;break}if(et)return 0}let Q=0;for(let et=0,K=L.length;et<K;et++){if(v&&v.push(l[L[et]]),I&&I.push(_[L[et]]),E){const rt=c.P.getNAN();n.queryCoord2D(l[L[et]],rt),E.push(rt)}Q++}return Q}function tu(f,n,r,l,_,x,E,v,I){if((0,c.J)(r,0,1)&&(0,c.J)(l,0,1)&&0===c.P.distance(f.getCoord2D(r),n.getCoord2D(l))){const G=new Vt,q=Number.EPSILON;if(f.queryDerivative(new c.F(r,q),G),G.isTrueZero()){const Q=1===r?-1e-12:1e-12;f.queryDerivative(new c.F(r,q).add(Q),G)}1===r&&G.negateThis();const B=new Vt;if(n.queryDerivative(new c.F(l,q),B),B.isTrueZero()){const Q=1===r?-1e-12:1e-12;n.queryDerivative(new c.F(l,q).add(Q),B)}1===l&&B.negateThis(),G.isZero()||G.normalize(),B.isZero()||B.normalize();const z=G.dotProduct(B),L=G.crossProduct(B);L.scaleError(3);const j=()=>{if(I)return.001;{const Q=f.calculateUpperLength2D(),et=n.calculateUpperLength2D();return Math.min(.01*_/Math.min(Q,et),1e-10)}};if(z.ge(c.H)&&(L.isZero()||Math.abs(L.value())<j()))return ve(f,n,r,l,_,x,E,v)}return 0}function tr(f,n,r,l,_){let x=-1,E=-1,v=-1,I=-1;{const D=[0,n],G=[n,0],q=[0,l],B=[l,0];for(let z=0;z<2&&-1===x;++z)for(let L=0;L<2;++L)if(f[D[z]].equals(r[q[L]])){x=D[z],E=G[z],v=q[L],I=B[L];break}}if(-1===x){const D=new jt;D.setFromPoints(f,n+1);const G=new jt;return G.setFromPoints(r,l+1),G.inflate(_),D.isIntersectingW(G)?-1:0}{const D=(0,c.d)(n+1,Number.NaN),G=Cm(f,n+1,D);(0,R.g)(G>1);let q=0,B=0;for(let gt=0;gt<G;++gt)x===D[gt]&&(B=gt,q++),E===D[gt]&&q++;if(2!==q)return-1;const z=(0,c.d)(l+1,Number.NaN),L=Cm(r,l+1,z);(0,R.g)(L>1),q=0;let j=0;for(let gt=0;gt<L;++gt)v===z[gt]&&(j=gt,q++),I===z[gt]&&q++;if(2!==q)return-1;const Q=f[D[(B+G-1)%G]],et=f[D[(B+1)%G]],K=r[z[(j+L-1)%L]],rt=r[z[(j+1)%L]],ot=f[x],nt=[Q,et,K,rt],at=[0,1,2,3];at.sort((gt,yt)=>c.P.compareVectorsOrigin(ot,nt[gt],nt[yt]));let pt=at[0];for(let gt=1;gt<4;gt++){if(at[gt]!==(pt+1)%4)return-1;pt=at[gt]}{const gt=Q.sub(ot),yt=rt.sub(ot),ft=yt.dotProduct(gt);if(ft>0){const bt=yt.crossProduct(gt),Dt=Math.abs(Math.atan2(bt,ft)),Nt=Dt*gt.length(),Ft=Dt*yt.length();if(Nt<=_||Ft<=_)return-1}}{const gt=et.sub(ot),yt=K.sub(ot),ft=yt.dotProduct(gt);if(ft>0){const bt=yt.crossProduct(gt),Dt=Math.abs(Math.atan2(bt,ft)),Nt=Dt*gt.length(),Ft=Dt*yt.length();if(Nt<=_||Ft<=_)return-1}}return 1}}var Dn=F.V;class ke extends To{constructor(n){super(n||{XStart:0,YStart:0,XEnd:0,YEnd:0})}assignMove(n){return this!==n&&(this.m_description=n.m_description,n.m_description=null,this.m_attributes=n.m_attributes,n.m_attributes=null,this.m_XStart=n.m_XStart,n.m_XStart=Number.NaN,this.m_YStart=n.m_YStart,this.m_XEnd=n.m_XEnd,n.m_XEnd=Number.NaN,this.m_YEnd=n.m_YEnd),this}assignCopy(n){return this!==n&&n.copyTo(this),this}calculateLowerLength3D(){return(0,R.g)(0),0}calculateUpperLength3D(){return(0,R.g)(0),0}changeEndPoints3D(n,r){(0,R.g)(0)}getClosestCoordinate3D(n,r,l){return(0,R.g)(0),0}getBoundary(){return mi(this)}getAttributeAsDbl(n,r,l){if(0===r)return 0===l?Is(this,n):Ii(this,n);const _=Dn.getInterpolation(r),x=this.getStartAttributeAsDbl(r,l),E=this.getEndAttributeAsDbl(r,l);return(0,c.T)(_,x,E,n,Dn.getDefaultValue(r))}constructFromCoords(n,r,l,_){this.dropAllAttributes(),this.setStartXYCoords(n,r),this.setEndXYCoords(l,_)}construct(n,r){this.dropAllAttributes(),this.setStartXY(n),this.setEndXY(r)}construct3D(n,r){(0,R.g)(0)}constructPoint(n,r){this.assignVertexDescription(n.getDescription()),this.mergeVertexDescription(r.getDescription()),this.setStart(n),this.setEnd(r)}getGeometryType(){return ke.type}queryEnvelope(n){if(4===n.m_EnvelopeType){n.setEmpty(),n.assignVertexDescription(this.m_description);const r=dt.J.constructEmpty();this.queryEnvelope(r),n.setEnvelope(r);for(let l=1,_=this.m_description.getAttributeCount();l<_;l++){const x=this.m_description.getSemantics(l);for(let E=0,v=Dn.getComponentCount(x);l<v;l++){const I=this.queryInterval(x,E);n.setIntervalEnvelope(x,E,I)}}}else 2===n.m_EnvelopeType?n.setCoords({xmin:this.m_XStart,ymin:this.m_YStart,xmax:this.m_XEnd,ymax:this.m_YEnd}):3===n.m_EnvelopeType?(n.setEmpty(),n.mergeCoords(this.m_XStart,this.m_YStart,ye(this,0,1,0)),n.mergeCoords(this.m_XEnd,this.m_YEnd,ye(this,1,1,0))):(0,R.b)("env type not impl")}applyTransformation(n){(0,R.g)(n instanceof Y.T);const r=new c.P;r.x=this.m_XStart,r.y=this.m_YStart,n.transformInPlace(r),this.m_XStart=r.x,this.m_YStart=r.y,r.x=this.m_XEnd,r.y=this.m_YEnd,n.transformInPlace(r),this.m_XEnd=r.x,this.m_YEnd=r.y}createInstance(){return new ke({vd:this.m_description})}calculateLength2D(){return Math.sqrt(mr(this))}calculateLength3D(n){return(0,R.g)(0),0}changeEndPoints2D(n,r){this.setStartXY(n),this.setEndXY(r),this.normalizeAfterEndpointChange()}queryCoord2D(n,r){return Us(this,n,r)}queryCoord3D(n,r){(0,R.g)(0)}getCoordZ(n){return function rr(f,n){const r=f.getStartZ(),l=f.getEndZ();return(0,c.q)(r,l,n)}(this,n)}queryCoord2DE(n,r){or(this,n,r)}getCoordX(n){return Is(this,n)}getCoordY(n){return Ii(this,n)}cut(n,r,l){const _=new is;return this.queryCut(n,r,_,l),_.releaseSegment()}queryCut(n,r,l,_){const x=l.createLine();_&&x.assignVertexDescription(this.m_description);const E=c.P.getNAN();if(Us(this,n,E),x.setStartXYCoords(E.x,E.y),Us(this,r,E),x.setEndXYCoords(E.x,E.y),!_)for(let v=1,I=this.m_description.getAttributeCount();v<I;v++){const D=this.m_description.getSemantics(v),G=Dn.getComponentCount(D);for(let q=0;q<G;q++){const B=this.getAttributeAsDbl(n,D,q);x.setStartAttribute(D,q,B);const z=this.getAttributeAsDbl(r,D,q);x.setEndAttribute(D,q,z)}}}queryDerivative(n,r){!function Br(f,n,r){const l=Vt.constructPoint2D(f.getStartXY()),_=Vt.constructPoint2D(f.getEndXY());r.setCoordsE(_.x.subE(l.x),_.y.subE(l.y))}(this,0,r)}getClosestCoordinate(n,r){return c.P.getClosestCoordinate(this.getStartXY(),this.getEndXY(),n,r)}getClosestCoordinateOnInterval(n,r,l=-1){const _=new c.P;this.queryCoord2D(r.vmin,_);const x=new c.P;this.queryCoord2D(r.vmax,x);const E=c.P.getClosestCoordinate(_,x,n,!1);return qs.recalculateParentT(r.vmin,r.vmax,E)}intersectionOfYMonotonicWithAxisX(n,r){const l=this.m_YEnd-this.m_YStart;if(!l)return n===this.m_YEnd?r:Number.NaN;const _=(n-this.m_YStart)/l;let x=Is(this,_);return 1===_&&(x=this.m_XEnd),x}isCurve(){return!1}isMonotoneQuickAndDirty(){return!0}isDegenerate(n){const r=this.m_XStart-this.m_XEnd,l=this.m_YStart-this.m_YEnd;return Math.sqrt(r*r+l*l)<=n}isDegenerate3D(n,r){return(0,R.g)(0),!1}queryLooseEnvelope(n){this.queryEnvelope(n)}clone(n){const r=new ke;return this.copyTo(r),r}tToLength(n){return n*this.calculateLength2D()}lengthToT(n){const r=this.calculateLength2D();return 0!==r?n/r:0}calculateWeightedAreaCentroid2D(n){const r=new c.P;return r.setCoords(0,0),r}calculateWeightedCentroid2D(){return this.getCoord2D(.5).mul(this.calculateLength2D())}getTangent(n){const r=c.P.getNAN();return r.setSub(this.getEndXY(),this.getStartXY()),r}getDerivative(n){const r=new c.P;return r.setSub(this.getEndXY(),this.getStartXY()),r}getCurvature(n){return 0}isIntersectingPoint(n,r,l){return Qi(this,n,r,l)>=0}isIntersectingPoint3D(n,r,l,_,x=1){return(0,R.g)(0),!1}getYMonotonicParts(n,r){return 0}getMonotonicParts(n,r){return 0}getMonotonicPartParams(n,r){return r&&(n<2&&(0,R.t)(""),r[0]=0,r[1]=1),2}intersectionWithAxis2D(n,r,l,_){if(n){const x=this.m_YEnd-this.m_YStart;if(!x)return r===this.m_YEnd?-1:0;const E=(r-this.m_YStart)/x;return E<0||E>1?0:(l&&(l[0]=Is(this,E)),_&&(_[0]=E),1)}{const x=this.m_XEnd-this.m_XStart;if(!x)return r===this.m_XEnd?-1:0;const E=(r-this.m_XStart)/x;return E<0||E>1?0:(l&&(l[0]=Ii(this,E)),_&&(_[0]=E),1)}}calculateUpperLength2D(){return this.calculateLength2D()}calculateLowerLength2D(){return this.calculateLength2D()}normalizeAfterEndpointChange(){return!1}queryLooseEnvelopeOnInterval(n,r){if(2===r.m_EnvelopeType){let l=(0,c.c)(n.vmin,0,1);const _=new c.P;return this.queryCoord2D(l,_),r.setCoords({pt:_}),l=(0,c.c)(n.vmax,0,1),this.queryCoord2D(l,_),void r.mergeNe(_)}(0,R.b)("3d dst not impl")}orientBottomUp(){Oe(this)}isLine(){return!0}isDegenerateToLineHelper(n){return!0}copyIgnoreAttributes(n){n.setStartXY(this.getStartXY()),n.setEndXY(this.getEndXY()),n.normalizeAfterEndpointChange()}calculateArea2DHelper(){return 0}absNormXYZ(n){return function Qs(f,n){const r=f.getStartXYZ();r.z*=n;const l=f.getEndXYZ();return l.z*=n,r.norm(1)+l.norm(1)}(this,n)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)}queryEnvelopeW(n,r){r.setCoords(this.getCoord2D(n.vmin)),r.mergeNe(this.getCoord2D(n.vmax))}setSegmentFromCoords(n,r){Hr(this,n[0],n[r-1])}writeInBufferStream(n,r){return(0,R.g)(0),0}readFromBufferStream(n,r){(0,R.g)(0)}snapControlPoints(n){return!1}needsSnapControlPoints(n){return!1}calculateSpecialPointsForCracking(n,r){return 0}ensureXYMonotone(){return!1}setCoordsForIntersector(n,r,l){Hr(this,n,r)}static isIntersectingLineLine(n,r,l,_){return Oi(n,r,l,_)}static isIntersectingLineLine_(n,r,l,_){return Oi(n,r,l,_)}copyToImpl(n){}reverseImpl(){}equalsImpl(n){return!0}equalsImplTol(n,r){return!0}swapImpl(n){}afterCompletedModification(){}endPointModified(){}clearEndPointModified(){}intersect(n,r,l,_,x){return $n(!1,this,n,r,l,_,x)}intersectPoint(n,r,l){r.length<1&&(0,R.n)("");const _=Qi(this,n,l,!1);return _>=0?(r&&(r[0]=_),1):0}isIntersecting(n,r,l){return 0!==Kn(!1,this,n,r,l)}}ke.type=R.G.enumLine;class is{constructor(n){this.m_seg=null,this.m_curves=null,this.m_lineBuffer=new ke,this.m_mask=0,this.m_active=0,void 0!==n&&(n.copy?n.copy.copyTo(this,!1):n.move?this.assignMove(n.move):n.segment?this.copyFrom(n.segment,!!n.bIgnoreAttributes):(0,R.c)("bad constructor params"))}assignCopy(n){return n instanceof is?this!==n&&n.copyTo(this,!1):this.copyFrom(n,!1),this}assignMove(n){if(n instanceof is){if(this===n)return this;this.reset(),1&n.m_mask&&(this.m_lineBuffer=n.m_lineBuffer,n.m_lineBuffer=null,this.m_mask=1),this.m_curves=n.m_curves,this.m_mask=n.m_mask,this.m_active=n.m_active,n.reset(),this.m_seg=this.activeSegment(),n.m_seg=null}else{if(this.m_seg===n)return this;this.create(n.getGeometryType()),this.m_seg.swap(n)}return this}activeSegment(){switch(this.m_active){case 0:return null;case 1:return this.line();case 2:return this.arc();case 4:return this.bezier3();case 8:return this.bezier2();case 16:return this.rbezier2();default:(0,R.c)("")}}get(){return this.m_seg}reset(){1&this.m_mask&&(this.m_lineBuffer=null),this.m_mask>1&&(this.m_curves=null),this.m_mask=0,this.m_active=0}empty(){return null===this.m_seg}copyTo(n,r){this!==n&&(this.empty()?n.m_seg=null:n.copyFrom(this.m_seg,r))}copyToWithZ(n,r){(0,R.g)(0)}createImpl(n){switch(n){case R.G.enumLine:1&this.m_mask||(this.m_lineBuffer=new ke,this.m_mask|=1,this.m_active=1);break;case R.G.enumEllipticArc:2&this.m_mask||(this.m_curves=new Pi,this.m_mask=1&this.m_mask|2,this.m_active=2);break;case R.G.enumBezier:4&this.m_mask||(this.m_curves=new fi,this.m_mask=1&this.m_mask|4,this.m_active=4);break;case R.G.enumBezier2:8&this.m_mask||(this.m_curves=new ns,this.m_mask=1&this.m_mask|8,this.m_active=8);break;case R.G.enumRationalBezier2:16&this.m_mask||(this.m_curves=new as,this.m_mask=1&this.m_mask|16,this.m_active=16);break;default:(0,R.t)("")}}create(n){n===R.G.enumLine?this.createLine():n===R.G.enumEllipticArc?this.createEllipticArc():n===R.G.enumBezier?this.createCubicBezier():n===R.G.enumRationalBezier2?this.createQuadraticRationalBezier():n===R.G.enumBezier2?this.createQuadraticBezier():(0,R.t)("Segment_buffer.create")}copyFrom(n,r){this.m_seg!==n&&(this.create(n.getGeometryType()),r?n.copyIgnoreAttributes(this.m_seg):n.copyTo(this.m_seg))}copyFromWithZ(n,r){(0,R.g)(0)}line(){return this.m_lineBuffer}arc(){return this.m_curves}bezier3(){return this.m_curves}bezier2(){return this.m_curves}rbezier2(){return this.m_curves}createLine(){return this.createImpl(R.G.enumLine),this.m_seg=this.line(),this.line()}createEllipticArc(){return this.createImpl(R.G.enumEllipticArc),this.m_seg=this.arc(),this.arc()}createCubicBezier(){return this.createImpl(R.G.enumBezier),this.m_seg=this.bezier3(),this.bezier3()}createQuadraticRationalBezier(){return this.createImpl(R.G.enumRationalBezier2),this.m_seg=this.rbezier2(),this.rbezier2()}createQuadraticBezier(){return this.createImpl(R.G.enumBezier2),this.m_seg=this.bezier2(),this.bezier2()}releaseSegment(){if(this.m_seg=null,0===this.m_active&&(0,R.c)("releaseSegment"),1&this.m_active){const r=this.line();return this.m_mask-=1,this.m_active=0,this.m_lineBuffer=null,r}let n;return 2&this.m_active?n=this.arc():4&this.m_active?n=this.bezier3():8&this.m_active?n=this.bezier2():16&this.m_active?n=this.rbezier2():(0,R.c)("releaseSegment"),this.m_mask-=this.m_active,this.m_active=0,this.m_curves=null,n}equals(n){return n instanceof is?this===n||(this.empty()?n.empty():!n.empty()&&this.get().equals(n.get())):((0,R.b)("seg comparison not yet impl"),!1)}}}}]);