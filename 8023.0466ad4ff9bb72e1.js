"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[8023],{62059:(gt,Y,i)=>{i.d(Y,{H:()=>Dt,b:()=>P,c:()=>lt});var c=i(83953),X=i(45475),H=i(89141),N=i(47258),F=i(74567),d=i(29359),U=i(70094),_=i(66978),I=i(49132),T=i(22426),Z=i(10064),ut=i(14051),mt=i(33605),O=i(71781),tt=i(35955),L=i(30475),rt=i(7741),pt=i(99286),st=i(21130),Ct=i(80585),yt=i(18356),wt=i(82374),Mt=i(65840),h=i(24493),vt=i(18679),bt=i(35089),E=i(96443),at=i(40972),At=i(43713),B=i(28700);function P(a){const y=new At.N5,b=a.signedDistanceFieldEnabled;y.include(I.Q,a),y.vertex.include(d.rA,a);const{occlusionPass:Et,output:C,oitPass:t}=a;if(Et)return y.include(T.I,a),y;const{vertex:r,fragment:s}=y;y.include(L.Y6),y.include(mt.A,a),y.include(U.g,a),y.include(Z.y),s.include(tt.W),s.include(O.a),y.varyings.add("vcolor","vec4"),y.varyings.add("vtc","vec2"),y.varyings.add("vsize","vec2");const f=C===F.V.Highlight,m=f&&a.occlusionTestEnabled;m&&y.varyings.add("voccluded","float"),r.uniforms.add(new st.I("viewport",D=>D.camera.fullViewport),new pt.G("screenOffset",(D,et)=>(0,c.hZ)(p,2*D.screenOffset[0]*et.camera.pixelRatio,2*D.screenOffset[1]*et.camera.pixelRatio)),new pt.G("anchorPosition",D=>lt(D)),new yt.E("materialColor",D=>D.color),new Mt.m("materialRotation",D=>D.rotation)),(0,rt.Nz)(r),b&&(r.uniforms.add(new yt.E("outlineColor",D=>D.outlineColor)),s.uniforms.add(new yt.E("outlineColor",D=>Ot(D)?D.outlineColor:H.uY),new Mt.m("outlineSize",D=>Ot(D)?D.outlineSize:0))),a.horizonCullingEnabled&&r.uniforms.add(new Ct.V("pointDistanceSphere",(D,et)=>{const q=et.camera.eye,xt=D.origin;return(0,H.fA)(xt[0]-q[0],xt[1]-q[1],xt[2]-q[2],N.$O.radius)})),a.pixelSnappingEnabled&&r.include(_.K),a.hasScreenSizePerspective&&((0,L.pM)(r),(0,L.OH)(r)),a.debugDrawLabelBorder&&y.varyings.add("debugBorderCoords","vec4"),y.attributes.add(at.r.UV0,"vec2"),y.attributes.add(at.r.COLOR,"vec4"),y.attributes.add(at.r.SIZE,"vec2"),y.attributes.add(at.r.ROTATION,"float"),y.attributes.add(at.r.FEATUREATTRIBUTE,"vec4"),r.code.add(a.horizonCullingEnabled?h.H`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return  b > 0.0 && b < a && b * b  > a * c;
}`:h.H`bool behindHorizon(vec3 posModel) { return false; }`),r.main.add(h.H`
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      if (behindHorizon(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      vec2 inputSize;
      ${(0,h.If)(a.hasScreenSizePerspective,h.H`
          inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
          vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`,h.H`
          inputSize = size;
          vec2 screenOffsetScaled = screenOffset;`)}
      ${(0,h.If)(a.vvSize,h.H`inputSize *= vvScale(featureAttribute).xx;`)}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${(0,h.If)(a.occlusionTestEnabled,h.H`
      bool visible = testHUDVisibility(posProj);
      if (!visible) {
        vtc = vec2(0.0);
        ${(0,h.If)(a.debugDrawLabelBorder,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
        return;
      }`)}
      ${(0,h.If)(m,h.H`voccluded = visible ? 0.0 : 1.0;`)}
    `);const V=h.H`
      vec2 uv01 = floor(uv0);
      vec2 uv = uv0 - uv01;
      quadOffset.xy = (uv01 - anchorPosition) * 2.0 * combinedSize;

      ${(0,h.If)(a.hasRotation,h.H`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `,ft=a.pixelSnappingEnabled?b?h.H`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:h.H`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:h.H`posProj += quadOffset;`;r.main.add(h.H`
    ${V}
    ${a.vvColor?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${(0,h.If)(C===F.V.ObjectAndLayerIdColor,h.H`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${h.H.float(B.Q)};
    ${(0,h.If)(b,`alphaDiscard = alphaDiscard && outlineColor.a < ${h.H.float(B.Q)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${ft}
      gl_Position = posProj;
    }

    vtc = uv;

    ${(0,h.If)(a.debugDrawLabelBorder,h.H`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `),s.uniforms.add(new bt.N("tex",D=>D.texture)),a.occludedFragmentFade&&(s.uniforms.add(new vt.x("depthMap",D=>D.mainDepth)),s.uniforms.add(new wt.U("occludedOpacity",D=>D.hudOccludedFragmentOpacity)));const ht=a.debugDrawLabelBorder?h.H`(isBorder > 0.0 ? 0.0 : ${h.H.float(B.Q)})`:h.H.float(B.Q),ot=h.H`
    ${(0,h.If)(a.debugDrawLabelBorder,h.H`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    ${(0,h.If)(a.sampleSignedDistanceFieldTexelCenter,h.H`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;`,h.H`vec2 samplePos = vtc;`)}

    ${b?h.H`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgbaTofloat(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${ht} ||
          fillPixelColor.a + outlinePixelColor.a < ${h.H.float(B.Q)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${(0,h.If)(!f,h.H`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${ht}) {
          discard;
        }

        ${(0,h.If)(!f,h.H`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:h.H`
          vec4 texColor = texture(tex, vtc, -0.5);
          if (texColor.a < ${ht}) {
            discard;
          }
          ${(0,h.If)(!f,h.H`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${(0,h.If)(a.occludedFragmentFade&&!f,h.H`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= occludedOpacity;
        }
        `)}

    ${(0,h.If)(!f&&a.debugDrawLabelBorder,h.H`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;switch(C){case F.V.Color:case F.V.ColorEmission:y.outputs.add("fragColor","vec4",0),C===F.V.ColorEmission&&y.outputs.add("fragEmission","vec4",1),t===E.Y.ColorAlpha&&y.outputs.add("fragAlpha","float",C===F.V.ColorEmission?2:1),s.main.add(h.H`
        ${ot}
        ${(0,h.If)(t===E.Y.FrontFace,h.H`fragColor.rgb /= fragColor.a;`)}
        ${(0,h.If)(C===F.V.ColorEmission,h.H`fragEmission = vec4(0.0);`)}
        ${(0,h.If)(t===E.Y.ColorAlpha,h.H`fragAlpha = fragColor.a;`)}`);break;case F.V.ObjectAndLayerIdColor:s.main.add(h.H`
        ${ot}
        outputObjectAndLayerIdColor();`);break;case F.V.Highlight:y.include(ut.Q,a),s.main.add(h.H`
        ${ot}
        outputHighlight(${(0,h.If)(m,h.H`voccluded == 1.0`,h.H`false`)});`)}return y}function Ot(a){return a.outlineColor[3]>0&&a.outlineSize>0}function lt(a){return a.textureIsSignedDistanceField?function Pt(a,y,b){(0,c.hZ)(b,a[0]*(y[2]-y[0])+y[0],a[1]*(y[3]-y[1])+y[1])}(a.anchorPosition,a.distanceFieldBoundingBox,p):(0,c.C)(p,a.anchorPosition),p}const p=(0,X.vt)(),Dt=Object.freeze(Object.defineProperty({__proto__:null,build:P,calculateAnchorPosition:lt},Symbol.toStringTag,{value:"Module"}))},93318:(gt,Y,i)=>{i.d(Y,{E:()=>N});var c=i(25866),H=(i(13970),i(44929));function N(_,I,T){return!!(0,H.F)(_,I,U,T.spatialReference)&&(T.x=U[0],T.y=U[1],T.z=U[2],!0)}const U=(0,c.vt)()},79439:(gt,Y,i)=>{i.d(Y,{U:()=>H});var c=i(50915),X=i(30454);function H(d,U=0){const _=d.stride;return Array.from(d.fields.keys()).map(I=>{const T=d.fields.get(I),Z=T.constructor.ElementCount,ut=function N(d){const U=F[d];if(U)return U;throw new Error("BufferType not supported in WebGL")}(T.constructor.ElementType);return new X._(I,Z,ut,T.offset,_,T.optional?.glNormalized??!1,U)})}const F={u8:c.pe.UNSIGNED_BYTE,u16:c.pe.UNSIGNED_SHORT,u32:c.pe.UNSIGNED_INT,i8:c.pe.BYTE,i16:c.pe.SHORT,i32:c.pe.INT,f32:c.pe.FLOAT}},22426:(gt,Y,i)=>{i.d(Y,{I:()=>N});var c=i(66978),X=i(51734),H=i(24493);function N(F,d){const{vertex:U,fragment:_}=F;F.include(X.Z,d),U.include(c.K),U.main.add(H.H`vec4 posProjCenter;
if (dot(position, position) > 0.0) {
ProjectHUDAux projectAux;
vec4 posProj = projectPositionHUD(projectAux);
posProjCenter = alignToPixelCenter(posProj, viewport.zw);
forwardViewPosDepth(projectAux.posView);
vec3 vpos = projectAux.posModel;
if (rejectBySlice(vpos)) {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
} else {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
gl_Position = posProjCenter;
gl_PointSize = 1.0;`),_.main.add(H.H`fragColor = vec4(1);
if(discardByTerrainDepth()) {
fragColor.g = 0.5;
}`)}},85732:(gt,Y,i)=>{i.d(Y,{Cc:()=>U,RW:()=>d});var c=i(98877);i(74567);const H={required:[]};class F extends c.A{precompile(I){return!!this.acquireTechniques(I)}consumes(){return H}get usedMemory(){return 0}get isDecoration(){return!1}get running(){return!1}modify(I){}get numGeometries(){return 0}get hasOccludees(){return!1}get hasEmissions(){return!1}forEachGeometry(I){}queryRenderOccludedState(I){return!1}}class d extends F{}class U extends F{}},30614:(gt,Y,i)=>{i.d(Y,{Z:()=>X});var c=i(45513);class X extends c.Z{}},14064:(gt,Y,i)=>{i.d(Y,{R:()=>ft});var c=i(69287),X=i(31610),H=i(32954),N=i(92771),F=i(62789),d=i(83953),U=i(45475),_=i(28714),I=i(25866),T=i(89141);var O=i(51995),tt=i(45434),L=i(85222),rt=i(45321),pt=i(48499),st=i(74567),Ct=i(49132),yt=i(12335),wt=i(19589),Mt=i(50957),h=i(55128),vt=i(30986),bt=i(65388),E=i(40972);class At{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}}var B=i(38499),P=i(3264),Ot=i(62059),lt=i(11556),Pt=i(18110),p=i(96443),Dt=i(14356),a=i(50915),y=i(41396);class b extends Pt.w{constructor(o,l){super(o,l,new lt.$(Ot.H,()=>i.e(705).then(i.bind(i,10705)))),this.primitiveType=l.occlusionPass?a.WR.POINTS:a.WR.TRIANGLES}initializePipeline(o){const{oitPass:l,hasPolygonOffset:n,draped:u,output:v,depthTestEnabled:x,occlusionPass:M}=o,R=l===p.Y.NONE,w=x&&!u&&!(l===p.Y.ColorAlpha)&&!M&&!(v===st.V.Highlight);return(0,y.Ey)({blending:(0,st.RN)(v)?R?y.Os:(0,Dt.ez)(l):null,depthTest:x&&!u?{func:a.MT.LEQUAL}:null,depthWrite:w?y.Uy:null,drawBuffers:(0,Dt.m6)(l,v),colorWrite:y.kn,polygonOffset:n?Et:null})}}const Et={factor:0,units:-4};var C=i(8189),t=i(66874),r=i(43167),s=i(55062),f=i(35094);class m extends f.E{constructor(o){super(),this.spherical=o,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.objectAndLayerIdColorInstanced=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.textureCoordinateType=t.I.None,this.emissionSource=r.ZX.None,this.discardInvisibleFragments=!0,this.hasVvInstancing=!1}}(0,C._)([(0,s.W)()],m.prototype,"screenCenterOffsetUnitsEnabled",void 0),(0,C._)([(0,s.W)()],m.prototype,"occlusionTestEnabled",void 0),(0,C._)([(0,s.W)()],m.prototype,"signedDistanceFieldEnabled",void 0),(0,C._)([(0,s.W)()],m.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),(0,C._)([(0,s.W)()],m.prototype,"vvSize",void 0),(0,C._)([(0,s.W)()],m.prototype,"vvColor",void 0),(0,C._)([(0,s.W)()],m.prototype,"hasVerticalOffset",void 0),(0,C._)([(0,s.W)()],m.prototype,"hasScreenSizePerspective",void 0),(0,C._)([(0,s.W)()],m.prototype,"hasRotation",void 0),(0,C._)([(0,s.W)()],m.prototype,"debugDrawLabelBorder",void 0),(0,C._)([(0,s.W)()],m.prototype,"hasPolygonOffset",void 0),(0,C._)([(0,s.W)()],m.prototype,"depthTestEnabled",void 0),(0,C._)([(0,s.W)()],m.prototype,"pixelSnappingEnabled",void 0),(0,C._)([(0,s.W)()],m.prototype,"draped",void 0),(0,C._)([(0,s.W)()],m.prototype,"terrainDepthTest",void 0),(0,C._)([(0,s.W)()],m.prototype,"cullAboveTerrain",void 0),(0,C._)([(0,s.W)()],m.prototype,"occlusionPass",void 0),(0,C._)([(0,s.W)()],m.prototype,"occludedFragmentFade",void 0),(0,C._)([(0,s.W)()],m.prototype,"objectAndLayerIdColorInstanced",void 0),(0,C._)([(0,s.W)()],m.prototype,"horizonCullingEnabled",void 0),(0,C._)([(0,s.W)()],m.prototype,"isFocused",void 0);var V=i(28700);class ft extends Mt.im{constructor(o,l){super(o,te),this.produces=new Map([[h.N.HUD_MATERIAL,n=>(0,st.Mb)(n)&&!this.parameters.drawAsLabel],[h.N.LABEL_MATERIAL,n=>(0,st.Mb)(n)&&this.parameters.drawAsLabel],[h.N.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[h.N.DRAPED_MATERIAL,n=>this.parameters.draped&&(0,st.Mb)(n)]]),this._visible=!0,this._configuration=new m(l)}getConfiguration(o,l){return this._configuration.output=o,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.draped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=l.slot===h.N.OCCLUSION_PIXELS,this._configuration.occludedFragmentFade=this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||l.slot===h.N.OCCLUSION_PIXELS,(0,st.RN)(o)&&(this._configuration.debugDrawLabelBorder=!!rt.b.LABELS_SHOW_BORDER),this._configuration.oitPass=l.oitPass,this._configuration.terrainDepthTest=l.terrainDepthTest,this._configuration.cullAboveTerrain=l.cullAboveTerrain,this._configuration}intersect(o,l,n,u,v,x){const{options:{selectionMode:M,hud:R,excludeLabels:j},point:S,camera:w}=n,{parameters:z}=this;if(!M||!R||j&&z.isLabel||!o.visible||!S)return;const{scaleX:A,scaleY:$}=this._getScreenScale(o,w.pixelRatio);(0,X.z0)(Ft,l),o.attributes.has(E.r.FEATUREATTRIBUTE)&&function et(g){const o=g[0],l=g[1],n=g[2],u=g[3],v=g[4],x=g[5],M=g[6],R=g[7],j=g[8],S=1/Math.sqrt(o*o+l*l+n*n),w=1/Math.sqrt(u*u+v*v+x*x),z=1/Math.sqrt(M*M+R*R+j*j);g[0]=o*S,g[1]=l*S,g[2]=n*S,g[3]=u*w,g[4]=v*w,g[5]=x*w,g[6]=M*z,g[7]=R*z,g[8]=j*z}(Ft);const G=o.attributes.get(E.r.POSITION),nt=o.attributes.get(E.r.SIZE),ct=o.attributes.get(E.r.NORMAL),Q=o.attributes.get(E.r.ROTATION),it=o.attributes.get(E.r.CENTEROFFSETANDDISTANCE);(0,bt.vA)(G.size>=3);const _t=(0,Ot.c)(z),Tt="screen"===this.parameters.centerOffsetUnits;for(let dt=0;dt<G.data.length/G.size;dt++){const Ut=dt*G.size;(0,_.i)(W,G.data[Ut],G.data[Ut+1],G.data[Ut+2]),(0,_.t)(W,W,l),(0,_.t)(W,W,w.viewMatrix);const Bt=dt*it.size;if((0,_.i)(k,it.data[Bt],it.data[Bt+1],it.data[Bt+2]),!Tt&&(W[0]+=k[0],W[1]+=k[1],0!==k[2])){const jt=k[2];(0,_.n)(k,W),(0,_.d)(W,W,(0,_.h)(k,k,jt))}const Vt=dt*ct.size;if((0,_.i)(St,ct.data[Vt],ct.data[Vt+1],ct.data[Vt+2]),D(St,Ft,w,zt),this._applyVerticalOffsetTransformationView(W,zt,w,xt),w.applyProjection(W,K),K[0]>-1){Tt&&(k[0]||k[1])&&(K[0]+=k[0]*w.pixelRatio,0!==k[1]&&(K[1]+=(0,vt.m0)(k[1],xt.factorAlignment)*w.pixelRatio),w.unapplyProjection(K,W)),K[0]+=this.parameters.screenOffset[0]*w.pixelRatio,K[1]+=this.parameters.screenOffset[1]*w.pixelRatio,K[0]=Math.floor(K[0]),K[1]=Math.floor(K[1]);const jt=dt*nt.size;J[0]=nt.data[jt],J[1]=nt.data[jt+1],(0,vt.MD)(J,xt.factor,J);const re=Jt*w.pixelRatio;let Kt=0;if(z.textureIsSignedDistanceField&&(Kt=Math.min(z.outlineSize,.5*J[0])*w.pixelRatio/2),J[0]*=A,J[1]*=$,q(S,K[0],K[1],J,re,Kt,z.rotation+Q.data[dt*Q.size],z,_t)){const $t=n.ray;if((0,_.t)(Wt,W,(0,N.B8)(Xt,w.viewMatrix)),K[0]=S[0],K[1]=S[1],w.unprojectFromRenderScreen(K,W)){const It=(0,I.vt)();(0,_.c)(It,$t.direction);const Gt=1/(0,_.l)(It);(0,_.h)(It,It,Gt),x((0,_.j)($t.origin,W)*Gt,It,-1,!0,1,Wt)}}}}}intersectDraped(o,l,n,u,v,x){const M=o.attributes.get(E.r.POSITION),R=o.attributes.get(E.r.SIZE),j=o.attributes.get(E.r.ROTATION),S=this.parameters,w=(0,Ot.c)(S),{scaleX:z,scaleY:A}=this._getScreenScale(o,o.screenToWorldRatio),$=kt*o.screenToWorldRatio;for(let G=0;G<M.data.length/M.size;G++){const nt=G*M.size,ct=M.data[nt],Q=M.data[nt+1],it=G*R.size;J[0]=R.data[it],J[1]=R.data[it+1];let _t=0;S.textureIsSignedDistanceField&&(_t=Math.min(S.outlineSize,.5*J[0])*o.screenToWorldRatio/2),J[0]*=z,J[1]*=A,q(u,ct,Q,J,$,_t,S.rotation+j.data[G*j.size],S,w)&&v(x.dist,x.normal,-1,!1)}}createBufferWriter(){return new ie}_updateScaleInfo(o,l,n){const u=this.parameters;null!=u.screenSizePerspective?(0,vt.cJ)(n,l,u.screenSizePerspective,o.factor):(o.factor.scale=1,o.factor.factor=0,o.factor.minScaleFactor=0),null!=u.screenSizePerspectiveAlignment?(0,vt.cJ)(n,l,u.screenSizePerspectiveAlignment,o.factorAlignment):(o.factorAlignment.factor=o.factor.factor,o.factorAlignment.scale=o.factor.scale,o.factorAlignment.minScaleFactor=o.factor.minScaleFactor)}applyShaderOffsetsView(o,l,n,u,v,x,M){const R=D(l,n,v,zt);return this._applyVerticalGroundOffsetView(o,R,v,M),this._applyVerticalOffsetTransformationView(M,R,v,x),this._applyPolygonOffsetView(M,R,u[3],v,M),this._applyCenterOffsetView(M,u,M),M}applyShaderOffsetsNDC(o,l,n,u,v){return this._applyCenterOffsetNDC(o,l,n,u),null!=v&&(0,_.c)(v,u),this._applyPolygonOffsetNDC(u,l,n,u),u}_applyPolygonOffsetView(o,l,n,u,v){const x=u.aboveGround?1:-1;let M=Math.sign(n);0===M&&(M=x);const R=x*M;if(this.parameters.shaderPolygonOffset<=0)return(0,_.c)(v,o);const j=(0,c.qE)(Math.abs(l.cosAngle),.01,1),S=1-Math.sqrt(1-j*j)/j/u.viewport[2];return(0,_.h)(v,o,R>0?S:1/S),v}_applyVerticalGroundOffsetView(o,l,n,u){const v=(0,_.l)(o),x=n.aboveGround?1:-1,M=n.computeRenderPixelSizeAtDist(v)*Ct.R,R=(0,_.h)(W,l.normal,x*M);return(0,_.g)(u,o,R),u}_applyVerticalOffsetTransformationView(o,l,n,u){const v=this.parameters;if(!v.verticalOffset?.screenLength){if(v.screenSizePerspective||v.screenSizePerspectiveAlignment){const j=(0,_.l)(o);this._updateScaleInfo(u,j,l.cosAngle)}else u.factor.scale=1,u.factorAlignment.scale=1;return o}const x=(0,_.l)(o),R=(0,P.kE)(n,x,v.verticalOffset,l.cosAngle,v.screenSizePerspectiveAlignment??v.screenSizePerspective);return this._updateScaleInfo(u,x,l.cosAngle),(0,_.h)(l.normal,l.normal,R),(0,_.g)(o,o,l.normal)}_applyCenterOffsetView(o,l,n){const u="screen"!==this.parameters.centerOffsetUnits;return n!==o&&(0,_.c)(n,o),u&&(n[0]+=l[0],n[1]+=l[1],l[2]&&((0,_.n)(St,n),(0,_.g)(n,n,(0,_.h)(St,St,l[2])))),n}_applyCenterOffsetNDC(o,l,n,u){const v="screen"!==this.parameters.centerOffsetUnits;return u!==o&&(0,_.c)(u,o),v||(u[0]+=l[0]/n.fullWidth*2,u[1]+=l[1]/n.fullHeight*2),u}_applyPolygonOffsetNDC(o,l,n,u){const v=this.parameters.shaderPolygonOffset;if(o!==u&&(0,_.c)(u,o),v){const x=n.aboveGround?1:-1,M=x*Math.sign(l[3]);u[2]-=(M||x)*v}return u}set visible(o){this._visible=o}get visible(){const{color:o,outlineSize:l,outlineColor:n}=this.parameters;return this._visible&&(o[3]>=V.Q||l>=V.Q&&n[3]>=V.Q)}createGLMaterial(o){return new ht(o)}calculateRelativeScreenBounds(o,l,n=(0,O.vt)()){return function ot(g,o,l,n){n[0]=g.anchorPosition[0]*-o[0]+g.screenOffset[0]*l,n[1]=g.anchorPosition[1]*-o[1]+g.screenOffset[1]*l}(this.parameters,o,l,n),n[2]=n[0]+o[0],n[3]=n[1]+o[1],n}_getScreenScale(o,l){const n=o.attributes.get(E.r.FEATUREATTRIBUTE);if(null==n)return{scaleX:l,scaleY:l};const u=(0,T.ci)(n.data,Qt);return(0,L.VC)(Lt,this.parameters,u),{scaleX:Lt[0]*l,scaleY:Lt[1]*l}}}class ht extends wt.m8{constructor(o){super({...o,...o.material.parameters})}beginSlot(o){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(b,o)}}function D(g,o,l,n){return function mt(g){return function Z(g){return g instanceof Float32Array&&g.length>=16}(g)||function ut(g){return Array.isArray(g)&&g.length>=16}(g)}(o)&&(o=(0,X.z0)(Yt,o)),(0,_.q)(n.normal,g,o),(0,_.t)(n.normal,n.normal,l.viewInverseTransposeMatrix),n.cosAngle=(0,_.f)(Ht,qt),n}function q(g,o,l,n,u,v,x,M,R){let j=o-u-n[0]*R[0],S=j+n[0]+2*u,w=l-u-n[1]*R[1],z=w+n[1]+2*u;const A=M.distanceFieldBoundingBox;return M.textureIsSignedDistanceField&&null!=A&&(j+=n[0]*A[0],w+=n[1]*A[1],S-=n[0]*(1-A[2]),z-=n[1]*(1-A[3]),j-=v,S+=v,w-=v,z+=v),(0,d.hZ)(Nt,o,l),(0,d.e$)(Rt,g,Nt,(0,c.kU)(x)),Rt[0]>j&&Rt[0]<S&&Rt[1]>w&&Rt[1]<z}const xt=new class at{constructor(){this.factor=new At,this.factorAlignment=new At}},W=(0,I.vt)(),St=(0,I.vt)(),K=(0,T.vt)(),Ht=(0,I.vt)(),Wt=(0,I.vt)(),Rt=(0,U.vt)(),Nt=(0,U.vt)(),Ft=(0,H.vt)(),Yt=(0,H.vt)(),Xt=(0,F.vt)(),k=(0,I.vt)(),Lt=(0,I.vt)(),Qt=(0,T.vt)(),zt={normal:Ht,cosAngle:0},Jt=1,kt=2,J=[0,0],qt=(0,I.fA)(0,0,1);class te extends wt.NV{constructor(){super(...arguments),this.renderOccluded=Mt.m$.Occlude,this.isDecoration=!1,this.color=(0,T.CN)(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=(0,U.fA)(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=(0,T.CN)(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=(0,T.vt)(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusEffect="none",this.draped=!1,this.isLabel=!1}}const Zt=(0,pt.BP)().vec3f(E.r.POSITION).vec3f(E.r.NORMAL).vec2f(E.r.UV0).vec4u8(E.r.COLOR).vec2f(E.r.SIZE).f32(E.r.ROTATION).vec4f(E.r.CENTEROFFSETANDDISTANCE).vec4f(E.r.FEATUREATTRIBUTE),ee=Zt.clone().vec4u8(E.r.OBJECTANDLAYERIDCOLOR);class ie{constructor(){this.vertexBufferLayout=(0,yt.E)()?ee:Zt}elementCount(o){return 6*o.get(E.r.POSITION).indices.length}write(o,l,n,u,v,x){(0,B.Hk)(n.get(E.r.POSITION),o,v.position,x,6),(0,B.p1)(n.get(E.r.NORMAL),l,v.normal,x,6);const M=n.get(E.r.UV0)?.data;let R=0,j=0,S=1,w=1;M&&M.length>=4&&(R=M[0],j=M[1],S=M[2],w=M[3]),S=Math.min(1.99999,S+1),w=Math.min(1.99999,w+1);let z=n.get(E.r.POSITION).indices.length,A=x;const $=v.uv0;for(let Q=0;Q<z;++Q)$.set(A,0,R),$.set(A,1,j),A++,$.set(A,0,S),$.set(A,1,j),A++,$.set(A,0,S),$.set(A,1,w),A++,$.set(A,0,S),$.set(A,1,w),A++,$.set(A,0,R),$.set(A,1,w),A++,$.set(A,0,R),$.set(A,1,j),A++;(0,B.tb)(n.get(E.r.COLOR),4,v.color,x,6);const{data:G,indices:nt}=n.get(E.r.SIZE);z=nt.length;const ct=v.size;A=x;for(let Q=0;Q<z;++Q){const it=G[2*nt[Q]],_t=G[2*nt[Q]+1];for(let Tt=0;Tt<6;++Tt)ct.set(A,0,it),ct.set(A,1,_t),A++}if((0,B.uO)(n.get(E.r.ROTATION),v.rotation,x,6),n.get(E.r.CENTEROFFSETANDDISTANCE)?(0,B.Ut)(n.get(E.r.CENTEROFFSETANDDISTANCE),v.centerOffsetAndDistance,x,6):(0,B.Pq)(v.centerOffsetAndDistance,x,6*z),n.get(E.r.FEATUREATTRIBUTE)?(0,B.Ut)(n.get(E.r.FEATUREATTRIBUTE),v.featureAttribute,x,6):(0,B.Pq)(v.featureAttribute,x,6*z),null!=u){const Q=n.get(E.r.POSITION)?.indices;if(Q){const it=Q.length,_t=v.getField(E.r.OBJECTANDLAYERIDCOLOR,tt.XP);(0,B.tH)(u,_t,it,x,6)}}}}},80009:(gt,Y,i)=>{i.d(Y,{A:()=>Dt});var B,P,t,Pt,c=i(8189),X=i(98877),H=i(35150),N=i(69287),F=i(67685),d=i(85211),I=(i(3248),i(40707),i(76576)),T=i(92771),Z=i(62789),ut=i(83953),mt=i(45475),O=i(28714),tt=i(25866),L=i(53781),rt=i(89141),pt=i(91421),st=i(55703),Ct=i(99608),yt=i(23191);i(12438),(t=B||(B={}))[t.Default=0]="Default",t[t.Screenshot=1]="Screenshot",t[t.ObjectAndLayerID=2]="ObjectAndLayerID",function(t){t[t.TOP=0]="TOP",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.LEFT=3]="LEFT"}(P||(P={}));let p=Pt=class extends X.A{constructor(t){super(t),this._ray=(0,st.vt)(),this._viewport=(0,rt.fA)(0,0,1,1),this._padding=(0,rt.fA)(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=(0,mt.fA)(1,1e3),this._viewDirty=!0,this._viewMatrix=(0,Z.vt)(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=(0,Z.vt)(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=(0,Z.vt)(),this._frustumDirty=!0,this._frustum=(0,pt.vt)(),this._fullViewport=(0,rt.vt)(),this._pixelRatio=1,this.row=0,this.column=0,this._rows=1,this._columns=1,this._center=(0,tt.vt)(),this._up=(0,tt.vt)(),this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t>0?t:1}get rows(){return this._rows}set rows(t){this._rows=Math.max(1,t)}get columns(){return this._columns}set columns(t){this._columns=Math.max(1,t)}get eye(){return this._ray.origin}set eye(t){this._compareAndSetView(t,this._ray.origin)}get center(){return this._center}set center(t){this._compareAndSetView(t,this._center,"_center")}get ray(){return(0,O.d)(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(t){this._compareAndSetView(t,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(t){(0,T.C)(this._viewMatrix,t),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),(0,O.i)((0,tt.vt)(),-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10])}get viewUp(){return this._ensureViewClean(),(0,O.i)((0,tt.vt)(),this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9])}get viewRight(){return this._ensureViewClean(),(0,O.i)((0,tt.vt)(),this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8])}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(t){this._nearFar[0]!==t&&(this._nearFar[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(t){this._nearFar[1]!==t&&(this._nearFar[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(t){this.x=t[0],this.y=t[1],this.width=t[2],this.height=t[3]}get screenViewport(){if(1===this.pixelRatio)return this._viewport;const t=(0,L.b)((0,rt.vt)(),this._viewport,1/this.pixelRatio),r=this._get("screenViewport");return r&&(0,L.e)(t,r)?r:t}get screenPadding(){if(1===this.pixelRatio)return this._padding;const t=(0,L.b)((0,rt.vt)(),this._padding,1/this.pixelRatio),r=this._get("screenPadding");return r&&(0,L.e)(t,r)?r:t}get x(){return this._viewport[0]}set x(t){this._viewport[0]!==(t+=this._padding[P.LEFT])&&(this._viewport[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(t){this._viewport[1]!==(t+=this._padding[P.BOTTOM])&&(this._viewport[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(t){this._viewport[2]!==t&&(this._viewport[2]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(t){this._viewport[3]!==t&&(this._viewport[3]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[P.RIGHT]+this._padding[P.LEFT]}set fullWidth(t){this.width=t-(this._padding[P.RIGHT]+this._padding[P.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[P.TOP]+this._padding[P.BOTTOM]}set fullHeight(t){this.height=t-(this._padding[P.TOP]+this._padding[P.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[P.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[P.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(t){(0,L.a)(this._padding,t)||(this._viewport[0]+=t[P.LEFT]-this._padding[P.LEFT],this._viewport[1]+=t[P.BOTTOM]-this._padding[P.BOTTOM],this._viewport[2]-=t[P.RIGHT]+t[P.LEFT]-(this._padding[P.RIGHT]+this._padding[P.LEFT]),this._viewport[3]-=t[P.TOP]+t[P.BOTTOM]-(this._padding[P.TOP]+this._padding[P.BOTTOM]),(0,L.c)(this._padding,t),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&((0,T.lw)(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){return this._projectionMatrixInternal}get inverseProjectionMatrix(){return(0,T.B8)((0,Z.vt)(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||(0,Z.vt)()}get fov(){return this._fov}set fov(t){this._fov=t,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return function h(t,r,s){return 2*Math.atan(r*Math.tan(.5*t)/Math.sqrt(r*r+s*s))}(this._fov,this.width,this.height)}set fovX(t){this._fov=function wt(t,r,s){return 2*Math.atan(Math.sqrt(r*r+s*s)*Math.tan(.5*t)/r)}(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return function vt(t,r,s){return 2*Math.atan(s*Math.tan(.5*t)/Math.sqrt(r*r+s*s))}(this._fov,this.width,this.height)}set fovY(t){this._fov=function Mt(t,r,s){return 2*Math.atan(Math.sqrt(r*r+s*s)*Math.tan(.5*t)/s)}(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return(0,O.j)(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&((0,T.B8)(this._viewInverseTransposeMatrix,this.viewMatrix),(0,T.mg)(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(t){const{near:r,far:s}=this;return 2*r*s/(s+r-t*(s-r))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return null!=this.relativeElevation&&this.relativeElevation>=0}get _projectionMatrixInternal(){const t=this.width,r=this.height,s=this.near*Math.tan(this.fovY/2)*2,f=s*this._aspect,m=s/this.rows,V=f/this.columns,ft=-f/2+this.column*V,ht=ft+V,ot=-s/2+this.row*m,D=ot+m,et=(0,T.$h)((0,Z.vt)(),ft*(1+2*this._padding[P.LEFT]/t),ht*(1+2*this._padding[P.RIGHT]/t),ot*(1+2*this._padding[P.BOTTOM]/r),D*(1+2*this._padding[P.TOP]/r),this.near,this.far),q=this._get("projectionMatrix");return q&&(0,T.aI)(q,et)?q:et}copyFrom(t){(0,O.c)(this._ray.origin,t.eye),this.center=t.center,this.up=t.up,(0,L.c)(this._viewport,t.viewport),this.notifyChange("_viewport"),(0,L.c)(this._padding,t.padding),this.notifyChange("_padding"),(0,ut.C)(this._nearFar,t.nearFar),this.notifyChange("_nearFar"),this._fov=t.fov,this.row=t.row,this.column=t.column,this.rows=t.rows,this.columns=t.columns,this.relativeElevation=t.relativeElevation;const r=t;return this._viewDirty=r._viewDirty,this._viewDirty||((0,T.C)(this._viewMatrix,t.viewMatrix),this.notifyChange("_viewMatrix")),this._viewProjectionDirty=!0,this._frustumDirty=r._frustumDirty,this._frustumDirty||((0,pt.C)(this._frustum,t.frustum),this._frustumDirty=!1),r._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:((0,T.C)(this._viewInverseTransposeMatrix,t.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),(0,L.c)(this._fullViewport,t.fullViewport),this.pixelRatio=t.pixelRatio,this}copyViewFrom(t){this.eye=t.eye,this.center=t.center,this.up=t.up,this.fov=t.fov}clone(){return(new Pt).copyFrom(this)}equals(t){return(0,O.p)(this.eye,t.eye)&&(0,O.p)(this.center,t.center)&&(0,O.p)(this.up,t.up)&&(0,L.a)(this._viewport,t.viewport)&&(0,L.a)(this._padding,t.padding)&&(0,ut.t2)(this.nearFar,t.nearFar)&&this._fov===t.fov&&this.pixelRatio===t.pixelRatio&&this.relativeElevation===t.relativeElevation&&this.row===t.row&&this.column===t.column&&this.rows===t.rows&&this.columns===t.columns}almostEquals(t){const r=Math.max(1,1/this.pixelRatio,1/t.pixelRatio);if(Math.abs(t.fov-this._fov)>=.001||(0,L.d)(t.screenPadding,this.screenPadding)>=r||(0,L.d)(this.screenViewport,t.screenViewport)>=r||this.row!==t.row||this.column!==t.column||this.rows!==t.rows||this.columns!==t.columns)return!1;(0,O.a)(b,t.eye,t.center),(0,O.a)(Et,this.eye,this.center);const s=(0,O.f)(b,Et),f=(0,O.z)(b),m=(0,O.z)(Et),V=5e-4;return s*s>=(1-1e-10)*f*m&&(0,O.y)(t.eye,this.eye)<Math.max(f,m)*V*V}computeRenderPixelSizeAt(t){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t))}computeRenderPixelSizeAtDist(t){return t*this.perRenderPixelRatio}computeScreenPixelSizeAt(t){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t))}_viewDirectionDistance(t){return Math.abs((0,Ct.gr)(this.viewForward,(0,O.d)(b,t,this.eye)))}computeScreenPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeDistanceFromRadius(t,r){return t/Math.tan(Math.min(this.fovX,this.fovY)/(2*(r||1)))}getScreenCenter(t=(0,F.gs)()){return t[0]=(this.padding[P.LEFT]+this.width/2)/this.pixelRatio,t[1]=(this.padding[P.TOP]+this.height/2)/this.pixelRatio,t}getRenderCenter(t,r=.5,s=.5){return t[0]=this.padding[P.LEFT]+this.width*r,t[1]=this.padding[P.BOTTOM]+this.height*s,t[2]=.5,t}setGLViewport(t){const r=this.viewport,s=this.padding;t.setViewport(r[0]-s[3],r[1]-s[2],r[2]+s[1]+s[3],r[3]+s[0]+s[2])}applyProjection(t,r){t!==a&&(0,O.c)(a,t),a[3]=1,(0,L.t)(a,a,this.projectionMatrix);const s=Math.abs(a[3]);(0,O.h)(a,a,1/s);const f=this.fullViewport;r[0]=(0,N.Cc)(0,f[0]+f[2],.5+.5*a[0]),r[1]=(0,N.Cc)(0,f[1]+f[3],.5+.5*a[1]),r[2]=.5*(a[2]+1),r[3]=s}unapplyProjection(t,r){const s=this.fullViewport;a[0]=(t[0]/(s[0]+s[2])*2-1)*t[3],a[1]=(t[1]/(s[1]+s[3])*2-1)*t[3],a[2]=(2*t[2]-1)*t[3],a[3]=t[3],null!=this.inverseProjectionMatrix&&((0,L.t)(a,a,this.inverseProjectionMatrix),r[0]=a[0],r[1]=a[1],r[2]=a[2])}projectToScreen(t,r){return this.projectToRenderScreen(t,C),this.renderToScreen(C,r),r}projectToRenderScreen(t,r){if(a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=1,(0,L.t)(a,a,this.viewProjectionMatrix),0===a[3])return null;const s=a;(0,O.h)(s,s,1/Math.abs(a[3]));const f=this.fullViewport,m=(0,N.Cc)(0,f[0]+f[2],.5+.5*s[0]),V=(0,N.Cc)(0,f[1]+f[3],.5+.5*s[1]);return"x"in r?(r.x=m,r.y=V):(r[0]=m,r[1]=V,r.length>2&&(r[2]=.5*(s[2]+1))),r}unprojectFromScreen(t,r){return this.unprojectFromRenderScreen(this.screenToRender(t,C),r)}unprojectFromRenderScreen(t,r){if((0,T.lw)(y,this.projectionMatrix,this.viewMatrix),!(0,T.B8)(y,y))return null;const s=this.fullViewport;return a[0]=2*(t[0]-s[0])/s[2]-1,a[1]=2*(t[1]-s[1])/s[3]-1,a[2]=2*t[2]-1,a[3]=1,(0,L.t)(a,a,y),0===a[3]?null:(r[0]=a[0]/a[3],r[1]=a[1]/a[3],r[2]=a[2]/a[3],r)}constrainWindowSize(t,r,s,f){const m=t*this.pixelRatio,V=r*this.pixelRatio,ft=Math.max(m-s/2,0),ht=Math.max(this.fullHeight-V-f/2,0),ot=-Math.min(m-s/2,0),D=-Math.min(this.fullHeight-V-f/2,0),et=s-ot- -Math.min(this.fullWidth-m-s/2,0),q=f-D- -Math.min(V-f/2,0);return[Math.round(ft),Math.round(ht),Math.round(et),Math.round(q)]}computeUp(t){t===yt.RT.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(t,r){const f=this.fullHeight-t[1]*this.pixelRatio;return r[0]=t[0]*this.pixelRatio,r[1]=f,r}renderToScreen(t,r){const f=(this.fullHeight-t[1])/this.pixelRatio;r[0]=t[0]/this.pixelRatio,r[1]=f}_computeUpGlobal(){(0,O.d)(b,this.center,this.eye);const t=(0,O.l)(this.center);t<1?((0,O.i)(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs((0,O.f)(b,this.center))>.9999*(0,O.l)(b)*t||((0,O.e)(this._up,b,this.center),(0,O.e)(this._up,this._up,b),(0,O.n)(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){(0,O.o)(b,this.eye,this.center),Math.abs(b[2])<=.9999&&((0,O.h)(b,b,b[2]),(0,O.i)(this._up,-b[0],-b[1],1-b[2]),(0,O.n)(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(t,r,s=""){"number"==typeof t[0]&&isFinite(t[0])&&"number"==typeof t[1]&&isFinite(t[1])&&"number"==typeof t[2]&&isFinite(t[2])?(0,O.p)(t,r)||((0,O.c)(r,t),this._markViewDirty(),s.length&&this.notifyChange(s)):H.A.getLogger("esri.views.3d.webgl-engine.lib.RenderCamera").warn("RenderCamera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&((0,pt.ui)(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&((0,T.t5)(this._viewMatrix,this.eye,this.center,this.up),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};(0,c._)([(0,d.MZ)()],p.prototype,"_viewport",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"_padding",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"_fov",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"_nearFar",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"_viewDirty",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"_viewMatrix",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"_pixelRatio",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"pixelRatio",null),(0,c._)([(0,d.MZ)()],p.prototype,"row",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"column",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"_rows",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"rows",null),(0,c._)([(0,d.MZ)()],p.prototype,"_columns",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"columns",null),(0,c._)([(0,d.MZ)()],p.prototype,"eye",null),(0,c._)([(0,d.MZ)()],p.prototype,"center",null),(0,c._)([(0,d.MZ)()],p.prototype,"_center",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"up",null),(0,c._)([(0,d.MZ)()],p.prototype,"_up",void 0),(0,c._)([(0,d.MZ)()],p.prototype,"viewMatrix",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"viewForward",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"viewUp",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"viewRight",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"nearFar",null),(0,c._)([(0,d.MZ)()],p.prototype,"near",null),(0,c._)([(0,d.MZ)()],p.prototype,"far",null),(0,c._)([(0,d.MZ)()],p.prototype,"viewport",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"screenViewport",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"screenPadding",null),(0,c._)([(0,d.MZ)()],p.prototype,"x",null),(0,c._)([(0,d.MZ)()],p.prototype,"y",null),(0,c._)([(0,d.MZ)()],p.prototype,"width",null),(0,c._)([(0,d.MZ)()],p.prototype,"height",null),(0,c._)([(0,d.MZ)()],p.prototype,"fullWidth",null),(0,c._)([(0,d.MZ)()],p.prototype,"fullHeight",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"_aspect",null),(0,c._)([(0,d.MZ)()],p.prototype,"padding",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"projectionMatrix",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"inverseProjectionMatrix",null),(0,c._)([(0,d.MZ)()],p.prototype,"fov",null),(0,c._)([(0,d.MZ)()],p.prototype,"fovX",null),(0,c._)([(0,d.MZ)()],p.prototype,"fovY",null),(0,c._)([(0,d.MZ)()],p.prototype,"viewInverseTransposeMatrix",null),(0,c._)([(0,d.MZ)({readOnly:!0})],p.prototype,"_projectionMatrixInternal",null),(0,c._)([(0,d.MZ)()],p.prototype,"relativeElevation",void 0),p=Pt=(0,c._)([(0,I.$)("esri.views.3d.webgl.RenderCamera")],p);const Dt=p,a=(0,rt.vt)(),y=(0,Z.vt)(),b=(0,tt.vt)(),Et=(0,tt.vt)(),C=(0,F.r_)()}}]);