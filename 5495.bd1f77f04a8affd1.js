"use strict";(self.webpackChunkAngularClient=self.webpackChunkAngularClient||[]).push([[5495],{40460:(J,x,i)=>{i.r(x),i.d(x,{default:()=>Y});var K,D=i(10467),P=i(8189),E=i(89563),Z=i(5922),A=i(4879),c=i(39693),R=i(56492),p=i(45272),r=i(85211),_=i(48669),g=(i(3248),i(40707),i(17221)),L=i(76576),N=i(50305),B=i(32034),F=i(95478),v=i(94376),I=i(73474),e=i(50630),s=i(25936),o=i(93410),t=i(23e3),h=i(17049),l=i(85551),a=i(1151),M=i(33036),T=i(58993),n=i(68438),u=i(22329),m=i(63014),f=i(49498);const j=["Canvas/World_Dark_Gray_Base","Canvas/World_Dark_Gray_Reference","Canvas/World_Light_Gray_Base","Canvas/World_Light_Gray_Reference","Elevation/World_Hillshade","Elevation/World_Hillshade_Dark","Ocean/World_Ocean_Base","Ocean/World_Ocean_Reference","Ocean_Basemap","Reference/World_Boundaries_and_Places","Reference/World_Boundaries_and_Places_Alternate","Reference/World_Transportation","World_Imagery","World_Street_Map","World_Topo_Map"];let U=K=class extends((0,o.dM)((0,M.j)((0,T.I)((0,I.f)((0,e.V)((0,h.q)((0,l.A)((0,s.b)((0,c.P)((0,a.J)((0,v.p)((0,t.d)(F.A))))))))))))){constructor(...d){super(...d),this.listMode="show",this.isReference=null,this.operationalLayerType="ArcGISTiledMapServiceLayer",this.resampling=!0,this.sourceJSON=null,this.spatialReference=null,this.path=null,this.sublayers=null,this.type="tile",this.url=null}normalizeCtorArgs(d,O){return"string"==typeof d?{url:d,...O}:d}load(d){const O=null!=d?d.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Map Service"]},d).catch(R.QP).then(()=>this._fetchService(O))),Promise.resolve(this)}get attributionDataUrl(){const d=this.parsedUrl?.path.toLowerCase();return d?this._getDefaultAttribution(this._getMapName(d)):null}readSpatialReference(d,O){return(d=d||O.tileInfo?.spatialReference)&&B.A.fromJSON(d)}writeSublayers(d,O,C,W){if(!this.loaded||!d)return;const b=d.slice().reverse().flatten(({sublayers:w})=>w&&w.toArray().reverse()).toArray(),G=[],z={writeSublayerStructure:!1,...W};b.forEach(w=>{const V=w.write({},z);G.push(V)}),G.some(w=>Object.keys(w).length>1)&&(O.layers=G)}get tileServers(){return this._getDefaultTileServers(this.parsedUrl?.path)}castTileServers(d){return Array.isArray(d)?d.map(O=>(0,p.An)(O).path):null}fetchTile(d,O,C,W={}){const{signal:b}=W,G=this.getTileUrl(d,O,C),z={responseType:"image",signal:b,query:{...this.refreshParameters}};return(0,E.A)(G,z).then(w=>w.data)}fetchImageBitmapTile(d,O,C,W={}){var b=this;return(0,D.A)(function*(){const{signal:G}=W;if(b.fetchTile!==K.prototype.fetchTile){const Q=yield b.fetchTile(d,O,C,W);return(0,m.C)(Q,d,O,C,G)}const z=b.getTileUrl(d,O,C),w={responseType:"blob",signal:G,query:{...b.refreshParameters}},{data:V}=yield(0,E.A)(z,w);return(0,m.C)(V,d,O,C,G)})()}getTileUrl(d,O,C){const W=!this.capabilities.operations.supportsTileMap&&this.supportsBlankTile,b=(0,p.x0)({...this.parsedUrl?.query,blankTile:!W&&null,...this.customParameters,token:this.apiKey}),G=this.tileServers;return`${G&&G.length?G[O%G.length]:this.parsedUrl?.path}/tile/${d}/${O}/${C}${b?"?"+b:""}`}loadAll(){return(0,A.g)(this,d=>{d(this.allSublayers)})}_fetchService(d){return new Promise((O,C)=>{if(this.sourceJSON){if(null!=this.sourceJSON.bandCount&&null!=this.sourceJSON.pixelSizeX)throw new Z.A("tile-layer:unsupported-url","use ImageryTileLayer to open a tiled image service");return void O({data:this.sourceJSON})}if(!this.parsedUrl)throw new Z.A("tile-layer:undefined-url","layer's url is not defined");const W=(0,n.qg)(this.parsedUrl.path);if(null!=W&&"ImageServer"===W.serverType)throw new Z.A("tile-layer:unsupported-url","use ImageryTileLayer to open a tiled image service");(0,E.A)(this.parsedUrl.path,{query:{f:"json",...this.parsedUrl.query,...this.customParameters,token:this.apiKey},responseType:"json",signal:d}).then(O,C)}).then(O=>{let C=this.url;if(O.ssl&&(C=this.url=C.replace(/^http:/i,"https:")),this.sourceJSON=O.data,this.read(O.data,{origin:"service",url:this.parsedUrl}),10.1===this.version&&!(0,n.Wo)(C))return this._fetchServerVersion(C,d).then(W=>{this.read({currentVersion:W})}).catch(()=>{})})}_fetchServerVersion(d,O){if(!(0,n.Fi)(d))return Promise.reject();const C=d.replace(/(.*\/rest)\/.*/i,"$1")+"/info";return(0,E.A)(C,{query:{f:"json",...this.customParameters,token:this.apiKey},responseType:"json",signal:O}).then(W=>{if(W.data&&W.data.currentVersion)return W.data.currentVersion;throw new Z.A("tile-layer:version-not-available")})}_getMapName(d){const O=d.match(/^(?:https?:)?\/\/(server\.arcgisonline\.com|services\.arcgisonline\.com|ibasemaps-api\.arcgis\.com)\/arcgis\/rest\/services\/([^/]+(\/[^/]+)*)\/mapserver/i);return O?O[2]:void 0}_getDefaultAttribution(d){if(null==d)return null;let O;d=d.toLowerCase();for(let C=0,W=j.length;C<W;C++)if(O=j[C],O.toLowerCase().includes(d))return(0,p.s2)("//static.arcgis.com/attribution/"+O);return null}_getDefaultTileServers(d){if(null==d)return[];const O=-1!==d.search(/^(?:https?:)?\/\/server\.arcgisonline\.com/i),C=-1!==d.search(/^(?:https?:)?\/\/services\.arcgisonline\.com/i);return O||C?[d,d.replace(O?/server\.arcgisonline/i:/services\.arcgisonline/i,O?"services.arcgisonline":"server.arcgisonline")]:[]}get hasOverriddenFetchTile(){return!this.fetchTile[$]}};(0,P._)([(0,r.MZ)({readOnly:!0})],U.prototype,"attributionDataUrl",null),(0,P._)([(0,r.MZ)({type:["show","hide","hide-children"]})],U.prototype,"listMode",void 0),(0,P._)([(0,r.MZ)({json:{read:!0,write:!0}})],U.prototype,"blendMode",void 0),(0,P._)([(0,r.MZ)({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],U.prototype,"isReference",void 0),(0,P._)([(0,r.MZ)({readOnly:!0,type:["ArcGISTiledMapServiceLayer"]})],U.prototype,"operationalLayerType",void 0),(0,P._)([(0,r.MZ)({type:Boolean})],U.prototype,"resampling",void 0),(0,P._)([(0,r.MZ)()],U.prototype,"sourceJSON",void 0),(0,P._)([(0,r.MZ)({type:B.A})],U.prototype,"spatialReference",void 0),(0,P._)([(0,g.w)("spatialReference",["spatialReference","tileInfo"])],U.prototype,"readSpatialReference",null),(0,P._)([(0,r.MZ)({type:String,json:{origins:{"web-scene":{read:!0,write:!0}},read:!1}})],U.prototype,"path",void 0),(0,P._)([(0,r.MZ)({readOnly:!0})],U.prototype,"sublayers",void 0),(0,P._)([(0,N.K)("sublayers",{layers:{type:[f.A]}})],U.prototype,"writeSublayers",null),(0,P._)([(0,r.MZ)({json:{read:!1,write:!1}})],U.prototype,"popupEnabled",void 0),(0,P._)([(0,r.MZ)()],U.prototype,"tileServers",null),(0,P._)([(0,_.w)("tileServers")],U.prototype,"castTileServers",null),(0,P._)([(0,r.MZ)({readOnly:!0,json:{read:!1}})],U.prototype,"type",void 0),(0,P._)([(0,r.MZ)(u.OZ)],U.prototype,"url",void 0),U=K=(0,P._)([(0,L.$)("esri.layers.TileLayer")],U);const $=Symbol("default-fetch-tile");U.prototype.fetchTile[$]=!0;const Y=U},42086:(J,x,i)=>{i.d(x,{N3:()=>A,Om:()=>Z});var D=i(11445),P=i(27999),E=i(13682);class Z{constructor(p=null,r={},_,y,S=0){this.geometry=p,this.attributes=r,this.centroid=_,this.objectId=y,this.displayId=S}static fromJSON(p){const r=p.geometry?E.A.fromJSON(p.geometry):null,_=p.centroid?E.A.fromJSON(p.centroid):null;return new Z(r,p.attributes,_,p.objectId)}weakClone(){const p=new Z(this.geometry,this.attributes,this.centroid,this.objectId);return p.displayId=this.displayId,p}clone(){const p=this.geometry?.clone(),r=new Z(p,{...this.attributes},this.centroid?.clone(),this.objectId);return r.displayId=this.displayId,r}ensureCentroid(p){return this.centroid??=(0,P.Q)(new E.A,this.geometry,p.hasZ,p.hasM),this.centroid}get usedMemory(){return 128+(0,D.lM)(this.attributes)+(this.geometry?.usedMemory??0)}}function A(R){return!!R.geometry?.coords?.length}},61808:(J,x,i)=>{i.d(x,{A:()=>D});class D{constructor(){this.objectIdFieldName=null,this.globalIdFieldName=null,this.geohashFieldName=null,this.geometryProperties=null,this.geometryType=null,this.spatialReference=null,this.hasZ=!1,this.hasM=!1,this.features=[],this.fields=[],this.transform=null,this.exceededTransferLimit=!1,this.uniqueIdField=null,this.queryGeometryType=null,this.queryGeometry=null}weakClone(){const E=new D;return E.objectIdFieldName=this.objectIdFieldName,E.globalIdFieldName=this.globalIdFieldName,E.geohashFieldName=this.geohashFieldName,E.geometryProperties=this.geometryProperties,E.geometryType=this.geometryType,E.spatialReference=this.spatialReference,E.hasZ=this.hasZ,E.hasM=this.hasM,E.features=this.features,E.fields=this.fields,E.transform=this.transform,E.exceededTransferLimit=this.exceededTransferLimit,E.uniqueIdField=this.uniqueIdField,E.queryGeometry=this.queryGeometry,E.queryGeometryType=this.queryGeometryType,E}}},13682:(J,x,i)=>{i.d(x,{A:()=>E});var D=i(11445);class E{constructor(A=[],c=[]){this.lengths=A??[],this.coords=c??[]}static fromJSON(A){return new E(A.lengths,A.coords)}static fromRect(A){const[c,R,p,r]=A,_=p-c,y=r-R;return new E([5],[c,R,_,0,0,y,-_,0,0,-y])}get isPoint(){return 0===this.lengths.length&&this.coords.length>=2}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((A,c)=>A+c)}get usedMemory(){return 64+(0,D.Qf)(this.lengths,this.coords)}area(){let A=0,c=0;if(!this.lengths.length)return 0;for(let R=0;R<this.lengths.length;R++){const p=this.lengths[R];if(p<3)continue;let r=this.coords[2*c],_=this.coords[2*c+1];for(let y=1;y<p;y+=1){const S=this.coords[2*(y+c)],g=this.coords[2*(y+c)+1];A+=-.5*(S-r)*(g+_),r=S,_=g}c+=p}return A}forEachVertex(A){let c=0;this.lengths.length||A(this.coords[0],this.coords[1]);for(let R=0;R<this.lengths.length;R++){const p=this.lengths[R];for(let r=0;r<p;r++)A(this.coords[2*(r+c)],this.coords[2*(r+c)+1]);c+=p}}deltaDecode(){const A=this.clone(),{coords:c,lengths:R}=A;let p=0;for(const r of R){for(let _=1;_<r;_++)c[2*(p+_)]+=c[2*(p+_)-2],c[2*(p+_)+1]+=c[2*(p+_)-1];p+=r}return A}clone(A){if(0===this.lengths.length)return new E([],[this.coords[0],this.coords[1]]);const c=2*(0===this.lengths.length?1:this.lengths.reduce((p,r)=>p+r)),R=this.coords.slice(0,c);return A?(A.set(R),new E(this.lengths,A)):new E(Array.from(this.lengths),Array.from(R))}}},27999:(J,x,i)=>{function D(r,_){return r?_?4:3:_?3:2}function P(r,_,y,S){if(!_?.lengths.length)return null;r.lengths.length&&(r.lengths.length=0),r.coords.length&&(r.coords.length=0);const g=r.coords,L=[],N=y?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:B,coords:F}=_,v=D(y,S);let I=0;for(const e of B){const s=E(N,F,I,e,y,S);s&&L.push(s),I+=e*v}if(L.sort((e,s)=>{let o=e[2]-s[2];return 0===o&&y&&(o=e[4]-s[4]),o}),L.length){let e=6*L[0][2];g[0]=L[0][0]/e,g[1]=L[0][1]/e,y&&(e=6*L[0][4],g[2]=0!==e?L[0][3]/e:0),(g[0]<N[0]||g[0]>N[1]||g[1]<N[2]||g[1]>N[3]||y&&(g[2]<N[4]||g[2]>N[5]))&&(g.length=0)}if(!g.length){const e=_.lengths[0]?function Z(r,_,y,S,g){const L=D(S,g);let N=_,B=_+L,F=0,v=0,I=0,e=0;for(let s=0,o=y-1;s<o;s++,N+=L,B+=L){const t=r[N],h=r[N+1],l=r[N+2],a=r[B],M=r[B+1],T=r[B+2],n=S?c(t,h,l,a,M,T):A(t,h,a,M);if(n)if(F+=n,S){const u=p(t,h,l,a,M,T);v+=n*u[0],I+=n*u[1],e+=n*u[2]}else{const u=R(t,h,a,M);v+=n*u[0],I+=n*u[1]}}return F>0?S?[v/F,I/F,e/F]:[v/F,I/F]:y>0?S?[r[_],r[_+1],r[_+2]]:[r[_],r[_+1]]:null}(F,0,B[0],y,S):null;if(!e)return null;g[0]=e[0],g[1]=e[1],y&&e.length>2&&(g[2]=e[2])}return r}function E(r,_,y,S,g,L){const N=D(g,L);let B=y,F=y+N,v=0,I=0,e=0,s=0,o=0;for(let h=0,l=S-1;h<l;h++,B+=N,F+=N){const a=_[B],M=_[B+1],T=_[B+2],n=_[F],u=_[F+1],m=_[F+2];let f=a*u-n*M;s+=f,v+=(a+n)*f,I+=(M+u)*f,g&&(f=a*m-n*T,e+=(T+m)*f,o+=f),a<r[0]&&(r[0]=a),a>r[1]&&(r[1]=a),M<r[2]&&(r[2]=M),M>r[3]&&(r[3]=M),g&&(T<r[4]&&(r[4]=T),T>r[5]&&(r[5]=T))}if(s>0&&(s*=-1),o>0&&(o*=-1),!s)return null;const t=[v,I,.5*s];return g&&(t[3]=e,t[4]=.5*o),t}function A(r,_,y,S){const g=y-r,L=S-_;return Math.sqrt(g*g+L*L)}function c(r,_,y,S,g,L){const N=S-r,B=g-_,F=L-y;return Math.sqrt(N*N+B*B+F*F)}function R(r,_,y,S){return[r+.5*(y-r),_+.5*(S-_)]}function p(r,_,y,S,g,L){return[r+.5*(S-r),_+.5*(g-_),y+.5*(L-y)]}i.d(x,{Q:()=>P})},73258:(J,x,i)=>{i.d(x,{A:()=>L});var D=i(5922),P=i(71065),E=i(35150),Z=i(60797),A=i(24098),c=i(86300),R=i(20543),p=i(22639),r=i(44549);const g=new Map;class L{static fromJSON(e){return new L(e.fields,e.timeZoneByFieldName)}static fromLayer(e){return new L(e.fields??[],v(e))}static fromLayerJSON(e){return new L(e.fields??[],v(e))}constructor(e=[],s){this._fieldsMap=new Map,this._normalizedFieldsMap=new Map,this._dateFieldsSet=new Set,this._numericFieldsSet=new Set,this._requiredFields=null,this.dateFields=[],this.numericFields=[],this.fields=e||[],this._timeZoneByFieldName=s?new Map(s):null;const o=[];for(const t of this.fields){const h=t?.name,l=B(h);if(h&&l){const a=N(h);this._fieldsMap.set(h,t),this._fieldsMap.set(a,t),this._normalizedFieldsMap.set(l,t),o.push(`${a}:${t.type}:${this._timeZoneByFieldName?.get(h)}`),(0,c.vE)(t)?(this.dateFields.push(t),this._dateFieldsSet.add(t)):(0,c.WA)(t)&&(this._numericFieldsSet.add(t),this.numericFields.push(t)),(0,c.te)(t)||(0,c.Xz)(t)||(t.editable=null==t.editable||!!t.editable,t.nullable=null==t.nullable||!!t.nullable)}}o.sort(),this.uid=o.join()}get requiredFields(){if(!this._requiredFields){this._requiredFields=[];for(const e of this.fields)(0,c.te)(e)||(0,c.Xz)(e)||e.nullable||void 0!==(0,c.lD)(e)||this._requiredFields.push(e)}return this._requiredFields}equals(e){return this.uid===e?.uid}has(e){return null!=this.get(e)}get(e){if(!e)return;let s=this._fieldsMap.get(e);return s||(s=this._fieldsMap.get(N(e))??this._normalizedFieldsMap.get(B(e)),s&&this._fieldsMap.set(e,s),s)}getTimeZone(e){const s=this.get(e&&"string"!=typeof e?e.name:e);return s?this._timeZoneByFieldName?this._timeZoneByFieldName.get(s.name):"date"===s.type||"esriFieldTypeDate"===s.type?(E.A.getLogger("esri.layers.support.FieldsIndex").errorOnce(new D.A("getTimeZone:no-timezone-information",`no time zone information for field '${s.name}'`)),R.n$):F.has(s.type)?R.L5:null:null}getLuxonTimeZone(e){const s=this.getTimeZone(e);return s?s===R.L5?A.GB.instance:s===R.n$?r.mQ.utcInstance:(0,Z.tE)(g,s,()=>r.oh.create(s)):null}isDateField(e){return this._dateFieldsSet.has(this.get(e))}isTimeOnlyField(e){return(0,c.OH)(this.get(e))}isNumericField(e){return this._numericFieldsSet.has(this.get(e))}normalizeFieldName(e){return this.get(e)?.name??void 0}toJSON(){return{fields:this.fields.map(e=>P.A.isSerializable(e)?e.toJSON():e),timeZoneByFieldName:this._timeZoneByFieldName?Array.from(this._timeZoneByFieldName.entries()):null}}}function N(I){return I.trim().toLowerCase()}function B(I){return(0,c.rS)(I)?.toLowerCase()??""}const F=new Set(["time-only","date-only","timestamp-offset","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]);function v(I){const e=new Map;if(!I.fields)return e;const s=!0===I.datesInUnknownTimezone,{timeInfo:o,editFieldsInfo:t}=I,h=(o?"startField"in o?o.startField:o.startTimeField:"")??"",l=(o?"endField"in o?o.endField:o.endTimeField:"")??"",a=function S(I){return"dateFieldsTimeZone"in I}(I)?I.dateFieldsTimeZone??null:I.dateFieldsTimeReference?(0,p.ZS)(I.dateFieldsTimeReference):null,M=t?function _(I){return"timeZone"in I}(t)?t.timeZone??a:t.dateFieldsTimeReference?(0,p.ZS)(t.dateFieldsTimeReference):a??R.n$:null,T=o?function y(I){return"timeZone"in I}(o)?o.timeZone??a:o.timeReference?(0,p.ZS)(o.timeReference):a:null,n=new Map([[N(t?.creationDateField??""),M],[N(t?.editDateField??""),M],[N(h),T],[N(l),T]]);for(const{name:u,type:m}of I.fields)if(F.has(m))e.set(u,R.L5);else if("date"!==m&&"esriFieldTypeDate"!==m)e.set(u,null);else if(s)e.set(u,R.L5);else{const f=n.get(N(u??""))??a;e.set(u,f)}return e}},93327:(J,x,i)=>{i.d(x,{A:()=>I});var B,D=i(8189),P=i(81098),E=i(49976),Z=i(71065),A=i(77806),c=i(85211),r=(i(3248),i(35150),i(17221)),_=i(76576),y=i(50305),S=i(32034),g=i(61320),L=i(6434),N=i(29141);const F=new E.J({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});let v=B=class extends Z.A{constructor(e){super(e),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(e,s){return this.readFeaturesWithClass(e,s,P.A)}writeGeometryType(e,s,o,t){if(e)return void F.write(e,s,o,t);const{features:h}=this;if(h)for(const l of h)if(null!=l?.geometry)return void F.write(l.geometry.type,s,o,t)}readQueryGeometry(e,s){if(!e)return null;const o=!!e.spatialReference,t=(0,g.rS)(e);return t&&!o&&s.spatialReference&&(t.spatialReference=S.A.fromJSON(s.spatialReference)),t}writeSpatialReference(e,s){if(e)return void(s.spatialReference=e.toJSON());const{features:o}=this;if(o)for(const t of o)if(t&&null!=t.geometry&&t.geometry.spatialReference)return void(s.spatialReference=t.geometry.spatialReference.toJSON())}clone(){return new B(this.cloneProperties())}cloneProperties(){return(0,A.o8)({displayFieldName:this.displayFieldName,exceededTransferLimit:this.exceededTransferLimit,features:this.features,fields:this.fields,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,queryGeometry:this.queryGeometry,spatialReference:this.spatialReference,transform:this.transform})}toJSON(e){const s=this.write();if(s.features&&Array.isArray(e)&&e.length>0)for(let o=0;o<s.features.length;o++){const t=s.features[o];if(t.geometry){const h=e?.[o];t.geometry=h?.toJSON()||t.geometry}}return s}quantize(e){const{scale:[s,o],translate:[t,h]}=e,M=this.features,T=this._getQuantizationFunction(this.geometryType,n=>Math.round((n-t)/s),n=>Math.round((h-n)/o));for(let n=0,u=M.length;n<u;n++)T?.(M[n].geometry)||(M.splice(n,1),n--,u--);return this.transform=e,this}unquantize(){const{geometryType:e,features:s,transform:o}=this;if(!o)return this;const{translate:[t,h],scale:[l,a]}=o;let n=null,u=null;if(this.hasZ&&null!=o?.scale?.[2]){const{translate:[,,f],scale:[,,K]}=o;n=j=>j*K+f}if(this.hasM&&null!=o?.scale?.[3]){const{translate:[,,,f],scale:[,,,K]}=o;u=j=>null==j?j:j*K+f}const m=this._getHydrationFunction(e,f=>f*l+t,f=>h-f*a,n,u);for(const{geometry:f}of s)null!=f&&m&&m(f);return this.transform=null,this}readFeaturesWithClass(e,s,o){const t=S.A.fromJSON(s.spatialReference),h=[];for(let l=0;l<e.length;l++){const a=e[l],M=o.fromJSON(a),T=a.geometry?.spatialReference;null==M.geometry||T||(M.geometry.spatialReference=t);const n=a.aggregateGeometries,u=M.aggregateGeometries;if(n&&null!=u)for(const m in u){const f=u[m],K=n[m],j=K?.spatialReference;null==f||j||(f.spatialReference=t)}h.push(M)}return h}_quantizePoints(e,s,o){let t,h;const l=[];for(let a=0,M=e.length;a<M;a++){const T=e[a];if(a>0){const n=s(T[0]),u=o(T[1]);n===t&&u===h||(l.push([n-t,u-h]),t=n,h=u)}else t=s(T[0]),h=o(T[1]),l.push([t,h])}return l.length>0?l:null}_getQuantizationFunction(e,s,o){return"point"===e?t=>(t.x=s(t.x),t.y=o(t.y),t):"polyline"===e||"polygon"===e?t=>{const h=(0,g.Bi)(t)?t.rings:t.paths,l=[];for(let a=0,M=h.length;a<M;a++){const n=this._quantizePoints(h[a],s,o);n&&l.push(n)}return l.length>0?((0,g.Bi)(t)?t.rings=l:t.paths=l,t):null}:"multipoint"===e?t=>{const h=this._quantizePoints(t.points,s,o);return h&&h.length>0?(t.points=h,t):null}:"extent"===e?t=>t:null}_getHydrationFunction(e,s,o,t,h){return"point"===e?l=>{l.x=s(l.x),l.y=o(l.y),t&&(l.z=t(l.z))}:"polyline"===e||"polygon"===e?l=>{const a=(0,g.Bi)(l)?l.rings:l.paths;let M,T;for(let n=0,u=a.length;n<u;n++){const m=a[n];for(let f=0,K=m.length;f<K;f++){const j=m[f];f>0?(M+=j[0],T+=j[1]):(M=j[0],T=j[1]),j[0]=s(M),j[1]=o(T)}}if(t&&h)for(let n=0,u=a.length;n<u;n++){const m=a[n];for(let f=0,K=m.length;f<K;f++){const j=m[f];j[2]=t(j[2]),j[3]=h(j[3])}}else if(t)for(let n=0,u=a.length;n<u;n++){const m=a[n];for(let f=0,K=m.length;f<K;f++){const j=m[f];j[2]=t(j[2])}}else if(h)for(let n=0,u=a.length;n<u;n++){const m=a[n];for(let f=0,K=m.length;f<K;f++){const j=m[f];j[2]=h(j[2])}}}:"extent"===e?l=>{l.xmin=s(l.xmin),l.ymin=o(l.ymin),l.xmax=s(l.xmax),l.ymax=o(l.ymax),t&&null!=l.zmax&&null!=l.zmin&&(l.zmax=t(l.zmax),l.zmin=t(l.zmin)),h&&null!=l.mmax&&null!=l.mmin&&(l.mmax=h(l.mmax),l.mmin=h(l.mmin))}:"multipoint"===e?l=>{const a=l.points;let M,T;for(let n=0,u=a.length;n<u;n++){const m=a[n];n>0?(M+=m[0],T+=m[1]):(M=m[0],T=m[1]),m[0]=s(M),m[1]=o(T)}if(t&&h)for(let n=0,u=a.length;n<u;n++){const m=a[n];m[2]=t(m[2]),m[3]=h(m[3])}else if(t)for(let n=0,u=a.length;n<u;n++){const m=a[n];m[2]=t(m[2])}else if(h)for(let n=0,u=a.length;n<u;n++){const m=a[n];m[2]=h(m[2])}}:null}};(0,D._)([(0,c.MZ)({type:String,json:{write:!0}})],v.prototype,"displayFieldName",void 0),(0,D._)([(0,c.MZ)({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],v.prototype,"exceededTransferLimit",void 0),(0,D._)([(0,c.MZ)({type:[P.A],json:{write:!0}})],v.prototype,"features",void 0),(0,D._)([(0,r.w)("features")],v.prototype,"readFeatures",null),(0,D._)([(0,c.MZ)({type:[N.A],json:{write:!0}})],v.prototype,"fields",void 0),(0,D._)([(0,c.MZ)({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:F.read}}})],v.prototype,"geometryType",void 0),(0,D._)([(0,y.K)("geometryType")],v.prototype,"writeGeometryType",null),(0,D._)([(0,c.MZ)({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],v.prototype,"hasM",void 0),(0,D._)([(0,c.MZ)({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],v.prototype,"hasZ",void 0),(0,D._)([(0,c.MZ)({types:L.yR,json:{write:!0}})],v.prototype,"queryGeometry",void 0),(0,D._)([(0,r.w)("queryGeometry")],v.prototype,"readQueryGeometry",null),(0,D._)([(0,c.MZ)({type:S.A,json:{write:!0}})],v.prototype,"spatialReference",void 0),(0,D._)([(0,y.K)("spatialReference")],v.prototype,"writeSpatialReference",null),(0,D._)([(0,c.MZ)({json:{write:!0}})],v.prototype,"transform",void 0),v=B=(0,D._)([(0,_.$)("esri.rest.support.FeatureSet")],v),v.prototype.toJSON.isDefaultToJSON=!0;const I=v}}]);